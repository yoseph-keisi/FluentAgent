#
# This is an auto-generated file.  DO NOT EDIT!
#
# pylint: disable=line-too-long

from ansys.fluent.core.services.datamodel_se import (
    PyMenu,
    PyParameter,
    PyTextual,
    PyNumerical,
    PyDictionary,
    PyNamedObjectContainer,
    PyCommand,
    PyQuery,
    PyArguments,
    PyArgumentsTextualSubItem,
    PyArgumentsNumericalSubItem,
    PyArgumentsDictionarySubItem,
    PyArgumentsParameterSubItem,
    PyArgumentsSingletonSubItem
)


class Root(PyMenu):
    """
    Meshing workflow API.
    """
    def __init__(self, service, rules, path):
        self.application = self.__class__.application(service, rules, path + [("application", "")])
        self.general = self.__class__.general(service, rules, path + [("general", "")])
        self.parts = self.__class__.parts(service, rules, path + [("parts", "")])
        self.parts_files = self.__class__.parts_files(service, rules, path + [("parts_files", "")])
        self.task_object = self.__class__.task_object(service, rules, path + [("task_object", "")])
        super().__init__(service, rules, path)

    class application(PyMenu):
        """
        Singleton application.
        """
        def __init__(self, service, rules, path):
            self.diagnostics = self.__class__.diagnostics(service, rules, path + [("diagnostics", "")])
            self.file = self.__class__.file(service, rules, path + [("file", "")])
            self.global_settings = self.__class__.global_settings(service, rules, path + [("global_settings", "")])
            self.graphics = self.__class__.graphics(service, rules, path + [("graphics", "")])
            self.add_2d_boundary_layers = self.__class__.add_2d_boundary_layers(service, rules, "add_2d_boundary_layers", path)
            self.add_boundary_layers = self.__class__.add_boundary_layers(service, rules, "add_boundary_layers", path)
            self.add_boundary_layers_for_part_replacement = self.__class__.add_boundary_layers_for_part_replacement(service, rules, "add_boundary_layers_for_part_replacement", path)
            self.add_boundary_type = self.__class__.add_boundary_type(service, rules, "add_boundary_type", path)
            self.add_linear_mesh_pattern = self.__class__.add_linear_mesh_pattern(service, rules, "add_linear_mesh_pattern", path)
            self.add_local_sizing_wtm = self.__class__.add_local_sizing_wtm(service, rules, "add_local_sizing_wtm", path)
            self.add_multizone_controls = self.__class__.add_multizone_controls(service, rules, "add_multizone_controls", path)
            self.add_shell_boundary_layers = self.__class__.add_shell_boundary_layers(service, rules, "add_shell_boundary_layers", path)
            self.add_thin_volume_meshing_controls = self.__class__.add_thin_volume_meshing_controls(service, rules, "add_thin_volume_meshing_controls", path)
            self.add_virtual_topology = self.__class__.add_virtual_topology(service, rules, "add_virtual_topology", path)
            self.apply_share_topology = self.__class__.apply_share_topology(service, rules, "apply_share_topology", path)
            self.axisymmetric_sweep = self.__class__.axisymmetric_sweep(service, rules, "axisymmetric_sweep", path)
            self.capping = self.__class__.capping(service, rules, "capping", path)
            self.check_mesh = self.__class__.check_mesh(service, rules, "check_mesh", path)
            self.check_surface_quality = self.__class__.check_surface_quality(service, rules, "check_surface_quality", path)
            self.check_volume_quality = self.__class__.check_volume_quality(service, rules, "check_volume_quality", path)
            self.choose_mesh_control_options = self.__class__.choose_mesh_control_options(service, rules, "choose_mesh_control_options", path)
            self.close_leakage = self.__class__.close_leakage(service, rules, "close_leakage", path)
            self.compute_regions = self.__class__.compute_regions(service, rules, "compute_regions", path)
            self.compute_size_fields = self.__class__.compute_size_fields(service, rules, "compute_size_fields", path)
            self.create_collar_mesh = self.__class__.create_collar_mesh(service, rules, "create_collar_mesh", path)
            self.create_component_mesh = self.__class__.create_component_mesh(service, rules, "create_component_mesh", path)
            self.create_contact_patch = self.__class__.create_contact_patch(service, rules, "create_contact_patch", path)
            self.create_external_flow_boundaries = self.__class__.create_external_flow_boundaries(service, rules, "create_external_flow_boundaries", path)
            self.create_gap_cover = self.__class__.create_gap_cover(service, rules, "create_gap_cover", path)
            self.create_group = self.__class__.create_group(service, rules, "create_group", path)
            self.create_leak_shield = self.__class__.create_leak_shield(service, rules, "create_leak_shield", path)
            self.create_local_refinement_regions = self.__class__.create_local_refinement_regions(service, rules, "create_local_refinement_regions", path)
            self.create_mesh_objects = self.__class__.create_mesh_objects(service, rules, "create_mesh_objects", path)
            self.create_multizone_mesh = self.__class__.create_multizone_mesh(service, rules, "create_multizone_mesh", path)
            self.create_overset_mesh = self.__class__.create_overset_mesh(service, rules, "create_overset_mesh", path)
            self.create_porous_regions = self.__class__.create_porous_regions(service, rules, "create_porous_regions", path)
            self.create_regions = self.__class__.create_regions(service, rules, "create_regions", path)
            self.create_surface_mesh = self.__class__.create_surface_mesh(service, rules, "create_surface_mesh", path)
            self.create_volume_mesh_ftm = self.__class__.create_volume_mesh_ftm(service, rules, "create_volume_mesh_ftm", path)
            self.create_volume_mesh_wtm = self.__class__.create_volume_mesh_wtm(service, rules, "create_volume_mesh_wtm", path)
            self.create_zero_thickness_geometry = self.__class__.create_zero_thickness_geometry(service, rules, "create_zero_thickness_geometry", path)
            self.custom_journal_task = self.__class__.custom_journal_task(service, rules, "custom_journal_task", path)
            self.define_boundary_layer_controls = self.__class__.define_boundary_layer_controls(service, rules, "define_boundary_layer_controls", path)
            self.define_global_sizing = self.__class__.define_global_sizing(service, rules, "define_global_sizing", path)
            self.define_leakage_threshold = self.__class__.define_leakage_threshold(service, rules, "define_leakage_threshold", path)
            self.describe_geometry = self.__class__.describe_geometry(service, rules, "describe_geometry", path)
            self.describe_geometry_and_flow = self.__class__.describe_geometry_and_flow(service, rules, "describe_geometry_and_flow", path)
            self.describe_overset_features = self.__class__.describe_overset_features(service, rules, "describe_overset_features", path)
            self.extract_edge_features = self.__class__.extract_edge_features(service, rules, "extract_edge_features", path)
            self.extrude_volume_mesh = self.__class__.extrude_volume_mesh(service, rules, "extrude_volume_mesh", path)
            self.generate_initial_surface_mesh = self.__class__.generate_initial_surface_mesh(service, rules, "generate_initial_surface_mesh", path)
            self.generate_map_mesh = self.__class__.generate_map_mesh(service, rules, "generate_map_mesh", path)
            self.generate_prism_layers = self.__class__.generate_prism_layers(service, rules, "generate_prism_layers", path)
            self.generate_surface_mesh = self.__class__.generate_surface_mesh(service, rules, "generate_surface_mesh", path)
            self.generate_volume_mesh = self.__class__.generate_volume_mesh(service, rules, "generate_volume_mesh", path)
            self.identify_construction_surfaces = self.__class__.identify_construction_surfaces(service, rules, "identify_construction_surfaces", path)
            self.identify_deviated_faces = self.__class__.identify_deviated_faces(service, rules, "identify_deviated_faces", path)
            self.identify_orphans = self.__class__.identify_orphans(service, rules, "identify_orphans", path)
            self.identify_regions = self.__class__.identify_regions(service, rules, "identify_regions", path)
            self.import_boi_geometry = self.__class__.import_boi_geometry(service, rules, "import_boi_geometry", path)
            self.import_cad_and_part_management = self.__class__.import_cad_and_part_management(service, rules, "import_cad_and_part_management", path)
            self.import_geometry = self.__class__.import_geometry(service, rules, "import_geometry", path)
            self.improve_surface_mesh = self.__class__.improve_surface_mesh(service, rules, "improve_surface_mesh", path)
            self.improve_volume_mesh = self.__class__.improve_volume_mesh(service, rules, "improve_volume_mesh", path)
            self.load_cad_geometry = self.__class__.load_cad_geometry(service, rules, "load_cad_geometry", path)
            self.manage_zones_ftm = self.__class__.manage_zones_ftm(service, rules, "manage_zones_ftm", path)
            self.mesh_controls_table = self.__class__.mesh_controls_table(service, rules, "mesh_controls_table", path)
            self.modify_mesh_refinement = self.__class__.modify_mesh_refinement(service, rules, "modify_mesh_refinement", path)
            self.part_replacement_options = self.__class__.part_replacement_options(service, rules, "part_replacement_options", path)
            self.part_replacement_settings = self.__class__.part_replacement_settings(service, rules, "part_replacement_settings", path)
            self.prepare_for_volume_meshing = self.__class__.prepare_for_volume_meshing(service, rules, "prepare_for_volume_meshing", path)
            self.remesh_surface = self.__class__.remesh_surface(service, rules, "remesh_surface", path)
            self.separate_contacts = self.__class__.separate_contacts(service, rules, "separate_contacts", path)
            self.set_up_rotational_periodic_boundaries = self.__class__.set_up_rotational_periodic_boundaries(service, rules, "set_up_rotational_periodic_boundaries", path)
            self.setup_size_controls = self.__class__.setup_size_controls(service, rules, "setup_size_controls", path)
            self.switch_to_solution = self.__class__.switch_to_solution(service, rules, "switch_to_solution", path)
            self.transform_volume_mesh = self.__class__.transform_volume_mesh(service, rules, "transform_volume_mesh", path)
            self.update_boundaries = self.__class__.update_boundaries(service, rules, "update_boundaries", path)
            self.update_region_settings = self.__class__.update_region_settings(service, rules, "update_region_settings", path)
            self.update_regions = self.__class__.update_regions(service, rules, "update_regions", path)
            self.update_volume_mesh = self.__class__.update_volume_mesh(service, rules, "update_volume_mesh", path)
            self.wrap_main = self.__class__.wrap_main(service, rules, "wrap_main", path)
            self.write_2d_mesh = self.__class__.write_2d_mesh(service, rules, "write_2d_mesh", path)
            self.write_skin = self.__class__.write_skin(service, rules, "write_skin", path)
            super().__init__(service, rules, path)

        class diagnostics(PyMenu):
            """
            Singleton diagnostics.
            """
            def __init__(self, service, rules, path):
                self.close = self.__class__.close(service, rules, "close", path)
                self.compute = self.__class__.compute(service, rules, "compute", path)
                self.diag_options = self.__class__.diag_options(service, rules, "diag_options", path)
                self.draw = self.__class__.draw(service, rules, "draw", path)
                self.first = self.__class__.first(service, rules, "first", path)
                self.histogram = self.__class__.histogram(service, rules, "histogram", path)
                self.ignore = self.__class__.ignore(service, rules, "ignore", path)
                self.list = self.__class__.list(service, rules, "list", path)
                self.mark = self.__class__.mark(service, rules, "mark", path)
                self.next = self.__class__.next(service, rules, "next", path)
                self.previous = self.__class__.previous(service, rules, "previous", path)
                self.restore = self.__class__.restore(service, rules, "restore", path)
                self.summary = self.__class__.summary(service, rules, "summary", path)
                self.update = self.__class__.update(service, rules, "update", path)
                super().__init__(service, rules, path)

            class close(PyCommand):
                """
                Command close.


                Returns
                -------
                None
                """
                class _closeArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _closeArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._closeArguments(*args)

            class compute(PyCommand):
                """
                Command compute.


                Returns
                -------
                None
                """
                class _computeArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _computeArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._computeArguments(*args)

            class diag_options(PyCommand):
                """
                Command diag_options.

                Parameters
                ----------
                option : str
                measure : str
                average : float
                minimum : float
                maximum : float
                mark_range_type : str
                mark_min : float
                mark_max : float
                selected : str
                marked_count : int
                current_count : int
                extents_update_bounds : bool
                extents_x_min : float
                extents_y_min : float
                extents_z_min : float
                extents_x_max : float
                extents_y_max : float
                extents_z_max : float

                Returns
                -------
                None
                """
                class _diag_optionsArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.option = self._option(self, "option", service, rules, path)
                        self.measure = self._measure(self, "measure", service, rules, path)
                        self.average = self._average(self, "average", service, rules, path)
                        self.minimum = self._minimum(self, "minimum", service, rules, path)
                        self.maximum = self._maximum(self, "maximum", service, rules, path)
                        self.mark_range_type = self._mark_range_type(self, "mark_range_type", service, rules, path)
                        self.mark_min = self._mark_min(self, "mark_min", service, rules, path)
                        self.mark_max = self._mark_max(self, "mark_max", service, rules, path)
                        self.selected = self._selected(self, "selected", service, rules, path)
                        self.marked_count = self._marked_count(self, "marked_count", service, rules, path)
                        self.current_count = self._current_count(self, "current_count", service, rules, path)
                        self.extents_update_bounds = self._extents_update_bounds(self, "extents_update_bounds", service, rules, path)
                        self.extents_x_min = self._extents_x_min(self, "extents_x_min", service, rules, path)
                        self.extents_y_min = self._extents_y_min(self, "extents_y_min", service, rules, path)
                        self.extents_z_min = self._extents_z_min(self, "extents_z_min", service, rules, path)
                        self.extents_x_max = self._extents_x_max(self, "extents_x_max", service, rules, path)
                        self.extents_y_max = self._extents_y_max(self, "extents_y_max", service, rules, path)
                        self.extents_z_max = self._extents_z_max(self, "extents_z_max", service, rules, path)

                    class _option(PyArgumentsTextualSubItem):
                        """
                        Argument option.
                        """

                    class _measure(PyArgumentsTextualSubItem):
                        """
                        Argument measure.
                        """

                    class _average(PyArgumentsNumericalSubItem):
                        """
                        Argument average.
                        """

                    class _minimum(PyArgumentsNumericalSubItem):
                        """
                        Argument minimum.
                        """

                    class _maximum(PyArgumentsNumericalSubItem):
                        """
                        Argument maximum.
                        """

                    class _mark_range_type(PyArgumentsTextualSubItem):
                        """
                        Argument mark_range_type.
                        """

                    class _mark_min(PyArgumentsNumericalSubItem):
                        """
                        Argument mark_min.
                        """

                    class _mark_max(PyArgumentsNumericalSubItem):
                        """
                        Argument mark_max.
                        """

                    class _selected(PyArgumentsTextualSubItem):
                        """
                        Argument selected.
                        """

                    class _marked_count(PyArgumentsNumericalSubItem):
                        """
                        Argument marked_count.
                        """

                    class _current_count(PyArgumentsNumericalSubItem):
                        """
                        Argument current_count.
                        """

                    class _extents_update_bounds(PyArgumentsParameterSubItem):
                        """
                        Argument extents_update_bounds.
                        """

                    class _extents_x_min(PyArgumentsNumericalSubItem):
                        """
                        Argument extents_x_min.
                        """

                    class _extents_y_min(PyArgumentsNumericalSubItem):
                        """
                        Argument extents_y_min.
                        """

                    class _extents_z_min(PyArgumentsNumericalSubItem):
                        """
                        Argument extents_z_min.
                        """

                    class _extents_x_max(PyArgumentsNumericalSubItem):
                        """
                        Argument extents_x_max.
                        """

                    class _extents_y_max(PyArgumentsNumericalSubItem):
                        """
                        Argument extents_y_max.
                        """

                    class _extents_z_max(PyArgumentsNumericalSubItem):
                        """
                        Argument extents_z_max.
                        """

                def create_instance(self) -> _diag_optionsArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._diag_optionsArguments(*args)

            class draw(PyCommand):
                """
                Command draw.


                Returns
                -------
                None
                """
                class _drawArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _drawArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._drawArguments(*args)

            class first(PyCommand):
                """
                Command first.


                Returns
                -------
                None
                """
                class _firstArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _firstArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._firstArguments(*args)

            class histogram(PyCommand):
                """
                Command histogram.


                Returns
                -------
                None
                """
                class _histogramArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _histogramArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._histogramArguments(*args)

            class ignore(PyCommand):
                """
                Command ignore.


                Returns
                -------
                None
                """
                class _ignoreArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _ignoreArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._ignoreArguments(*args)

            class list(PyCommand):
                """
                Command list.


                Returns
                -------
                None
                """
                class _listArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _listArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._listArguments(*args)

            class mark(PyCommand):
                """
                Command mark.


                Returns
                -------
                None
                """
                class _markArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _markArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._markArguments(*args)

            class next(PyCommand):
                """
                Command next.


                Returns
                -------
                None
                """
                class _nextArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _nextArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._nextArguments(*args)

            class previous(PyCommand):
                """
                Command previous.


                Returns
                -------
                None
                """
                class _previousArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _previousArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._previousArguments(*args)

            class restore(PyCommand):
                """
                Command restore.


                Returns
                -------
                None
                """
                class _restoreArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _restoreArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._restoreArguments(*args)

            class summary(PyCommand):
                """
                Command summary.


                Returns
                -------
                None
                """
                class _summaryArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _summaryArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._summaryArguments(*args)

            class update(PyCommand):
                """
                Command update.


                Returns
                -------
                None
                """
                class _updateArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _updateArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._updateArguments(*args)

        class file(PyMenu):
            """
            Singleton file.
            """
            def __init__(self, service, rules, path):
                self.read_case = self.__class__.read_case(service, rules, "read_case", path)
                self.read_journal = self.__class__.read_journal(service, rules, "read_journal", path)
                self.read_mesh = self.__class__.read_mesh(service, rules, "read_mesh", path)
                self.start_journal = self.__class__.start_journal(service, rules, "start_journal", path)
                self.stop_journal = self.__class__.stop_journal(service, rules, "stop_journal", path)
                self.write_case = self.__class__.write_case(service, rules, "write_case", path)
                self.write_mesh = self.__class__.write_mesh(service, rules, "write_mesh", path)
                super().__init__(service, rules, path)

            class read_case(PyCommand):
                """
                Command read_case.

                Parameters
                ----------
                file_name : str

                Returns
                -------
                None
                """
                class _read_caseArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.file_name = self._file_name(self, "file_name", service, rules, path)

                    class _file_name(PyArgumentsTextualSubItem):
                        """
                        Argument file_name.
                        """

                def create_instance(self) -> _read_caseArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._read_caseArguments(*args)

            class read_journal(PyCommand):
                """
                Command read_journal.

                Parameters
                ----------
                file_name : list[str]
                change_directory : bool

                Returns
                -------
                None
                """
                class _read_journalArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.file_name = self._file_name(self, "file_name", service, rules, path)
                        self.change_directory = self._change_directory(self, "change_directory", service, rules, path)

                    class _file_name(PyArgumentsTextualSubItem):
                        """
                        Argument file_name.
                        """

                    class _change_directory(PyArgumentsParameterSubItem):
                        """
                        Argument change_directory.
                        """

                def create_instance(self) -> _read_journalArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._read_journalArguments(*args)

            class read_mesh(PyCommand):
                """
                Command read_mesh.

                Parameters
                ----------
                file_name : str

                Returns
                -------
                None
                """
                class _read_meshArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.file_name = self._file_name(self, "file_name", service, rules, path)

                    class _file_name(PyArgumentsTextualSubItem):
                        """
                        Argument file_name.
                        """

                def create_instance(self) -> _read_meshArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._read_meshArguments(*args)

            class start_journal(PyCommand):
                """
                Command start_journal.

                Parameters
                ----------
                file_name : str

                Returns
                -------
                None
                """
                class _start_journalArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.file_name = self._file_name(self, "file_name", service, rules, path)

                    class _file_name(PyArgumentsTextualSubItem):
                        """
                        Argument file_name.
                        """

                def create_instance(self) -> _start_journalArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._start_journalArguments(*args)

            class stop_journal(PyCommand):
                """
                Command stop_journal.


                Returns
                -------
                None
                """
                class _stop_journalArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _stop_journalArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._stop_journalArguments(*args)

            class write_case(PyCommand):
                """
                Command write_case.

                Parameters
                ----------
                file_name : str

                Returns
                -------
                None
                """
                class _write_caseArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.file_name = self._file_name(self, "file_name", service, rules, path)

                    class _file_name(PyArgumentsTextualSubItem):
                        """
                        Argument file_name.
                        """

                def create_instance(self) -> _write_caseArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._write_caseArguments(*args)

            class write_mesh(PyCommand):
                """
                Command write_mesh.

                Parameters
                ----------
                file_name : str

                Returns
                -------
                None
                """
                class _write_meshArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.file_name = self._file_name(self, "file_name", service, rules, path)

                    class _file_name(PyArgumentsTextualSubItem):
                        """
                        Argument file_name.
                        """

                def create_instance(self) -> _write_meshArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._write_meshArguments(*args)

        class global_settings(PyMenu):
            """
            Singleton global_settings.
            """
            def __init__(self, service, rules, path):
                self.ftm_region_data = self.__class__.ftm_region_data(service, rules, path + [("ftm_region_data", "")])
                self.area_unit = self.__class__.area_unit(service, rules, path + [("area_unit", "")])
                self.current_task = self.__class__.current_task(service, rules, path + [("current_task", "")])
                self.enable_clean_cad = self.__class__.enable_clean_cad(service, rules, path + [("enable_clean_cad", "")])
                self.enable_complex_meshing = self.__class__.enable_complex_meshing(service, rules, path + [("enable_complex_meshing", "")])
                self.enable_overset_meshing = self.__class__.enable_overset_meshing(service, rules, path + [("enable_overset_meshing", "")])
                self.enable_prime_2d_meshing = self.__class__.enable_prime_2d_meshing(service, rules, path + [("enable_prime_2d_meshing", "")])
                self.enable_prime_meshing = self.__class__.enable_prime_meshing(service, rules, path + [("enable_prime_meshing", "")])
                self.initial_version = self.__class__.initial_version(service, rules, path + [("initial_version", "")])
                self.length_unit = self.__class__.length_unit(service, rules, path + [("length_unit", "")])
                self.normal_mode = self.__class__.normal_mode(service, rules, path + [("normal_mode", "")])
                self.old_size = self.__class__.old_size(service, rules, path + [("old_size", "")])
                self.use_allowed_values = self.__class__.use_allowed_values(service, rules, path + [("use_allowed_values", "")])
                self.utl_enabled = self.__class__.utl_enabled(service, rules, path + [("utl_enabled", "")])
                self.volume_unit = self.__class__.volume_unit(service, rules, path + [("volume_unit", "")])
                super().__init__(service, rules, path)

            class ftm_region_data(PyMenu):
                """
                Singleton ftm_region_data.
                """
                def __init__(self, service, rules, path):
                    self.all_overset_name_list = self.__class__.all_overset_name_list(service, rules, path + [("all_overset_name_list", "")])
                    self.all_overset_size_list = self.__class__.all_overset_size_list(service, rules, path + [("all_overset_size_list", "")])
                    self.all_overset_type_list = self.__class__.all_overset_type_list(service, rules, path + [("all_overset_type_list", "")])
                    self.all_overset_volume_fill_list = self.__class__.all_overset_volume_fill_list(service, rules, path + [("all_overset_volume_fill_list", "")])
                    self.all_region_filter_categories = self.__class__.all_region_filter_categories(service, rules, path + [("all_region_filter_categories", "")])
                    self.all_region_leakage_size_list = self.__class__.all_region_leakage_size_list(service, rules, path + [("all_region_leakage_size_list", "")])
                    self.all_region_linked_construction_surface_list = self.__class__.all_region_linked_construction_surface_list(service, rules, path + [("all_region_linked_construction_surface_list", "")])
                    self.all_region_mesh_method_list = self.__class__.all_region_mesh_method_list(service, rules, path + [("all_region_mesh_method_list", "")])
                    self.all_region_name_list = self.__class__.all_region_name_list(service, rules, path + [("all_region_name_list", "")])
                    self.all_region_overset_componen_list = self.__class__.all_region_overset_componen_list(service, rules, path + [("all_region_overset_componen_list", "")])
                    self.all_region_size_list = self.__class__.all_region_size_list(service, rules, path + [("all_region_size_list", "")])
                    self.all_region_source_list = self.__class__.all_region_source_list(service, rules, path + [("all_region_source_list", "")])
                    self.all_region_type_list = self.__class__.all_region_type_list(service, rules, path + [("all_region_type_list", "")])
                    self.all_region_volume_fill_list = self.__class__.all_region_volume_fill_list(service, rules, path + [("all_region_volume_fill_list", "")])
                    super().__init__(service, rules, path)

                class all_overset_name_list(PyTextual):
                    """
                    Parameter all_overset_name_list of value type list[str].
                    """
                    pass

                class all_overset_size_list(PyTextual):
                    """
                    Parameter all_overset_size_list of value type list[str].
                    """
                    pass

                class all_overset_type_list(PyTextual):
                    """
                    Parameter all_overset_type_list of value type list[str].
                    """
                    pass

                class all_overset_volume_fill_list(PyTextual):
                    """
                    Parameter all_overset_volume_fill_list of value type list[str].
                    """
                    pass

                class all_region_filter_categories(PyTextual):
                    """
                    Parameter all_region_filter_categories of value type list[str].
                    """
                    pass

                class all_region_leakage_size_list(PyTextual):
                    """
                    Parameter all_region_leakage_size_list of value type list[str].
                    """
                    pass

                class all_region_linked_construction_surface_list(PyTextual):
                    """
                    Parameter all_region_linked_construction_surface_list of value type list[str].
                    """
                    pass

                class all_region_mesh_method_list(PyTextual):
                    """
                    Parameter all_region_mesh_method_list of value type list[str].
                    """
                    pass

                class all_region_name_list(PyTextual):
                    """
                    Parameter all_region_name_list of value type list[str].
                    """
                    pass

                class all_region_overset_componen_list(PyTextual):
                    """
                    Parameter all_region_overset_componen_list of value type list[str].
                    """
                    pass

                class all_region_size_list(PyTextual):
                    """
                    Parameter all_region_size_list of value type list[str].
                    """
                    pass

                class all_region_source_list(PyTextual):
                    """
                    Parameter all_region_source_list of value type list[str].
                    """
                    pass

                class all_region_type_list(PyTextual):
                    """
                    Parameter all_region_type_list of value type list[str].
                    """
                    pass

                class all_region_volume_fill_list(PyTextual):
                    """
                    Parameter all_region_volume_fill_list of value type list[str].
                    """
                    pass

            class area_unit(PyTextual):
                """
                Parameter area_unit of value type str.
                """
                pass

            class current_task(PyTextual):
                """
                Parameter current_task of value type str.
                """
                pass

            class enable_clean_cad(PyParameter):
                """
                Parameter enable_clean_cad of value type bool.
                """
                pass

            class enable_complex_meshing(PyParameter):
                """
                Parameter enable_complex_meshing of value type bool.
                """
                pass

            class enable_overset_meshing(PyParameter):
                """
                Parameter enable_overset_meshing of value type bool.
                """
                pass

            class enable_prime_2d_meshing(PyParameter):
                """
                Parameter enable_prime_2d_meshing of value type bool.
                """
                pass

            class enable_prime_meshing(PyParameter):
                """
                Parameter enable_prime_meshing of value type bool.
                """
                pass

            class initial_version(PyTextual):
                """
                Parameter initial_version of value type str.
                """
                pass

            class length_unit(PyTextual):
                """
                Parameter length_unit of value type str.
                """
                pass

            class normal_mode(PyParameter):
                """
                Parameter normal_mode of value type bool.
                """
                pass

            class old_size(PyNumerical):
                """
                Parameter old_size of value type float.
                """
                pass

            class use_allowed_values(PyParameter):
                """
                Parameter use_allowed_values of value type bool.
                """
                pass

            class utl_enabled(PyParameter):
                """
                Parameter utl_enabled of value type bool.
                """
                pass

            class volume_unit(PyTextual):
                """
                Parameter volume_unit of value type str.
                """
                pass

        class graphics(PyMenu):
            """
            Singleton graphics.
            """
            def __init__(self, service, rules, path):
                self.bounds = self.__class__.bounds(service, rules, path + [("bounds", "")])
                self.regions = self.__class__.regions(service, rules, path + [("regions", "")])
                self.clipping_plane = self.__class__.clipping_plane(service, rules, "clipping_plane", path)
                self.draw_thin_volume_regions = self.__class__.draw_thin_volume_regions(service, rules, "draw_thin_volume_regions", path)
                self.get_clipping_zone_i_ds = self.__class__.get_clipping_zone_i_ds(service, rules, "get_clipping_zone_i_ds", path)
                self.get_visible_domain_bounds = self.__class__.get_visible_domain_bounds(service, rules, "get_visible_domain_bounds", path)
                self.mark_gaps = self.__class__.mark_gaps(service, rules, "mark_gaps", path)
                super().__init__(service, rules, path)

            class bounds(PyMenu):
                """
                Singleton bounds.
                """
                def __init__(self, service, rules, path):
                    self.bound_x = self.__class__.bound_x(service, rules, path + [("bound_x", "")])
                    self.bound_y = self.__class__.bound_y(service, rules, path + [("bound_y", "")])
                    self.bound_z = self.__class__.bound_z(service, rules, path + [("bound_z", "")])
                    self.delta_value = self.__class__.delta_value(service, rules, path + [("delta_value", "")])
                    self.selection = self.__class__.selection(service, rules, path + [("selection", "")])
                    self.reset_bounds = self.__class__.reset_bounds(service, rules, "reset_bounds", path)
                    self.set_bounds = self.__class__.set_bounds(service, rules, "set_bounds", path)
                    super().__init__(service, rules, path)

                class bound_x(PyParameter):
                    """
                    Parameter bound_x of value type bool.
                    """
                    pass

                class bound_y(PyParameter):
                    """
                    Parameter bound_y of value type bool.
                    """
                    pass

                class bound_z(PyParameter):
                    """
                    Parameter bound_z of value type bool.
                    """
                    pass

                class delta_value(PyNumerical):
                    """
                    Parameter delta_value of value type float.
                    """
                    pass

                class selection(PyTextual):
                    """
                    Parameter selection of value type str.
                    """
                    pass

                class reset_bounds(PyCommand):
                    """
                    Command reset_bounds.


                    Returns
                    -------
                    None
                    """
                    class _reset_boundsArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _reset_boundsArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._reset_boundsArguments(*args)

                class set_bounds(PyCommand):
                    """
                    Command set_bounds.

                    Parameters
                    ----------
                    value : float

                    Returns
                    -------
                    None
                    """
                    class _set_boundsArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.value = self._value(self, "value", service, rules, path)

                        class _value(PyArgumentsNumericalSubItem):
                            """
                            Argument value.
                            """

                    def create_instance(self) -> _set_boundsArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_boundsArguments(*args)

            class regions(PyMenu):
                """
                Singleton regions.
                """
                def __init__(self, service, rules, path):
                    self.draw_all = self.__class__.draw_all(service, rules, "draw_all", path)
                    self.draw_dead = self.__class__.draw_dead(service, rules, "draw_dead", path)
                    self.draw_fluid = self.__class__.draw_fluid(service, rules, "draw_fluid", path)
                    self.draw_solid = self.__class__.draw_solid(service, rules, "draw_solid", path)
                    super().__init__(service, rules, path)

                class draw_all(PyCommand):
                    """
                    Command draw_all.


                    Returns
                    -------
                    None
                    """
                    class _draw_allArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _draw_allArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._draw_allArguments(*args)

                class draw_dead(PyCommand):
                    """
                    Command draw_dead.


                    Returns
                    -------
                    None
                    """
                    class _draw_deadArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _draw_deadArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._draw_deadArguments(*args)

                class draw_fluid(PyCommand):
                    """
                    Command draw_fluid.


                    Returns
                    -------
                    None
                    """
                    class _draw_fluidArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _draw_fluidArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._draw_fluidArguments(*args)

                class draw_solid(PyCommand):
                    """
                    Command draw_solid.


                    Returns
                    -------
                    None
                    """
                    class _draw_solidArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _draw_solidArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._draw_solidArguments(*args)

            class clipping_plane(PyCommand):
                """
                Command clipping_plane.

                Parameters
                ----------
                insert_clipping_plane : bool
                draw_cell_layer : bool
                freeze_cell_layer : bool
                flip_clipping_plane : bool
                point_coordinates : list[float]
                plane_normal : list[float]
                slider_position : int
                cut_direction : str

                Returns
                -------
                None
                """
                class _clipping_planeArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.insert_clipping_plane = self._insert_clipping_plane(self, "insert_clipping_plane", service, rules, path)
                        self.draw_cell_layer = self._draw_cell_layer(self, "draw_cell_layer", service, rules, path)
                        self.freeze_cell_layer = self._freeze_cell_layer(self, "freeze_cell_layer", service, rules, path)
                        self.flip_clipping_plane = self._flip_clipping_plane(self, "flip_clipping_plane", service, rules, path)
                        self.point_coordinates = self._point_coordinates(self, "point_coordinates", service, rules, path)
                        self.plane_normal = self._plane_normal(self, "plane_normal", service, rules, path)
                        self.slider_position = self._slider_position(self, "slider_position", service, rules, path)
                        self.cut_direction = self._cut_direction(self, "cut_direction", service, rules, path)

                    class _insert_clipping_plane(PyArgumentsParameterSubItem):
                        """
                        Argument insert_clipping_plane.
                        """

                    class _draw_cell_layer(PyArgumentsParameterSubItem):
                        """
                        Argument draw_cell_layer.
                        """

                    class _freeze_cell_layer(PyArgumentsParameterSubItem):
                        """
                        Argument freeze_cell_layer.
                        """

                    class _flip_clipping_plane(PyArgumentsParameterSubItem):
                        """
                        Argument flip_clipping_plane.
                        """

                    class _point_coordinates(PyArgumentsNumericalSubItem):
                        """
                        Argument point_coordinates.
                        """

                    class _plane_normal(PyArgumentsNumericalSubItem):
                        """
                        Argument plane_normal.
                        """

                    class _slider_position(PyArgumentsNumericalSubItem):
                        """
                        Argument slider_position.
                        """

                    class _cut_direction(PyArgumentsTextualSubItem):
                        """
                        Argument cut_direction.
                        """

                def create_instance(self) -> _clipping_planeArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._clipping_planeArguments(*args)

            class draw_thin_volume_regions(PyCommand):
                """
                Command draw_thin_volume_regions.

                Parameters
                ----------
                task_instance_name : str

                Returns
                -------
                None
                """
                class _draw_thin_volume_regionsArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.task_instance_name = self._task_instance_name(self, "task_instance_name", service, rules, path)

                    class _task_instance_name(PyArgumentsTextualSubItem):
                        """
                        Argument task_instance_name.
                        """

                def create_instance(self) -> _draw_thin_volume_regionsArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._draw_thin_volume_regionsArguments(*args)

            class get_clipping_zone_i_ds(PyCommand):
                """
                Command get_clipping_zone_i_ds.


                Returns
                -------
                None
                """
                class _get_clipping_zone_i_dsArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _get_clipping_zone_i_dsArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._get_clipping_zone_i_dsArguments(*args)

            class get_visible_domain_bounds(PyCommand):
                """
                Command get_visible_domain_bounds.


                Returns
                -------
                None
                """
                class _get_visible_domain_boundsArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _get_visible_domain_boundsArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._get_visible_domain_boundsArguments(*args)

            class mark_gaps(PyCommand):
                """
                Command mark_gaps.

                Parameters
                ----------
                gap_distance : float
                gap_distance_connect : float
                min_size : float
                share_topology_preferences : dict[str, Any]

                Returns
                -------
                None
                """
                class _mark_gapsArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.gap_distance = self._gap_distance(self, "gap_distance", service, rules, path)
                        self.gap_distance_connect = self._gap_distance_connect(self, "gap_distance_connect", service, rules, path)
                        self.min_size = self._min_size(self, "min_size", service, rules, path)
                        self.share_topology_preferences = self._share_topology_preferences(self, "share_topology_preferences", service, rules, path)

                    class _gap_distance(PyArgumentsNumericalSubItem):
                        """
                        Argument gap_distance.
                        """

                    class _gap_distance_connect(PyArgumentsNumericalSubItem):
                        """
                        Argument gap_distance_connect.
                        """

                    class _min_size(PyArgumentsNumericalSubItem):
                        """
                        Argument min_size.
                        """

                    class _share_topology_preferences(PyArgumentsSingletonSubItem):
                        """
                        Argument share_topology_preferences.
                        """

                        def __init__(self, parent, attr, service, rules, path):
                            super().__init__(parent, attr, service, rules, path)
                            self.per_label_list = self._per_label_list(self, "per_label_list", service, rules, path)
                            self.advanced_improve = self._advanced_improve(self, "advanced_improve", service, rules, path)
                            self.share_topology_angle = self._share_topology_angle(self, "share_topology_angle", service, rules, path)
                            self.join_tolerance_increment = self._join_tolerance_increment(self, "join_tolerance_increment", service, rules, path)
                            self.model_is_periodic = self._model_is_periodic(self, "model_is_periodic", service, rules, path)
                            self.fluid_label_wildcard = self._fluid_label_wildcard(self, "fluid_label_wildcard", service, rules, path)
                            self.intf_label_list = self._intf_label_list(self, "intf_label_list", service, rules, path)
                            self.relative_share_topology_tolerance = self._relative_share_topology_tolerance(self, "relative_share_topology_tolerance", service, rules, path)
                            self.execute_join_intersect = self._execute_join_intersect(self, "execute_join_intersect", service, rules, path)
                            self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)
                            self.allow_defeaturing = self._allow_defeaturing(self, "allow_defeaturing", service, rules, path)
                            self.number_of_join_tries = self._number_of_join_tries(self, "number_of_join_tries", service, rules, path)
                            self.operation = self._operation(self, "operation", service, rules, path)
                            self.rename_internals_by_body_names = self._rename_internals_by_body_names(self, "rename_internals_by_body_names", service, rules, path)
                            self.connect_label_wildcard = self._connect_label_wildcard(self, "connect_label_wildcard", service, rules, path)

                        class _per_label_list(PyArgumentsTextualSubItem):
                            """
                            Argument per_label_list.
                            """

                        class _advanced_improve(PyArgumentsParameterSubItem):
                            """
                            Argument advanced_improve.
                            """

                        class _share_topology_angle(PyArgumentsNumericalSubItem):
                            """
                            Specify the threshold angle for joining face pairs.
                            """

                        class _join_tolerance_increment(PyArgumentsNumericalSubItem):
                            """
                            Specify the increment by which the tolerance changes for each attempt to join face pairs.
                            """

                        class _model_is_periodic(PyArgumentsParameterSubItem):
                            """
                            Choose whether or not you need to set up periodic boundaries. If you select yes, then choose your periodic boundaries from the list of available boundaries.
                            """

                        class _fluid_label_wildcard(PyArgumentsTextualSubItem):
                            """
                            Argument fluid_label_wildcard.
                            """

                        class _intf_label_list(PyArgumentsTextualSubItem):
                            """
                            Enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                            """

                        class _relative_share_topology_tolerance(PyArgumentsNumericalSubItem):
                            """
                            Specify the relative tolerance for joining or intersecting face pairs, or the relative tolerance for connecting edge and face pairs.
                            """

                        class _execute_join_intersect(PyArgumentsTextualSubItem):
                            """
                            Choose whether the system will only join faces, only intersect faces, or do both.
                            """

                        class _show_in_gui(PyArgumentsParameterSubItem):
                            """
                            Display advanced options that you may want to apply to the task.
                            """

                        class _allow_defeaturing(PyArgumentsParameterSubItem):
                            """
                            Argument allow_defeaturing.
                            """

                        class _number_of_join_tries(PyArgumentsNumericalSubItem):
                            """
                            Specify the number of attempts that will be made to join face pairs under the given criteria.
                            """

                        class _operation(PyArgumentsTextualSubItem):
                            """
                            Choose whether to apply share topology using the Join-Intersect method where you join and/or intersect the problematic faces, or using the Interface Connect method where you connect edges of overlapping face pairs. Note that imprinting of overlapping faces in SCDM/Discovery is highly recommended for the Interface Connect method.
                            """

                        class _rename_internals_by_body_names(PyArgumentsParameterSubItem):
                            """
                            Choose whether or not to apply body names from the imported geometry and use them in naming internal boundaries.  For instance, the internal face between two regions solid and body would be renamed to solid-body.
                            """

                        class _connect_label_wildcard(PyArgumentsTextualSubItem):
                            """
                            Enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                            """

                def create_instance(self) -> _mark_gapsArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._mark_gapsArguments(*args)

        class add_2d_boundary_layers(PyCommand):
            """
            Command add_2d_boundary_layers.

            Parameters
            ----------
            add_child : bool
            control_name : str
            offset_method_type : str
            number_of_layers : int
            first_aspect_ratio : float
            transition_ratio : float
            last_aspect_ratio : float
            rate : float
            first_layer_height : float
            max_layer_height : float
            addin : str
            face_label_list : list[str]
            grow_on : str
            edge_label_list : list[str]
            edge_zone_list : list[str]
            shell_bl_advanced_options : dict[str, Any]

            Returns
            -------
            bool
            """
            class _add_2d_boundary_layersArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.add_child = self._add_child(self, "add_child", service, rules, path)
                    self.control_name = self._control_name(self, "control_name", service, rules, path)
                    self.offset_method_type = self._offset_method_type(self, "offset_method_type", service, rules, path)
                    self.number_of_layers = self._number_of_layers(self, "number_of_layers", service, rules, path)
                    self.first_aspect_ratio = self._first_aspect_ratio(self, "first_aspect_ratio", service, rules, path)
                    self.transition_ratio = self._transition_ratio(self, "transition_ratio", service, rules, path)
                    self.last_aspect_ratio = self._last_aspect_ratio(self, "last_aspect_ratio", service, rules, path)
                    self.rate = self._rate(self, "rate", service, rules, path)
                    self.first_layer_height = self._first_layer_height(self, "first_layer_height", service, rules, path)
                    self.max_layer_height = self._max_layer_height(self, "max_layer_height", service, rules, path)
                    self.addin = self._addin(self, "addin", service, rules, path)
                    self.face_label_list = self._face_label_list(self, "face_label_list", service, rules, path)
                    self.grow_on = self._grow_on(self, "grow_on", service, rules, path)
                    self.edge_label_list = self._edge_label_list(self, "edge_label_list", service, rules, path)
                    self.edge_zone_list = self._edge_zone_list(self, "edge_zone_list", service, rules, path)
                    self.shell_bl_advanced_options = self._shell_bl_advanced_options(self, "shell_bl_advanced_options", service, rules, path)

                class _add_child(PyArgumentsParameterSubItem):
                    """
                    Argument add_child.
                    """

                class _control_name(PyArgumentsTextualSubItem):
                    """
                    Argument control_name.
                    """

                class _offset_method_type(PyArgumentsTextualSubItem):
                    """
                    Argument offset_method_type.
                    """

                class _number_of_layers(PyArgumentsNumericalSubItem):
                    """
                    Argument number_of_layers.
                    """

                class _first_aspect_ratio(PyArgumentsNumericalSubItem):
                    """
                    Argument first_aspect_ratio.
                    """

                class _transition_ratio(PyArgumentsNumericalSubItem):
                    """
                    Argument transition_ratio.
                    """

                class _last_aspect_ratio(PyArgumentsNumericalSubItem):
                    """
                    Argument last_aspect_ratio.
                    """

                class _rate(PyArgumentsNumericalSubItem):
                    """
                    Argument rate.
                    """

                class _first_layer_height(PyArgumentsNumericalSubItem):
                    """
                    Argument first_layer_height.
                    """

                class _max_layer_height(PyArgumentsNumericalSubItem):
                    """
                    Argument max_layer_height.
                    """

                class _addin(PyArgumentsTextualSubItem):
                    """
                    Argument addin.
                    """

                class _face_label_list(PyArgumentsTextualSubItem):
                    """
                    Argument face_label_list.
                    """

                class _grow_on(PyArgumentsTextualSubItem):
                    """
                    Argument grow_on.
                    """

                class _edge_label_list(PyArgumentsTextualSubItem):
                    """
                    Argument edge_label_list.
                    """

                class _edge_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument edge_zone_list.
                    """

                class _shell_bl_advanced_options(PyArgumentsSingletonSubItem):
                    """
                    Argument shell_bl_advanced_options.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.adjacent_attach_angle = self._adjacent_attach_angle(self, "adjacent_attach_angle", service, rules, path)
                        self.expose_side = self._expose_side(self, "expose_side", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)
                        self.max_aspect_ratio = self._max_aspect_ratio(self, "max_aspect_ratio", service, rules, path)
                        self.last_ratio_num_layers = self._last_ratio_num_layers(self, "last_ratio_num_layers", service, rules, path)
                        self.last_ratio_percentage = self._last_ratio_percentage(self, "last_ratio_percentage", service, rules, path)
                        self.min_aspect_ratio = self._min_aspect_ratio(self, "min_aspect_ratio", service, rules, path)
                        self.gap_factor = self._gap_factor(self, "gap_factor", service, rules, path)

                    class _adjacent_attach_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument adjacent_attach_angle.
                        """

                    class _expose_side(PyArgumentsParameterSubItem):
                        """
                        Argument expose_side.
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Argument show_in_gui.
                        """

                    class _max_aspect_ratio(PyArgumentsNumericalSubItem):
                        """
                        Argument max_aspect_ratio.
                        """

                    class _last_ratio_num_layers(PyArgumentsNumericalSubItem):
                        """
                        Argument last_ratio_num_layers.
                        """

                    class _last_ratio_percentage(PyArgumentsNumericalSubItem):
                        """
                        Argument last_ratio_percentage.
                        """

                    class _min_aspect_ratio(PyArgumentsNumericalSubItem):
                        """
                        Argument min_aspect_ratio.
                        """

                    class _gap_factor(PyArgumentsNumericalSubItem):
                        """
                        Argument gap_factor.
                        """

            def create_instance(self) -> _add_2d_boundary_layersArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._add_2d_boundary_layersArguments(*args)

        class add_boundary_layers(PyCommand):
            """
            Determine whether or not boundary layers will be added to various portions of the model. Once a boundary layer is defined, global boundary layer settings are determined in the Create Volume Mesh task.
            Parameters
            ----------
            add_child : str
                Determine whether (yes) or not (no) you want to specify one or more boundary layers for your simulation. If none are yet defined, you can choose yes, using prism control file and read in a prism control file that holds the boundary layer definition.
            read_prism_control_file : str
                Specify (or browse for) a .pzmcontrol file that contains the boundary (prism) layer specifications.
            control_name : str
                Specify a name for the boundary layer control or use the default value.
            offset_method_type : str
                Choose the type of offset to determine how the mesh cells closest to the boundary are generated.  More...
            number_of_layers : int
                Select the number of boundary layers to be generated.
            first_aspect_ratio : float
                Specify the aspect ratio of the first layer of prism cells that are extruded from the base boundary zone.
            transition_ratio : float
                For the smooth transition offset method, specify the rate at which adjacent elements grow. For the last-ratio offset method, specify the factor by which the thickness of each subsequent boundary layer increases or decreases compared to the previous layer.
            rate : float
                Specify the rate of growth for the boundary layer.
            first_height : float
                Specify the height of the first layer of cells in the boundary layer.
            max_layer_height : float
            face_scope : dict[str, Any]
            region_scope : list[str]
                Select the named region(s) from the list to which you would like to add a boundary layer. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            bl_label_list : list[str]
                Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_selection_list : list[str]
                Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_location : list[str]
            local_prism_preferences : dict[str, Any]
            zone_list : list[str]
            region_list : list[str]
            invalid_added : str
            complete_region_scope : list[str]
                Select the named region(s) from the list to which you would like to add a boundary layer. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            complete_bl_label_list : list[str]
                Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            complete_bl_zone_list : list[str]
            complete_bl_region_list : list[str]
            complete_zone_selection_list : list[str]
                Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            complete_label_selection_list : list[str]

            Returns
            -------
            bool
            """
            class _add_boundary_layersArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.add_child = self._add_child(self, "add_child", service, rules, path)
                    self.read_prism_control_file = self._read_prism_control_file(self, "read_prism_control_file", service, rules, path)
                    self.control_name = self._control_name(self, "control_name", service, rules, path)
                    self.offset_method_type = self._offset_method_type(self, "offset_method_type", service, rules, path)
                    self.number_of_layers = self._number_of_layers(self, "number_of_layers", service, rules, path)
                    self.first_aspect_ratio = self._first_aspect_ratio(self, "first_aspect_ratio", service, rules, path)
                    self.transition_ratio = self._transition_ratio(self, "transition_ratio", service, rules, path)
                    self.rate = self._rate(self, "rate", service, rules, path)
                    self.first_height = self._first_height(self, "first_height", service, rules, path)
                    self.max_layer_height = self._max_layer_height(self, "max_layer_height", service, rules, path)
                    self.face_scope = self._face_scope(self, "face_scope", service, rules, path)
                    self.region_scope = self._region_scope(self, "region_scope", service, rules, path)
                    self.bl_label_list = self._bl_label_list(self, "bl_label_list", service, rules, path)
                    self.zone_selection_list = self._zone_selection_list(self, "zone_selection_list", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.local_prism_preferences = self._local_prism_preferences(self, "local_prism_preferences", service, rules, path)
                    self.zone_list = self._zone_list(self, "zone_list", service, rules, path)
                    self.region_list = self._region_list(self, "region_list", service, rules, path)
                    self.invalid_added = self._invalid_added(self, "invalid_added", service, rules, path)
                    self.complete_region_scope = self._complete_region_scope(self, "complete_region_scope", service, rules, path)
                    self.complete_bl_label_list = self._complete_bl_label_list(self, "complete_bl_label_list", service, rules, path)
                    self.complete_bl_zone_list = self._complete_bl_zone_list(self, "complete_bl_zone_list", service, rules, path)
                    self.complete_bl_region_list = self._complete_bl_region_list(self, "complete_bl_region_list", service, rules, path)
                    self.complete_zone_selection_list = self._complete_zone_selection_list(self, "complete_zone_selection_list", service, rules, path)
                    self.complete_label_selection_list = self._complete_label_selection_list(self, "complete_label_selection_list", service, rules, path)

                class _add_child(PyArgumentsTextualSubItem):
                    """
                    Determine whether (yes) or not (no) you want to specify one or more boundary layers for your simulation. If none are yet defined, you can choose yes, using prism control file and read in a prism control file that holds the boundary layer definition.
                    """

                class _read_prism_control_file(PyArgumentsTextualSubItem):
                    """
                    Specify (or browse for) a .pzmcontrol file that contains the boundary (prism) layer specifications.
                    """

                class _control_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the boundary layer control or use the default value.
                    """

                class _offset_method_type(PyArgumentsTextualSubItem):
                    """
                    Choose the type of offset to determine how the mesh cells closest to the boundary are generated.  More...
                    """

                class _number_of_layers(PyArgumentsNumericalSubItem):
                    """
                    Select the number of boundary layers to be generated.
                    """

                class _first_aspect_ratio(PyArgumentsNumericalSubItem):
                    """
                    Specify the aspect ratio of the first layer of prism cells that are extruded from the base boundary zone.
                    """

                class _transition_ratio(PyArgumentsNumericalSubItem):
                    """
                    For the smooth transition offset method, specify the rate at which adjacent elements grow. For the last-ratio offset method, specify the factor by which the thickness of each subsequent boundary layer increases or decreases compared to the previous layer.
                    """

                class _rate(PyArgumentsNumericalSubItem):
                    """
                    Specify the rate of growth for the boundary layer.
                    """

                class _first_height(PyArgumentsNumericalSubItem):
                    """
                    Specify the height of the first layer of cells in the boundary layer.
                    """

                class _max_layer_height(PyArgumentsNumericalSubItem):
                    """
                    Argument max_layer_height.
                    """

                class _face_scope(PyArgumentsSingletonSubItem):
                    """
                    Argument face_scope.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.face_scope_mesh_object = self._face_scope_mesh_object(self, "face_scope_mesh_object", service, rules, path)
                        self.regions_type = self._regions_type(self, "regions_type", service, rules, path)
                        self.grow_on = self._grow_on(self, "grow_on", service, rules, path)
                        self.topology_list = self._topology_list(self, "topology_list", service, rules, path)

                    class _face_scope_mesh_object(PyArgumentsTextualSubItem):
                        """
                        Argument face_scope_mesh_object.
                        """

                    class _regions_type(PyArgumentsTextualSubItem):
                        """
                        Specify what regions you would like to add the boundary layers: solid regions, fluid regions, or specifically named regions.
                        """

                    class _grow_on(PyArgumentsTextualSubItem):
                        """
                        Specify where you would like to develop the boundary layers: either along only walls, all zones, along solid-fluid interfaces, or specifically selected zones or labels.
                        """

                    class _topology_list(PyArgumentsTextualSubItem):
                        """
                        Argument topology_list.
                        """

                class _region_scope(PyArgumentsTextualSubItem):
                    """
                    Select the named region(s) from the list to which you would like to add a boundary layer. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _bl_label_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _local_prism_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument local_prism_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.additional_ignored_layers = self._additional_ignored_layers(self, "additional_ignored_layers", service, rules, path)
                        self.last_ratio = self._last_ratio(self, "last_ratio", service, rules, path)
                        self.split_prism = self._split_prism(self, "split_prism", service, rules, path)
                        self.allowed_tangency_at_invalid_normals = self._allowed_tangency_at_invalid_normals(self, "allowed_tangency_at_invalid_normals", service, rules, path)
                        self.invalid_normal_method = self._invalid_normal_method(self, "invalid_normal_method", service, rules, path)
                        self.modify_at_invalid_normals = self._modify_at_invalid_normals(self, "modify_at_invalid_normals", service, rules, path)
                        self.remesh_at_invalid_normals = self._remesh_at_invalid_normals(self, "remesh_at_invalid_normals", service, rules, path)
                        self.number_of_split_layers = self._number_of_split_layers(self, "number_of_split_layers", service, rules, path)
                        self.smooth_rings_at_invalid_normals = self._smooth_rings_at_invalid_normals(self, "smooth_rings_at_invalid_normals", service, rules, path)
                        self.sphere_radius_factor_at_invalid_normals = self._sphere_radius_factor_at_invalid_normals(self, "sphere_radius_factor_at_invalid_normals", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)
                        self.continuous = self._continuous(self, "continuous", service, rules, path)
                        self.last_ratio_num_layers = self._last_ratio_num_layers(self, "last_ratio_num_layers", service, rules, path)
                        self.ignore_boundary_layers = self._ignore_boundary_layers(self, "ignore_boundary_layers", service, rules, path)

                    class _additional_ignored_layers(PyArgumentsNumericalSubItem):
                        """
                        Indicate the number of buffer layers that can be placed around ignored boundary layer faces, extending the ignored regions around sharp angles. Increasing the value increases the number of faces for which the boundary layer will be ignored at acute angles.
                        """

                    class _last_ratio(PyArgumentsNumericalSubItem):
                        """
                        Argument last_ratio.
                        """

                    class _split_prism(PyArgumentsParameterSubItem):
                        """
                        Choose whether or not to add split prisms to each layer along the boundary. Not available when the Offset Method Type is set to last-ratio.
                        """

                    class _allowed_tangency_at_invalid_normals(PyArgumentsNumericalSubItem):
                        """
                        Controls the tangency of the invalid normal faces. An invalid normal location with all 90 degree angles has a tangency of 1. So, faces are still treated as an invalid normal even if the angle deviates slightly from 90 degrees (resulting in a tangency of 0.98).
                        """

                    class _invalid_normal_method(PyArgumentsTextualSubItem):
                        """
                        Argument invalid_normal_method.
                        """

                    class _modify_at_invalid_normals(PyArgumentsParameterSubItem):
                        """
                        Specify whether to automatically change the surface mesh where invalid normal faces are detected. To grow the boundary layer mesh in the proper direction (away from the boundary), normal vectors (valid) are required at the boundary face nodes of the surface mesh. More...
                        """

                    class _remesh_at_invalid_normals(PyArgumentsParameterSubItem):
                        """
                        Specify whether or not to remesh around the area of the invalid normal(s). When enabled, a local (non-size function-based) remeshing procedure is performed to obtain similar sizes around the sphere with a reasonable transition to the surrounding mesh.
                        """

                    class _number_of_split_layers(PyArgumentsNumericalSubItem):
                        """
                        Indicate the number of split prism layers you wish to apply to each layer that you specified for the boundary layer definition.
                        """

                    class _smooth_rings_at_invalid_normals(PyArgumentsNumericalSubItem):
                        """
                        Argument smooth_rings_at_invalid_normals.
                        """

                    class _sphere_radius_factor_at_invalid_normals(PyArgumentsNumericalSubItem):
                        """
                        This factor is used to determine the size of the spheres created at the invalid normal location. The spheres have a radius of one half of the average mesh edge length adjacent to the invalid location. The default factor of 0.8 ensures a sphere size that is slightly smaller than that.
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Display advanced options that you may want to apply to this task.
                        """

                    class _continuous(PyArgumentsTextualSubItem):
                        """
                        Specify how you would like to improve the generated boundary layer: as a continuous or stair-stepped boundary layer in the specified area(s).
                        """

                    class _last_ratio_num_layers(PyArgumentsNumericalSubItem):
                        """
                        Argument last_ratio_num_layers.
                        """

                    class _ignore_boundary_layers(PyArgumentsParameterSubItem):
                        """
                        Specify whether to automatically ignore boundary layers where there is an acute angle. Note that if there are sharp angles adjacent to other regions with boundary layers, some boundary layer removal may occur in those adjacent regions.
                        """

                class _zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument zone_list.
                    """

                class _region_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_list.
                    """

                class _invalid_added(PyArgumentsTextualSubItem):
                    """
                    Argument invalid_added.
                    """

                class _complete_region_scope(PyArgumentsTextualSubItem):
                    """
                    Select the named region(s) from the list to which you would like to add a boundary layer. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _complete_bl_label_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _complete_bl_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument complete_bl_zone_list.
                    """

                class _complete_bl_region_list(PyArgumentsTextualSubItem):
                    """
                    Argument complete_bl_region_list.
                    """

                class _complete_zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _complete_label_selection_list(PyArgumentsTextualSubItem):
                    """
                    Argument complete_label_selection_list.
                    """

            def create_instance(self) -> _add_boundary_layersArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._add_boundary_layersArguments(*args)

        class add_boundary_layers_for_part_replacement(PyCommand):
            """
            Determine whether or not boundary layers will be added to your replacement parts for this model.
            Parameters
            ----------
            add_child : str
                Determine whether (yes) or not (no) you want to specify one or more boundary layers for your simulation. If none are yet defined, you can choose yes, using prism control file and read in a prism control file that holds the boundary layer definition.
            read_prism_control_file : str
                Specify (or browse for) a .pzmcontrol file that contains the boundary (prism) layer specifications.
            control_name : str
                Specify a name for the boundary layer control or use the default value.
            offset_method_type : str
                Choose the type of offset to determine how the mesh cells closest to the boundary are generated.  More...
            number_of_layers : int
                Select the number of boundary layers to be generated.
            first_aspect_ratio : float
                Specify the aspect ratio of the first layer of prism cells that are extruded from the base boundary zone.
            transition_ratio : float
                For the smooth transition offset method, specify the rate at which adjacent elements grow. For the last-ratio offset method, specify the factor by which the thickness of each subsequent boundary layer increases or decreases compared to the previous layer.
            rate : float
                Specify the rate of growth for the boundary layer.
            first_height : float
                Specify the height of the first layer of cells in the boundary layer.
            max_layer_height : float
            face_scope : dict[str, Any]
            region_scope : list[str]
                Select the named region(s) from the list to which you would like to add a boundary layer. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            label_list : list[str]
                Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_selection_list : list[str]
                Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_location : list[str]
            local_prism_preferences : dict[str, Any]
            bl_zone_list : list[str]
            bl_region_list : list[str]
            complete_region_scope : list[str]
                Select the named region(s) from the list to which you would like to add a boundary layer. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            complete_bl_label_list : list[str]
                Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            complete_bl_zone_list : list[str]
            complete_bl_region_list : list[str]
            complete_zone_selection_list : list[str]
                Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            complete_label_selection_list : list[str]

            Returns
            -------
            bool
            """
            class _add_boundary_layers_for_part_replacementArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.add_child = self._add_child(self, "add_child", service, rules, path)
                    self.read_prism_control_file = self._read_prism_control_file(self, "read_prism_control_file", service, rules, path)
                    self.control_name = self._control_name(self, "control_name", service, rules, path)
                    self.offset_method_type = self._offset_method_type(self, "offset_method_type", service, rules, path)
                    self.number_of_layers = self._number_of_layers(self, "number_of_layers", service, rules, path)
                    self.first_aspect_ratio = self._first_aspect_ratio(self, "first_aspect_ratio", service, rules, path)
                    self.transition_ratio = self._transition_ratio(self, "transition_ratio", service, rules, path)
                    self.rate = self._rate(self, "rate", service, rules, path)
                    self.first_height = self._first_height(self, "first_height", service, rules, path)
                    self.max_layer_height = self._max_layer_height(self, "max_layer_height", service, rules, path)
                    self.face_scope = self._face_scope(self, "face_scope", service, rules, path)
                    self.region_scope = self._region_scope(self, "region_scope", service, rules, path)
                    self.label_list = self._label_list(self, "label_list", service, rules, path)
                    self.zone_selection_list = self._zone_selection_list(self, "zone_selection_list", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.local_prism_preferences = self._local_prism_preferences(self, "local_prism_preferences", service, rules, path)
                    self.bl_zone_list = self._bl_zone_list(self, "bl_zone_list", service, rules, path)
                    self.bl_region_list = self._bl_region_list(self, "bl_region_list", service, rules, path)
                    self.complete_region_scope = self._complete_region_scope(self, "complete_region_scope", service, rules, path)
                    self.complete_bl_label_list = self._complete_bl_label_list(self, "complete_bl_label_list", service, rules, path)
                    self.complete_bl_zone_list = self._complete_bl_zone_list(self, "complete_bl_zone_list", service, rules, path)
                    self.complete_bl_region_list = self._complete_bl_region_list(self, "complete_bl_region_list", service, rules, path)
                    self.complete_zone_selection_list = self._complete_zone_selection_list(self, "complete_zone_selection_list", service, rules, path)
                    self.complete_label_selection_list = self._complete_label_selection_list(self, "complete_label_selection_list", service, rules, path)

                class _add_child(PyArgumentsTextualSubItem):
                    """
                    Determine whether (yes) or not (no) you want to specify one or more boundary layers for your simulation. If none are yet defined, you can choose yes, using prism control file and read in a prism control file that holds the boundary layer definition.
                    """

                class _read_prism_control_file(PyArgumentsTextualSubItem):
                    """
                    Specify (or browse for) a .pzmcontrol file that contains the boundary (prism) layer specifications.
                    """

                class _control_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the boundary layer control or use the default value.
                    """

                class _offset_method_type(PyArgumentsTextualSubItem):
                    """
                    Choose the type of offset to determine how the mesh cells closest to the boundary are generated.  More...
                    """

                class _number_of_layers(PyArgumentsNumericalSubItem):
                    """
                    Select the number of boundary layers to be generated.
                    """

                class _first_aspect_ratio(PyArgumentsNumericalSubItem):
                    """
                    Specify the aspect ratio of the first layer of prism cells that are extruded from the base boundary zone.
                    """

                class _transition_ratio(PyArgumentsNumericalSubItem):
                    """
                    For the smooth transition offset method, specify the rate at which adjacent elements grow. For the last-ratio offset method, specify the factor by which the thickness of each subsequent boundary layer increases or decreases compared to the previous layer.
                    """

                class _rate(PyArgumentsNumericalSubItem):
                    """
                    Specify the rate of growth for the boundary layer.
                    """

                class _first_height(PyArgumentsNumericalSubItem):
                    """
                    Specify the height of the first layer of cells in the boundary layer.
                    """

                class _max_layer_height(PyArgumentsNumericalSubItem):
                    """
                    Argument max_layer_height.
                    """

                class _face_scope(PyArgumentsSingletonSubItem):
                    """
                    Argument face_scope.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.face_scope_mesh_object = self._face_scope_mesh_object(self, "face_scope_mesh_object", service, rules, path)
                        self.regions_type = self._regions_type(self, "regions_type", service, rules, path)
                        self.grow_on = self._grow_on(self, "grow_on", service, rules, path)
                        self.topology_list = self._topology_list(self, "topology_list", service, rules, path)

                    class _face_scope_mesh_object(PyArgumentsTextualSubItem):
                        """
                        Argument face_scope_mesh_object.
                        """

                    class _regions_type(PyArgumentsTextualSubItem):
                        """
                        Specify what regions you would like to add the boundary layers: solid regions, fluid regions, or specifically named regions.
                        """

                    class _grow_on(PyArgumentsTextualSubItem):
                        """
                        Specify where you would like to develop the boundary layers: either along only walls, all zones, along solid-fluid interfaces, or specifically selected zones or labels.
                        """

                    class _topology_list(PyArgumentsTextualSubItem):
                        """
                        Argument topology_list.
                        """

                class _region_scope(PyArgumentsTextualSubItem):
                    """
                    Select the named region(s) from the list to which you would like to add a boundary layer. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _label_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _local_prism_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument local_prism_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.additional_ignored_layers = self._additional_ignored_layers(self, "additional_ignored_layers", service, rules, path)
                        self.allowed_tangency_at_invalid_normals = self._allowed_tangency_at_invalid_normals(self, "allowed_tangency_at_invalid_normals", service, rules, path)
                        self.last_ratio = self._last_ratio(self, "last_ratio", service, rules, path)
                        self.split_prism = self._split_prism(self, "split_prism", service, rules, path)
                        self.invalid_normal_method = self._invalid_normal_method(self, "invalid_normal_method", service, rules, path)
                        self.modify_at_invalid_normals = self._modify_at_invalid_normals(self, "modify_at_invalid_normals", service, rules, path)
                        self.remesh_at_invalid_normals = self._remesh_at_invalid_normals(self, "remesh_at_invalid_normals", service, rules, path)
                        self.number_of_split_layers = self._number_of_split_layers(self, "number_of_split_layers", service, rules, path)
                        self.smooth_rings_at_invalid_normals = self._smooth_rings_at_invalid_normals(self, "smooth_rings_at_invalid_normals", service, rules, path)
                        self.sphere_radius_factor_at_invalid_normals = self._sphere_radius_factor_at_invalid_normals(self, "sphere_radius_factor_at_invalid_normals", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)
                        self.last_ratio_num_layers = self._last_ratio_num_layers(self, "last_ratio_num_layers", service, rules, path)
                        self.continuous = self._continuous(self, "continuous", service, rules, path)
                        self.ignore_boundary_layers = self._ignore_boundary_layers(self, "ignore_boundary_layers", service, rules, path)

                    class _additional_ignored_layers(PyArgumentsNumericalSubItem):
                        """
                        Indicate the number of buffer layers that can be placed around ignored boundary layer faces, extending the ignored regions around sharp angles. Increasing the value increases the number of faces for which the boundary layer will be ignored at acute angles.
                        """

                    class _allowed_tangency_at_invalid_normals(PyArgumentsNumericalSubItem):
                        """
                        Controls the tangency of the invalid normal faces. An invalid normal location with all 90 degree angles has a tangency of 1. So, faces are still treated as an invalid normal even if the angle deviates slightly from 90 degrees (resulting in a tangency of 0.98).
                        """

                    class _last_ratio(PyArgumentsNumericalSubItem):
                        """
                        Argument last_ratio.
                        """

                    class _split_prism(PyArgumentsParameterSubItem):
                        """
                        Choose whether or not to add split prisms to each layer along the boundary. Not available when the Offset Method Type is set to last-ratio.
                        """

                    class _invalid_normal_method(PyArgumentsTextualSubItem):
                        """
                        Argument invalid_normal_method.
                        """

                    class _modify_at_invalid_normals(PyArgumentsParameterSubItem):
                        """
                        Specify whether to automatically change the surface mesh where invalid normal faces are detected. To grow the boundary layer mesh in the proper direction (away from the boundary), normal vectors (valid) are required at the boundary face nodes of the surface mesh. More...
                        """

                    class _remesh_at_invalid_normals(PyArgumentsParameterSubItem):
                        """
                        Specify whether or not to remesh around the area of the invalid normal(s). When enabled, a local (non-size function-based) remeshing procedure is performed to obtain similar sizes around the sphere with a reasonable transition to the surrounding mesh.
                        """

                    class _number_of_split_layers(PyArgumentsNumericalSubItem):
                        """
                        Indicate the number of split prism layers you wish to apply to each layer that you specified for the boundary layer definition.
                        """

                    class _smooth_rings_at_invalid_normals(PyArgumentsNumericalSubItem):
                        """
                        Argument smooth_rings_at_invalid_normals.
                        """

                    class _sphere_radius_factor_at_invalid_normals(PyArgumentsNumericalSubItem):
                        """
                        This factor is used to determine the size of the spheres created at the invalid normal location. The spheres have a radius of one half of the average mesh edge length adjacent to the invalid location. The default factor of 0.8 ensures a sphere size that is slightly smaller than that.
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Display advanced options that you may want to apply to this task.
                        """

                    class _last_ratio_num_layers(PyArgumentsNumericalSubItem):
                        """
                        Argument last_ratio_num_layers.
                        """

                    class _continuous(PyArgumentsTextualSubItem):
                        """
                        Specify how you would like to improve the generated boundary layer: as a continuous or stair-stepped boundary layer in the specified area(s).
                        """

                    class _ignore_boundary_layers(PyArgumentsParameterSubItem):
                        """
                        Specify whether to automatically ignore boundary layers where there is an acute angle. Note that if there are sharp angles adjacent to other regions with boundary layers, some boundary layer removal may occur in those adjacent regions.
                        """

                class _bl_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument bl_zone_list.
                    """

                class _bl_region_list(PyArgumentsTextualSubItem):
                    """
                    Argument bl_region_list.
                    """

                class _complete_region_scope(PyArgumentsTextualSubItem):
                    """
                    Select the named region(s) from the list to which you would like to add a boundary layer. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _complete_bl_label_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _complete_bl_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument complete_bl_zone_list.
                    """

                class _complete_bl_region_list(PyArgumentsTextualSubItem):
                    """
                    Argument complete_bl_region_list.
                    """

                class _complete_zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _complete_label_selection_list(PyArgumentsTextualSubItem):
                    """
                    Argument complete_label_selection_list.
                    """

            def create_instance(self) -> _add_boundary_layers_for_part_replacementArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._add_boundary_layers_for_part_replacementArguments(*args)

        class add_boundary_type(PyCommand):
            """
            Create additional boundaries for your simulation. Provide a name, and assign a boundary type to one or more selected zones in your geometry.  More...
            Parameters
            ----------
            mesh_object : str
            new_boundary_label_name : str
                Specify a name for the boundary type.
            new_boundary_type : str
                Choose a boundary type from the available options.
            selection_type : str
            boundary_face_zone_list : list[str]
                Enter a text string to filter out the list of zones. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            topology_list : list[str]
            merge : bool
                Determine whether or not to merge the selected zones (set to yes by default).
            zone_location : list[str]

            Returns
            -------
            bool
            """
            class _add_boundary_typeArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.mesh_object = self._mesh_object(self, "mesh_object", service, rules, path)
                    self.new_boundary_label_name = self._new_boundary_label_name(self, "new_boundary_label_name", service, rules, path)
                    self.new_boundary_type = self._new_boundary_type(self, "new_boundary_type", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.boundary_face_zone_list = self._boundary_face_zone_list(self, "boundary_face_zone_list", service, rules, path)
                    self.topology_list = self._topology_list(self, "topology_list", service, rules, path)
                    self.merge = self._merge(self, "merge", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)

                class _mesh_object(PyArgumentsTextualSubItem):
                    """
                    Argument mesh_object.
                    """

                class _new_boundary_label_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the boundary type.
                    """

                class _new_boundary_type(PyArgumentsTextualSubItem):
                    """
                    Choose a boundary type from the available options.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Argument selection_type.
                    """

                class _boundary_face_zone_list(PyArgumentsTextualSubItem):
                    """
                    Enter a text string to filter out the list of zones. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _topology_list(PyArgumentsTextualSubItem):
                    """
                    Argument topology_list.
                    """

                class _merge(PyArgumentsParameterSubItem):
                    """
                    Determine whether or not to merge the selected zones (set to yes by default).
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

            def create_instance(self) -> _add_boundary_typeArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._add_boundary_typeArguments(*args)

        class add_linear_mesh_pattern(PyCommand):
            """
            Create linear patterns of objects based on one or more CAD parts, greatly simplifying meshing for CAD geometries that require multiple, linearly spaced parts such as in modeling batteries.   More...
            Parameters
            ----------
            child_name : str
                Specify a name for the mesh pattern or use the default value.
            object_list : list[str]
                Select one or more parts from the list below that you want to use for creating the mesh pattern. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            auto_populate_vector : str
                Indicate whether or not you want Fluent to approximate both the axes orientation and the pitch value, or whether you want to estimate the Pitch Only (default). This estimation only takes place once, either when the object is selected, or when the option is changed.
            axis_direction : dict[str, Any]
                Specify a name for the mesh pattern or use the default value.
            pitch : float
                Specify a value for the pitch, or displacement factor, or use the default value.
            number_of_units : int
                Indicate the overall number of instances that the pattern will use.
            check_overlapping_faces : bool
                Graphically highlights the mesh pattern units so that you can visualize them and make sure they are properly aligned. Misaligned units can cause a failure in the share topology of the battery cells.
            battery_modeling_options : dict[str, Any]

            Returns
            -------
            bool
            """
            class _add_linear_mesh_patternArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.child_name = self._child_name(self, "child_name", service, rules, path)
                    self.object_list = self._object_list(self, "object_list", service, rules, path)
                    self.auto_populate_vector = self._auto_populate_vector(self, "auto_populate_vector", service, rules, path)
                    self.axis_direction = self._axis_direction(self, "axis_direction", service, rules, path)
                    self.pitch = self._pitch(self, "pitch", service, rules, path)
                    self.number_of_units = self._number_of_units(self, "number_of_units", service, rules, path)
                    self.check_overlapping_faces = self._check_overlapping_faces(self, "check_overlapping_faces", service, rules, path)
                    self.battery_modeling_options = self._battery_modeling_options(self, "battery_modeling_options", service, rules, path)

                class _child_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the mesh pattern or use the default value.
                    """

                class _object_list(PyArgumentsTextualSubItem):
                    """
                    Select one or more parts from the list below that you want to use for creating the mesh pattern. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _auto_populate_vector(PyArgumentsTextualSubItem):
                    """
                    Indicate whether or not you want Fluent to approximate both the axes orientation and the pitch value, or whether you want to estimate the Pitch Only (default). This estimation only takes place once, either when the object is selected, or when the option is changed.
                    """

                class _axis_direction(PyArgumentsSingletonSubItem):
                    """
                    Specify a name for the mesh pattern or use the default value.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.y = self._y(self, "y", service, rules, path)
                        self.z = self._z(self, "z", service, rules, path)
                        self.x = self._x(self, "x", service, rules, path)

                    class _y(PyArgumentsNumericalSubItem):
                        """
                        Specify the Y component of the axis orientation/direction.
                        """

                    class _z(PyArgumentsNumericalSubItem):
                        """
                        Specify the Z component of the axis orientation/direction.
                        """

                    class _x(PyArgumentsNumericalSubItem):
                        """
                        Specify the X component of the axis orientation/direction.
                        """

                class _pitch(PyArgumentsNumericalSubItem):
                    """
                    Specify a value for the pitch, or displacement factor, or use the default value.
                    """

                class _number_of_units(PyArgumentsNumericalSubItem):
                    """
                    Indicate the overall number of instances that the pattern will use.
                    """

                class _check_overlapping_faces(PyArgumentsParameterSubItem):
                    """
                    Graphically highlights the mesh pattern units so that you can visualize them and make sure they are properly aligned. Misaligned units can cause a failure in the share topology of the battery cells.
                    """

                class _battery_modeling_options(PyArgumentsSingletonSubItem):
                    """
                    Argument battery_modeling_options.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.nb_cells_per_unit = self._nb_cells_per_unit(self, "nb_cells_per_unit", service, rules, path)
                        self.use_custom_pattern = self._use_custom_pattern(self, "use_custom_pattern", service, rules, path)
                        self.custom_pattern_string = self._custom_pattern_string(self, "custom_pattern_string", service, rules, path)
                        self.first_number = self._first_number(self, "first_number", service, rules, path)
                        self.invoke_battery_modeling_options = self._invoke_battery_modeling_options(self, "invoke_battery_modeling_options", service, rules, path)

                    class _nb_cells_per_unit(PyArgumentsNumericalSubItem):
                        """
                        Specify the numerical value that will be appended to the name of the first unit associated with the meshing pattern object. This value also dictates the labeling for mesh objects associated with this mesh pattern.   More...
                        """

                    class _use_custom_pattern(PyArgumentsParameterSubItem):
                        """
                        Indicate whether or not you want to create a customized pattern based on your own specifications. Enter the pattern specification in the field below.  More...
                        """

                    class _custom_pattern_string(PyArgumentsTextualSubItem):
                        """
                        Argument custom_pattern_string.
                        """

                    class _first_number(PyArgumentsNumericalSubItem):
                        """
                        Specify the numerical value that will be appended to the name of the first unit associated with the meshing pattern object. This value also dictates the labeling for mesh objects associated with this mesh pattern.  More...
                        """

                    class _invoke_battery_modeling_options(PyArgumentsParameterSubItem):
                        """
                        Specify whether or not you are interested in creating a pattern based on custom numbering/labeling and setting dual unit labeling options (often useful in battery modeling).   More...
                        """

            def create_instance(self) -> _add_linear_mesh_patternArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._add_linear_mesh_patternArguments(*args)

        class add_local_sizing_wtm(PyCommand):
            """
            Apply local sizing controls. Use this task to gain better control over the mesh size distribution, and define specific mesh size controls that operate on specific, localized, portions of the geometry and mesh. Using this task, you can add as many localized size controls to the workflow as you need, depending on the requirements and details of your geometry.  More...
            Parameters
            ----------
            add_child : bool
                Choose whether or not you want to add local size controls in order to create the surface mesh.
            boi_control_name : str
                Provide a name for this specific size control.
            boi_growth_rate : float
                Specify the increase in element edge length with each succeeding layer of elements.
            boi_execution : str
                Choose whether the size control is to be applied to a local edge size, a local face size, a local body size, a body of influence, a face of influence, curvature, or proximity.
            assign_size_using : str
            boi_size : float
                Specify a value for the desired size of the local sizing (or body/face of influence) to be applied to the indicated label(s) or zone(s).
            numberof_layers : int
            smallest_height : float
            growth_pattern : str
            growth_method : str
            bias_factor : float
            boi_min_size : float
                Specify the minimum size of the elements for the surface mesh.
            boi_max_size : float
                Specify the maximum size of the elements for the surface mesh.
            boi_curvature_normal_angle : float
                Specify the maximum allowable angle (from 0 to 180 degrees) that one element edge is allowed to span given a particular geometry curvature. You can use this field to limit the number of elements that are generated along a curve or surface if the minimum size is too small for that particular curve.
            boi_cells_per_gap : float
                Specify the minimum number of layers of elements to be generated in the gaps. The number of cells per gap can be a real value, with a minimum value of 0.01.
            boi_scope_to : str
                Set curvature or proximity based refinement. The edges option considers edge-to-edge proximity, while faces considers face-to-face proximity, and faces and edges considers both. The edge labels option considers edge sizing based on edge labels. Note that when you use the edges or the faces and edges options, you can only select face zones or face labels. Also, saving a size control file after using either of these two options will not be persistent.
            ignore_orientation : bool
                Specify whether or not you need to apply additional refinement in and around thin areas (such as between plates), without over-refinement. This ignores face proximity within voids and will not allow you to refine in thin voids, but will allow refinement in gaps. This should be used in predominantly fluid regions with no thin solid regions.
            ignore_proximity_across_objects : bool
                Enable to prevent proximity sizing from considering gaps to other separate objects, which can reduce over-refinement between distinct parts.
            boi_zoneor_label : str
                Choose how you want to select your surface (by label or by zone).
            boi_face_label_list : list[str]
                Choose one or more face zone labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            boi_face_zone_list : list[str]
                Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            edge_label_list : list[str]
            edge_zone_list : list[str]
            topology_list : list[str]
            reverse_edge_zone_orientation : bool
            reverse_edge_zone_list : list[str]
            boi_patchingtoggle : bool
                Enable this option to repair any openings that may still exist in the body of influence-based local sizing control.
            draw_size_control : bool
                Enable this field to display the size boxes in the graphics window.
            zone_location : list[str]
            complete_face_zone_list : list[str]
            complete_face_label_list : list[str]
            complete_edge_label_list : list[str]
            complete_topology_list : list[str]
            prime_size_control_id : int

            Returns
            -------
            bool
            """
            class _add_local_sizing_wtmArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.add_child = self._add_child(self, "add_child", service, rules, path)
                    self.boi_control_name = self._boi_control_name(self, "boi_control_name", service, rules, path)
                    self.boi_growth_rate = self._boi_growth_rate(self, "boi_growth_rate", service, rules, path)
                    self.boi_execution = self._boi_execution(self, "boi_execution", service, rules, path)
                    self.assign_size_using = self._assign_size_using(self, "assign_size_using", service, rules, path)
                    self.boi_size = self._boi_size(self, "boi_size", service, rules, path)
                    self.numberof_layers = self._numberof_layers(self, "numberof_layers", service, rules, path)
                    self.smallest_height = self._smallest_height(self, "smallest_height", service, rules, path)
                    self.growth_pattern = self._growth_pattern(self, "growth_pattern", service, rules, path)
                    self.growth_method = self._growth_method(self, "growth_method", service, rules, path)
                    self.bias_factor = self._bias_factor(self, "bias_factor", service, rules, path)
                    self.boi_min_size = self._boi_min_size(self, "boi_min_size", service, rules, path)
                    self.boi_max_size = self._boi_max_size(self, "boi_max_size", service, rules, path)
                    self.boi_curvature_normal_angle = self._boi_curvature_normal_angle(self, "boi_curvature_normal_angle", service, rules, path)
                    self.boi_cells_per_gap = self._boi_cells_per_gap(self, "boi_cells_per_gap", service, rules, path)
                    self.boi_scope_to = self._boi_scope_to(self, "boi_scope_to", service, rules, path)
                    self.ignore_orientation = self._ignore_orientation(self, "ignore_orientation", service, rules, path)
                    self.ignore_proximity_across_objects = self._ignore_proximity_across_objects(self, "ignore_proximity_across_objects", service, rules, path)
                    self.boi_zoneor_label = self._boi_zoneor_label(self, "boi_zoneor_label", service, rules, path)
                    self.boi_face_label_list = self._boi_face_label_list(self, "boi_face_label_list", service, rules, path)
                    self.boi_face_zone_list = self._boi_face_zone_list(self, "boi_face_zone_list", service, rules, path)
                    self.edge_label_list = self._edge_label_list(self, "edge_label_list", service, rules, path)
                    self.edge_zone_list = self._edge_zone_list(self, "edge_zone_list", service, rules, path)
                    self.topology_list = self._topology_list(self, "topology_list", service, rules, path)
                    self.reverse_edge_zone_orientation = self._reverse_edge_zone_orientation(self, "reverse_edge_zone_orientation", service, rules, path)
                    self.reverse_edge_zone_list = self._reverse_edge_zone_list(self, "reverse_edge_zone_list", service, rules, path)
                    self.boi_patchingtoggle = self._boi_patchingtoggle(self, "boi_patchingtoggle", service, rules, path)
                    self.draw_size_control = self._draw_size_control(self, "draw_size_control", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.complete_face_zone_list = self._complete_face_zone_list(self, "complete_face_zone_list", service, rules, path)
                    self.complete_face_label_list = self._complete_face_label_list(self, "complete_face_label_list", service, rules, path)
                    self.complete_edge_label_list = self._complete_edge_label_list(self, "complete_edge_label_list", service, rules, path)
                    self.complete_topology_list = self._complete_topology_list(self, "complete_topology_list", service, rules, path)
                    self.prime_size_control_id = self._prime_size_control_id(self, "prime_size_control_id", service, rules, path)

                class _add_child(PyArgumentsParameterSubItem):
                    """
                    Choose whether or not you want to add local size controls in order to create the surface mesh.
                    """

                class _boi_control_name(PyArgumentsTextualSubItem):
                    """
                    Provide a name for this specific size control.
                    """

                class _boi_growth_rate(PyArgumentsNumericalSubItem):
                    """
                    Specify the increase in element edge length with each succeeding layer of elements.
                    """

                class _boi_execution(PyArgumentsTextualSubItem):
                    """
                    Choose whether the size control is to be applied to a local edge size, a local face size, a local body size, a body of influence, a face of influence, curvature, or proximity.
                    """

                class _assign_size_using(PyArgumentsTextualSubItem):
                    """
                    Argument assign_size_using.
                    """

                class _boi_size(PyArgumentsNumericalSubItem):
                    """
                    Specify a value for the desired size of the local sizing (or body/face of influence) to be applied to the indicated label(s) or zone(s).
                    """

                class _numberof_layers(PyArgumentsNumericalSubItem):
                    """
                    Argument numberof_layers.
                    """

                class _smallest_height(PyArgumentsNumericalSubItem):
                    """
                    Argument smallest_height.
                    """

                class _growth_pattern(PyArgumentsTextualSubItem):
                    """
                    Argument growth_pattern.
                    """

                class _growth_method(PyArgumentsTextualSubItem):
                    """
                    Argument growth_method.
                    """

                class _bias_factor(PyArgumentsNumericalSubItem):
                    """
                    Argument bias_factor.
                    """

                class _boi_min_size(PyArgumentsNumericalSubItem):
                    """
                    Specify the minimum size of the elements for the surface mesh.
                    """

                class _boi_max_size(PyArgumentsNumericalSubItem):
                    """
                    Specify the maximum size of the elements for the surface mesh.
                    """

                class _boi_curvature_normal_angle(PyArgumentsNumericalSubItem):
                    """
                    Specify the maximum allowable angle (from 0 to 180 degrees) that one element edge is allowed to span given a particular geometry curvature. You can use this field to limit the number of elements that are generated along a curve or surface if the minimum size is too small for that particular curve.
                    """

                class _boi_cells_per_gap(PyArgumentsNumericalSubItem):
                    """
                    Specify the minimum number of layers of elements to be generated in the gaps. The number of cells per gap can be a real value, with a minimum value of 0.01.
                    """

                class _boi_scope_to(PyArgumentsTextualSubItem):
                    """
                    Set curvature or proximity based refinement. The edges option considers edge-to-edge proximity, while faces considers face-to-face proximity, and faces and edges considers both. The edge labels option considers edge sizing based on edge labels. Note that when you use the edges or the faces and edges options, you can only select face zones or face labels. Also, saving a size control file after using either of these two options will not be persistent.
                    """

                class _ignore_orientation(PyArgumentsParameterSubItem):
                    """
                    Specify whether or not you need to apply additional refinement in and around thin areas (such as between plates), without over-refinement. This ignores face proximity within voids and will not allow you to refine in thin voids, but will allow refinement in gaps. This should be used in predominantly fluid regions with no thin solid regions.
                    """

                class _ignore_proximity_across_objects(PyArgumentsParameterSubItem):
                    """
                    Enable to prevent proximity sizing from considering gaps to other separate objects, which can reduce over-refinement between distinct parts.
                    """

                class _boi_zoneor_label(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to select your surface (by label or by zone).
                    """

                class _boi_face_label_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zone labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _boi_face_zone_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _edge_label_list(PyArgumentsTextualSubItem):
                    """
                    Argument edge_label_list.
                    """

                class _edge_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument edge_zone_list.
                    """

                class _topology_list(PyArgumentsTextualSubItem):
                    """
                    Argument topology_list.
                    """

                class _reverse_edge_zone_orientation(PyArgumentsParameterSubItem):
                    """
                    Argument reverse_edge_zone_orientation.
                    """

                class _reverse_edge_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument reverse_edge_zone_list.
                    """

                class _boi_patchingtoggle(PyArgumentsParameterSubItem):
                    """
                    Enable this option to repair any openings that may still exist in the body of influence-based local sizing control.
                    """

                class _draw_size_control(PyArgumentsParameterSubItem):
                    """
                    Enable this field to display the size boxes in the graphics window.
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _complete_face_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument complete_face_zone_list.
                    """

                class _complete_face_label_list(PyArgumentsTextualSubItem):
                    """
                    Argument complete_face_label_list.
                    """

                class _complete_edge_label_list(PyArgumentsTextualSubItem):
                    """
                    Argument complete_edge_label_list.
                    """

                class _complete_topology_list(PyArgumentsTextualSubItem):
                    """
                    Argument complete_topology_list.
                    """

                class _prime_size_control_id(PyArgumentsNumericalSubItem):
                    """
                    Argument prime_size_control_id.
                    """

            def create_instance(self) -> _add_local_sizing_wtmArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._add_local_sizing_wtmArguments(*args)

        class add_multizone_controls(PyCommand):
            """
            Use this task to add multi-zone mesh controls for the selected regions.  More...
            Parameters
            ----------
            control_type : str
                Determine if you want to define the multi-zone control by selecting regions or edges.
            multi_z_name : str
                Enter a name for the multi-zone mesh control, or use the default.
            mesh_method : str
                Choose a multi-zone meshing technique: Standard or the Thin volume technique (for only a single layer)
            fill_with : str
                Choose a multi-zone meshing fill type: Hex-Pave, Hex-Map, Prism, or Mixed.
            use_sweep_size : bool
                Specify the minimum size for the edge-based multizone control.
            max_sweep_size : float
                Indicates the maximum value for the sweep size.
            region_scope : list[str]
                Select the named region(s) from the list to which you would like to create the multi-zone control. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            source_method : str
                Choose one or more face zones or labels from the list below. You can also provide the ability to select all source-target zones that are parallel to a global plane by choosing Zones parallel to XY plane, Zones parallel to XZ plane, or Zones parallel to YZ plane. For zones or labels. use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            parallel_selection : bool
                When your desired zones are aligned with the global x,y, or z plane, enable this checkbox to automatically select all parallel zones in  the selected region(s).
            show_edge_biasing : str
                If edge labels are automatically created on all edges, preserving the face/edge topology, use this field to determine if you want to save time and preview any edge biasing, since when many edges are selected, there can be many nodes and biases that can take additional time. Choices include yes, selected to only preview the selected edge, yes, all to preview all edges, and no to not preview edge biasing.
            topo_source_list : list[str]
            label_source_list : list[str]
                Choose one or more face zone labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_source_list : list[str]
                Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_location : list[str]
            assign_size_using : str
                For edge-based multizone controls, you can choose from Interval, Size, or Smallest Height. If double graded biasing is used and the Interval is set to an odd number (or the Size or Smallest Height results in an odd number Interval), the interval will automatically be increased by one.
            intervals : int
                Specify the number of intervals for the edge-based multizone control. If double graded biasing is used and the Interval is set to an odd number (or the Size or Smallest Height results in an odd number Interval), the interval will automatically be increased by one.
            size : float
                Specify the minimum size for the edge-based multizone control.
            smallest_height : float
                Specify a value for the smallest height for the edge-based multizone control.
            bias_method : str
                Select from a choice of patterns that you want to apply to your edge-based multizone control.
            growth_method : str
                For edge-based multizone controls when using variable Growth Patterns, determine how you would like to determine the growth: either as a Growth Rate or as Bias Factor.
            growth_rate : float
                Specify a value for the growth rate for the multizone, or use the default value.
            bias_factor : float
                Specify a value for the bias factor for the multizone, or use the default value. The Bias Factor is the ratio of the largest to the smallest segment on the edge.
            edge_label_selection : list[str]
            edge_label_list : list[str]
                Choose one or more edge labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            cfd_surface_mesh_controls : dict[str, Any]
            complete_region_scope : list[str]
                Select the named region(s) from the list to which you would like to create the multi-zone control. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            complete_edge_scope : list[str]

            Returns
            -------
            bool
            """
            class _add_multizone_controlsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.control_type = self._control_type(self, "control_type", service, rules, path)
                    self.multi_z_name = self._multi_z_name(self, "multi_z_name", service, rules, path)
                    self.mesh_method = self._mesh_method(self, "mesh_method", service, rules, path)
                    self.fill_with = self._fill_with(self, "fill_with", service, rules, path)
                    self.use_sweep_size = self._use_sweep_size(self, "use_sweep_size", service, rules, path)
                    self.max_sweep_size = self._max_sweep_size(self, "max_sweep_size", service, rules, path)
                    self.region_scope = self._region_scope(self, "region_scope", service, rules, path)
                    self.source_method = self._source_method(self, "source_method", service, rules, path)
                    self.parallel_selection = self._parallel_selection(self, "parallel_selection", service, rules, path)
                    self.show_edge_biasing = self._show_edge_biasing(self, "show_edge_biasing", service, rules, path)
                    self.topo_source_list = self._topo_source_list(self, "topo_source_list", service, rules, path)
                    self.label_source_list = self._label_source_list(self, "label_source_list", service, rules, path)
                    self.zone_source_list = self._zone_source_list(self, "zone_source_list", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.assign_size_using = self._assign_size_using(self, "assign_size_using", service, rules, path)
                    self.intervals = self._intervals(self, "intervals", service, rules, path)
                    self.size = self._size(self, "size", service, rules, path)
                    self.smallest_height = self._smallest_height(self, "smallest_height", service, rules, path)
                    self.bias_method = self._bias_method(self, "bias_method", service, rules, path)
                    self.growth_method = self._growth_method(self, "growth_method", service, rules, path)
                    self.growth_rate = self._growth_rate(self, "growth_rate", service, rules, path)
                    self.bias_factor = self._bias_factor(self, "bias_factor", service, rules, path)
                    self.edge_label_selection = self._edge_label_selection(self, "edge_label_selection", service, rules, path)
                    self.edge_label_list = self._edge_label_list(self, "edge_label_list", service, rules, path)
                    self.cfd_surface_mesh_controls = self._cfd_surface_mesh_controls(self, "cfd_surface_mesh_controls", service, rules, path)
                    self.complete_region_scope = self._complete_region_scope(self, "complete_region_scope", service, rules, path)
                    self.complete_edge_scope = self._complete_edge_scope(self, "complete_edge_scope", service, rules, path)

                class _control_type(PyArgumentsTextualSubItem):
                    """
                    Determine if you want to define the multi-zone control by selecting regions or edges.
                    """

                class _multi_z_name(PyArgumentsTextualSubItem):
                    """
                    Enter a name for the multi-zone mesh control, or use the default.
                    """

                class _mesh_method(PyArgumentsTextualSubItem):
                    """
                    Choose a multi-zone meshing technique: Standard or the Thin volume technique (for only a single layer)
                    """

                class _fill_with(PyArgumentsTextualSubItem):
                    """
                    Choose a multi-zone meshing fill type: Hex-Pave, Hex-Map, Prism, or Mixed.
                    """

                class _use_sweep_size(PyArgumentsParameterSubItem):
                    """
                    Specify the minimum size for the edge-based multizone control.
                    """

                class _max_sweep_size(PyArgumentsNumericalSubItem):
                    """
                    Indicates the maximum value for the sweep size.
                    """

                class _region_scope(PyArgumentsTextualSubItem):
                    """
                    Select the named region(s) from the list to which you would like to create the multi-zone control. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _source_method(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zones or labels from the list below. You can also provide the ability to select all source-target zones that are parallel to a global plane by choosing Zones parallel to XY plane, Zones parallel to XZ plane, or Zones parallel to YZ plane. For zones or labels. use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _parallel_selection(PyArgumentsParameterSubItem):
                    """
                    When your desired zones are aligned with the global x,y, or z plane, enable this checkbox to automatically select all parallel zones in  the selected region(s).
                    """

                class _show_edge_biasing(PyArgumentsTextualSubItem):
                    """
                    If edge labels are automatically created on all edges, preserving the face/edge topology, use this field to determine if you want to save time and preview any edge biasing, since when many edges are selected, there can be many nodes and biases that can take additional time. Choices include yes, selected to only preview the selected edge, yes, all to preview all edges, and no to not preview edge biasing.
                    """

                class _topo_source_list(PyArgumentsTextualSubItem):
                    """
                    Argument topo_source_list.
                    """

                class _label_source_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zone labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_source_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _assign_size_using(PyArgumentsTextualSubItem):
                    """
                    For edge-based multizone controls, you can choose from Interval, Size, or Smallest Height. If double graded biasing is used and the Interval is set to an odd number (or the Size or Smallest Height results in an odd number Interval), the interval will automatically be increased by one.
                    """

                class _intervals(PyArgumentsNumericalSubItem):
                    """
                    Specify the number of intervals for the edge-based multizone control. If double graded biasing is used and the Interval is set to an odd number (or the Size or Smallest Height results in an odd number Interval), the interval will automatically be increased by one.
                    """

                class _size(PyArgumentsNumericalSubItem):
                    """
                    Specify the minimum size for the edge-based multizone control.
                    """

                class _smallest_height(PyArgumentsNumericalSubItem):
                    """
                    Specify a value for the smallest height for the edge-based multizone control.
                    """

                class _bias_method(PyArgumentsTextualSubItem):
                    """
                    Select from a choice of patterns that you want to apply to your edge-based multizone control.
                    """

                class _growth_method(PyArgumentsTextualSubItem):
                    """
                    For edge-based multizone controls when using variable Growth Patterns, determine how you would like to determine the growth: either as a Growth Rate or as Bias Factor.
                    """

                class _growth_rate(PyArgumentsNumericalSubItem):
                    """
                    Specify a value for the growth rate for the multizone, or use the default value.
                    """

                class _bias_factor(PyArgumentsNumericalSubItem):
                    """
                    Specify a value for the bias factor for the multizone, or use the default value. The Bias Factor is the ratio of the largest to the smallest segment on the edge.
                    """

                class _edge_label_selection(PyArgumentsTextualSubItem):
                    """
                    Argument edge_label_selection.
                    """

                class _edge_label_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more edge labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _cfd_surface_mesh_controls(PyArgumentsSingletonSubItem):
                    """
                    Argument cfd_surface_mesh_controls.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.scope_proximity_to = self._scope_proximity_to(self, "scope_proximity_to", service, rules, path)
                        self.object_based_controls = self._object_based_controls(self, "object_based_controls", service, rules, path)
                        self.cells_per_gap = self._cells_per_gap(self, "cells_per_gap", service, rules, path)
                        self.draw_size_control = self._draw_size_control(self, "draw_size_control", service, rules, path)
                        self.min_size = self._min_size(self, "min_size", service, rules, path)
                        self.preview_sizefield = self._preview_sizefield(self, "preview_sizefield", service, rules, path)
                        self.max_size = self._max_size(self, "max_size", service, rules, path)
                        self.size_functions = self._size_functions(self, "size_functions", service, rules, path)
                        self.remesh_imported_mesh = self._remesh_imported_mesh(self, "remesh_imported_mesh", service, rules, path)
                        self.save_size_field = self._save_size_field(self, "save_size_field", service, rules, path)
                        self.curvature_normal_angle = self._curvature_normal_angle(self, "curvature_normal_angle", service, rules, path)
                        self.growth_rate = self._growth_rate(self, "growth_rate", service, rules, path)
                        self.auto_create_scoped_sizing = self._auto_create_scoped_sizing(self, "auto_create_scoped_sizing", service, rules, path)
                        self.refacet = self._refacet(self, "refacet", service, rules, path)
                        self.size_field_file = self._size_field_file(self, "size_field_file", service, rules, path)
                        self.size_control_file = self._size_control_file(self, "size_control_file", service, rules, path)
                        self.use_size_files = self._use_size_files(self, "use_size_files", service, rules, path)
                        self.save_size_field_file = self._save_size_field_file(self, "save_size_field_file", service, rules, path)
                        self.surface_mesh_method = self._surface_mesh_method(self, "surface_mesh_method", service, rules, path)

                    class _scope_proximity_to(PyArgumentsTextualSubItem):
                        """
                        Argument scope_proximity_to.
                        """

                    class _object_based_controls(PyArgumentsParameterSubItem):
                        """
                        Argument object_based_controls.
                        """

                    class _cells_per_gap(PyArgumentsNumericalSubItem):
                        """
                        Argument cells_per_gap.
                        """

                    class _draw_size_control(PyArgumentsParameterSubItem):
                        """
                        Argument draw_size_control.
                        """

                    class _min_size(PyArgumentsNumericalSubItem):
                        """
                        Specify the minimum size for the edge-based multizone control.
                        """

                    class _preview_sizefield(PyArgumentsParameterSubItem):
                        """
                        Argument preview_sizefield.
                        """

                    class _max_size(PyArgumentsNumericalSubItem):
                        """
                        Specify the minimum size for the edge-based multizone control.
                        """

                    class _size_functions(PyArgumentsTextualSubItem):
                        """
                        Argument size_functions.
                        """

                    class _remesh_imported_mesh(PyArgumentsTextualSubItem):
                        """
                        Argument remesh_imported_mesh.
                        """

                    class _save_size_field(PyArgumentsParameterSubItem):
                        """
                        Argument save_size_field.
                        """

                    class _curvature_normal_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument curvature_normal_angle.
                        """

                    class _growth_rate(PyArgumentsNumericalSubItem):
                        """
                        Specify a value for the growth rate for the multizone, or use the default value.
                        """

                    class _auto_create_scoped_sizing(PyArgumentsParameterSubItem):
                        """
                        Argument auto_create_scoped_sizing.
                        """

                    class _refacet(PyArgumentsParameterSubItem):
                        """
                        Argument refacet.
                        """

                    class _size_field_file(PyArgumentsTextualSubItem):
                        """
                        Argument size_field_file.
                        """

                    class _size_control_file(PyArgumentsTextualSubItem):
                        """
                        Argument size_control_file.
                        """

                    class _use_size_files(PyArgumentsTextualSubItem):
                        """
                        Argument use_size_files.
                        """

                    class _save_size_field_file(PyArgumentsTextualSubItem):
                        """
                        Argument save_size_field_file.
                        """

                    class _surface_mesh_method(PyArgumentsTextualSubItem):
                        """
                        Choose a multi-zone meshing technique: Standard or the Thin volume technique (for only a single layer)
                        """

                class _complete_region_scope(PyArgumentsTextualSubItem):
                    """
                    Select the named region(s) from the list to which you would like to create the multi-zone control. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _complete_edge_scope(PyArgumentsTextualSubItem):
                    """
                    Argument complete_edge_scope.
                    """

            def create_instance(self) -> _add_multizone_controlsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._add_multizone_controlsArguments(*args)

        class add_shell_boundary_layers(PyCommand):
            """
            Command add_shell_boundary_layers.

            Parameters
            ----------
            add_child : bool
            control_name : str
            offset_method_type : str
            number_of_layers : int
            first_aspect_ratio : float
            last_aspect_ratio : float
            rate : float
            first_layer_height : float
            max_layer_height : float
            grow_on : str
            face_label_list : list[str]
            face_zone_list : list[str]
            edge_selection_type : str
            edge_label_list : list[str]
            edge_zone_list : list[str]
            shell_bl_advanced_options : dict[str, Any]

            Returns
            -------
            bool
            """
            class _add_shell_boundary_layersArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.add_child = self._add_child(self, "add_child", service, rules, path)
                    self.control_name = self._control_name(self, "control_name", service, rules, path)
                    self.offset_method_type = self._offset_method_type(self, "offset_method_type", service, rules, path)
                    self.number_of_layers = self._number_of_layers(self, "number_of_layers", service, rules, path)
                    self.first_aspect_ratio = self._first_aspect_ratio(self, "first_aspect_ratio", service, rules, path)
                    self.last_aspect_ratio = self._last_aspect_ratio(self, "last_aspect_ratio", service, rules, path)
                    self.rate = self._rate(self, "rate", service, rules, path)
                    self.first_layer_height = self._first_layer_height(self, "first_layer_height", service, rules, path)
                    self.max_layer_height = self._max_layer_height(self, "max_layer_height", service, rules, path)
                    self.grow_on = self._grow_on(self, "grow_on", service, rules, path)
                    self.face_label_list = self._face_label_list(self, "face_label_list", service, rules, path)
                    self.face_zone_list = self._face_zone_list(self, "face_zone_list", service, rules, path)
                    self.edge_selection_type = self._edge_selection_type(self, "edge_selection_type", service, rules, path)
                    self.edge_label_list = self._edge_label_list(self, "edge_label_list", service, rules, path)
                    self.edge_zone_list = self._edge_zone_list(self, "edge_zone_list", service, rules, path)
                    self.shell_bl_advanced_options = self._shell_bl_advanced_options(self, "shell_bl_advanced_options", service, rules, path)

                class _add_child(PyArgumentsParameterSubItem):
                    """
                    Argument add_child.
                    """

                class _control_name(PyArgumentsTextualSubItem):
                    """
                    Argument control_name.
                    """

                class _offset_method_type(PyArgumentsTextualSubItem):
                    """
                    Argument offset_method_type.
                    """

                class _number_of_layers(PyArgumentsNumericalSubItem):
                    """
                    Argument number_of_layers.
                    """

                class _first_aspect_ratio(PyArgumentsNumericalSubItem):
                    """
                    Argument first_aspect_ratio.
                    """

                class _last_aspect_ratio(PyArgumentsNumericalSubItem):
                    """
                    Argument last_aspect_ratio.
                    """

                class _rate(PyArgumentsNumericalSubItem):
                    """
                    Argument rate.
                    """

                class _first_layer_height(PyArgumentsNumericalSubItem):
                    """
                    Argument first_layer_height.
                    """

                class _max_layer_height(PyArgumentsNumericalSubItem):
                    """
                    Argument max_layer_height.
                    """

                class _grow_on(PyArgumentsTextualSubItem):
                    """
                    Argument grow_on.
                    """

                class _face_label_list(PyArgumentsTextualSubItem):
                    """
                    Argument face_label_list.
                    """

                class _face_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument face_zone_list.
                    """

                class _edge_selection_type(PyArgumentsTextualSubItem):
                    """
                    Argument edge_selection_type.
                    """

                class _edge_label_list(PyArgumentsTextualSubItem):
                    """
                    Argument edge_label_list.
                    """

                class _edge_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument edge_zone_list.
                    """

                class _shell_bl_advanced_options(PyArgumentsSingletonSubItem):
                    """
                    Argument shell_bl_advanced_options.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.adjacent_attach_angle = self._adjacent_attach_angle(self, "adjacent_attach_angle", service, rules, path)
                        self.expose_side = self._expose_side(self, "expose_side", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)
                        self.max_aspect_ratio = self._max_aspect_ratio(self, "max_aspect_ratio", service, rules, path)
                        self.last_ratio_num_layers = self._last_ratio_num_layers(self, "last_ratio_num_layers", service, rules, path)
                        self.last_ratio_percentage = self._last_ratio_percentage(self, "last_ratio_percentage", service, rules, path)
                        self.min_aspect_ratio = self._min_aspect_ratio(self, "min_aspect_ratio", service, rules, path)
                        self.gap_factor = self._gap_factor(self, "gap_factor", service, rules, path)

                    class _adjacent_attach_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument adjacent_attach_angle.
                        """

                    class _expose_side(PyArgumentsParameterSubItem):
                        """
                        Argument expose_side.
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Argument show_in_gui.
                        """

                    class _max_aspect_ratio(PyArgumentsNumericalSubItem):
                        """
                        Argument max_aspect_ratio.
                        """

                    class _last_ratio_num_layers(PyArgumentsNumericalSubItem):
                        """
                        Argument last_ratio_num_layers.
                        """

                    class _last_ratio_percentage(PyArgumentsNumericalSubItem):
                        """
                        Argument last_ratio_percentage.
                        """

                    class _min_aspect_ratio(PyArgumentsNumericalSubItem):
                        """
                        Argument min_aspect_ratio.
                        """

                    class _gap_factor(PyArgumentsNumericalSubItem):
                        """
                        Argument gap_factor.
                        """

            def create_instance(self) -> _add_shell_boundary_layersArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._add_shell_boundary_layersArguments(*args)

        class add_thin_volume_meshing_controls(PyCommand):
            """
            Use this task to add thin volume meshing controls for the selected regions.
            Parameters
            ----------
            thin_meshing_name : str
                Enter a name for the thin volume mesh control, or use the default.
            assign_size_using : str
                Specify the sizing of the mesh layers to be based on Intervals or based on the Size of the plates.
            intervals : int
                Specifies the minimum number of mesh layers to be created within the thin volume mesh.
            max_number_of_intervals : int
                Specifies the minimum number of mesh layers to be created within the thin volume mesh.
            size : float
                enter the Size of each thin mesh layer or use the default.
            growth_rate : float
                Specify the Growth Rate which is the expansion rate of the extrusion for each thin volume mesh layer and is set to 1 by default. A growth rate of 1.2 for example will expand each layer of the extrusion by 20 percent of the previous length.
            remesh_overlapping : bool
            double_biasing : bool
                Enable the Doubling biasing option to invoke double biasing on edges of the thin volume mesh layers. Enabling double biasing will automatically set the Growth Rate to 1.3. When disabled, the thin volume mesh can only be graded from the Source to the Target.
            side_imprints : bool
                Specifies the mesher to project the outer nodes of the thin volume mesh onto adjacent boundary face zones and is enabled by default. This ensures that geometric details of the thin volume are accurately captured at the boundary.
            stacked_plates : bool
                For models consisting of stacked planar plates, you can enable the Stacked Plates option to select all source-target zones that are aligned with the global x-y-z plane.
            auto_control_creation : bool
                enter the Size of each thin mesh layer or use the default.
            objects : list[str]
            region_scope : list[str]
                Specify the Region(s) where the thin volume meshing controls will be applied.
            select_source_by : str
                Choose whether to select the source surfaces by label or by zone.
            parallel_source : bool
                Enable this option if you have multiple source zones in parallel that you want to select for thin meshing.
            label_source_list : list[str]
                Select the label(s) to use as the source.
            zone_source_list : list[str]
                Select the zone(s) to use as the source.
            topo_source_list : list[str]
            select_target_by : str
                Choose whether to select the source surfaces by label or by zone.
            parallel_target : bool
                Enable this option if you have multiple target zones in parallel that you want to select for thin meshing,
            label_target_list : list[str]
                Select the label(s) to use as the target.
            zone_target_list : list[str]
                Select the zone(s) to use as the target.
            thin_vol_regs : list[str]
            complete_region_scope : list[str]
                Specify the Region(s) where the thin volume meshing controls will be applied.
            complete_label_source_list : list[str]
                Select the label(s) to use as the source.
            complete_zone_source_list : list[str]
                Select the zone(s) to use as the source.
            complete_topo_source_list : list[str]
            complete_label_target_list : list[str]
                Select the label(s) to use as the target.
            complete_zone_target_list : list[str]
                Select the zone(s) to use as the target.
            thin_volume_preferences : dict[str, Any]
            zone_location : list[str]
            zone_location_2 : list[str]

            Returns
            -------
            bool
            """
            class _add_thin_volume_meshing_controlsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.thin_meshing_name = self._thin_meshing_name(self, "thin_meshing_name", service, rules, path)
                    self.assign_size_using = self._assign_size_using(self, "assign_size_using", service, rules, path)
                    self.intervals = self._intervals(self, "intervals", service, rules, path)
                    self.max_number_of_intervals = self._max_number_of_intervals(self, "max_number_of_intervals", service, rules, path)
                    self.size = self._size(self, "size", service, rules, path)
                    self.growth_rate = self._growth_rate(self, "growth_rate", service, rules, path)
                    self.remesh_overlapping = self._remesh_overlapping(self, "remesh_overlapping", service, rules, path)
                    self.double_biasing = self._double_biasing(self, "double_biasing", service, rules, path)
                    self.side_imprints = self._side_imprints(self, "side_imprints", service, rules, path)
                    self.stacked_plates = self._stacked_plates(self, "stacked_plates", service, rules, path)
                    self.auto_control_creation = self._auto_control_creation(self, "auto_control_creation", service, rules, path)
                    self.objects = self._objects(self, "objects", service, rules, path)
                    self.region_scope = self._region_scope(self, "region_scope", service, rules, path)
                    self.select_source_by = self._select_source_by(self, "select_source_by", service, rules, path)
                    self.parallel_source = self._parallel_source(self, "parallel_source", service, rules, path)
                    self.label_source_list = self._label_source_list(self, "label_source_list", service, rules, path)
                    self.zone_source_list = self._zone_source_list(self, "zone_source_list", service, rules, path)
                    self.topo_source_list = self._topo_source_list(self, "topo_source_list", service, rules, path)
                    self.select_target_by = self._select_target_by(self, "select_target_by", service, rules, path)
                    self.parallel_target = self._parallel_target(self, "parallel_target", service, rules, path)
                    self.label_target_list = self._label_target_list(self, "label_target_list", service, rules, path)
                    self.zone_target_list = self._zone_target_list(self, "zone_target_list", service, rules, path)
                    self.thin_vol_regs = self._thin_vol_regs(self, "thin_vol_regs", service, rules, path)
                    self.complete_region_scope = self._complete_region_scope(self, "complete_region_scope", service, rules, path)
                    self.complete_label_source_list = self._complete_label_source_list(self, "complete_label_source_list", service, rules, path)
                    self.complete_zone_source_list = self._complete_zone_source_list(self, "complete_zone_source_list", service, rules, path)
                    self.complete_topo_source_list = self._complete_topo_source_list(self, "complete_topo_source_list", service, rules, path)
                    self.complete_label_target_list = self._complete_label_target_list(self, "complete_label_target_list", service, rules, path)
                    self.complete_zone_target_list = self._complete_zone_target_list(self, "complete_zone_target_list", service, rules, path)
                    self.thin_volume_preferences = self._thin_volume_preferences(self, "thin_volume_preferences", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.zone_location_2 = self._zone_location_2(self, "zone_location_2", service, rules, path)

                class _thin_meshing_name(PyArgumentsTextualSubItem):
                    """
                    Enter a name for the thin volume mesh control, or use the default.
                    """

                class _assign_size_using(PyArgumentsTextualSubItem):
                    """
                    Specify the sizing of the mesh layers to be based on Intervals or based on the Size of the plates.
                    """

                class _intervals(PyArgumentsNumericalSubItem):
                    """
                    Specifies the minimum number of mesh layers to be created within the thin volume mesh.
                    """

                class _max_number_of_intervals(PyArgumentsNumericalSubItem):
                    """
                    Specifies the minimum number of mesh layers to be created within the thin volume mesh.
                    """

                class _size(PyArgumentsNumericalSubItem):
                    """
                    enter the Size of each thin mesh layer or use the default.
                    """

                class _growth_rate(PyArgumentsNumericalSubItem):
                    """
                    Specify the Growth Rate which is the expansion rate of the extrusion for each thin volume mesh layer and is set to 1 by default. A growth rate of 1.2 for example will expand each layer of the extrusion by 20 percent of the previous length.
                    """

                class _remesh_overlapping(PyArgumentsParameterSubItem):
                    """
                    Argument remesh_overlapping.
                    """

                class _double_biasing(PyArgumentsParameterSubItem):
                    """
                    Enable the Doubling biasing option to invoke double biasing on edges of the thin volume mesh layers. Enabling double biasing will automatically set the Growth Rate to 1.3. When disabled, the thin volume mesh can only be graded from the Source to the Target.
                    """

                class _side_imprints(PyArgumentsParameterSubItem):
                    """
                    Specifies the mesher to project the outer nodes of the thin volume mesh onto adjacent boundary face zones and is enabled by default. This ensures that geometric details of the thin volume are accurately captured at the boundary.
                    """

                class _stacked_plates(PyArgumentsParameterSubItem):
                    """
                    For models consisting of stacked planar plates, you can enable the Stacked Plates option to select all source-target zones that are aligned with the global x-y-z plane.
                    """

                class _auto_control_creation(PyArgumentsParameterSubItem):
                    """
                    enter the Size of each thin mesh layer or use the default.
                    """

                class _objects(PyArgumentsTextualSubItem):
                    """
                    Argument objects.
                    """

                class _region_scope(PyArgumentsTextualSubItem):
                    """
                    Specify the Region(s) where the thin volume meshing controls will be applied.
                    """

                class _select_source_by(PyArgumentsTextualSubItem):
                    """
                    Choose whether to select the source surfaces by label or by zone.
                    """

                class _parallel_source(PyArgumentsParameterSubItem):
                    """
                    Enable this option if you have multiple source zones in parallel that you want to select for thin meshing.
                    """

                class _label_source_list(PyArgumentsTextualSubItem):
                    """
                    Select the label(s) to use as the source.
                    """

                class _zone_source_list(PyArgumentsTextualSubItem):
                    """
                    Select the zone(s) to use as the source.
                    """

                class _topo_source_list(PyArgumentsTextualSubItem):
                    """
                    Argument topo_source_list.
                    """

                class _select_target_by(PyArgumentsTextualSubItem):
                    """
                    Choose whether to select the source surfaces by label or by zone.
                    """

                class _parallel_target(PyArgumentsParameterSubItem):
                    """
                    Enable this option if you have multiple target zones in parallel that you want to select for thin meshing,
                    """

                class _label_target_list(PyArgumentsTextualSubItem):
                    """
                    Select the label(s) to use as the target.
                    """

                class _zone_target_list(PyArgumentsTextualSubItem):
                    """
                    Select the zone(s) to use as the target.
                    """

                class _thin_vol_regs(PyArgumentsTextualSubItem):
                    """
                    Argument thin_vol_regs.
                    """

                class _complete_region_scope(PyArgumentsTextualSubItem):
                    """
                    Specify the Region(s) where the thin volume meshing controls will be applied.
                    """

                class _complete_label_source_list(PyArgumentsTextualSubItem):
                    """
                    Select the label(s) to use as the source.
                    """

                class _complete_zone_source_list(PyArgumentsTextualSubItem):
                    """
                    Select the zone(s) to use as the source.
                    """

                class _complete_topo_source_list(PyArgumentsTextualSubItem):
                    """
                    Argument complete_topo_source_list.
                    """

                class _complete_label_target_list(PyArgumentsTextualSubItem):
                    """
                    Select the label(s) to use as the target.
                    """

                class _complete_zone_target_list(PyArgumentsTextualSubItem):
                    """
                    Select the zone(s) to use as the target.
                    """

                class _thin_volume_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument thin_volume_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.stacked_plate_tolerance = self._stacked_plate_tolerance(self, "stacked_plate_tolerance", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)
                        self.max_gap_size = self._max_gap_size(self, "max_gap_size", service, rules, path)
                        self.include_adjacent = self._include_adjacent(self, "include_adjacent", service, rules, path)
                        self.ignore_extra_sources = self._ignore_extra_sources(self, "ignore_extra_sources", service, rules, path)

                    class _stacked_plate_tolerance(PyArgumentsNumericalSubItem):
                        """
                        Specifies the tolerance to include adjacent source faces.
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Advanced settings for thin volume meshing controls.
                        """

                    class _max_gap_size(PyArgumentsNumericalSubItem):
                        """
                        The maximum gap distance between thin mesh layers. This size is will default to 0 mm when Auto Control Creation is disabled and will default to 1 mm when Auto Control Creation is turned on. When auto control creation is disabled, note that the default value of 0 mm indicates automatic computation. When auto control creation is enabled, although the default value is 1 mm, this value should be manually specified based on plate thickness. Any plates thicker than the specified value will be excluded from thin meshing.
                        """

                    class _include_adjacent(PyArgumentsParameterSubItem):
                        """
                        Specify whether or not adjacent stacked plate(s) are included in the thin mesh. This option is set to Yes by default.
                        """

                    class _ignore_extra_sources(PyArgumentsTextualSubItem):
                        """
                        Choose to have Standard or Aggressive unstructured fill. This option applies unstructured meshing in complex regions of the thin volume mesh.
                        """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _zone_location_2(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location_2.
                    """

            def create_instance(self) -> _add_thin_volume_meshing_controlsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._add_thin_volume_meshing_controlsArguments(*args)

        class add_virtual_topology(PyCommand):
            """
            Command add_virtual_topology.

            Parameters
            ----------
            add_child : bool
            control_name : str
            selection_type : str
            face_label_list : list[str]
            face_zone_list : list[str]
            new_faces : list[int]

            Returns
            -------
            bool
            """
            class _add_virtual_topologyArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.add_child = self._add_child(self, "add_child", service, rules, path)
                    self.control_name = self._control_name(self, "control_name", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.face_label_list = self._face_label_list(self, "face_label_list", service, rules, path)
                    self.face_zone_list = self._face_zone_list(self, "face_zone_list", service, rules, path)
                    self.new_faces = self._new_faces(self, "new_faces", service, rules, path)

                class _add_child(PyArgumentsParameterSubItem):
                    """
                    Argument add_child.
                    """

                class _control_name(PyArgumentsTextualSubItem):
                    """
                    Argument control_name.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Argument selection_type.
                    """

                class _face_label_list(PyArgumentsTextualSubItem):
                    """
                    Argument face_label_list.
                    """

                class _face_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument face_zone_list.
                    """

                class _new_faces(PyArgumentsNumericalSubItem):
                    """
                    Argument new_faces.
                    """

            def create_instance(self) -> _add_virtual_topologyArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._add_virtual_topologyArguments(*args)

        class apply_share_topology(PyCommand):
            """
            For imported CAD assemblies with multiple parts, use this task to identify and close any problematic gaps and choose whether to join and/or intersect the problematic faces.   More...
            Parameters
            ----------
            gap_distance : float
                Specify the maximum distance under which gaps will be removed. Use the Show Marked Gaps button to display such gaps.
            gap_distance_connect : float
                Specify the maximum distance under which gaps will be removed (the default value of 0 is recommended). Use the Show Marked Gaps button to display such gaps.
            min_size : float
            interface_select : str
                Choose whether to have the interface labels selected manually (Manual), automatically (Automatic), or when force share connect topology is utilized in the  geometry (Automatic - Using Connect Topology).
            edge_labels : list[str]
            share_topology_preferences : dict[str, Any]
            improve_surface_mesh_preferences : dict[str, Any]
            surface_mesh_preferences : dict[str, Any]

            Returns
            -------
            bool
            """
            class _apply_share_topologyArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.gap_distance = self._gap_distance(self, "gap_distance", service, rules, path)
                    self.gap_distance_connect = self._gap_distance_connect(self, "gap_distance_connect", service, rules, path)
                    self.min_size = self._min_size(self, "min_size", service, rules, path)
                    self.interface_select = self._interface_select(self, "interface_select", service, rules, path)
                    self.edge_labels = self._edge_labels(self, "edge_labels", service, rules, path)
                    self.share_topology_preferences = self._share_topology_preferences(self, "share_topology_preferences", service, rules, path)
                    self.improve_surface_mesh_preferences = self._improve_surface_mesh_preferences(self, "improve_surface_mesh_preferences", service, rules, path)
                    self.surface_mesh_preferences = self._surface_mesh_preferences(self, "surface_mesh_preferences", service, rules, path)

                class _gap_distance(PyArgumentsNumericalSubItem):
                    """
                    Specify the maximum distance under which gaps will be removed. Use the Show Marked Gaps button to display such gaps.
                    """

                class _gap_distance_connect(PyArgumentsNumericalSubItem):
                    """
                    Specify the maximum distance under which gaps will be removed (the default value of 0 is recommended). Use the Show Marked Gaps button to display such gaps.
                    """

                class _min_size(PyArgumentsNumericalSubItem):
                    """
                    Argument min_size.
                    """

                class _interface_select(PyArgumentsTextualSubItem):
                    """
                    Choose whether to have the interface labels selected manually (Manual), automatically (Automatic), or when force share connect topology is utilized in the  geometry (Automatic - Using Connect Topology).
                    """

                class _edge_labels(PyArgumentsTextualSubItem):
                    """
                    Argument edge_labels.
                    """

                class _share_topology_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument share_topology_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.per_label_list = self._per_label_list(self, "per_label_list", service, rules, path)
                        self.advanced_improve = self._advanced_improve(self, "advanced_improve", service, rules, path)
                        self.share_topology_angle = self._share_topology_angle(self, "share_topology_angle", service, rules, path)
                        self.join_tolerance_increment = self._join_tolerance_increment(self, "join_tolerance_increment", service, rules, path)
                        self.model_is_periodic = self._model_is_periodic(self, "model_is_periodic", service, rules, path)
                        self.fluid_label_wildcard = self._fluid_label_wildcard(self, "fluid_label_wildcard", service, rules, path)
                        self.intf_label_list = self._intf_label_list(self, "intf_label_list", service, rules, path)
                        self.relative_share_topology_tolerance = self._relative_share_topology_tolerance(self, "relative_share_topology_tolerance", service, rules, path)
                        self.execute_join_intersect = self._execute_join_intersect(self, "execute_join_intersect", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)
                        self.allow_defeaturing = self._allow_defeaturing(self, "allow_defeaturing", service, rules, path)
                        self.number_of_join_tries = self._number_of_join_tries(self, "number_of_join_tries", service, rules, path)
                        self.rename_internals_by_body_names = self._rename_internals_by_body_names(self, "rename_internals_by_body_names", service, rules, path)
                        self.operation = self._operation(self, "operation", service, rules, path)
                        self.connect_label_wildcard = self._connect_label_wildcard(self, "connect_label_wildcard", service, rules, path)

                    class _per_label_list(PyArgumentsTextualSubItem):
                        """
                        Argument per_label_list.
                        """

                    class _advanced_improve(PyArgumentsParameterSubItem):
                        """
                        Argument advanced_improve.
                        """

                    class _share_topology_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify the threshold angle for joining face pairs.
                        """

                    class _join_tolerance_increment(PyArgumentsNumericalSubItem):
                        """
                        Specify the increment by which the tolerance changes for each attempt to join face pairs.
                        """

                    class _model_is_periodic(PyArgumentsParameterSubItem):
                        """
                        Choose whether or not you need to set up periodic boundaries. If you select yes, then choose your periodic boundaries from the list of available boundaries.
                        """

                    class _fluid_label_wildcard(PyArgumentsTextualSubItem):
                        """
                        Argument fluid_label_wildcard.
                        """

                    class _intf_label_list(PyArgumentsTextualSubItem):
                        """
                        Enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """

                    class _relative_share_topology_tolerance(PyArgumentsNumericalSubItem):
                        """
                        Specify the relative tolerance for joining or intersecting face pairs, or the relative tolerance for connecting edge and face pairs.
                        """

                    class _execute_join_intersect(PyArgumentsTextualSubItem):
                        """
                        Choose whether the system will only join faces, only intersect faces, or do both.
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Display advanced options that you may want to apply to the task.
                        """

                    class _allow_defeaturing(PyArgumentsParameterSubItem):
                        """
                        Argument allow_defeaturing.
                        """

                    class _number_of_join_tries(PyArgumentsNumericalSubItem):
                        """
                        Specify the number of attempts that will be made to join face pairs under the given criteria.
                        """

                    class _rename_internals_by_body_names(PyArgumentsParameterSubItem):
                        """
                        Choose whether or not to apply body names from the imported geometry and use them in naming internal boundaries.  For instance, the internal face between two regions solid and body would be renamed to solid-body.
                        """

                    class _operation(PyArgumentsTextualSubItem):
                        """
                        Choose whether to apply share topology using the Join-Intersect method where you join and/or intersect the problematic faces, or using the Interface Connect method where you connect edges of overlapping face pairs. Note that imprinting of overlapping faces in SCDM/Discovery is highly recommended for the Interface Connect method.
                        """

                    class _connect_label_wildcard(PyArgumentsTextualSubItem):
                        """
                        Enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """

                class _improve_surface_mesh_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument improve_surface_mesh_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.si_improve_dihedral_angle = self._si_improve_dihedral_angle(self, "si_improve_dihedral_angle", service, rules, path)
                        self.si_quality_max_angle = self._si_quality_max_angle(self, "si_quality_max_angle", service, rules, path)
                        self.advanced_improve = self._advanced_improve(self, "advanced_improve", service, rules, path)
                        self.si_quality_collapse_limit = self._si_quality_collapse_limit(self, "si_quality_collapse_limit", service, rules, path)
                        self.si_step_width = self._si_step_width(self, "si_step_width", service, rules, path)
                        self.si_quality_iterations = self._si_quality_iterations(self, "si_quality_iterations", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)
                        self.si_remove_step = self._si_remove_step(self, "si_remove_step", service, rules, path)
                        self.si_step_quality_limit = self._si_step_quality_limit(self, "si_step_quality_limit", service, rules, path)
                        self.allow_defeaturing = self._allow_defeaturing(self, "allow_defeaturing", service, rules, path)
                        self.si_dihedral_angle = self._si_dihedral_angle(self, "si_dihedral_angle", service, rules, path)

                    class _si_improve_dihedral_angle(PyArgumentsParameterSubItem):
                        """
                        Argument si_improve_dihedral_angle.
                        """

                    class _si_quality_max_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument si_quality_max_angle.
                        """

                    class _advanced_improve(PyArgumentsParameterSubItem):
                        """
                        Argument advanced_improve.
                        """

                    class _si_quality_collapse_limit(PyArgumentsNumericalSubItem):
                        """
                        Argument si_quality_collapse_limit.
                        """

                    class _si_step_width(PyArgumentsNumericalSubItem):
                        """
                        Argument si_step_width.
                        """

                    class _si_quality_iterations(PyArgumentsNumericalSubItem):
                        """
                        Argument si_quality_iterations.
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Argument show_in_gui.
                        """

                    class _si_remove_step(PyArgumentsParameterSubItem):
                        """
                        Argument si_remove_step.
                        """

                    class _si_step_quality_limit(PyArgumentsNumericalSubItem):
                        """
                        Argument si_step_quality_limit.
                        """

                    class _allow_defeaturing(PyArgumentsParameterSubItem):
                        """
                        Argument allow_defeaturing.
                        """

                    class _si_dihedral_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument si_dihedral_angle.
                        """

                class _surface_mesh_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument surface_mesh_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.volume_mesh_max_size = self._volume_mesh_max_size(self, "volume_mesh_max_size", service, rules, path)
                        self.self_intersect_check = self._self_intersect_check(self, "self_intersect_check", service, rules, path)
                        self.auto_surface_remesh = self._auto_surface_remesh(self, "auto_surface_remesh", service, rules, path)
                        self.quality_improve_collapase_skewness_limit = self._quality_improve_collapase_skewness_limit(self, "quality_improve_collapase_skewness_limit", service, rules, path)
                        self.set_volume_mesh_max_size = self._set_volume_mesh_max_size(self, "set_volume_mesh_max_size", service, rules, path)
                        self.separate_by_angle = self._separate_by_angle(self, "separate_by_angle", service, rules, path)
                        self.quality_improve_skewness_limit = self._quality_improve_skewness_limit(self, "quality_improve_skewness_limit", service, rules, path)
                        self.parallel_region_compute = self._parallel_region_compute(self, "parallel_region_compute", service, rules, path)
                        self.remove_steps = self._remove_steps(self, "remove_steps", service, rules, path)
                        self.fold_face_limit = self._fold_face_limit(self, "fold_face_limit", service, rules, path)
                        self.max_step_width = self._max_step_width(self, "max_step_width", service, rules, path)
                        self.thin_volume_meshing_auto_control_creation = self._thin_volume_meshing_auto_control_creation(self, "thin_volume_meshing_auto_control_creation", service, rules, path)
                        self.improve_quality = self._improve_quality(self, "improve_quality", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)
                        self.quality_improve_max_angle = self._quality_improve_max_angle(self, "quality_improve_max_angle", service, rules, path)
                        self.auto_assign_zone_types = self._auto_assign_zone_types(self, "auto_assign_zone_types", service, rules, path)
                        self.auto_merge = self._auto_merge(self, "auto_merge", service, rules, path)
                        self.separation_angle = self._separation_angle(self, "separation_angle", service, rules, path)

                    class _volume_mesh_max_size(PyArgumentsNumericalSubItem):
                        """
                        Argument volume_mesh_max_size.
                        """

                    class _self_intersect_check(PyArgumentsParameterSubItem):
                        """
                        Argument self_intersect_check.
                        """

                    class _auto_surface_remesh(PyArgumentsTextualSubItem):
                        """
                        Argument auto_surface_remesh.
                        """

                    class _quality_improve_collapase_skewness_limit(PyArgumentsNumericalSubItem):
                        """
                        Argument quality_improve_collapase_skewness_limit.
                        """

                    class _set_volume_mesh_max_size(PyArgumentsParameterSubItem):
                        """
                        Argument set_volume_mesh_max_size.
                        """

                    class _separate_by_angle(PyArgumentsTextualSubItem):
                        """
                        Argument separate_by_angle.
                        """

                    class _quality_improve_skewness_limit(PyArgumentsNumericalSubItem):
                        """
                        Argument quality_improve_skewness_limit.
                        """

                    class _parallel_region_compute(PyArgumentsTextualSubItem):
                        """
                        Argument parallel_region_compute.
                        """

                    class _remove_steps(PyArgumentsParameterSubItem):
                        """
                        Argument remove_steps.
                        """

                    class _fold_face_limit(PyArgumentsNumericalSubItem):
                        """
                        Argument fold_face_limit.
                        """

                    class _max_step_width(PyArgumentsNumericalSubItem):
                        """
                        Argument max_step_width.
                        """

                    class _thin_volume_meshing_auto_control_creation(PyArgumentsParameterSubItem):
                        """
                        Argument thin_volume_meshing_auto_control_creation.
                        """

                    class _improve_quality(PyArgumentsParameterSubItem):
                        """
                        Argument improve_quality.
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Argument show_in_gui.
                        """

                    class _quality_improve_max_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument quality_improve_max_angle.
                        """

                    class _auto_assign_zone_types(PyArgumentsParameterSubItem):
                        """
                        Argument auto_assign_zone_types.
                        """

                    class _auto_merge(PyArgumentsParameterSubItem):
                        """
                        Argument auto_merge.
                        """

                    class _separation_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument separation_angle.
                        """

            def create_instance(self) -> _apply_share_topologyArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._apply_share_topologyArguments(*args)

        class axisymmetric_sweep(PyCommand):
            """
            Command axisymmetric_sweep.

            Parameters
            ----------
            axis_sweep_control_name : str
                Specify a name for this axisymmetric sweep control.
            selection_type : str
            sweep_boundary_zone_list : list[str]
                Select one or more boundary zones from the list to which you will apply the sweep. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            topology_list : list[str]
            axis_origin : dict[str, Any]
            axis_direction : dict[str, Any]
            revolution_angle_deg : float
                Specify the revolution angle for the sweep in degrees (typically 360 for a full rotation).
            number_of_layers : int
                Specify the number of layers (divisions) used in the swept direction.
            zone_location : list[str]

            Returns
            -------
            bool
            """
            class _axisymmetric_sweepArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.axis_sweep_control_name = self._axis_sweep_control_name(self, "axis_sweep_control_name", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.sweep_boundary_zone_list = self._sweep_boundary_zone_list(self, "sweep_boundary_zone_list", service, rules, path)
                    self.topology_list = self._topology_list(self, "topology_list", service, rules, path)
                    self.axis_origin = self._axis_origin(self, "axis_origin", service, rules, path)
                    self.axis_direction = self._axis_direction(self, "axis_direction", service, rules, path)
                    self.revolution_angle_deg = self._revolution_angle_deg(self, "revolution_angle_deg", service, rules, path)
                    self.number_of_layers = self._number_of_layers(self, "number_of_layers", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)

                class _axis_sweep_control_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for this axisymmetric sweep control.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Argument selection_type.
                    """

                class _sweep_boundary_zone_list(PyArgumentsTextualSubItem):
                    """
                    Select one or more boundary zones from the list to which you will apply the sweep. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _topology_list(PyArgumentsTextualSubItem):
                    """
                    Argument topology_list.
                    """

                class _axis_origin(PyArgumentsSingletonSubItem):
                    """
                    Argument axis_origin.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.y = self._y(self, "y", service, rules, path)
                        self.z = self._z(self, "z", service, rules, path)
                        self.x = self._x(self, "x", service, rules, path)

                    class _y(PyArgumentsNumericalSubItem):
                        """
                        Specify the Y component for the currently active axis definition (axis origin or axis direction).
                        """

                    class _z(PyArgumentsNumericalSubItem):
                        """
                        Specify the Z component for the currently active axis definition (axis origin or axis direction).
                        """

                    class _x(PyArgumentsNumericalSubItem):
                        """
                        Specify the X component for the currently active axis definition (axis origin or axis direction).
                        """

                class _axis_direction(PyArgumentsSingletonSubItem):
                    """
                    Argument axis_direction.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.y = self._y(self, "y", service, rules, path)
                        self.z = self._z(self, "z", service, rules, path)
                        self.x = self._x(self, "x", service, rules, path)

                    class _y(PyArgumentsNumericalSubItem):
                        """
                        Specify the Y component for the currently active axis definition (axis origin or axis direction).
                        """

                    class _z(PyArgumentsNumericalSubItem):
                        """
                        Specify the Z component for the currently active axis definition (axis origin or axis direction).
                        """

                    class _x(PyArgumentsNumericalSubItem):
                        """
                        Specify the X component for the currently active axis definition (axis origin or axis direction).
                        """

                class _revolution_angle_deg(PyArgumentsNumericalSubItem):
                    """
                    Specify the revolution angle for the sweep in degrees (typically 360 for a full rotation).
                    """

                class _number_of_layers(PyArgumentsNumericalSubItem):
                    """
                    Specify the number of layers (divisions) used in the swept direction.
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

            def create_instance(self) -> _axisymmetric_sweepArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._axisymmetric_sweepArguments(*args)

        class capping(PyCommand):
            """
            For solid model geometries where you want to extract a flow volume, use this task to enclose, or cap, any openings in your geometry in order to later calculate your fluid region(s). Assign a name for the capping surface, and designate the type of opening (inlet, outlet, etc.) and assign one or more zones or labels to the capping surface. Create as many caps as required to cover all openings. Choose any advanced options that you want to take effect upon updating the task.  More...
            Parameters
            ----------
            patch_name : str
                Enter a name for the capping surface.
            zone_type : str
                Choose the type of zone to assign to the capping surface (velocity inlet, pressure outlet, etc.).
            patch_type : str
                Choose the type of capping surface: a regular, simple opening with one or more faces:  or an annular opening where the fluid is within two concentric cylinders:
            selection_type : str
                Choose how you want to select your surface (by label or by zone).
            label_selection_list : list[str]
                Choose one or more face zone labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_selection_list : list[str]
                Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            topology_list : list[str]
            create_patch_preferences : dict[str, Any]
            object_association : str
            new_object_name : str
            patch_object_name : str
            cap_labels : list[str]
            zone_location : list[str]
            complete_zone_selection_list : list[str]
                Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            complete_label_selection_list : list[str]
                Choose one or more face zone labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            complete_topology_list : list[str]

            Returns
            -------
            bool
            """
            class _cappingArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.patch_name = self._patch_name(self, "patch_name", service, rules, path)
                    self.zone_type = self._zone_type(self, "zone_type", service, rules, path)
                    self.patch_type = self._patch_type(self, "patch_type", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.label_selection_list = self._label_selection_list(self, "label_selection_list", service, rules, path)
                    self.zone_selection_list = self._zone_selection_list(self, "zone_selection_list", service, rules, path)
                    self.topology_list = self._topology_list(self, "topology_list", service, rules, path)
                    self.create_patch_preferences = self._create_patch_preferences(self, "create_patch_preferences", service, rules, path)
                    self.object_association = self._object_association(self, "object_association", service, rules, path)
                    self.new_object_name = self._new_object_name(self, "new_object_name", service, rules, path)
                    self.patch_object_name = self._patch_object_name(self, "patch_object_name", service, rules, path)
                    self.cap_labels = self._cap_labels(self, "cap_labels", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.complete_zone_selection_list = self._complete_zone_selection_list(self, "complete_zone_selection_list", service, rules, path)
                    self.complete_label_selection_list = self._complete_label_selection_list(self, "complete_label_selection_list", service, rules, path)
                    self.complete_topology_list = self._complete_topology_list(self, "complete_topology_list", service, rules, path)

                class _patch_name(PyArgumentsTextualSubItem):
                    """
                    Enter a name for the capping surface.
                    """

                class _zone_type(PyArgumentsTextualSubItem):
                    """
                    Choose the type of zone to assign to the capping surface (velocity inlet, pressure outlet, etc.).
                    """

                class _patch_type(PyArgumentsTextualSubItem):
                    """
                    Choose the type of capping surface: a regular, simple opening with one or more faces:  or an annular opening where the fluid is within two concentric cylinders:
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to select your surface (by label or by zone).
                    """

                class _label_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zone labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _topology_list(PyArgumentsTextualSubItem):
                    """
                    Argument topology_list.
                    """

                class _create_patch_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument create_patch_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.max_cap_limit = self._max_cap_limit(self, "max_cap_limit", service, rules, path)
                        self.check_cap_self_intersection = self._check_cap_self_intersection(self, "check_cap_self_intersection", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)

                    class _max_cap_limit(PyArgumentsNumericalSubItem):
                        """
                        Specify the upper limit for the number of edges that can be present on the capping surface.
                        """

                    class _check_cap_self_intersection(PyArgumentsParameterSubItem):
                        """
                        Choose whether or not the system will detect if the capping surface intersects with any other face in the model. If an intersected face is found, it is automatically deleted. To increase the efficiency of the capping task, this option should be set to "no".
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Display advanced options that you may want to apply to the task.
                        """

                class _object_association(PyArgumentsTextualSubItem):
                    """
                    Argument object_association.
                    """

                class _new_object_name(PyArgumentsTextualSubItem):
                    """
                    Argument new_object_name.
                    """

                class _patch_object_name(PyArgumentsTextualSubItem):
                    """
                    Argument patch_object_name.
                    """

                class _cap_labels(PyArgumentsTextualSubItem):
                    """
                    Argument cap_labels.
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _complete_zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _complete_label_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zone labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _complete_topology_list(PyArgumentsTextualSubItem):
                    """
                    Argument complete_topology_list.
                    """

            def create_instance(self) -> _cappingArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._cappingArguments(*args)

        class check_mesh(PyCommand):
            """
            Command check_mesh.


            Returns
            -------
            None
            """
            class _check_meshArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)

            def create_instance(self) -> _check_meshArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._check_meshArguments(*args)

        class check_surface_quality(PyCommand):
            """
            Command check_surface_quality.


            Returns
            -------
            None
            """
            class _check_surface_qualityArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)

            def create_instance(self) -> _check_surface_qualityArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._check_surface_qualityArguments(*args)

        class check_volume_quality(PyCommand):
            """
            Command check_volume_quality.


            Returns
            -------
            None
            """
            class _check_volume_qualityArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)

            def create_instance(self) -> _check_volume_qualityArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._check_volume_qualityArguments(*args)

        class choose_mesh_control_options(PyCommand):
            """
            Pick and choose various means of generating and refining the mesh in your simulation. Determine how you want to create and manage and view your size controls in the workflow. More...
            Parameters
            ----------
            read_or_create : str
                Determine whether you want to create new, or use existing mesh size controls or size fields.
            size_control_file_name : str
                Browse to specify the location and the name of the size control file (.szcontrol) where your mesh controls are defined.
            wrap_size_control_file_name : str
                Browse to specify the location and the name of the size control file (.szcontrol) where your mesh controls are defined.
            creation_method : str
                Determine whether you want to use default size controls or not. Default will populate your size controls with default settings, based on the number of objects in your model. The Custom option can be used to populate as many size controls as you need using your own customized settings.
            view_option : str
                Determine if you would like to use separate tasks or a table to view and work with your mesh controls.
            global_min : float
            global_max : float
            global_growth_rate : float
            mesh_control_options : dict[str, Any]

            Returns
            -------
            bool
            """
            class _choose_mesh_control_optionsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.read_or_create = self._read_or_create(self, "read_or_create", service, rules, path)
                    self.size_control_file_name = self._size_control_file_name(self, "size_control_file_name", service, rules, path)
                    self.wrap_size_control_file_name = self._wrap_size_control_file_name(self, "wrap_size_control_file_name", service, rules, path)
                    self.creation_method = self._creation_method(self, "creation_method", service, rules, path)
                    self.view_option = self._view_option(self, "view_option", service, rules, path)
                    self.global_min = self._global_min(self, "global_min", service, rules, path)
                    self.global_max = self._global_max(self, "global_max", service, rules, path)
                    self.global_growth_rate = self._global_growth_rate(self, "global_growth_rate", service, rules, path)
                    self.mesh_control_options = self._mesh_control_options(self, "mesh_control_options", service, rules, path)

                class _read_or_create(PyArgumentsTextualSubItem):
                    """
                    Determine whether you want to create new, or use existing mesh size controls or size fields.
                    """

                class _size_control_file_name(PyArgumentsTextualSubItem):
                    """
                    Browse to specify the location and the name of the size control file (.szcontrol) where your mesh controls are defined.
                    """

                class _wrap_size_control_file_name(PyArgumentsTextualSubItem):
                    """
                    Browse to specify the location and the name of the size control file (.szcontrol) where your mesh controls are defined.
                    """

                class _creation_method(PyArgumentsTextualSubItem):
                    """
                    Determine whether you want to use default size controls or not. Default will populate your size controls with default settings, based on the number of objects in your model. The Custom option can be used to populate as many size controls as you need using your own customized settings.
                    """

                class _view_option(PyArgumentsTextualSubItem):
                    """
                    Determine if you would like to use separate tasks or a table to view and work with your mesh controls.
                    """

                class _global_min(PyArgumentsNumericalSubItem):
                    """
                    Argument global_min.
                    """

                class _global_max(PyArgumentsNumericalSubItem):
                    """
                    Argument global_max.
                    """

                class _global_growth_rate(PyArgumentsNumericalSubItem):
                    """
                    Argument global_growth_rate.
                    """

                class _mesh_control_options(PyArgumentsSingletonSubItem):
                    """
                    Argument mesh_control_options.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.existing_size_field = self._existing_size_field(self, "existing_size_field", service, rules, path)
                        self.target_size_field_file_name = self._target_size_field_file_name(self, "target_size_field_file_name", service, rules, path)
                        self.targe_size_field_file_name = self._targe_size_field_file_name(self, "targe_size_field_file_name", service, rules, path)
                        self.edge_proximity_computation = self._edge_proximity_computation(self, "edge_proximity_computation", service, rules, path)
                        self.wrap_target_both_options = self._wrap_target_both_options(self, "wrap_target_both_options", service, rules, path)
                        self.wrap_target_raio = self._wrap_target_raio(self, "wrap_target_raio", service, rules, path)
                        self.wrap_target_ratio = self._wrap_target_ratio(self, "wrap_target_ratio", service, rules, path)
                        self.advanced_options = self._advanced_options(self, "advanced_options", service, rules, path)
                        self.solid_fluid_ratio = self._solid_fluid_ratio(self, "solid_fluid_ratio", service, rules, path)
                        self.boundary_layers = self._boundary_layers(self, "boundary_layers", service, rules, path)
                        self.solid_fluid_raio = self._solid_fluid_raio(self, "solid_fluid_raio", service, rules, path)
                        self.wrap_size_field_file_name = self._wrap_size_field_file_name(self, "wrap_size_field_file_name", service, rules, path)
                        self.wrap_target_size_field_ratio = self._wrap_target_size_field_ratio(self, "wrap_target_size_field_ratio", service, rules, path)

                    class _existing_size_field(PyArgumentsTextualSubItem):
                        """
                        Determine which existing size field files will be used: Both Wrap and Target (the default), Target Only, or Wrap Only. For complex models, computational expense can be lowered by choosing one of the other options. If either Wrap Only or Target Only is selected, then the other values are determined using the Wrap/Target Size Ratio value.
                        """

                    class _target_size_field_file_name(PyArgumentsTextualSubItem):
                        """
                        Argument target_size_field_file_name.
                        """

                    class _targe_size_field_file_name(PyArgumentsTextualSubItem):
                        """
                        Indicate the name and location of the target size field file (\\*.sf).
                        """

                    class _edge_proximity_computation(PyArgumentsParameterSubItem):
                        """
                        For geometries having a very large number of small feature edges, select Yes to speed up the calculation and reduce memory requirements when using a proximity size function.
                        """

                    class _wrap_target_both_options(PyArgumentsTextualSubItem):
                        """
                        Determine how the size controls are calculated in the Add Local Sizing task: using Both Wrap and Target values, by Target Only (the default), or by Wrap Only. For complex models, computational expense can be lowered by choosing one of the other options. If either Wrap Only or Target Only is selected, then the other values are determined using the Wrap/Target Size Ratio value.
                        """

                    class _wrap_target_raio(PyArgumentsNumericalSubItem):
                        """
                        This is the ratio of the wrap size and the target size controls. For example, if this ratio is 0.67 and the initial minimum target size is 1 and initial maximum target size is 16, then the initial minimum wrap size will be 0.67 and the initial maximum wrap size will be 10.72 . This value does not affect BOI or soft size controls, since, in such cases, the Wrap/Target Size Control Ratio is set to 1.
                        """

                    class _wrap_target_ratio(PyArgumentsNumericalSubItem):
                        """
                        Argument wrap_target_ratio.
                        """

                    class _advanced_options(PyArgumentsParameterSubItem):
                        """
                        Display advanced options that you may want to apply to the task.
                        """

                    class _solid_fluid_ratio(PyArgumentsNumericalSubItem):
                        """
                        Argument solid_fluid_ratio.
                        """

                    class _boundary_layers(PyArgumentsParameterSubItem):
                        """
                        Argument boundary_layers.
                        """

                    class _solid_fluid_raio(PyArgumentsNumericalSubItem):
                        """
                        The ratio of the actual size of the solid and the actual size of the fluid.
                        """

                    class _wrap_size_field_file_name(PyArgumentsTextualSubItem):
                        """
                        Indicate the name and location of the wrap size field file (\\*.sf).
                        """

                    class _wrap_target_size_field_ratio(PyArgumentsNumericalSubItem):
                        """
                        The ratio of the initial wrap size field and the local target size field.
                        """

            def create_instance(self) -> _choose_mesh_control_optionsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._choose_mesh_control_optionsArguments(*args)

        class close_leakage(PyCommand):
            """
            Command close_leakage.

            Parameters
            ----------
            close_leakage_option : bool

            Returns
            -------
            bool
            """
            class _close_leakageArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.close_leakage_option = self._close_leakage_option(self, "close_leakage_option", service, rules, path)

                class _close_leakage_option(PyArgumentsParameterSubItem):
                    """
                    Argument close_leakage_option.
                    """

            def create_instance(self) -> _close_leakageArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._close_leakageArguments(*args)

        class compute_regions(PyCommand):
            """
            Command compute_regions.

            Parameters
            ----------
            complex_meshing_regions_option : bool

            Returns
            -------
            bool
            """
            class _compute_regionsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.complex_meshing_regions_option = self._complex_meshing_regions_option(self, "complex_meshing_regions_option", service, rules, path)

                class _complex_meshing_regions_option(PyArgumentsParameterSubItem):
                    """
                    Argument complex_meshing_regions_option.
                    """

            def create_instance(self) -> _compute_regionsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._compute_regionsArguments(*args)

        class compute_size_fields(PyCommand):
            """
            Command compute_size_fields.

            Parameters
            ----------
            compute_size_field_control : bool

            Returns
            -------
            bool
            """
            class _compute_size_fieldsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.compute_size_field_control = self._compute_size_field_control(self, "compute_size_field_control", service, rules, path)

                class _compute_size_field_control(PyArgumentsParameterSubItem):
                    """
                    Argument compute_size_field_control.
                    """

            def create_instance(self) -> _compute_size_fieldsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._compute_size_fieldsArguments(*args)

        class create_collar_mesh(PyCommand):
            """
            Use this task to create an overset collar mesh. You can use various techniques, such as using intersecting objects, using an edge-based approach, or using an existing object. 
                            More...
            Parameters
            ----------
            refinement_regions_name : str
                Specify a name for the collar mesh or use the default name.
            creation_method : str
                Choose how you want to create the collar mesh: either by using intersecting objects, an edge-based collar, or an existing object.
            boi_max_size : float
                Specify the maximum size of the elements for the collar mesh.
            boi_size_name : str
            selection_type : str
                Choose how you want to make your selection (by object, label, or zone name).
            zone_selection_list : list[str]
                Choose one or more zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_location : list[str]
            label_selection_list : list[str]
                Select one or more labels that will make up the collar mesh. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            object_selection_list : list[str]
                Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_selection_single : list[str]
                Choose a single zone from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            object_selection_single : list[str]
                Choose a single object from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            topology_list : list[str]
            bounding_box_object : dict[str, Any]
            offset_object : dict[str, Any]
            cylinder_method : str
            cylinder_object : dict[str, Any]
            axis : dict[str, Any]
            volume_fill : str
                Specify the type of mesh cell to use to fill the collar mesh. Available options are tetrahedral, hexcore, poly, or poly-hexcore. .
            cylinder_length : float
            geometry_tools_properties : dict[str, Any]

            Returns
            -------
            bool
            """
            class _create_collar_meshArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.refinement_regions_name = self._refinement_regions_name(self, "refinement_regions_name", service, rules, path)
                    self.creation_method = self._creation_method(self, "creation_method", service, rules, path)
                    self.boi_max_size = self._boi_max_size(self, "boi_max_size", service, rules, path)
                    self.boi_size_name = self._boi_size_name(self, "boi_size_name", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.zone_selection_list = self._zone_selection_list(self, "zone_selection_list", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.label_selection_list = self._label_selection_list(self, "label_selection_list", service, rules, path)
                    self.object_selection_list = self._object_selection_list(self, "object_selection_list", service, rules, path)
                    self.zone_selection_single = self._zone_selection_single(self, "zone_selection_single", service, rules, path)
                    self.object_selection_single = self._object_selection_single(self, "object_selection_single", service, rules, path)
                    self.topology_list = self._topology_list(self, "topology_list", service, rules, path)
                    self.bounding_box_object = self._bounding_box_object(self, "bounding_box_object", service, rules, path)
                    self.offset_object = self._offset_object(self, "offset_object", service, rules, path)
                    self.cylinder_method = self._cylinder_method(self, "cylinder_method", service, rules, path)
                    self.cylinder_object = self._cylinder_object(self, "cylinder_object", service, rules, path)
                    self.axis = self._axis(self, "axis", service, rules, path)
                    self.volume_fill = self._volume_fill(self, "volume_fill", service, rules, path)
                    self.cylinder_length = self._cylinder_length(self, "cylinder_length", service, rules, path)
                    self.geometry_tools_properties = self._geometry_tools_properties(self, "geometry_tools_properties", service, rules, path)

                class _refinement_regions_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the collar mesh or use the default name.
                    """

                class _creation_method(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to create the collar mesh: either by using intersecting objects, an edge-based collar, or an existing object.
                    """

                class _boi_max_size(PyArgumentsNumericalSubItem):
                    """
                    Specify the maximum size of the elements for the collar mesh.
                    """

                class _boi_size_name(PyArgumentsTextualSubItem):
                    """
                    Argument boi_size_name.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to make your selection (by object, label, or zone name).
                    """

                class _zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _label_selection_list(PyArgumentsTextualSubItem):
                    """
                    Select one or more labels that will make up the collar mesh. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_selection_single(PyArgumentsTextualSubItem):
                    """
                    Choose a single zone from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _object_selection_single(PyArgumentsTextualSubItem):
                    """
                    Choose a single object from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _topology_list(PyArgumentsTextualSubItem):
                    """
                    Argument topology_list.
                    """

                class _bounding_box_object(PyArgumentsSingletonSubItem):
                    """
                    Argument bounding_box_object.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.zmax = self._zmax(self, "zmax", service, rules, path)
                        self.ymax_ratio = self._ymax_ratio(self, "ymax_ratio", service, rules, path)
                        self.size_relative_length = self._size_relative_length(self, "size_relative_length", service, rules, path)
                        self.xmin_ratio = self._xmin_ratio(self, "xmin_ratio", service, rules, path)
                        self.zmax_ratio = self._zmax_ratio(self, "zmax_ratio", service, rules, path)
                        self.ymin_ratio = self._ymin_ratio(self, "ymin_ratio", service, rules, path)
                        self.zmin_ratio = self._zmin_ratio(self, "zmin_ratio", service, rules, path)
                        self.xmax_ratio = self._xmax_ratio(self, "xmax_ratio", service, rules, path)
                        self.xmin = self._xmin(self, "xmin", service, rules, path)
                        self.zmin = self._zmin(self, "zmin", service, rules, path)
                        self.ymin = self._ymin(self, "ymin", service, rules, path)
                        self.xmax = self._xmax(self, "xmax", service, rules, path)
                        self.ymax = self._ymax(self, "ymax", service, rules, path)

                    class _zmax(PyArgumentsNumericalSubItem):
                        """
                        Specify the x-coordinate of the offset collar mesh.
                        """

                    class _ymax_ratio(PyArgumentsNumericalSubItem):
                        """
                        Argument ymax_ratio.
                        """

                    class _size_relative_length(PyArgumentsTextualSubItem):
                        """
                        Argument size_relative_length.
                        """

                    class _xmin_ratio(PyArgumentsNumericalSubItem):
                        """
                        Argument xmin_ratio.
                        """

                    class _zmax_ratio(PyArgumentsNumericalSubItem):
                        """
                        Argument zmax_ratio.
                        """

                    class _ymin_ratio(PyArgumentsNumericalSubItem):
                        """
                        Argument ymin_ratio.
                        """

                    class _zmin_ratio(PyArgumentsNumericalSubItem):
                        """
                        Argument zmin_ratio.
                        """

                    class _xmax_ratio(PyArgumentsNumericalSubItem):
                        """
                        Argument xmax_ratio.
                        """

                    class _xmin(PyArgumentsNumericalSubItem):
                        """
                        Argument xmin.
                        """

                    class _zmin(PyArgumentsNumericalSubItem):
                        """
                        Argument zmin.
                        """

                    class _ymin(PyArgumentsNumericalSubItem):
                        """
                        Argument ymin.
                        """

                    class _xmax(PyArgumentsNumericalSubItem):
                        """
                        Specify the x-coordinate of the offset collar mesh.
                        """

                    class _ymax(PyArgumentsNumericalSubItem):
                        """
                        Specify the x-coordinate of the offset collar mesh.
                        """

                class _offset_object(PyArgumentsSingletonSubItem):
                    """
                    Argument offset_object.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.flip_direction = self._flip_direction(self, "flip_direction", service, rules, path)
                        self.y = self._y(self, "y", service, rules, path)
                        self.boundary_layer_height = self._boundary_layer_height(self, "boundary_layer_height", service, rules, path)
                        self.cross_wake_growth_factor = self._cross_wake_growth_factor(self, "cross_wake_growth_factor", service, rules, path)
                        self.first_height = self._first_height(self, "first_height", service, rules, path)
                        self.mpt_method_type = self._mpt_method_type(self, "mpt_method_type", service, rules, path)
                        self.wake_growth_factor = self._wake_growth_factor(self, "wake_growth_factor", service, rules, path)
                        self.defeaturing_size = self._defeaturing_size(self, "defeaturing_size", service, rules, path)
                        self.aspect_ratio = self._aspect_ratio(self, "aspect_ratio", service, rules, path)
                        self.number_of_layers = self._number_of_layers(self, "number_of_layers", service, rules, path)
                        self.z = self._z(self, "z", service, rules, path)
                        self.x = self._x(self, "x", service, rules, path)
                        self.wake_levels = self._wake_levels(self, "wake_levels", service, rules, path)
                        self.offset_method_type = self._offset_method_type(self, "offset_method_type", service, rules, path)
                        self.boundary_layer_levels = self._boundary_layer_levels(self, "boundary_layer_levels", service, rules, path)
                        self.last_ratio_percentage = self._last_ratio_percentage(self, "last_ratio_percentage", service, rules, path)
                        self.flow_direction = self._flow_direction(self, "flow_direction", service, rules, path)
                        self.edge_selection_list = self._edge_selection_list(self, "edge_selection_list", service, rules, path)
                        self.show_coordinates = self._show_coordinates(self, "show_coordinates", service, rules, path)
                        self.rate = self._rate(self, "rate", service, rules, path)

                    class _flip_direction(PyArgumentsParameterSubItem):
                        """
                        Argument flip_direction.
                        """

                    class _y(PyArgumentsNumericalSubItem):
                        """
                        Specify the y-coordinate of the offset collar mesh.
                        """

                    class _boundary_layer_height(PyArgumentsNumericalSubItem):
                        """
                        Specify the total height of the boundary layer for this refinement region (this is flow in the vicinity).
                        """

                    class _cross_wake_growth_factor(PyArgumentsNumericalSubItem):
                        """
                        Argument cross_wake_growth_factor.
                        """

                    class _first_height(PyArgumentsNumericalSubItem):
                        """
                        Argument first_height.
                        """

                    class _mpt_method_type(PyArgumentsTextualSubItem):
                        """
                        Choose how you want to assign the location of the offset collar mesh. You can choose Automatic to have the system determine the best place for the collar mesh based on the intersected bodies or zones, or you can choose to use distinct Numerical Inputs.
                        """

                    class _wake_growth_factor(PyArgumentsNumericalSubItem):
                        """
                        Argument wake_growth_factor.
                        """

                    class _defeaturing_size(PyArgumentsNumericalSubItem):
                        """
                        Argument defeaturing_size.
                        """

                    class _aspect_ratio(PyArgumentsNumericalSubItem):
                        """
                        Argument aspect_ratio.
                        """

                    class _number_of_layers(PyArgumentsNumericalSubItem):
                        """
                        Argument number_of_layers.
                        """

                    class _z(PyArgumentsNumericalSubItem):
                        """
                        Specify the z-coordinate of the offset collar mesh.
                        """

                    class _x(PyArgumentsNumericalSubItem):
                        """
                        Specify the x-coordinate of the offset collar mesh.
                        """

                    class _wake_levels(PyArgumentsNumericalSubItem):
                        """
                        Argument wake_levels.
                        """

                    class _offset_method_type(PyArgumentsTextualSubItem):
                        """
                        Argument offset_method_type.
                        """

                    class _boundary_layer_levels(PyArgumentsNumericalSubItem):
                        """
                        Argument boundary_layer_levels.
                        """

                    class _last_ratio_percentage(PyArgumentsNumericalSubItem):
                        """
                        Argument last_ratio_percentage.
                        """

                    class _flow_direction(PyArgumentsTextualSubItem):
                        """
                        Argument flow_direction.
                        """

                    class _edge_selection_list(PyArgumentsTextualSubItem):
                        """
                        Choose a single edge zone from the list below for your edge-based collar mesh. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """

                    class _show_coordinates(PyArgumentsParameterSubItem):
                        """
                        Display the X, Y, and Z coordinate fields
                        """

                    class _rate(PyArgumentsNumericalSubItem):
                        """
                        Argument rate.
                        """

                class _cylinder_method(PyArgumentsTextualSubItem):
                    """
                    Argument cylinder_method.
                    """

                class _cylinder_object(PyArgumentsSingletonSubItem):
                    """
                    Argument cylinder_object.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.node_2 = self._node_2(self, "node_2", service, rules, path)
                        self.node_3 = self._node_3(self, "node_3", service, rules, path)
                        self.x2 = self._x2(self, "x2", service, rules, path)
                        self.x_offset = self._x_offset(self, "x_offset", service, rules, path)
                        self.x1 = self._x1(self, "x1", service, rules, path)
                        self.height_back_inc = self._height_back_inc(self, "height_back_inc", service, rules, path)
                        self.height_front_inc = self._height_front_inc(self, "height_front_inc", service, rules, path)
                        self.height_node = self._height_node(self, "height_node", service, rules, path)
                        self.z_offset = self._z_offset(self, "z_offset", service, rules, path)
                        self.z1 = self._z1(self, "z1", service, rules, path)
                        self.node_1 = self._node_1(self, "node_1", service, rules, path)
                        self.y_offset = self._y_offset(self, "y_offset", service, rules, path)
                        self.radius_2 = self._radius_2(self, "radius_2", service, rules, path)
                        self.z2 = self._z2(self, "z2", service, rules, path)
                        self.radius_1 = self._radius_1(self, "radius_1", service, rules, path)
                        self.y2 = self._y2(self, "y2", service, rules, path)
                        self.y1 = self._y1(self, "y1", service, rules, path)

                    class _node_2(PyArgumentsTextualSubItem):
                        """
                        Argument node_2.
                        """

                    class _node_3(PyArgumentsTextualSubItem):
                        """
                        Argument node_3.
                        """

                    class _x2(PyArgumentsNumericalSubItem):
                        """
                        Argument x2.
                        """

                    class _x_offset(PyArgumentsNumericalSubItem):
                        """
                        Argument x_offset.
                        """

                    class _x1(PyArgumentsNumericalSubItem):
                        """
                        Argument x1.
                        """

                    class _height_back_inc(PyArgumentsNumericalSubItem):
                        """
                        Argument height_back_inc.
                        """

                    class _height_front_inc(PyArgumentsNumericalSubItem):
                        """
                        Argument height_front_inc.
                        """

                    class _height_node(PyArgumentsTextualSubItem):
                        """
                        Argument height_node.
                        """

                    class _z_offset(PyArgumentsNumericalSubItem):
                        """
                        Argument z_offset.
                        """

                    class _z1(PyArgumentsNumericalSubItem):
                        """
                        Argument z1.
                        """

                    class _node_1(PyArgumentsTextualSubItem):
                        """
                        Argument node_1.
                        """

                    class _y_offset(PyArgumentsNumericalSubItem):
                        """
                        Argument y_offset.
                        """

                    class _radius_2(PyArgumentsNumericalSubItem):
                        """
                        Argument radius_2.
                        """

                    class _z2(PyArgumentsNumericalSubItem):
                        """
                        Argument z2.
                        """

                    class _radius_1(PyArgumentsNumericalSubItem):
                        """
                        Argument radius_1.
                        """

                    class _y2(PyArgumentsNumericalSubItem):
                        """
                        Argument y2.
                        """

                    class _y1(PyArgumentsNumericalSubItem):
                        """
                        Argument y1.
                        """

                class _axis(PyArgumentsSingletonSubItem):
                    """
                    Argument axis.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.z_component = self._z_component(self, "z_component", service, rules, path)
                        self.y_component = self._y_component(self, "y_component", service, rules, path)
                        self.x_component = self._x_component(self, "x_component", service, rules, path)

                    class _z_component(PyArgumentsNumericalSubItem):
                        """
                        Argument z_component.
                        """

                    class _y_component(PyArgumentsNumericalSubItem):
                        """
                        Argument y_component.
                        """

                    class _x_component(PyArgumentsNumericalSubItem):
                        """
                        Argument x_component.
                        """

                class _volume_fill(PyArgumentsTextualSubItem):
                    """
                    Specify the type of mesh cell to use to fill the collar mesh. Available options are tetrahedral, hexcore, poly, or poly-hexcore. .
                    """

                class _cylinder_length(PyArgumentsNumericalSubItem):
                    """
                    Argument cylinder_length.
                    """

                class _geometry_tools_properties(PyArgumentsSingletonSubItem):
                    """
                    Argument geometry_tools_properties.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.box_center_z = self._box_center_z(self, "box_center_z", service, rules, path)
                        self.cylinder_radius_1 = self._cylinder_radius_1(self, "cylinder_radius_1", service, rules, path)
                        self.cylinder_z1 = self._cylinder_z1(self, "cylinder_z1", service, rules, path)
                        self.box_center_x = self._box_center_x(self, "box_center_x", service, rules, path)
                        self.cylinder_x1 = self._cylinder_x1(self, "cylinder_x1", service, rules, path)
                        self.box_y_length = self._box_y_length(self, "box_y_length", service, rules, path)
                        self.box_z_length = self._box_z_length(self, "box_z_length", service, rules, path)
                        self.cylinder_z2 = self._cylinder_z2(self, "cylinder_z2", service, rules, path)
                        self.box_center_y = self._box_center_y(self, "box_center_y", service, rules, path)
                        self.cylinder_radius_2 = self._cylinder_radius_2(self, "cylinder_radius_2", service, rules, path)
                        self.cylinder_y1 = self._cylinder_y1(self, "cylinder_y1", service, rules, path)
                        self.box_x_length = self._box_x_length(self, "box_x_length", service, rules, path)
                        self.cylinder_x2 = self._cylinder_x2(self, "cylinder_x2", service, rules, path)
                        self.cylinder_y2 = self._cylinder_y2(self, "cylinder_y2", service, rules, path)

                    class _box_center_z(PyArgumentsNumericalSubItem):
                        """
                        Specify the z-coordinate of the offset collar mesh.
                        """

                    class _cylinder_radius_1(PyArgumentsNumericalSubItem):
                        """
                        Argument cylinder_radius_1.
                        """

                    class _cylinder_z1(PyArgumentsNumericalSubItem):
                        """
                        Argument cylinder_z1.
                        """

                    class _box_center_x(PyArgumentsNumericalSubItem):
                        """
                        Specify the x-coordinate of the offset collar mesh.
                        """

                    class _cylinder_x1(PyArgumentsNumericalSubItem):
                        """
                        Argument cylinder_x1.
                        """

                    class _box_y_length(PyArgumentsNumericalSubItem):
                        """
                        Argument box_y_length.
                        """

                    class _box_z_length(PyArgumentsNumericalSubItem):
                        """
                        Argument box_z_length.
                        """

                    class _cylinder_z2(PyArgumentsNumericalSubItem):
                        """
                        Argument cylinder_z2.
                        """

                    class _box_center_y(PyArgumentsNumericalSubItem):
                        """
                        Specify the y-coordinate of the offset collar mesh.
                        """

                    class _cylinder_radius_2(PyArgumentsNumericalSubItem):
                        """
                        Argument cylinder_radius_2.
                        """

                    class _cylinder_y1(PyArgumentsNumericalSubItem):
                        """
                        Argument cylinder_y1.
                        """

                    class _box_x_length(PyArgumentsNumericalSubItem):
                        """
                        Argument box_x_length.
                        """

                    class _cylinder_x2(PyArgumentsNumericalSubItem):
                        """
                        Argument cylinder_x2.
                        """

                    class _cylinder_y2(PyArgumentsNumericalSubItem):
                        """
                        Argument cylinder_y2.
                        """

            def create_instance(self) -> _create_collar_meshArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_collar_meshArguments(*args)

        class create_component_mesh(PyCommand):
            """
            Use this task to create an overset component mesh. You can use various techniques, such as using an offset surface, a bounding box, or an existing object. 
                            More...
            Parameters
            ----------
            refinement_regions_name : str
                Specify a name for the component mesh or use the default value.
            creation_method : str
                Choose how you want to create the component mesh: either by using an offset surface, creating a bounding box, using an existing portion of the geometry, or by growing a boundary layer.
            boi_max_size : float
                Specify the maximum size of the elements for the component mesh.
            boi_size_name : str
            selection_type : str
                Choose how you want to make your selection (by object, label, or zone name).
            zone_selection_list : list[str]
                Choose one or more zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_location : list[str]
            label_selection_list : list[str]
                Select one or more labels that will make up the component mesh. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            object_selection_list : list[str]
                Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_selection_single : list[str]
                Choose a single zone from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            object_selection_single : list[str]
                Choose a single object from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            topology_list : list[str]
            bounding_box_object : dict[str, Any]
                View the extents of the bounding box.
            offset_object : dict[str, Any]
            cylinder_method : str
            cylinder_object : dict[str, Any]
            axis : dict[str, Any]
            volume_fill : str
                Specify the type of mesh cell to use to fill the component mesh. Available options are tetrahedral, hexcore, poly, or poly-hexcore. .
            cylinder_length : float
            geometry_tools_properties : dict[str, Any]

            Returns
            -------
            bool
            """
            class _create_component_meshArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.refinement_regions_name = self._refinement_regions_name(self, "refinement_regions_name", service, rules, path)
                    self.creation_method = self._creation_method(self, "creation_method", service, rules, path)
                    self.boi_max_size = self._boi_max_size(self, "boi_max_size", service, rules, path)
                    self.boi_size_name = self._boi_size_name(self, "boi_size_name", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.zone_selection_list = self._zone_selection_list(self, "zone_selection_list", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.label_selection_list = self._label_selection_list(self, "label_selection_list", service, rules, path)
                    self.object_selection_list = self._object_selection_list(self, "object_selection_list", service, rules, path)
                    self.zone_selection_single = self._zone_selection_single(self, "zone_selection_single", service, rules, path)
                    self.object_selection_single = self._object_selection_single(self, "object_selection_single", service, rules, path)
                    self.topology_list = self._topology_list(self, "topology_list", service, rules, path)
                    self.bounding_box_object = self._bounding_box_object(self, "bounding_box_object", service, rules, path)
                    self.offset_object = self._offset_object(self, "offset_object", service, rules, path)
                    self.cylinder_method = self._cylinder_method(self, "cylinder_method", service, rules, path)
                    self.cylinder_object = self._cylinder_object(self, "cylinder_object", service, rules, path)
                    self.axis = self._axis(self, "axis", service, rules, path)
                    self.volume_fill = self._volume_fill(self, "volume_fill", service, rules, path)
                    self.cylinder_length = self._cylinder_length(self, "cylinder_length", service, rules, path)
                    self.geometry_tools_properties = self._geometry_tools_properties(self, "geometry_tools_properties", service, rules, path)

                class _refinement_regions_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the component mesh or use the default value.
                    """

                class _creation_method(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to create the component mesh: either by using an offset surface, creating a bounding box, using an existing portion of the geometry, or by growing a boundary layer.
                    """

                class _boi_max_size(PyArgumentsNumericalSubItem):
                    """
                    Specify the maximum size of the elements for the component mesh.
                    """

                class _boi_size_name(PyArgumentsTextualSubItem):
                    """
                    Argument boi_size_name.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to make your selection (by object, label, or zone name).
                    """

                class _zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _label_selection_list(PyArgumentsTextualSubItem):
                    """
                    Select one or more labels that will make up the component mesh. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_selection_single(PyArgumentsTextualSubItem):
                    """
                    Choose a single zone from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _object_selection_single(PyArgumentsTextualSubItem):
                    """
                    Choose a single object from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _topology_list(PyArgumentsTextualSubItem):
                    """
                    Argument topology_list.
                    """

                class _bounding_box_object(PyArgumentsSingletonSubItem):
                    """
                    View the extents of the bounding box.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.zmax = self._zmax(self, "zmax", service, rules, path)
                        self.ymax = self._ymax(self, "ymax", service, rules, path)
                        self.size_relative_length = self._size_relative_length(self, "size_relative_length", service, rules, path)
                        self.xmax_ratio = self._xmax_ratio(self, "xmax_ratio", service, rules, path)
                        self.zmax_ratio = self._zmax_ratio(self, "zmax_ratio", service, rules, path)
                        self.ymin_ratio = self._ymin_ratio(self, "ymin_ratio", service, rules, path)
                        self.zmin_ratio = self._zmin_ratio(self, "zmin_ratio", service, rules, path)
                        self.xmin_ratio = self._xmin_ratio(self, "xmin_ratio", service, rules, path)
                        self.xmin = self._xmin(self, "xmin", service, rules, path)
                        self.zmin = self._zmin(self, "zmin", service, rules, path)
                        self.ymin = self._ymin(self, "ymin", service, rules, path)
                        self.xmax = self._xmax(self, "xmax", service, rules, path)
                        self.ymax_ratio = self._ymax_ratio(self, "ymax_ratio", service, rules, path)

                    class _zmax(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the Z direction by the specified value.
                        """

                    class _ymax(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the Y direction by the specified value.
                        """

                    class _size_relative_length(PyArgumentsTextualSubItem):
                        """
                        Determine if you would like to specify the bounding box for the component mesh as a ratio of the geometry length, or by specifying a specific location for the minimum and maximum coordinates.
                        """

                    class _xmax_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the X direction by the specified value. The value is the ratio relative to the geometry size in the X direction.
                        """

                    class _zmax_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the Z direction by the specified value. The value is the ratio relative to the geometry size in the Z direction.
                        """

                    class _ymin_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the Y direction by the specified value. The value is the ratio relative to the geometry size in the Y direction.
                        """

                    class _zmin_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the Z direction by the specified value. The value is the ratio relative to the geometry size in the Z direction.
                        """

                    class _xmin_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the X direction by the specified value. The value is the ratio relative to the geometry size in the X direction.
                        """

                    class _xmin(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the X direction by the specified value.
                        """

                    class _zmin(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the Z direction by the specified value.
                        """

                    class _ymin(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the Y direction by the specified value.
                        """

                    class _xmax(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the X direction by the specified value.
                        """

                    class _ymax_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the Y direction by the specified value. The value is the ratio relative to the geometry size in the Y direction.
                        """

                class _offset_object(PyArgumentsSingletonSubItem):
                    """
                    Argument offset_object.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.y = self._y(self, "y", service, rules, path)
                        self.rate = self._rate(self, "rate", service, rules, path)
                        self.boundary_layer_height = self._boundary_layer_height(self, "boundary_layer_height", service, rules, path)
                        self.flip_direction = self._flip_direction(self, "flip_direction", service, rules, path)
                        self.first_height = self._first_height(self, "first_height", service, rules, path)
                        self.mpt_method_type = self._mpt_method_type(self, "mpt_method_type", service, rules, path)
                        self.wake_growth_factor = self._wake_growth_factor(self, "wake_growth_factor", service, rules, path)
                        self.defeaturing_size = self._defeaturing_size(self, "defeaturing_size", service, rules, path)
                        self.aspect_ratio = self._aspect_ratio(self, "aspect_ratio", service, rules, path)
                        self.number_of_layers = self._number_of_layers(self, "number_of_layers", service, rules, path)
                        self.z = self._z(self, "z", service, rules, path)
                        self.offset_method_type = self._offset_method_type(self, "offset_method_type", service, rules, path)
                        self.x = self._x(self, "x", service, rules, path)
                        self.wake_levels = self._wake_levels(self, "wake_levels", service, rules, path)
                        self.boundary_layer_levels = self._boundary_layer_levels(self, "boundary_layer_levels", service, rules, path)
                        self.last_ratio_percentage = self._last_ratio_percentage(self, "last_ratio_percentage", service, rules, path)
                        self.flow_direction = self._flow_direction(self, "flow_direction", service, rules, path)
                        self.edge_selection_list = self._edge_selection_list(self, "edge_selection_list", service, rules, path)
                        self.show_coordinates = self._show_coordinates(self, "show_coordinates", service, rules, path)
                        self.cross_wake_growth_factor = self._cross_wake_growth_factor(self, "cross_wake_growth_factor", service, rules, path)

                    class _y(PyArgumentsNumericalSubItem):
                        """
                        Argument y.
                        """

                    class _rate(PyArgumentsNumericalSubItem):
                        """
                        Specify the rate of growth of the boundary layer.
                        """

                    class _boundary_layer_height(PyArgumentsNumericalSubItem):
                        """
                        Specify the total height of the boundary layer for this refinement region (this is flow in the vicinity).
                        """

                    class _flip_direction(PyArgumentsParameterSubItem):
                        """
                        Argument flip_direction.
                        """

                    class _first_height(PyArgumentsNumericalSubItem):
                        """
                        Specify the height of the first layer of cells in the boundary layer.
                        """

                    class _mpt_method_type(PyArgumentsTextualSubItem):
                        """
                        Argument mpt_method_type.
                        """

                    class _wake_growth_factor(PyArgumentsNumericalSubItem):
                        """
                        Argument wake_growth_factor.
                        """

                    class _defeaturing_size(PyArgumentsNumericalSubItem):
                        """
                        Argument defeaturing_size.
                        """

                    class _aspect_ratio(PyArgumentsNumericalSubItem):
                        """
                        Specify the ratio of the prism base length to the prism layer height.
                        """

                    class _number_of_layers(PyArgumentsNumericalSubItem):
                        """
                        Select the number of boundary layers to be generated.
                        """

                    class _z(PyArgumentsNumericalSubItem):
                        """
                        Argument z.
                        """

                    class _offset_method_type(PyArgumentsTextualSubItem):
                        """
                        Choose the method that will be used to create the boundary layer, or prism, controls.
                        """

                    class _x(PyArgumentsNumericalSubItem):
                        """
                        Argument x.
                        """

                    class _wake_levels(PyArgumentsNumericalSubItem):
                        """
                        Argument wake_levels.
                        """

                    class _boundary_layer_levels(PyArgumentsNumericalSubItem):
                        """
                        Argument boundary_layer_levels.
                        """

                    class _last_ratio_percentage(PyArgumentsNumericalSubItem):
                        """
                        Specify the offset height of the last layer as a percentage of the local base mesh size.
                        """

                    class _flow_direction(PyArgumentsTextualSubItem):
                        """
                        Argument flow_direction.
                        """

                    class _edge_selection_list(PyArgumentsTextualSubItem):
                        """
                        Argument edge_selection_list.
                        """

                    class _show_coordinates(PyArgumentsParameterSubItem):
                        """
                        Argument show_coordinates.
                        """

                    class _cross_wake_growth_factor(PyArgumentsNumericalSubItem):
                        """
                        Argument cross_wake_growth_factor.
                        """

                class _cylinder_method(PyArgumentsTextualSubItem):
                    """
                    Argument cylinder_method.
                    """

                class _cylinder_object(PyArgumentsSingletonSubItem):
                    """
                    Argument cylinder_object.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.node_2 = self._node_2(self, "node_2", service, rules, path)
                        self.node_3 = self._node_3(self, "node_3", service, rules, path)
                        self.x2 = self._x2(self, "x2", service, rules, path)
                        self.x_offset = self._x_offset(self, "x_offset", service, rules, path)
                        self.x1 = self._x1(self, "x1", service, rules, path)
                        self.height_back_inc = self._height_back_inc(self, "height_back_inc", service, rules, path)
                        self.height_front_inc = self._height_front_inc(self, "height_front_inc", service, rules, path)
                        self.height_node = self._height_node(self, "height_node", service, rules, path)
                        self.z_offset = self._z_offset(self, "z_offset", service, rules, path)
                        self.z1 = self._z1(self, "z1", service, rules, path)
                        self.node_1 = self._node_1(self, "node_1", service, rules, path)
                        self.y_offset = self._y_offset(self, "y_offset", service, rules, path)
                        self.z2 = self._z2(self, "z2", service, rules, path)
                        self.radius_2 = self._radius_2(self, "radius_2", service, rules, path)
                        self.radius_1 = self._radius_1(self, "radius_1", service, rules, path)
                        self.y1 = self._y1(self, "y1", service, rules, path)
                        self.y2 = self._y2(self, "y2", service, rules, path)

                    class _node_2(PyArgumentsTextualSubItem):
                        """
                        Argument node_2.
                        """

                    class _node_3(PyArgumentsTextualSubItem):
                        """
                        Argument node_3.
                        """

                    class _x2(PyArgumentsNumericalSubItem):
                        """
                        Argument x2.
                        """

                    class _x_offset(PyArgumentsNumericalSubItem):
                        """
                        Argument x_offset.
                        """

                    class _x1(PyArgumentsNumericalSubItem):
                        """
                        Argument x1.
                        """

                    class _height_back_inc(PyArgumentsNumericalSubItem):
                        """
                        Argument height_back_inc.
                        """

                    class _height_front_inc(PyArgumentsNumericalSubItem):
                        """
                        Argument height_front_inc.
                        """

                    class _height_node(PyArgumentsTextualSubItem):
                        """
                        Argument height_node.
                        """

                    class _z_offset(PyArgumentsNumericalSubItem):
                        """
                        Argument z_offset.
                        """

                    class _z1(PyArgumentsNumericalSubItem):
                        """
                        Argument z1.
                        """

                    class _node_1(PyArgumentsTextualSubItem):
                        """
                        Argument node_1.
                        """

                    class _y_offset(PyArgumentsNumericalSubItem):
                        """
                        Argument y_offset.
                        """

                    class _z2(PyArgumentsNumericalSubItem):
                        """
                        Argument z2.
                        """

                    class _radius_2(PyArgumentsNumericalSubItem):
                        """
                        Argument radius_2.
                        """

                    class _radius_1(PyArgumentsNumericalSubItem):
                        """
                        Argument radius_1.
                        """

                    class _y1(PyArgumentsNumericalSubItem):
                        """
                        Argument y1.
                        """

                    class _y2(PyArgumentsNumericalSubItem):
                        """
                        Argument y2.
                        """

                class _axis(PyArgumentsSingletonSubItem):
                    """
                    Argument axis.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.z_component = self._z_component(self, "z_component", service, rules, path)
                        self.y_component = self._y_component(self, "y_component", service, rules, path)
                        self.x_component = self._x_component(self, "x_component", service, rules, path)

                    class _z_component(PyArgumentsNumericalSubItem):
                        """
                        Argument z_component.
                        """

                    class _y_component(PyArgumentsNumericalSubItem):
                        """
                        Argument y_component.
                        """

                    class _x_component(PyArgumentsNumericalSubItem):
                        """
                        Argument x_component.
                        """

                class _volume_fill(PyArgumentsTextualSubItem):
                    """
                    Specify the type of mesh cell to use to fill the component mesh. Available options are tetrahedral, hexcore, poly, or poly-hexcore. .
                    """

                class _cylinder_length(PyArgumentsNumericalSubItem):
                    """
                    Argument cylinder_length.
                    """

                class _geometry_tools_properties(PyArgumentsSingletonSubItem):
                    """
                    Argument geometry_tools_properties.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.box_center_z = self._box_center_z(self, "box_center_z", service, rules, path)
                        self.cylinder_radius_1 = self._cylinder_radius_1(self, "cylinder_radius_1", service, rules, path)
                        self.cylinder_z1 = self._cylinder_z1(self, "cylinder_z1", service, rules, path)
                        self.box_center_x = self._box_center_x(self, "box_center_x", service, rules, path)
                        self.cylinder_x1 = self._cylinder_x1(self, "cylinder_x1", service, rules, path)
                        self.box_y_length = self._box_y_length(self, "box_y_length", service, rules, path)
                        self.box_z_length = self._box_z_length(self, "box_z_length", service, rules, path)
                        self.cylinder_z2 = self._cylinder_z2(self, "cylinder_z2", service, rules, path)
                        self.box_x_length = self._box_x_length(self, "box_x_length", service, rules, path)
                        self.cylinder_radius_2 = self._cylinder_radius_2(self, "cylinder_radius_2", service, rules, path)
                        self.cylinder_y1 = self._cylinder_y1(self, "cylinder_y1", service, rules, path)
                        self.box_center_y = self._box_center_y(self, "box_center_y", service, rules, path)
                        self.cylinder_x2 = self._cylinder_x2(self, "cylinder_x2", service, rules, path)
                        self.cylinder_y2 = self._cylinder_y2(self, "cylinder_y2", service, rules, path)

                    class _box_center_z(PyArgumentsNumericalSubItem):
                        """
                        Argument box_center_z.
                        """

                    class _cylinder_radius_1(PyArgumentsNumericalSubItem):
                        """
                        Argument cylinder_radius_1.
                        """

                    class _cylinder_z1(PyArgumentsNumericalSubItem):
                        """
                        Argument cylinder_z1.
                        """

                    class _box_center_x(PyArgumentsNumericalSubItem):
                        """
                        Argument box_center_x.
                        """

                    class _cylinder_x1(PyArgumentsNumericalSubItem):
                        """
                        Argument cylinder_x1.
                        """

                    class _box_y_length(PyArgumentsNumericalSubItem):
                        """
                        Argument box_y_length.
                        """

                    class _box_z_length(PyArgumentsNumericalSubItem):
                        """
                        Argument box_z_length.
                        """

                    class _cylinder_z2(PyArgumentsNumericalSubItem):
                        """
                        Argument cylinder_z2.
                        """

                    class _box_x_length(PyArgumentsNumericalSubItem):
                        """
                        Argument box_x_length.
                        """

                    class _cylinder_radius_2(PyArgumentsNumericalSubItem):
                        """
                        Argument cylinder_radius_2.
                        """

                    class _cylinder_y1(PyArgumentsNumericalSubItem):
                        """
                        Argument cylinder_y1.
                        """

                    class _box_center_y(PyArgumentsNumericalSubItem):
                        """
                        Argument box_center_y.
                        """

                    class _cylinder_x2(PyArgumentsNumericalSubItem):
                        """
                        Argument cylinder_x2.
                        """

                    class _cylinder_y2(PyArgumentsNumericalSubItem):
                        """
                        Argument cylinder_y2.
                        """

            def create_instance(self) -> _create_component_meshArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_component_meshArguments(*args)

        class create_contact_patch(PyCommand):
            """
            This task will create patches in and around any problematic, sharp-angle contact areas (such as between a tire and the road surface) in order to avoid such areas during the meshing process. More...
            Parameters
            ----------
            contact_patch_name : str
                Specify a name for the contact patch object, or retain the default name.
            selection_type : str
                Choose how you want to make your selection (for instance, by object, zone, or label).
            zone_selection_list : list[str]
                Choose one or more face zones from the list below that represent the contact source. Use the Filter Text field to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_location : list[str]
            object_selection_list : list[str]
                Choose an object from the list below that represent the contact source. Use the Filter Text field to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            label_selection_list : list[str]
                Select one or more labels that represent the contact source. Use the Filter Text field to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            ground_zone_selection_list : list[str]
                Choose one or more face zones from the list below that represent the contact target (for instance, the ground face zone in an enclosing bounding box for a tire-ground contact scenario).
            distance : float
                Specify the distance of the contact patch geometry from the ground zone, or the thickness of the contact patch.
            contact_patch_defeaturing_size : float
                Allows you to control the smoothness of the contact patch. With the default value of 0, no smoothing takes place. With a value greater than 0, the patch is defeatured to create a smooth patch. This will lead to better quality volume mesh at the contact, for instance, between the tire and the ground.
            feature_angle : float
                Specify a value for the angle used to extract feature edges on the contact patch object.
            patch_hole : bool
                Indicate whether you want the contact patch object to be filled or not.
            flip_direction : bool
                Use this option to switch the direction/orientation of the contact patch.

            Returns
            -------
            bool
            """
            class _create_contact_patchArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.contact_patch_name = self._contact_patch_name(self, "contact_patch_name", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.zone_selection_list = self._zone_selection_list(self, "zone_selection_list", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.object_selection_list = self._object_selection_list(self, "object_selection_list", service, rules, path)
                    self.label_selection_list = self._label_selection_list(self, "label_selection_list", service, rules, path)
                    self.ground_zone_selection_list = self._ground_zone_selection_list(self, "ground_zone_selection_list", service, rules, path)
                    self.distance = self._distance(self, "distance", service, rules, path)
                    self.contact_patch_defeaturing_size = self._contact_patch_defeaturing_size(self, "contact_patch_defeaturing_size", service, rules, path)
                    self.feature_angle = self._feature_angle(self, "feature_angle", service, rules, path)
                    self.patch_hole = self._patch_hole(self, "patch_hole", service, rules, path)
                    self.flip_direction = self._flip_direction(self, "flip_direction", service, rules, path)

                class _contact_patch_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the contact patch object, or retain the default name.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to make your selection (for instance, by object, zone, or label).
                    """

                class _zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zones from the list below that represent the contact source. Use the Filter Text field to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose an object from the list below that represent the contact source. Use the Filter Text field to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _label_selection_list(PyArgumentsTextualSubItem):
                    """
                    Select one or more labels that represent the contact source. Use the Filter Text field to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _ground_zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zones from the list below that represent the contact target (for instance, the ground face zone in an enclosing bounding box for a tire-ground contact scenario).
                    """

                class _distance(PyArgumentsNumericalSubItem):
                    """
                    Specify the distance of the contact patch geometry from the ground zone, or the thickness of the contact patch.
                    """

                class _contact_patch_defeaturing_size(PyArgumentsNumericalSubItem):
                    """
                    Allows you to control the smoothness of the contact patch. With the default value of 0, no smoothing takes place. With a value greater than 0, the patch is defeatured to create a smooth patch. This will lead to better quality volume mesh at the contact, for instance, between the tire and the ground.
                    """

                class _feature_angle(PyArgumentsNumericalSubItem):
                    """
                    Specify a value for the angle used to extract feature edges on the contact patch object.
                    """

                class _patch_hole(PyArgumentsParameterSubItem):
                    """
                    Indicate whether you want the contact patch object to be filled or not.
                    """

                class _flip_direction(PyArgumentsParameterSubItem):
                    """
                    Use this option to switch the direction/orientation of the contact patch.
                    """

            def create_instance(self) -> _create_contact_patchArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_contact_patchArguments(*args)

        class create_external_flow_boundaries(PyCommand):
            """
            Create an enclosure, or a bounding box, around the geometry, or use a pre-existing object from the CAD model to represent the enclosure. This enclosure will represent the external flow region, whose bounds can be specified as a ratio of geometry size, or as specific minimum and maximum coordinates. More...
            Parameters
            ----------
            external_boundaries_name : str
                Enter a name for the external flow boundary or use the default value.
            creation_method : str
                Choose how you want to create the external flow boundary: either by creating a new boundary using a bounding box, or use an existing portion of the geometry.
            extraction_method : str
                Choose whether you would like to extract the external flow region either as a surface mesh object (a direct surface remesh of the object) a wrap, or an existing mesh (for overset components). The object setting is applied later when generating the surface mesh.
            selection_type : str
                Choose how you want to make your selection (by object, label, or zone name).
            object_selection_list : list[str]
                Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_selection_list : list[str]
                Choose one or more zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_location : list[str]
            label_selection_list : list[str]
                Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            object_selection_single : list[str]
                Choose a single object from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_selection_single : list[str]
                Choose a single zone from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            label_selection_single : list[str]
                Choose a single label from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            original_object_name : str
            bounding_box_object : dict[str, Any]
                View the extents of the bounding box.

            Returns
            -------
            bool
            """
            class _create_external_flow_boundariesArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.external_boundaries_name = self._external_boundaries_name(self, "external_boundaries_name", service, rules, path)
                    self.creation_method = self._creation_method(self, "creation_method", service, rules, path)
                    self.extraction_method = self._extraction_method(self, "extraction_method", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.object_selection_list = self._object_selection_list(self, "object_selection_list", service, rules, path)
                    self.zone_selection_list = self._zone_selection_list(self, "zone_selection_list", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.label_selection_list = self._label_selection_list(self, "label_selection_list", service, rules, path)
                    self.object_selection_single = self._object_selection_single(self, "object_selection_single", service, rules, path)
                    self.zone_selection_single = self._zone_selection_single(self, "zone_selection_single", service, rules, path)
                    self.label_selection_single = self._label_selection_single(self, "label_selection_single", service, rules, path)
                    self.original_object_name = self._original_object_name(self, "original_object_name", service, rules, path)
                    self.bounding_box_object = self._bounding_box_object(self, "bounding_box_object", service, rules, path)

                class _external_boundaries_name(PyArgumentsTextualSubItem):
                    """
                    Enter a name for the external flow boundary or use the default value.
                    """

                class _creation_method(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to create the external flow boundary: either by creating a new boundary using a bounding box, or use an existing portion of the geometry.
                    """

                class _extraction_method(PyArgumentsTextualSubItem):
                    """
                    Choose whether you would like to extract the external flow region either as a surface mesh object (a direct surface remesh of the object) a wrap, or an existing mesh (for overset components). The object setting is applied later when generating the surface mesh.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to make your selection (by object, label, or zone name).
                    """

                class _object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _label_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _object_selection_single(PyArgumentsTextualSubItem):
                    """
                    Choose a single object from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_selection_single(PyArgumentsTextualSubItem):
                    """
                    Choose a single zone from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _label_selection_single(PyArgumentsTextualSubItem):
                    """
                    Choose a single label from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _original_object_name(PyArgumentsTextualSubItem):
                    """
                    Argument original_object_name.
                    """

                class _bounding_box_object(PyArgumentsSingletonSubItem):
                    """
                    View the extents of the bounding box.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.zmax = self._zmax(self, "zmax", service, rules, path)
                        self.xmin_ratio = self._xmin_ratio(self, "xmin_ratio", service, rules, path)
                        self.size_relative_length = self._size_relative_length(self, "size_relative_length", service, rules, path)
                        self.ymax_ratio = self._ymax_ratio(self, "ymax_ratio", service, rules, path)
                        self.zmax_ratio = self._zmax_ratio(self, "zmax_ratio", service, rules, path)
                        self.ymin_ratio = self._ymin_ratio(self, "ymin_ratio", service, rules, path)
                        self.zmin_ratio = self._zmin_ratio(self, "zmin_ratio", service, rules, path)
                        self.xmax_ratio = self._xmax_ratio(self, "xmax_ratio", service, rules, path)
                        self.xmin = self._xmin(self, "xmin", service, rules, path)
                        self.zmin = self._zmin(self, "zmin", service, rules, path)
                        self.ymin = self._ymin(self, "ymin", service, rules, path)
                        self.xmax = self._xmax(self, "xmax", service, rules, path)
                        self.ymax = self._ymax(self, "ymax", service, rules, path)

                    class _zmax(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the Z direction by the specified value.
                        """

                    class _xmin_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the X direction by the specified value. The value is the ratio relative to the geometry size in the X direction.
                        """

                    class _size_relative_length(PyArgumentsTextualSubItem):
                        """
                        Determine if you would like to specify the bounding box as a ratio of the geometry length, or by specifying a specific location for the minimum and maximum coordinates.
                        """

                    class _ymax_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the Y direction by the specified value. The value is the ratio relative to the geometry size in the Y direction.
                        """

                    class _zmax_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the Z direction by the specified value. The value is the ratio relative to the geometry size in the Z direction.
                        """

                    class _ymin_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the Y direction by the specified value. The value is the ratio relative to the geometry size in the Y direction.
                        """

                    class _zmin_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the Z direction by the specified value. The value is the ratio relative to the geometry size in the Z direction.
                        """

                    class _xmax_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the X direction by the specified value. The value is the ratio relative to the geometry size in the X direction.
                        """

                    class _xmin(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the X direction by the specified value.
                        """

                    class _zmin(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the Z direction by the specified value.
                        """

                    class _ymin(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the Y direction by the specified value.
                        """

                    class _xmax(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the X direction by the specified value.
                        """

                    class _ymax(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the Y direction by the specified value.
                        """

            def create_instance(self) -> _create_external_flow_boundariesArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_external_flow_boundariesArguments(*args)

        class create_gap_cover(PyCommand):
            """
            This task will cover any gaps within a selected object. Recommended with geometries containing noticeable gaps and openings that need to be covered prior to surface meshing. More...
            Parameters
            ----------
            gap_cover_name : str
                Specify a name for the gap cover object, or retain the default name.
            sizing_method : str
                Determine the method for specifying the gap cover sizing controls. The Wrapper Based on Size Field option uses the size field control settings defined in the Choose Mesh Controls task. Using the Uniform Wrapper option requires you to provide a value for the Max Gap Size. If this task is located at a point in the workflow prior to the Choose Mesh Control Options task, then only the Uniform Wrapper option is available.
            gap_size_ratio : float
                Specify a value for the gap size factor that, when multiplied by the local initial size field, corresponds to the size of the gap that needs to be covered.
            gap_size : float
                A specified maximum width for the gap.
            selection_type : str
                Choose how you want to make your selection (for instance, by object name, zone name, or label name).
            zone_selection_list : list[str]
                Choose one or more face zones from the list below that represent the contact source. Use the Filter Text field to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_location : list[str]
            label_selection_list : list[str]
                Select one or more labels that represent the contact source. Use the Filter Text field to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            object_selection_list : list[str]
                Choose an object from the list below that represent the contact source. Use the Filter Text field to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            gap_cover_between_zones : bool
                Determine if you only want to cover gaps between boundary zones (Yes), or if you want to cover all gaps within and between boundary zones (No)
            gap_cover_refine_factor : float
                Allows you to control the resolution of the gap cover size based on a scaling of the Max Gap Size (or Max Gap Size Factor). It ranges from 0.0625 to 1 with a default value of 1.0). The higher the Resolution Factor, the more likely that some gaps may not be fully covered. Depending on the gap in question, lowering the Resolution Factor reduces the wrapper to sufficiently cover the gap in most cases.
            gap_cover_refine_factor_at_gap : float
                Allows you to specify the level of refinement for the gap-cover (patch). Decreasing the value increases the refinement of the patch.
            refine_wrapper_before_projection : bool
            advanced_options : bool
                Display advanced options that you may want to apply to the task.
            max_island_face_for_gap_cover : int
                Specify the maximum face count required for isolated areas (islands) to be created during surface mesh generation. Any islands that have a face count smaller than this value will be removed, and only larger islands will remain.
            gap_cover_feature_imprint : bool
                Use this option to better define gap coverings. When this option is set to Yes, the gap covers are more accurate. Once the coarse wrap closes any gaps, this option also snaps the nodes of the wrapper onto all previously defined edge features to more closely cover the gaps. Setting this option to Yes, however, can be computationally expensive when modeling large vehicles (such as in aerospace), thus, the default is No.  Here, when set to No, wrapper faces at the corners are not on the geometry and are incorrectly marked as a gap. When set to Yes, only wrap faces at the gap are marked.

            Returns
            -------
            bool
            """
            class _create_gap_coverArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.gap_cover_name = self._gap_cover_name(self, "gap_cover_name", service, rules, path)
                    self.sizing_method = self._sizing_method(self, "sizing_method", service, rules, path)
                    self.gap_size_ratio = self._gap_size_ratio(self, "gap_size_ratio", service, rules, path)
                    self.gap_size = self._gap_size(self, "gap_size", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.zone_selection_list = self._zone_selection_list(self, "zone_selection_list", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.label_selection_list = self._label_selection_list(self, "label_selection_list", service, rules, path)
                    self.object_selection_list = self._object_selection_list(self, "object_selection_list", service, rules, path)
                    self.gap_cover_between_zones = self._gap_cover_between_zones(self, "gap_cover_between_zones", service, rules, path)
                    self.gap_cover_refine_factor = self._gap_cover_refine_factor(self, "gap_cover_refine_factor", service, rules, path)
                    self.gap_cover_refine_factor_at_gap = self._gap_cover_refine_factor_at_gap(self, "gap_cover_refine_factor_at_gap", service, rules, path)
                    self.refine_wrapper_before_projection = self._refine_wrapper_before_projection(self, "refine_wrapper_before_projection", service, rules, path)
                    self.advanced_options = self._advanced_options(self, "advanced_options", service, rules, path)
                    self.max_island_face_for_gap_cover = self._max_island_face_for_gap_cover(self, "max_island_face_for_gap_cover", service, rules, path)
                    self.gap_cover_feature_imprint = self._gap_cover_feature_imprint(self, "gap_cover_feature_imprint", service, rules, path)

                class _gap_cover_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the gap cover object, or retain the default name.
                    """

                class _sizing_method(PyArgumentsTextualSubItem):
                    """
                    Determine the method for specifying the gap cover sizing controls. The Wrapper Based on Size Field option uses the size field control settings defined in the Choose Mesh Controls task. Using the Uniform Wrapper option requires you to provide a value for the Max Gap Size. If this task is located at a point in the workflow prior to the Choose Mesh Control Options task, then only the Uniform Wrapper option is available.
                    """

                class _gap_size_ratio(PyArgumentsNumericalSubItem):
                    """
                    Specify a value for the gap size factor that, when multiplied by the local initial size field, corresponds to the size of the gap that needs to be covered.
                    """

                class _gap_size(PyArgumentsNumericalSubItem):
                    """
                    A specified maximum width for the gap.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to make your selection (for instance, by object name, zone name, or label name).
                    """

                class _zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zones from the list below that represent the contact source. Use the Filter Text field to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _label_selection_list(PyArgumentsTextualSubItem):
                    """
                    Select one or more labels that represent the contact source. Use the Filter Text field to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose an object from the list below that represent the contact source. Use the Filter Text field to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _gap_cover_between_zones(PyArgumentsParameterSubItem):
                    """
                    Determine if you only want to cover gaps between boundary zones (Yes), or if you want to cover all gaps within and between boundary zones (No)
                    """

                class _gap_cover_refine_factor(PyArgumentsNumericalSubItem):
                    """
                    Allows you to control the resolution of the gap cover size based on a scaling of the Max Gap Size (or Max Gap Size Factor). It ranges from 0.0625 to 1 with a default value of 1.0). The higher the Resolution Factor, the more likely that some gaps may not be fully covered. Depending on the gap in question, lowering the Resolution Factor reduces the wrapper to sufficiently cover the gap in most cases.
                    """

                class _gap_cover_refine_factor_at_gap(PyArgumentsNumericalSubItem):
                    """
                    Allows you to specify the level of refinement for the gap-cover (patch). Decreasing the value increases the refinement of the patch.
                    """

                class _refine_wrapper_before_projection(PyArgumentsParameterSubItem):
                    """
                    Argument refine_wrapper_before_projection.
                    """

                class _advanced_options(PyArgumentsParameterSubItem):
                    """
                    Display advanced options that you may want to apply to the task.
                    """

                class _max_island_face_for_gap_cover(PyArgumentsNumericalSubItem):
                    """
                    Specify the maximum face count required for isolated areas (islands) to be created during surface mesh generation. Any islands that have a face count smaller than this value will be removed, and only larger islands will remain.
                    """

                class _gap_cover_feature_imprint(PyArgumentsParameterSubItem):
                    """
                    Use this option to better define gap coverings. When this option is set to Yes, the gap covers are more accurate. Once the coarse wrap closes any gaps, this option also snaps the nodes of the wrapper onto all previously defined edge features to more closely cover the gaps. Setting this option to Yes, however, can be computationally expensive when modeling large vehicles (such as in aerospace), thus, the default is No.  Here, when set to No, wrapper faces at the corners are not on the geometry and are incorrectly marked as a gap. When set to Yes, only wrap faces at the gap are marked.
                    """

            def create_instance(self) -> _create_gap_coverArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_gap_coverArguments(*args)

        class create_group(PyCommand):
            """
            Command create_group.

            Parameters
            ----------
            new_group_name : str
            selection_type : str
            topology_list : list[str]

            Returns
            -------
            bool
            """
            class _create_groupArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.new_group_name = self._new_group_name(self, "new_group_name", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.topology_list = self._topology_list(self, "topology_list", service, rules, path)

                class _new_group_name(PyArgumentsTextualSubItem):
                    """
                    Argument new_group_name.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Argument selection_type.
                    """

                class _topology_list(PyArgumentsTextualSubItem):
                    """
                    Argument topology_list.
                    """

            def create_instance(self) -> _create_groupArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_groupArguments(*args)

        class create_leak_shield(PyCommand):
            """
            Command create_leak_shield.

            Parameters
            ----------
            leak_shield_name : str
            use_size_field : str
            size_field_file_name : str
            min_hole_size : float
            max_hole_size : float
            specify_obj : bool
            specify_live : bool
            specify_dead : bool
            object_selection_list : list[str]
            live_mpt_selection_list : list[str]
            dead_regions_list : list[str]
            patch_at_live : bool
            prompt_for_cleanup : bool
            merge_patches : bool

            Returns
            -------
            bool
            """
            class _create_leak_shieldArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.leak_shield_name = self._leak_shield_name(self, "leak_shield_name", service, rules, path)
                    self.use_size_field = self._use_size_field(self, "use_size_field", service, rules, path)
                    self.size_field_file_name = self._size_field_file_name(self, "size_field_file_name", service, rules, path)
                    self.min_hole_size = self._min_hole_size(self, "min_hole_size", service, rules, path)
                    self.max_hole_size = self._max_hole_size(self, "max_hole_size", service, rules, path)
                    self.specify_obj = self._specify_obj(self, "specify_obj", service, rules, path)
                    self.specify_live = self._specify_live(self, "specify_live", service, rules, path)
                    self.specify_dead = self._specify_dead(self, "specify_dead", service, rules, path)
                    self.object_selection_list = self._object_selection_list(self, "object_selection_list", service, rules, path)
                    self.live_mpt_selection_list = self._live_mpt_selection_list(self, "live_mpt_selection_list", service, rules, path)
                    self.dead_regions_list = self._dead_regions_list(self, "dead_regions_list", service, rules, path)
                    self.patch_at_live = self._patch_at_live(self, "patch_at_live", service, rules, path)
                    self.prompt_for_cleanup = self._prompt_for_cleanup(self, "prompt_for_cleanup", service, rules, path)
                    self.merge_patches = self._merge_patches(self, "merge_patches", service, rules, path)

                class _leak_shield_name(PyArgumentsTextualSubItem):
                    """
                    Argument leak_shield_name.
                    """

                class _use_size_field(PyArgumentsTextualSubItem):
                    """
                    Argument use_size_field.
                    """

                class _size_field_file_name(PyArgumentsTextualSubItem):
                    """
                    Argument size_field_file_name.
                    """

                class _min_hole_size(PyArgumentsNumericalSubItem):
                    """
                    Argument min_hole_size.
                    """

                class _max_hole_size(PyArgumentsNumericalSubItem):
                    """
                    Argument max_hole_size.
                    """

                class _specify_obj(PyArgumentsParameterSubItem):
                    """
                    Argument specify_obj.
                    """

                class _specify_live(PyArgumentsParameterSubItem):
                    """
                    Argument specify_live.
                    """

                class _specify_dead(PyArgumentsParameterSubItem):
                    """
                    Argument specify_dead.
                    """

                class _object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Argument object_selection_list.
                    """

                class _live_mpt_selection_list(PyArgumentsTextualSubItem):
                    """
                    Argument live_mpt_selection_list.
                    """

                class _dead_regions_list(PyArgumentsTextualSubItem):
                    """
                    Argument dead_regions_list.
                    """

                class _patch_at_live(PyArgumentsParameterSubItem):
                    """
                    Argument patch_at_live.
                    """

                class _prompt_for_cleanup(PyArgumentsParameterSubItem):
                    """
                    Argument prompt_for_cleanup.
                    """

                class _merge_patches(PyArgumentsParameterSubItem):
                    """
                    Argument merge_patches.
                    """

            def create_instance(self) -> _create_leak_shieldArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_leak_shieldArguments(*args)

        class create_local_refinement_regions(PyCommand):
            """
            Define a more refined region, or body of influence (BOI) when simulating flow within or around your geometry. You can manually create a body of influence using a bounding box or by using an offset surface. This body surrounds the relevant aspects of your geometry, such as the wake region behind a vehicle. More...
            Parameters
            ----------
            refinement_regions_name : str
                Enter a name for the body of influence.
            creation_method : str
                Choose how you want to create the refinement region: by creating a bounding box, a cylindrical bounding region, or using an offset surface. You should select a closed body for the offset surface.
            boi_max_size : float
                Specify the cell size for the refinement region mesh.
            boi_size_name : str
            selection_type : str
                Choose how you want to make your selection (by object, label, or zone name).
            zone_selection_list : list[str]
                Choose one or more zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_location : list[str]
            label_selection_list : list[str]
                Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            object_selection_list : list[str]
                Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_selection_single : list[str]
            object_selection_single : list[str]
                Choose a single object from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            topology_list : list[str]
            bounding_box_object : dict[str, Any]
                View the extents of the bounding box.
            offset_object : dict[str, Any]
                These fields contain parameters that define the characteristics of the refinements region (direction, thickness, levels, etc.)
            cylinder_method : str
                Choose how the cylindrical refinement region will be defined. The Vector and Length option allows you to define the cylindrical refinement region based either on the location of selected object(s) or zone(s), or by coordinates. If you choose to select by object(s) or zone(s), the location of the cylindrical refinement region will be at the center point of the selected surface. The Two Positions option allows you to explicitly define the location and dimension of the cylindrical refinement region without having to select object(s) or zone(s).
            cylinder_object : dict[str, Any]
            axis : dict[str, Any]
            volume_fill : str
            cylinder_length : float
                Specify the Length of the cylinder.
            geometry_tools_properties : dict[str, Any]

            Returns
            -------
            bool
            """
            class _create_local_refinement_regionsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.refinement_regions_name = self._refinement_regions_name(self, "refinement_regions_name", service, rules, path)
                    self.creation_method = self._creation_method(self, "creation_method", service, rules, path)
                    self.boi_max_size = self._boi_max_size(self, "boi_max_size", service, rules, path)
                    self.boi_size_name = self._boi_size_name(self, "boi_size_name", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.zone_selection_list = self._zone_selection_list(self, "zone_selection_list", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.label_selection_list = self._label_selection_list(self, "label_selection_list", service, rules, path)
                    self.object_selection_list = self._object_selection_list(self, "object_selection_list", service, rules, path)
                    self.zone_selection_single = self._zone_selection_single(self, "zone_selection_single", service, rules, path)
                    self.object_selection_single = self._object_selection_single(self, "object_selection_single", service, rules, path)
                    self.topology_list = self._topology_list(self, "topology_list", service, rules, path)
                    self.bounding_box_object = self._bounding_box_object(self, "bounding_box_object", service, rules, path)
                    self.offset_object = self._offset_object(self, "offset_object", service, rules, path)
                    self.cylinder_method = self._cylinder_method(self, "cylinder_method", service, rules, path)
                    self.cylinder_object = self._cylinder_object(self, "cylinder_object", service, rules, path)
                    self.axis = self._axis(self, "axis", service, rules, path)
                    self.volume_fill = self._volume_fill(self, "volume_fill", service, rules, path)
                    self.cylinder_length = self._cylinder_length(self, "cylinder_length", service, rules, path)
                    self.geometry_tools_properties = self._geometry_tools_properties(self, "geometry_tools_properties", service, rules, path)

                class _refinement_regions_name(PyArgumentsTextualSubItem):
                    """
                    Enter a name for the body of influence.
                    """

                class _creation_method(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to create the refinement region: by creating a bounding box, a cylindrical bounding region, or using an offset surface. You should select a closed body for the offset surface.
                    """

                class _boi_max_size(PyArgumentsNumericalSubItem):
                    """
                    Specify the cell size for the refinement region mesh.
                    """

                class _boi_size_name(PyArgumentsTextualSubItem):
                    """
                    Argument boi_size_name.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to make your selection (by object, label, or zone name).
                    """

                class _zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _label_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_selection_single(PyArgumentsTextualSubItem):
                    """
                    Argument zone_selection_single.
                    """

                class _object_selection_single(PyArgumentsTextualSubItem):
                    """
                    Choose a single object from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _topology_list(PyArgumentsTextualSubItem):
                    """
                    Argument topology_list.
                    """

                class _bounding_box_object(PyArgumentsSingletonSubItem):
                    """
                    View the extents of the bounding box.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.zmax = self._zmax(self, "zmax", service, rules, path)
                        self.ymax = self._ymax(self, "ymax", service, rules, path)
                        self.size_relative_length = self._size_relative_length(self, "size_relative_length", service, rules, path)
                        self.xmax_ratio = self._xmax_ratio(self, "xmax_ratio", service, rules, path)
                        self.zmax_ratio = self._zmax_ratio(self, "zmax_ratio", service, rules, path)
                        self.ymin_ratio = self._ymin_ratio(self, "ymin_ratio", service, rules, path)
                        self.zmin_ratio = self._zmin_ratio(self, "zmin_ratio", service, rules, path)
                        self.xmin_ratio = self._xmin_ratio(self, "xmin_ratio", service, rules, path)
                        self.xmin = self._xmin(self, "xmin", service, rules, path)
                        self.zmin = self._zmin(self, "zmin", service, rules, path)
                        self.ymin = self._ymin(self, "ymin", service, rules, path)
                        self.xmax = self._xmax(self, "xmax", service, rules, path)
                        self.ymax_ratio = self._ymax_ratio(self, "ymax_ratio", service, rules, path)

                    class _zmax(PyArgumentsNumericalSubItem):
                        """
                        Specify the X-coordinate for the initial position of the cylindrical refinement region.
                        """

                    class _ymax(PyArgumentsNumericalSubItem):
                        """
                        Specify the X-coordinate for the initial position of the cylindrical refinement region.
                        """

                    class _size_relative_length(PyArgumentsTextualSubItem):
                        """
                        Determine if you would like to specify the bounding box for the refinement region as a ratio of the geometry length, or by specifying a specific location for the minimum and maximum coordinates.
                        """

                    class _xmax_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the X direction by the specified value. The value is the ratio relative to the geometry size in the X direction.
                        """

                    class _zmax_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the Z direction by the specified value. The value is the ratio relative to the geometry size in the Z direction.
                        """

                    class _ymin_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the Y direction by the specified value. The value is the ratio relative to the geometry size in the Y direction.
                        """

                    class _zmin_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the Z direction by the specified value. The value is the ratio relative to the geometry size in the Z direction.
                        """

                    class _xmin_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the X direction by the specified value. The value is the ratio relative to the geometry size in the X direction.
                        """

                    class _xmin(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the X direction by the specified value.
                        """

                    class _zmin(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the Z direction by the specified value.
                        """

                    class _ymin(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the Y direction by the specified value.
                        """

                    class _xmax(PyArgumentsNumericalSubItem):
                        """
                        Specify the X-coordinate for the initial position of the cylindrical refinement region.
                        """

                    class _ymax_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the Y direction by the specified value. The value is the ratio relative to the geometry size in the Y direction.
                        """

                class _offset_object(PyArgumentsSingletonSubItem):
                    """
                    These fields contain parameters that define the characteristics of the refinements region (direction, thickness, levels, etc.)
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.flip_direction = self._flip_direction(self, "flip_direction", service, rules, path)
                        self.y = self._y(self, "y", service, rules, path)
                        self.boundary_layer_height = self._boundary_layer_height(self, "boundary_layer_height", service, rules, path)
                        self.edge_selection_list = self._edge_selection_list(self, "edge_selection_list", service, rules, path)
                        self.first_height = self._first_height(self, "first_height", service, rules, path)
                        self.mpt_method_type = self._mpt_method_type(self, "mpt_method_type", service, rules, path)
                        self.wake_growth_factor = self._wake_growth_factor(self, "wake_growth_factor", service, rules, path)
                        self.defeaturing_size = self._defeaturing_size(self, "defeaturing_size", service, rules, path)
                        self.aspect_ratio = self._aspect_ratio(self, "aspect_ratio", service, rules, path)
                        self.number_of_layers = self._number_of_layers(self, "number_of_layers", service, rules, path)
                        self.z = self._z(self, "z", service, rules, path)
                        self.x = self._x(self, "x", service, rules, path)
                        self.offset_method_type = self._offset_method_type(self, "offset_method_type", service, rules, path)
                        self.wake_levels = self._wake_levels(self, "wake_levels", service, rules, path)
                        self.boundary_layer_levels = self._boundary_layer_levels(self, "boundary_layer_levels", service, rules, path)
                        self.last_ratio_percentage = self._last_ratio_percentage(self, "last_ratio_percentage", service, rules, path)
                        self.flow_direction = self._flow_direction(self, "flow_direction", service, rules, path)
                        self.show_coordinates = self._show_coordinates(self, "show_coordinates", service, rules, path)
                        self.cross_wake_growth_factor = self._cross_wake_growth_factor(self, "cross_wake_growth_factor", service, rules, path)
                        self.rate = self._rate(self, "rate", service, rules, path)

                    class _flip_direction(PyArgumentsParameterSubItem):
                        """
                        Reverses the orientation of the refinement region.
                        """

                    class _y(PyArgumentsNumericalSubItem):
                        """
                        Specify the Y-coordinate for the initial position of the cylindrical refinement region.
                        """

                    class _boundary_layer_height(PyArgumentsNumericalSubItem):
                        """
                        Specify the total height of the boundary layer for this refinement region (this is flow in the vicinity).
                        """

                    class _edge_selection_list(PyArgumentsTextualSubItem):
                        """
                        Argument edge_selection_list.
                        """

                    class _first_height(PyArgumentsNumericalSubItem):
                        """
                        Argument first_height.
                        """

                    class _mpt_method_type(PyArgumentsTextualSubItem):
                        """
                        Argument mpt_method_type.
                        """

                    class _wake_growth_factor(PyArgumentsNumericalSubItem):
                        """
                        Specify the factor by which the refinement region expands in the wake of the flow direction.
                        """

                    class _defeaturing_size(PyArgumentsNumericalSubItem):
                        """
                        Specify a value that is used to obtain a rough shape of the selected object(s). The larger the value, the more approximate the shape.
                        """

                    class _aspect_ratio(PyArgumentsNumericalSubItem):
                        """
                        Argument aspect_ratio.
                        """

                    class _number_of_layers(PyArgumentsNumericalSubItem):
                        """
                        Argument number_of_layers.
                        """

                    class _z(PyArgumentsNumericalSubItem):
                        """
                        Specify the Z-coordinate for the initial position of the cylindrical refinement region.
                        """

                    class _x(PyArgumentsNumericalSubItem):
                        """
                        Specify the X-coordinate for the initial position of the cylindrical refinement region.
                        """

                    class _offset_method_type(PyArgumentsTextualSubItem):
                        """
                        Argument offset_method_type.
                        """

                    class _wake_levels(PyArgumentsNumericalSubItem):
                        """
                        Specify the number of refinement layers that will appear in the wake.
                        """

                    class _boundary_layer_levels(PyArgumentsNumericalSubItem):
                        """
                        Specify the number of boundary layers that are to be captured in the refinement region.
                        """

                    class _last_ratio_percentage(PyArgumentsNumericalSubItem):
                        """
                        Argument last_ratio_percentage.
                        """

                    class _flow_direction(PyArgumentsTextualSubItem):
                        """
                        Specify the direction that the flow through this refinement region.
                        """

                    class _show_coordinates(PyArgumentsParameterSubItem):
                        """
                        Argument show_coordinates.
                        """

                    class _cross_wake_growth_factor(PyArgumentsNumericalSubItem):
                        """
                        Specify the factor by which the refinement region expands in the rest of the directions.
                        """

                    class _rate(PyArgumentsNumericalSubItem):
                        """
                        Argument rate.
                        """

                class _cylinder_method(PyArgumentsTextualSubItem):
                    """
                    Choose how the cylindrical refinement region will be defined. The Vector and Length option allows you to define the cylindrical refinement region based either on the location of selected object(s) or zone(s), or by coordinates. If you choose to select by object(s) or zone(s), the location of the cylindrical refinement region will be at the center point of the selected surface. The Two Positions option allows you to explicitly define the location and dimension of the cylindrical refinement region without having to select object(s) or zone(s).
                    """

                class _cylinder_object(PyArgumentsSingletonSubItem):
                    """
                    Argument cylinder_object.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.node_2 = self._node_2(self, "node_2", service, rules, path)
                        self.node_3 = self._node_3(self, "node_3", service, rules, path)
                        self.x2 = self._x2(self, "x2", service, rules, path)
                        self.x_offset = self._x_offset(self, "x_offset", service, rules, path)
                        self.x1 = self._x1(self, "x1", service, rules, path)
                        self.height_back_inc = self._height_back_inc(self, "height_back_inc", service, rules, path)
                        self.height_front_inc = self._height_front_inc(self, "height_front_inc", service, rules, path)
                        self.height_node = self._height_node(self, "height_node", service, rules, path)
                        self.z_offset = self._z_offset(self, "z_offset", service, rules, path)
                        self.z1 = self._z1(self, "z1", service, rules, path)
                        self.node_1 = self._node_1(self, "node_1", service, rules, path)
                        self.y_offset = self._y_offset(self, "y_offset", service, rules, path)
                        self.z2 = self._z2(self, "z2", service, rules, path)
                        self.radius_2 = self._radius_2(self, "radius_2", service, rules, path)
                        self.radius_1 = self._radius_1(self, "radius_1", service, rules, path)
                        self.y2 = self._y2(self, "y2", service, rules, path)
                        self.y1 = self._y1(self, "y1", service, rules, path)

                    class _node_2(PyArgumentsTextualSubItem):
                        """
                        Argument node_2.
                        """

                    class _node_3(PyArgumentsTextualSubItem):
                        """
                        Argument node_3.
                        """

                    class _x2(PyArgumentsNumericalSubItem):
                        """
                        Specify the X-coordinate of the second position of the cylinder.
                        """

                    class _x_offset(PyArgumentsNumericalSubItem):
                        """
                        Specify the X-coordinate for the offset of the initial position of the cylinder.
                        """

                    class _x1(PyArgumentsNumericalSubItem):
                        """
                        Specify the X-coordinate of the first position of the cylinder.
                        """

                    class _height_back_inc(PyArgumentsNumericalSubItem):
                        """
                        Argument height_back_inc.
                        """

                    class _height_front_inc(PyArgumentsNumericalSubItem):
                        """
                        Argument height_front_inc.
                        """

                    class _height_node(PyArgumentsTextualSubItem):
                        """
                        Argument height_node.
                        """

                    class _z_offset(PyArgumentsNumericalSubItem):
                        """
                        Specify the Z-coordinate for the offset of the initial position of the cylinder.
                        """

                    class _z1(PyArgumentsNumericalSubItem):
                        """
                        Specify the Z-coordinate of the first position of the cylinder.
                        """

                    class _node_1(PyArgumentsTextualSubItem):
                        """
                        Argument node_1.
                        """

                    class _y_offset(PyArgumentsNumericalSubItem):
                        """
                        Specify the Y-coordinate for the offset of the initial position of the cylinder.
                        """

                    class _z2(PyArgumentsNumericalSubItem):
                        """
                        Specify the Z-coordinate of the second position of the cylinder.
                        """

                    class _radius_2(PyArgumentsNumericalSubItem):
                        """
                        Specify the radius of the cylinder at the second position.
                        """

                    class _radius_1(PyArgumentsNumericalSubItem):
                        """
                        Specify the radius of the cylinder at the initial position.
                        """

                    class _y2(PyArgumentsNumericalSubItem):
                        """
                        Specify the Y-coordinate of the second position of the cylinder.
                        """

                    class _y1(PyArgumentsNumericalSubItem):
                        """
                        Specify the Y-coordinate of the first position of the cylinder.
                        """

                class _axis(PyArgumentsSingletonSubItem):
                    """
                    Argument axis.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.z_component = self._z_component(self, "z_component", service, rules, path)
                        self.y_component = self._y_component(self, "y_component", service, rules, path)
                        self.x_component = self._x_component(self, "x_component", service, rules, path)

                    class _z_component(PyArgumentsNumericalSubItem):
                        """
                        Specify the Z-component of the cylindrical vector.
                        """

                    class _y_component(PyArgumentsNumericalSubItem):
                        """
                        Specify the Y-component of the cylindrical vector.
                        """

                    class _x_component(PyArgumentsNumericalSubItem):
                        """
                        Specify the X-component of the cylindrical vector.
                        """

                class _volume_fill(PyArgumentsTextualSubItem):
                    """
                    Argument volume_fill.
                    """

                class _cylinder_length(PyArgumentsNumericalSubItem):
                    """
                    Specify the Length of the cylinder.
                    """

                class _geometry_tools_properties(PyArgumentsSingletonSubItem):
                    """
                    Argument geometry_tools_properties.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.box_center_z = self._box_center_z(self, "box_center_z", service, rules, path)
                        self.cylinder_radius_1 = self._cylinder_radius_1(self, "cylinder_radius_1", service, rules, path)
                        self.cylinder_z1 = self._cylinder_z1(self, "cylinder_z1", service, rules, path)
                        self.box_center_x = self._box_center_x(self, "box_center_x", service, rules, path)
                        self.cylinder_x1 = self._cylinder_x1(self, "cylinder_x1", service, rules, path)
                        self.box_y_length = self._box_y_length(self, "box_y_length", service, rules, path)
                        self.box_z_length = self._box_z_length(self, "box_z_length", service, rules, path)
                        self.cylinder_z2 = self._cylinder_z2(self, "cylinder_z2", service, rules, path)
                        self.box_x_length = self._box_x_length(self, "box_x_length", service, rules, path)
                        self.cylinder_radius_2 = self._cylinder_radius_2(self, "cylinder_radius_2", service, rules, path)
                        self.cylinder_y1 = self._cylinder_y1(self, "cylinder_y1", service, rules, path)
                        self.box_center_y = self._box_center_y(self, "box_center_y", service, rules, path)
                        self.cylinder_x2 = self._cylinder_x2(self, "cylinder_x2", service, rules, path)
                        self.cylinder_y2 = self._cylinder_y2(self, "cylinder_y2", service, rules, path)

                    class _box_center_z(PyArgumentsNumericalSubItem):
                        """
                        Specify the Z-coordinate for the initial position of the cylindrical refinement region.
                        """

                    class _cylinder_radius_1(PyArgumentsNumericalSubItem):
                        """
                        Specify the radius of the cylinder at the initial position.
                        """

                    class _cylinder_z1(PyArgumentsNumericalSubItem):
                        """
                        Specify the Z-coordinate of the first position of the cylinder.
                        """

                    class _box_center_x(PyArgumentsNumericalSubItem):
                        """
                        Specify the X-coordinate for the initial position of the cylindrical refinement region.
                        """

                    class _cylinder_x1(PyArgumentsNumericalSubItem):
                        """
                        Specify the X-coordinate of the first position of the cylinder.
                        """

                    class _box_y_length(PyArgumentsNumericalSubItem):
                        """
                        Argument box_y_length.
                        """

                    class _box_z_length(PyArgumentsNumericalSubItem):
                        """
                        Argument box_z_length.
                        """

                    class _cylinder_z2(PyArgumentsNumericalSubItem):
                        """
                        Specify the Z-coordinate of the second position of the cylinder.
                        """

                    class _box_x_length(PyArgumentsNumericalSubItem):
                        """
                        Argument box_x_length.
                        """

                    class _cylinder_radius_2(PyArgumentsNumericalSubItem):
                        """
                        Specify the radius of the cylinder at the second position.
                        """

                    class _cylinder_y1(PyArgumentsNumericalSubItem):
                        """
                        Specify the Y-coordinate of the first position of the cylinder.
                        """

                    class _box_center_y(PyArgumentsNumericalSubItem):
                        """
                        Specify the Y-coordinate for the initial position of the cylindrical refinement region.
                        """

                    class _cylinder_x2(PyArgumentsNumericalSubItem):
                        """
                        Specify the X-coordinate of the second position of the cylinder.
                        """

                    class _cylinder_y2(PyArgumentsNumericalSubItem):
                        """
                        Specify the Y-coordinate of the second position of the cylinder.
                        """

            def create_instance(self) -> _create_local_refinement_regionsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_local_refinement_regionsArguments(*args)

        class create_mesh_objects(PyCommand):
            """
            Command create_mesh_objects.

            Parameters
            ----------
            merge_zones_based_on_labels : bool
            create_a_face_zone_per_body : bool

            Returns
            -------
            bool
            """
            class _create_mesh_objectsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.merge_zones_based_on_labels = self._merge_zones_based_on_labels(self, "merge_zones_based_on_labels", service, rules, path)
                    self.create_a_face_zone_per_body = self._create_a_face_zone_per_body(self, "create_a_face_zone_per_body", service, rules, path)

                class _merge_zones_based_on_labels(PyArgumentsParameterSubItem):
                    """
                    Argument merge_zones_based_on_labels.
                    """

                class _create_a_face_zone_per_body(PyArgumentsParameterSubItem):
                    """
                    Argument create_a_face_zone_per_body.
                    """

            def create_instance(self) -> _create_mesh_objectsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_mesh_objectsArguments(*args)

        class create_multizone_mesh(PyCommand):
            """
            Use this task to create a multi-zone mesh for the designated region(s).  More...
            Parameters
            ----------
            orthogonal_quality_limit : float
                This value sets the threshold for when mesh quality improvements are automatically invoked that employ the orthogonal quality limit, and is recommended to be around 0.04.
            selection_type : str
            region_scope : list[str]
                Select the named region(s) from the list to which you would like to generate the multi-zone mesh. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            non_conformal : str
                Optionally specify that multizone regions are non-conformally connected to other volumetric regions.  If you want to have a conformal mesh but, because of meshing constraints, that is not possible, then you can switch to non-conformal here and avoid doing so in the CAD model.
            size_function_scale_factor : float
                Enable the scaling of the multizone mesh. In some cases when the multizone region is too coarse when compared to the adjacent surface mesh, a connection is not possible. You can specify a size function scaling factor here to improve the sizing match between the multizone and the non-multizone regions and avoid any free faces. Typically, a value between 0.7 and 0.8 is recommended.
            meshing_strategy : str
            re_merge_zones : bool
            merge_body_labels : bool
            cfd_surface_mesh_controls : dict[str, Any]
            body_label_list : list[str]
            body_label_body_list : list[str]
            cell_zone_list : list[str]
            complete_region_scope : list[str]
                Select the named region(s) from the list to which you would like to generate the multi-zone mesh. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...

            Returns
            -------
            bool
            """
            class _create_multizone_meshArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.orthogonal_quality_limit = self._orthogonal_quality_limit(self, "orthogonal_quality_limit", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.region_scope = self._region_scope(self, "region_scope", service, rules, path)
                    self.non_conformal = self._non_conformal(self, "non_conformal", service, rules, path)
                    self.size_function_scale_factor = self._size_function_scale_factor(self, "size_function_scale_factor", service, rules, path)
                    self.meshing_strategy = self._meshing_strategy(self, "meshing_strategy", service, rules, path)
                    self.re_merge_zones = self._re_merge_zones(self, "re_merge_zones", service, rules, path)
                    self.merge_body_labels = self._merge_body_labels(self, "merge_body_labels", service, rules, path)
                    self.cfd_surface_mesh_controls = self._cfd_surface_mesh_controls(self, "cfd_surface_mesh_controls", service, rules, path)
                    self.body_label_list = self._body_label_list(self, "body_label_list", service, rules, path)
                    self.body_label_body_list = self._body_label_body_list(self, "body_label_body_list", service, rules, path)
                    self.cell_zone_list = self._cell_zone_list(self, "cell_zone_list", service, rules, path)
                    self.complete_region_scope = self._complete_region_scope(self, "complete_region_scope", service, rules, path)

                class _orthogonal_quality_limit(PyArgumentsNumericalSubItem):
                    """
                    This value sets the threshold for when mesh quality improvements are automatically invoked that employ the orthogonal quality limit, and is recommended to be around 0.04.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Argument selection_type.
                    """

                class _region_scope(PyArgumentsTextualSubItem):
                    """
                    Select the named region(s) from the list to which you would like to generate the multi-zone mesh. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _non_conformal(PyArgumentsTextualSubItem):
                    """
                    Optionally specify that multizone regions are non-conformally connected to other volumetric regions.  If you want to have a conformal mesh but, because of meshing constraints, that is not possible, then you can switch to non-conformal here and avoid doing so in the CAD model.
                    """

                class _size_function_scale_factor(PyArgumentsNumericalSubItem):
                    """
                    Enable the scaling of the multizone mesh. In some cases when the multizone region is too coarse when compared to the adjacent surface mesh, a connection is not possible. You can specify a size function scaling factor here to improve the sizing match between the multizone and the non-multizone regions and avoid any free faces. Typically, a value between 0.7 and 0.8 is recommended.
                    """

                class _meshing_strategy(PyArgumentsTextualSubItem):
                    """
                    Argument meshing_strategy.
                    """

                class _re_merge_zones(PyArgumentsParameterSubItem):
                    """
                    Argument re_merge_zones.
                    """

                class _merge_body_labels(PyArgumentsParameterSubItem):
                    """
                    Argument merge_body_labels.
                    """

                class _cfd_surface_mesh_controls(PyArgumentsSingletonSubItem):
                    """
                    Argument cfd_surface_mesh_controls.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.scope_proximity_to = self._scope_proximity_to(self, "scope_proximity_to", service, rules, path)
                        self.object_based_controls = self._object_based_controls(self, "object_based_controls", service, rules, path)
                        self.cells_per_gap = self._cells_per_gap(self, "cells_per_gap", service, rules, path)
                        self.draw_size_control = self._draw_size_control(self, "draw_size_control", service, rules, path)
                        self.min_size = self._min_size(self, "min_size", service, rules, path)
                        self.preview_sizefield = self._preview_sizefield(self, "preview_sizefield", service, rules, path)
                        self.max_size = self._max_size(self, "max_size", service, rules, path)
                        self.size_functions = self._size_functions(self, "size_functions", service, rules, path)
                        self.remesh_imported_mesh = self._remesh_imported_mesh(self, "remesh_imported_mesh", service, rules, path)
                        self.auto_create_scoped_sizing = self._auto_create_scoped_sizing(self, "auto_create_scoped_sizing", service, rules, path)
                        self.curvature_normal_angle = self._curvature_normal_angle(self, "curvature_normal_angle", service, rules, path)
                        self.growth_rate = self._growth_rate(self, "growth_rate", service, rules, path)
                        self.save_size_field = self._save_size_field(self, "save_size_field", service, rules, path)
                        self.refacet = self._refacet(self, "refacet", service, rules, path)
                        self.size_field_file = self._size_field_file(self, "size_field_file", service, rules, path)
                        self.size_control_file = self._size_control_file(self, "size_control_file", service, rules, path)
                        self.use_size_files = self._use_size_files(self, "use_size_files", service, rules, path)
                        self.save_size_field_file = self._save_size_field_file(self, "save_size_field_file", service, rules, path)
                        self.surface_mesh_method = self._surface_mesh_method(self, "surface_mesh_method", service, rules, path)

                    class _scope_proximity_to(PyArgumentsTextualSubItem):
                        """
                        Argument scope_proximity_to.
                        """

                    class _object_based_controls(PyArgumentsParameterSubItem):
                        """
                        Argument object_based_controls.
                        """

                    class _cells_per_gap(PyArgumentsNumericalSubItem):
                        """
                        Argument cells_per_gap.
                        """

                    class _draw_size_control(PyArgumentsParameterSubItem):
                        """
                        Argument draw_size_control.
                        """

                    class _min_size(PyArgumentsNumericalSubItem):
                        """
                        Argument min_size.
                        """

                    class _preview_sizefield(PyArgumentsParameterSubItem):
                        """
                        Argument preview_sizefield.
                        """

                    class _max_size(PyArgumentsNumericalSubItem):
                        """
                        Argument max_size.
                        """

                    class _size_functions(PyArgumentsTextualSubItem):
                        """
                        Argument size_functions.
                        """

                    class _remesh_imported_mesh(PyArgumentsTextualSubItem):
                        """
                        Argument remesh_imported_mesh.
                        """

                    class _auto_create_scoped_sizing(PyArgumentsParameterSubItem):
                        """
                        Argument auto_create_scoped_sizing.
                        """

                    class _curvature_normal_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument curvature_normal_angle.
                        """

                    class _growth_rate(PyArgumentsNumericalSubItem):
                        """
                        Argument growth_rate.
                        """

                    class _save_size_field(PyArgumentsParameterSubItem):
                        """
                        Argument save_size_field.
                        """

                    class _refacet(PyArgumentsParameterSubItem):
                        """
                        Argument refacet.
                        """

                    class _size_field_file(PyArgumentsTextualSubItem):
                        """
                        Argument size_field_file.
                        """

                    class _size_control_file(PyArgumentsTextualSubItem):
                        """
                        Argument size_control_file.
                        """

                    class _use_size_files(PyArgumentsTextualSubItem):
                        """
                        Argument use_size_files.
                        """

                    class _save_size_field_file(PyArgumentsTextualSubItem):
                        """
                        Argument save_size_field_file.
                        """

                    class _surface_mesh_method(PyArgumentsTextualSubItem):
                        """
                        Argument surface_mesh_method.
                        """

                class _body_label_list(PyArgumentsTextualSubItem):
                    """
                    Argument body_label_list.
                    """

                class _body_label_body_list(PyArgumentsTextualSubItem):
                    """
                    Argument body_label_body_list.
                    """

                class _cell_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument cell_zone_list.
                    """

                class _complete_region_scope(PyArgumentsTextualSubItem):
                    """
                    Select the named region(s) from the list to which you would like to generate the multi-zone mesh. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

            def create_instance(self) -> _create_multizone_meshArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_multizone_meshArguments(*args)

        class create_overset_mesh(PyCommand):
            """
            Use this task to create a mesh interface between two or more overset mesh objects.  More...
            Parameters
            ----------
            overset_interfaces_name : str
                Specify a name for the overset mesh interface or use the default value.
            object_selection_list : list[str]
                Select one or more overset mesh objects that will make up the mesh interface. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...

            Returns
            -------
            bool
            """
            class _create_overset_meshArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.overset_interfaces_name = self._overset_interfaces_name(self, "overset_interfaces_name", service, rules, path)
                    self.object_selection_list = self._object_selection_list(self, "object_selection_list", service, rules, path)

                class _overset_interfaces_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the overset mesh interface or use the default value.
                    """

                class _object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Select one or more overset mesh objects that will make up the mesh interface. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

            def create_instance(self) -> _create_overset_meshArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_overset_meshArguments(*args)

        class create_porous_regions(PyCommand):
            """
            Identify porous regions in your imported geometry so that you can simulate flow through porous media. More...
            Parameters
            ----------
            input_method : str
                Indicate whether you are creating the porous region using Direct coordinates, by using a Text file, or by specifying a Nonrectangular region.
            porous_region_name : str
                Specify a name for the porous region or use the default value.
            wrapper_size_factor : float
            file_name : str
                Specify the name and location of the text file containing the porous region definition.  More...
            location : str
                Specify how you would like to determine the location of the porous region.
            cell_size_p1_p2 : float
                Specify the size of the cells that lie between P1 and P2 of the porous region. P1 is the first point designated for the porous region; P2 is the second point of the porous region - created to the left of P1 in the same plane.
            cell_size_p1_p3 : float
                Specify the size of the cells that lie between P1 and P3 of the porous region. P1 is the first point designated for the porous region; P3 is the third point of the porous region - created above P1 in the same plane.
            cell_size_p1_p4 : float
                Specify the size of the cells that lie between P1 and P4 of the porous region. P1 is the first point designated for the porous region; P4 is the fourth point of the porous region - created in relation to P1 to essentially define a thickness for the porous region.
            buffer_size_ratio : float
                Specify a value for the buffer size ratio. The buffer is created as an extra layer. The thickness is equivalent to the product of the buffer size ratio and the core thickness. The core thickness is the distance between P1 and P4.
            p1 : list[float]
            p2 : list[float]
            p3 : list[float]
            p4 : list[float]
            non_rectangular_parameters : dict[str, Any]

            Returns
            -------
            bool
            """
            class _create_porous_regionsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.input_method = self._input_method(self, "input_method", service, rules, path)
                    self.porous_region_name = self._porous_region_name(self, "porous_region_name", service, rules, path)
                    self.wrapper_size_factor = self._wrapper_size_factor(self, "wrapper_size_factor", service, rules, path)
                    self.file_name = self._file_name(self, "file_name", service, rules, path)
                    self.location = self._location(self, "location", service, rules, path)
                    self.cell_size_p1_p2 = self._cell_size_p1_p2(self, "cell_size_p1_p2", service, rules, path)
                    self.cell_size_p1_p3 = self._cell_size_p1_p3(self, "cell_size_p1_p3", service, rules, path)
                    self.cell_size_p1_p4 = self._cell_size_p1_p4(self, "cell_size_p1_p4", service, rules, path)
                    self.buffer_size_ratio = self._buffer_size_ratio(self, "buffer_size_ratio", service, rules, path)
                    self.p1 = self._p1(self, "p1", service, rules, path)
                    self.p2 = self._p2(self, "p2", service, rules, path)
                    self.p3 = self._p3(self, "p3", service, rules, path)
                    self.p4 = self._p4(self, "p4", service, rules, path)
                    self.non_rectangular_parameters = self._non_rectangular_parameters(self, "non_rectangular_parameters", service, rules, path)

                class _input_method(PyArgumentsTextualSubItem):
                    """
                    Indicate whether you are creating the porous region using Direct coordinates, by using a Text file, or by specifying a Nonrectangular region.
                    """

                class _porous_region_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the porous region or use the default value.
                    """

                class _wrapper_size_factor(PyArgumentsNumericalSubItem):
                    """
                    Argument wrapper_size_factor.
                    """

                class _file_name(PyArgumentsTextualSubItem):
                    """
                    Specify the name and location of the text file containing the porous region definition.  More...
                    """

                class _location(PyArgumentsTextualSubItem):
                    """
                    Specify how you would like to determine the location of the porous region.
                    """

                class _cell_size_p1_p2(PyArgumentsNumericalSubItem):
                    """
                    Specify the size of the cells that lie between P1 and P2 of the porous region. P1 is the first point designated for the porous region; P2 is the second point of the porous region - created to the left of P1 in the same plane.
                    """

                class _cell_size_p1_p3(PyArgumentsNumericalSubItem):
                    """
                    Specify the size of the cells that lie between P1 and P3 of the porous region. P1 is the first point designated for the porous region; P3 is the third point of the porous region - created above P1 in the same plane.
                    """

                class _cell_size_p1_p4(PyArgumentsNumericalSubItem):
                    """
                    Specify the size of the cells that lie between P1 and P4 of the porous region. P1 is the first point designated for the porous region; P4 is the fourth point of the porous region - created in relation to P1 to essentially define a thickness for the porous region.
                    """

                class _buffer_size_ratio(PyArgumentsNumericalSubItem):
                    """
                    Specify a value for the buffer size ratio. The buffer is created as an extra layer. The thickness is equivalent to the product of the buffer size ratio and the core thickness. The core thickness is the distance between P1 and P4.
                    """

                class _p1(PyArgumentsNumericalSubItem):
                    """
                    Argument p1.
                    """

                class _p2(PyArgumentsNumericalSubItem):
                    """
                    Argument p2.
                    """

                class _p3(PyArgumentsNumericalSubItem):
                    """
                    Argument p3.
                    """

                class _p4(PyArgumentsNumericalSubItem):
                    """
                    Argument p4.
                    """

                class _non_rectangular_parameters(PyArgumentsSingletonSubItem):
                    """
                    Argument non_rectangular_parameters.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.flip_direction = self._flip_direction(self, "flip_direction", service, rules, path)
                        self.object_selection_list = self._object_selection_list(self, "object_selection_list", service, rules, path)
                        self.non_rectangular_buffer_size = self._non_rectangular_buffer_size(self, "non_rectangular_buffer_size", service, rules, path)
                        self.number_of_layers = self._number_of_layers(self, "number_of_layers", service, rules, path)
                        self.buffer_size = self._buffer_size(self, "buffer_size", service, rules, path)
                        self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                        self.zone_selection_list = self._zone_selection_list(self, "zone_selection_list", service, rules, path)
                        self.label_selection_list = self._label_selection_list(self, "label_selection_list", service, rules, path)
                        self.feature_angle = self._feature_angle(self, "feature_angle", service, rules, path)
                        self.thickness = self._thickness(self, "thickness", service, rules, path)
                        self.mesh_size = self._mesh_size(self, "mesh_size", service, rules, path)

                    class _flip_direction(PyArgumentsParameterSubItem):
                        """
                        Reverses the orientation of the porous region.
                        """

                    class _object_selection_list(PyArgumentsTextualSubItem):
                        """
                        Choose a single object (or void) from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """

                    class _non_rectangular_buffer_size(PyArgumentsNumericalSubItem):
                        """
                        Specify a value for the buffer size. The buffer is created as an extra layer. The thickness is equivalent to the product of the buffer size ratio and the core thickness. The core thickness is the distance between P1 and P4.
                        """

                    class _number_of_layers(PyArgumentsNumericalSubItem):
                        """
                        Specify the number of layers, or divisions, along the thickness of the porous region.
                        """

                    class _buffer_size(PyArgumentsNumericalSubItem):
                        """
                        Specify a value for the buffer size. The buffer is created as an extra layer. The thickness is equivalent to the product of the buffer size ratio and the core thickness. The core thickness is the distance between P1 and P4.
                        """

                    class _selection_type(PyArgumentsTextualSubItem):
                        """
                        Choose how you want to make your selection (by object, zone, or label).
                        """

                    class _zone_selection_list(PyArgumentsTextualSubItem):
                        """
                        Choose a single face zone from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """

                    class _label_selection_list(PyArgumentsTextualSubItem):
                        """
                        Select a single label that will correspond to the porous region. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """

                    class _feature_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify the angle at which features will be extracted for the porous region.
                        """

                    class _thickness(PyArgumentsNumericalSubItem):
                        """
                        Specify the thickness (or the total height) of the porous region.
                        """

                    class _mesh_size(PyArgumentsNumericalSubItem):
                        """
                        Specify the cell size for the porous region mesh.
                        """

            def create_instance(self) -> _create_porous_regionsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_porous_regionsArguments(*args)

        class create_regions(PyCommand):
            """
            Confirm that Fluent has correctly estimated the number of fluid regions. Fluent will detect additional regions if they exist, however, it will detect fluid regions only where they are connected to capping surfaces. Your geometry may include a solid region only, or it may contain a fluid region within a solid region.  More...
            Parameters
            ----------
            number_of_flow_volumes : int
                Confirm the number of flow volumes required for the analysis. The system will detect additional regions if they exist, however, it will detect fluid regions only where they are connected to capping surfaces.
            retain_dead_region_name : bool
                If any dead regions are present, you can choose to determine how such regions are named. Voids or dead regions are usually named dead0, dead1, dead2, and so on, and can remain so when this prompt is set to no. When this prompt is set to yes, however, the dead region names will also be prefixed with the original dead region name (usually derived from an adjacent region), such as dead0-fluid:1, dead1-fluid:2, and so on.
            mesh_object : str

            Returns
            -------
            bool
            """
            class _create_regionsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.number_of_flow_volumes = self._number_of_flow_volumes(self, "number_of_flow_volumes", service, rules, path)
                    self.retain_dead_region_name = self._retain_dead_region_name(self, "retain_dead_region_name", service, rules, path)
                    self.mesh_object = self._mesh_object(self, "mesh_object", service, rules, path)

                class _number_of_flow_volumes(PyArgumentsNumericalSubItem):
                    """
                    Confirm the number of flow volumes required for the analysis. The system will detect additional regions if they exist, however, it will detect fluid regions only where they are connected to capping surfaces.
                    """

                class _retain_dead_region_name(PyArgumentsParameterSubItem):
                    """
                    If any dead regions are present, you can choose to determine how such regions are named. Voids or dead regions are usually named dead0, dead1, dead2, and so on, and can remain so when this prompt is set to no. When this prompt is set to yes, however, the dead region names will also be prefixed with the original dead region name (usually derived from an adjacent region), such as dead0-fluid:1, dead1-fluid:2, and so on.
                    """

                class _mesh_object(PyArgumentsTextualSubItem):
                    """
                    Argument mesh_object.
                    """

            def create_instance(self) -> _create_regionsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_regionsArguments(*args)

        class create_surface_mesh(PyCommand):
            """
            Generate a mesh over the surface of the imported CAD geometry, or remesh an imported surface mesh, or use pre-existing size field or size control files. Surface meshes are used to define the computational region or volume for the CFD analysis. Specify and adjust various properties of the computational surface mesh and preview them in the graphics window until you are satisfied that the surface mesh completely and accurately captures the topology of the imported CAD geometry. No gaps or slivers should be present, and you should refine the surface mesh in key areas to ensure that you can capture important physical behavior in your CFD analysis. Choose any advanced options that you want to take effect upon updating the task.  More...
            Parameters
            ----------
            cfd_surface_mesh_controls : dict[str, Any]
            separation_required : bool
                Choose whether or not to separate face zones. By default, this is set to No. If you choose to separate zones, specify a Separation Angle. You should separate zones when using Multizone meshing. Separation is needed in case named selections for inlets, outlets, capping, local boundary layers, etc. have not been defined within the CAD model in advance. You should only select Yes if you need to separate faces for capping, boundary conditions, or inflation on specific faces.
            separation_angle : float
                Specify a desired angle for determining separation. Assigning a smaller separation angle will produce more zones.
            remesh_selection_type : str
                Choose how you want to select your surface(s) to remesh (by label or by zone).
            remesh_zone_list : list[str]
            remesh_label_list : list[str]
            surface_mesh_preferences : dict[str, Any]
            import_type : str
            append_mesh : bool
            cad_faceting_file_name : str
            directory : str
            pattern : str
            length_unit : str
            tesselation_method : str
            original_zones : list[str]
            execute_share_topology : bool
                For imported CAD assemblies with multiple parts, use this task to identify and close any problematic gaps and choose whether to join and/or intersect the problematic faces.   More...
            cad_faceting_controls : dict[str, Any]
            cad_import_options : dict[str, Any]
            share_topology_preferences : dict[str, Any]
            preview_size_toggle : bool
                For an imported surface mesh, use this field to visualize those boundaries that already have assigned local sizing controls (and any selected boundaries if applicable).

            Returns
            -------
            bool
            """
            class _create_surface_meshArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.cfd_surface_mesh_controls = self._cfd_surface_mesh_controls(self, "cfd_surface_mesh_controls", service, rules, path)
                    self.separation_required = self._separation_required(self, "separation_required", service, rules, path)
                    self.separation_angle = self._separation_angle(self, "separation_angle", service, rules, path)
                    self.remesh_selection_type = self._remesh_selection_type(self, "remesh_selection_type", service, rules, path)
                    self.remesh_zone_list = self._remesh_zone_list(self, "remesh_zone_list", service, rules, path)
                    self.remesh_label_list = self._remesh_label_list(self, "remesh_label_list", service, rules, path)
                    self.surface_mesh_preferences = self._surface_mesh_preferences(self, "surface_mesh_preferences", service, rules, path)
                    self.import_type = self._import_type(self, "import_type", service, rules, path)
                    self.append_mesh = self._append_mesh(self, "append_mesh", service, rules, path)
                    self.cad_faceting_file_name = self._cad_faceting_file_name(self, "cad_faceting_file_name", service, rules, path)
                    self.directory = self._directory(self, "directory", service, rules, path)
                    self.pattern = self._pattern(self, "pattern", service, rules, path)
                    self.length_unit = self._length_unit(self, "length_unit", service, rules, path)
                    self.tesselation_method = self._tesselation_method(self, "tesselation_method", service, rules, path)
                    self.original_zones = self._original_zones(self, "original_zones", service, rules, path)
                    self.execute_share_topology = self._execute_share_topology(self, "execute_share_topology", service, rules, path)
                    self.cad_faceting_controls = self._cad_faceting_controls(self, "cad_faceting_controls", service, rules, path)
                    self.cad_import_options = self._cad_import_options(self, "cad_import_options", service, rules, path)
                    self.share_topology_preferences = self._share_topology_preferences(self, "share_topology_preferences", service, rules, path)
                    self.preview_size_toggle = self._preview_size_toggle(self, "preview_size_toggle", service, rules, path)

                class _cfd_surface_mesh_controls(PyArgumentsSingletonSubItem):
                    """
                    Argument cfd_surface_mesh_controls.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.scope_proximity_to = self._scope_proximity_to(self, "scope_proximity_to", service, rules, path)
                        self.object_based_controls = self._object_based_controls(self, "object_based_controls", service, rules, path)
                        self.draw_size_control = self._draw_size_control(self, "draw_size_control", service, rules, path)
                        self.cells_per_gap = self._cells_per_gap(self, "cells_per_gap", service, rules, path)
                        self.min_size = self._min_size(self, "min_size", service, rules, path)
                        self.auto_create_scoped_sizing = self._auto_create_scoped_sizing(self, "auto_create_scoped_sizing", service, rules, path)
                        self.max_size = self._max_size(self, "max_size", service, rules, path)
                        self.save_size_field = self._save_size_field(self, "save_size_field", service, rules, path)
                        self.remesh_imported_mesh = self._remesh_imported_mesh(self, "remesh_imported_mesh", service, rules, path)
                        self.size_functions = self._size_functions(self, "size_functions", service, rules, path)
                        self.curvature_normal_angle = self._curvature_normal_angle(self, "curvature_normal_angle", service, rules, path)
                        self.refacet = self._refacet(self, "refacet", service, rules, path)
                        self.growth_rate = self._growth_rate(self, "growth_rate", service, rules, path)
                        self.preview_sizefield = self._preview_sizefield(self, "preview_sizefield", service, rules, path)
                        self.size_field_file = self._size_field_file(self, "size_field_file", service, rules, path)
                        self.size_control_file = self._size_control_file(self, "size_control_file", service, rules, path)
                        self.use_size_files = self._use_size_files(self, "use_size_files", service, rules, path)
                        self.save_size_field_file = self._save_size_field_file(self, "save_size_field_file", service, rules, path)
                        self.surface_mesh_method = self._surface_mesh_method(self, "surface_mesh_method", service, rules, path)

                    class _scope_proximity_to(PyArgumentsTextualSubItem):
                        """
                        Set proximity based refinement. Edges considers edge-to-edge proximity, while Faces considers face-to-face proximity, and Faces and Edges considers both.  More...
                        """

                    class _object_based_controls(PyArgumentsParameterSubItem):
                        """
                        Choose if you would like to ignore any small artificial gaps that may exist between two objects/bodies; especially applicable to assemblies that typically have duplicate faces and edges in between each body.
                        """

                    class _draw_size_control(PyArgumentsParameterSubItem):
                        """
                        Enable this field to display the size boxes in the graphics window.
                        """

                    class _cells_per_gap(PyArgumentsNumericalSubItem):
                        """
                        Specify the minimum number of layers of elements to be generated in the gaps. The number of cells per gap can be a real value, with a minimum value of 0.01.
                        """

                    class _min_size(PyArgumentsNumericalSubItem):
                        """
                        Specify the minimum size of the elements for the surface mesh. A minimum size between approximately 0.1 - 10 is recommended.
                        """

                    class _auto_create_scoped_sizing(PyArgumentsParameterSubItem):
                        """
                        Argument auto_create_scoped_sizing.
                        """

                    class _max_size(PyArgumentsNumericalSubItem):
                        """
                        Specify the maximum size of the elements for the surface mesh.
                        """

                    class _save_size_field(PyArgumentsParameterSubItem):
                        """
                        Argument save_size_field.
                        """

                    class _remesh_imported_mesh(PyArgumentsTextualSubItem):
                        """
                        For an imported surface mesh, determine which surfaces you wish to remesh in this task. Choices depend upon if any local sizing has been added or not.  More...
                        """

                    class _size_functions(PyArgumentsTextualSubItem):
                        """
                        Choose the type of size function that you want to apply to the surface mesh: based on curvature, proximity, or both.
                        """

                    class _curvature_normal_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify the maximum allowable angle (from 0 to 180 degrees) that one element edge is allowed to span given a particular geometry curvature. You can use this field to limit the number of elements that are generated along a curve or surface if the minimum size is too small for that particular curve.  More...
                        """

                    class _refacet(PyArgumentsParameterSubItem):
                        """
                        Argument refacet.
                        """

                    class _growth_rate(PyArgumentsNumericalSubItem):
                        """
                        Specify the increase in element edge length with each succeeding layer of elements.
                        """

                    class _preview_sizefield(PyArgumentsParameterSubItem):
                        """
                        Enable this option to visualize the size field in the graphics window.
                        """

                    class _size_field_file(PyArgumentsTextualSubItem):
                        """
                        Specify a size field file that contains the size function definitions based on specified parameters.
                        """

                    class _size_control_file(PyArgumentsTextualSubItem):
                        """
                        Specify a size controls file (\\*.szcontrol) that contains the scoped sizing control definitions. The control name and type, and the scope of the control will be included in the size control file along with global size parameters.
                        """

                    class _use_size_files(PyArgumentsTextualSubItem):
                        """
                        Specify whether or not you want to use your own size field file and/or your own size control file when generating the surface mesh.
                        """

                    class _save_size_field_file(PyArgumentsTextualSubItem):
                        """
                        Specify a size field file that contains the size function definitions based on specified parameters.
                        """

                    class _surface_mesh_method(PyArgumentsTextualSubItem):
                        """
                        Argument surface_mesh_method.
                        """

                class _separation_required(PyArgumentsParameterSubItem):
                    """
                    Choose whether or not to separate face zones. By default, this is set to No. If you choose to separate zones, specify a Separation Angle. You should separate zones when using Multizone meshing. Separation is needed in case named selections for inlets, outlets, capping, local boundary layers, etc. have not been defined within the CAD model in advance. You should only select Yes if you need to separate faces for capping, boundary conditions, or inflation on specific faces.
                    """

                class _separation_angle(PyArgumentsNumericalSubItem):
                    """
                    Specify a desired angle for determining separation. Assigning a smaller separation angle will produce more zones.
                    """

                class _remesh_selection_type(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to select your surface(s) to remesh (by label or by zone).
                    """

                class _remesh_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument remesh_zone_list.
                    """

                class _remesh_label_list(PyArgumentsTextualSubItem):
                    """
                    Argument remesh_label_list.
                    """

                class _surface_mesh_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument surface_mesh_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.volume_mesh_max_size = self._volume_mesh_max_size(self, "volume_mesh_max_size", service, rules, path)
                        self.self_intersect_check = self._self_intersect_check(self, "self_intersect_check", service, rules, path)
                        self.auto_surface_remesh = self._auto_surface_remesh(self, "auto_surface_remesh", service, rules, path)
                        self.quality_improve_collapase_skewness_limit = self._quality_improve_collapase_skewness_limit(self, "quality_improve_collapase_skewness_limit", service, rules, path)
                        self.quality_improve_skewness_limit = self._quality_improve_skewness_limit(self, "quality_improve_skewness_limit", service, rules, path)
                        self.separate_by_angle = self._separate_by_angle(self, "separate_by_angle", service, rules, path)
                        self.fold_face_limit = self._fold_face_limit(self, "fold_face_limit", service, rules, path)
                        self.parallel_region_compute = self._parallel_region_compute(self, "parallel_region_compute", service, rules, path)
                        self.remove_steps = self._remove_steps(self, "remove_steps", service, rules, path)
                        self.set_volume_mesh_max_size = self._set_volume_mesh_max_size(self, "set_volume_mesh_max_size", service, rules, path)
                        self.max_step_width = self._max_step_width(self, "max_step_width", service, rules, path)
                        self.thin_volume_meshing_auto_control_creation = self._thin_volume_meshing_auto_control_creation(self, "thin_volume_meshing_auto_control_creation", service, rules, path)
                        self.improve_quality = self._improve_quality(self, "improve_quality", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)
                        self.auto_merge = self._auto_merge(self, "auto_merge", service, rules, path)
                        self.quality_improve_max_angle = self._quality_improve_max_angle(self, "quality_improve_max_angle", service, rules, path)
                        self.auto_assign_zone_types = self._auto_assign_zone_types(self, "auto_assign_zone_types", service, rules, path)
                        self.separation_angle = self._separation_angle(self, "separation_angle", service, rules, path)

                    class _volume_mesh_max_size(PyArgumentsNumericalSubItem):
                        """
                        Specify the maximum size of the elements for the surface mesh.
                        """

                    class _self_intersect_check(PyArgumentsParameterSubItem):
                        """
                        Choose whether or not to check for self-intersecting faces. Performance may be improved if this is disabled.
                        """

                    class _auto_surface_remesh(PyArgumentsTextualSubItem):
                        """
                        Choose whether or not to automatically remesh in order to remove excessive clustering of nodes. By default (auto), this is done if local sizing has been assigned or Share Topology is invoked, but skipped if not. Performance may be improved if this is disabled. In addition, you can choose to use the much faster refaceting technique as an alternative to automatic remeshing. When importing the mesh, remeshing is only performed if this option is set to yes and then all faces are remeshed; and the refaceting option is not available because the initial mesh cannot be refaceted.
                        """

                    class _quality_improve_collapase_skewness_limit(PyArgumentsNumericalSubItem):
                        """
                        Specify the limiting skewness value for cell collapse to improve the mesh. If any remaining triangles are above this limit, these triangles will be aggressively removed using a fixed maximum angle of 120 degrees.
                        """

                    class _quality_improve_skewness_limit(PyArgumentsNumericalSubItem):
                        """
                        Specify a limiting value for skewness to improve the quality of the surface mesh. Quality improvement is attempted on those triangles where the skewness is above this limit.
                        """

                    class _separate_by_angle(PyArgumentsTextualSubItem):
                        """
                        Choose whether or not to separate zones. This is required to select faces for capping. If Named Selections have already been defined at these locations, then separation is not needed. Performance may be improved if this is disabled.
                        """

                    class _fold_face_limit(PyArgumentsNumericalSubItem):
                        """
                        Specify the value limiting when folded faces are smoothed or resolved. Folded faces are resolved while under this limit. Set this value to 0 if the number of free nodes (due to a zero-thickness wall such as a baffle for instance) falls below 10.
                        """

                    class _parallel_region_compute(PyArgumentsTextualSubItem):
                        """
                        If your geometry contains conformal regions, you can choose whether or not to compute regions in parallel. Selecting yes for this option may speed up the computation if your geometry has a large number of regions. Note that when computing regions in parallel, nodal curvature data will be lost which may affect surface remeshing.
                        """

                    class _remove_steps(PyArgumentsParameterSubItem):
                        """
                        Indicate if there are any small imperfections (ledge or step artifacts from the original CAD geometry) that can be removed as part of this task. If you select yes, then you must specify a Max Step Width.
                        """

                    class _set_volume_mesh_max_size(PyArgumentsParameterSubItem):
                        """
                        Specify the maximum size of the elements for the surface mesh.
                        """

                    class _max_step_width(PyArgumentsNumericalSubItem):
                        """
                        Specify the width of the step that you wish to remove.
                        """

                    class _thin_volume_meshing_auto_control_creation(PyArgumentsParameterSubItem):
                        """
                        If your geometry contains small edges, you can choose to extract these edge features when generating the surface mesh by selecting yes. Note that selecting yes , will always extract small edge features regardless of your selection for the Auto Remesh to Remove Clustering? option.
                        """

                    class _improve_quality(PyArgumentsParameterSubItem):
                        """
                        Choose whether or not to apply quality measures during surface mesh generation. You should disable this option when using Multizone meshing of very thin structures, relative to the minimum size.
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Display advanced options that you may want to apply to the task.
                        """

                    class _auto_merge(PyArgumentsParameterSubItem):
                        """
                        Argument auto_merge.
                        """

                    class _quality_improve_max_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify the maximum angle between the normals of adjacent faces. This quality measure is useful in locating sharp corners in complicated geometries. The angle value ranges from 0 to 180 degrees. Four consecutive attempts are made to improve the quality, each using a larger adjacent angle, until this maximum value.
                        """

                    class _auto_assign_zone_types(PyArgumentsParameterSubItem):
                        """
                        Choose whether or not to automatically assign boundary types to zones.
                        """

                    class _separation_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify a desired angle for determining separation. Assigning a smaller separation angle will produce more zones.
                        """

                class _import_type(PyArgumentsTextualSubItem):
                    """
                    Argument import_type.
                    """

                class _append_mesh(PyArgumentsParameterSubItem):
                    """
                    Argument append_mesh.
                    """

                class _cad_faceting_file_name(PyArgumentsTextualSubItem):
                    """
                    Argument cad_faceting_file_name.
                    """

                class _directory(PyArgumentsTextualSubItem):
                    """
                    Argument directory.
                    """

                class _pattern(PyArgumentsTextualSubItem):
                    """
                    Argument pattern.
                    """

                class _length_unit(PyArgumentsTextualSubItem):
                    """
                    Argument length_unit.
                    """

                class _tesselation_method(PyArgumentsTextualSubItem):
                    """
                    Argument tesselation_method.
                    """

                class _original_zones(PyArgumentsTextualSubItem):
                    """
                    Argument original_zones.
                    """

                class _execute_share_topology(PyArgumentsParameterSubItem):
                    """
                    For imported CAD assemblies with multiple parts, use this task to identify and close any problematic gaps and choose whether to join and/or intersect the problematic faces.   More...
                    """

                class _cad_faceting_controls(PyArgumentsSingletonSubItem):
                    """
                    Argument cad_faceting_controls.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.max_size = self._max_size(self, "max_size", service, rules, path)
                        self.tolerance = self._tolerance(self, "tolerance", service, rules, path)
                        self.refine_faceting = self._refine_faceting(self, "refine_faceting", service, rules, path)

                    class _max_size(PyArgumentsNumericalSubItem):
                        """
                        Specify the maximum size of the elements for the surface mesh.
                        """

                    class _tolerance(PyArgumentsNumericalSubItem):
                        """
                        Argument tolerance.
                        """

                    class _refine_faceting(PyArgumentsParameterSubItem):
                        """
                        Argument refine_faceting.
                        """

                class _cad_import_options(PyArgumentsSingletonSubItem):
                    """
                    Argument cad_import_options.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.import_part_names = self._import_part_names(self, "import_part_names", service, rules, path)
                        self.extract_features = self._extract_features(self, "extract_features", service, rules, path)
                        self.import_named_selections = self._import_named_selections(self, "import_named_selections", service, rules, path)
                        self.create_cad_assemblies = self._create_cad_assemblies(self, "create_cad_assemblies", service, rules, path)
                        self.use_part_or_body_as_suffix = self._use_part_or_body_as_suffix(self, "use_part_or_body_as_suffix", service, rules, path)
                        self.one_zone_per = self._one_zone_per(self, "one_zone_per", service, rules, path)
                        self.save_pmdb_intermediate_file = self._save_pmdb_intermediate_file(self, "save_pmdb_intermediate_file", service, rules, path)
                        self.open_all_cad_in_subdirectories = self._open_all_cad_in_subdirectories(self, "open_all_cad_in_subdirectories", service, rules, path)
                        self.feature_angle = self._feature_angle(self, "feature_angle", service, rules, path)
                        self.one_object_per = self._one_object_per(self, "one_object_per", service, rules, path)
                        self.import_curvature_data_from_cad = self._import_curvature_data_from_cad(self, "import_curvature_data_from_cad", service, rules, path)

                    class _import_part_names(PyArgumentsParameterSubItem):
                        """
                        Argument import_part_names.
                        """

                    class _extract_features(PyArgumentsParameterSubItem):
                        """
                        Argument extract_features.
                        """

                    class _import_named_selections(PyArgumentsParameterSubItem):
                        """
                        Argument import_named_selections.
                        """

                    class _create_cad_assemblies(PyArgumentsParameterSubItem):
                        """
                        Argument create_cad_assemblies.
                        """

                    class _use_part_or_body_as_suffix(PyArgumentsParameterSubItem):
                        """
                        Argument use_part_or_body_as_suffix.
                        """

                    class _one_zone_per(PyArgumentsTextualSubItem):
                        """
                        Argument one_zone_per.
                        """

                    class _save_pmdb_intermediate_file(PyArgumentsParameterSubItem):
                        """
                        Argument save_pmdb_intermediate_file.
                        """

                    class _open_all_cad_in_subdirectories(PyArgumentsParameterSubItem):
                        """
                        Argument open_all_cad_in_subdirectories.
                        """

                    class _feature_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument feature_angle.
                        """

                    class _one_object_per(PyArgumentsTextualSubItem):
                        """
                        Argument one_object_per.
                        """

                    class _import_curvature_data_from_cad(PyArgumentsParameterSubItem):
                        """
                        Argument import_curvature_data_from_cad.
                        """

                class _share_topology_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument share_topology_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.share_topology_angle = self._share_topology_angle(self, "share_topology_angle", service, rules, path)
                        self.advanced_improve = self._advanced_improve(self, "advanced_improve", service, rules, path)
                        self.per_label_list = self._per_label_list(self, "per_label_list", service, rules, path)
                        self.join_tolerance_increment = self._join_tolerance_increment(self, "join_tolerance_increment", service, rules, path)
                        self.model_is_periodic = self._model_is_periodic(self, "model_is_periodic", service, rules, path)
                        self.fluid_label_wildcard = self._fluid_label_wildcard(self, "fluid_label_wildcard", service, rules, path)
                        self.intf_label_list = self._intf_label_list(self, "intf_label_list", service, rules, path)
                        self.relative_share_topology_tolerance = self._relative_share_topology_tolerance(self, "relative_share_topology_tolerance", service, rules, path)
                        self.execute_join_intersect = self._execute_join_intersect(self, "execute_join_intersect", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)
                        self.allow_defeaturing = self._allow_defeaturing(self, "allow_defeaturing", service, rules, path)
                        self.number_of_join_tries = self._number_of_join_tries(self, "number_of_join_tries", service, rules, path)
                        self.operation = self._operation(self, "operation", service, rules, path)
                        self.rename_internals_by_body_names = self._rename_internals_by_body_names(self, "rename_internals_by_body_names", service, rules, path)
                        self.connect_label_wildcard = self._connect_label_wildcard(self, "connect_label_wildcard", service, rules, path)

                    class _share_topology_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify the threshold angle for joining face pairs.
                        """

                    class _advanced_improve(PyArgumentsParameterSubItem):
                        """
                        Argument advanced_improve.
                        """

                    class _per_label_list(PyArgumentsTextualSubItem):
                        """
                        Argument per_label_list.
                        """

                    class _join_tolerance_increment(PyArgumentsNumericalSubItem):
                        """
                        Specify the increment by which the tolerance changes for each attempt to join face pairs.
                        """

                    class _model_is_periodic(PyArgumentsParameterSubItem):
                        """
                        Choose whether or not you need to set up periodic boundaries. If you select yes, then choose your periodic boundaries from the list of available boundaries.
                        """

                    class _fluid_label_wildcard(PyArgumentsTextualSubItem):
                        """
                        Argument fluid_label_wildcard.
                        """

                    class _intf_label_list(PyArgumentsTextualSubItem):
                        """
                        Enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """

                    class _relative_share_topology_tolerance(PyArgumentsNumericalSubItem):
                        """
                        Specify the relative tolerance for joining or intersecting face pairs, or the relative tolerance for connecting edge and face pairs.
                        """

                    class _execute_join_intersect(PyArgumentsTextualSubItem):
                        """
                        Choose whether the system will only join faces, only intersect faces, or do both.
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Display advanced options that you may want to apply to the task.
                        """

                    class _allow_defeaturing(PyArgumentsParameterSubItem):
                        """
                        Argument allow_defeaturing.
                        """

                    class _number_of_join_tries(PyArgumentsNumericalSubItem):
                        """
                        Specify the number of attempts that will be made to join face pairs under the given criteria.
                        """

                    class _operation(PyArgumentsTextualSubItem):
                        """
                        Choose whether to apply share topology using the Join-Intersect method where you join and/or intersect the problematic faces, or using the Interface Connect method where you connect edges of overlapping face pairs. Note that imprinting of overlapping faces in SCDM/Discovery is highly recommended for the Interface Connect method.
                        """

                    class _rename_internals_by_body_names(PyArgumentsParameterSubItem):
                        """
                        Choose whether or not to apply body names from the imported geometry and use them in naming internal boundaries.  For instance, the internal face between two regions solid and body would be renamed to solid-body.
                        """

                    class _connect_label_wildcard(PyArgumentsTextualSubItem):
                        """
                        Enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """

                class _preview_size_toggle(PyArgumentsParameterSubItem):
                    """
                    For an imported surface mesh, use this field to visualize those boundaries that already have assigned local sizing controls (and any selected boundaries if applicable).
                    """

            def create_instance(self) -> _create_surface_meshArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_surface_meshArguments(*args)

        class create_volume_mesh_ftm(PyCommand):
            """
            This task will generate the volume mesh for all the fluid regions. It will generate the cell type based on the selection from the Volume Fill setting in the Update Region Settings  task. Boundary layer prisms will also be generated if assigned for the fluid region. Use the Edit Volume Fill Setting option to view previous settings and edit them accordingly prior to creating the volume mesh.
            Parameters
            ----------
            mesh_quality : float
            orthogonal_quality : float
                This value sets the threshold for when mesh quality improvements are automatically invoked that employ the orthogonal quality limit, and is recommended to be around 0.04.
            enable_parallel : bool
                Enable this option to perform parallel volume and continuous boundary layer (prism) meshing for fluid region(s). Applicable for poly, hexcore and poly-hexcore volume fill types.
            save_volume_mesh : bool
                Select this option to save the volume mesh.
            edit_volume_settings : bool
                Enable this option to review and/or edit the fill settings for your volume region(s).
            region_name_list : list[str]
            region_volume_fill_list : list[str]
            region_size_list : list[str]
            old_region_name_list : list[str]
            old_region_volume_fill_list : list[str]
            old_region_size_list : list[str]
            all_region_name_list : list[str]
            all_region_volume_fill_list : list[str]
            all_region_size_list : list[str]
            fast_ro : bool
            ro_ref_size : float
            max_cell_level : int
            max_cell_size : float
            max_boundary_cell_level : int
            max_boundary_cell_size : float
            ro_curv_switch_angle_criterion : float
            ro_curv_min_angle : float
            ro_curv_max_angle : float
            advanced_options : bool
                Display advanced options that you may want to apply to the task.
            spike_removal_angle : float
            dihedral_min_angle : float
            quality_method : str
                Choose from different types of mesh quality controls (aspect ratio, change in size, and so on). Choices include Orthogonal (the default for the workflows) and Enhanced Orthogonal. For more information, see  More... .
            avoid_hanging_nodes : bool
                Specify whether or not you want to avoid any potential 1:8 cell transition in the hexcore or polyhexcore region of the volume mesh, replacing any abrupt change in the cell size with tetrahedral or polyhedral cells.
            octree_peel_layers : int
                Specify the number of octree layers to be removed between the boundary and the core. The resulting cavity will be filled with tet cells for hexcore meshes and with poly cells for polyhexcore meshes.
            fill_with_size_field : bool
                Determine whether or not you want to use size fields when generating the volume mesh. Generating the volume mesh using size fields can require additional memory as you increase the number of processing cores. This is because the size field is replicated for each core as the size field is not properly distributed. When using size fields, you are limited by the size of the machine. When not using size fields, however, you require less memory and you can use a higher number of cores with limited RAM, leading to a faster mesh generation.
            octree_boundary_face_size_ratio : float
                Specify the ratio between the octree face size and the boundary face size. The default is 2.5 such that the octree mesh near the boundary is 2.5 times larger than the boundary mesh.
            global_buffer_layers : int
                Specify the number of buffer layers for the octree volume mesh. If size controls have not been defined previously, then the default is 2, otherwise the default is calculated based on the maximum growth size.
            tet_poly_growth_rate : float
                Specify the maximum growth rate for tet and poly cells. By default, this corresponds to a growth rate of 1.2.
            thin_volume_meshing_max_aspect_ratio : float
            conformal_prism_split : bool
                Since neighboring zones with different numbers of layers will lead to conformal prism layers between them, use this field to determine whether you want to split the boundary layer cells conformally or not. When this option is set to Yes, the prism sides of the two zones will share nodes. This option is only available when stair-stepping is invoked. Note that adjacent regions should have an even ratio of prism layers when using this option.
            tet_prism_stairstep_exposed_quads : bool
                This option can be used when generating a tetrahedral mesh with prism cells and is set to No by default. Selecting Yes for this option will enable stair-stepping for exposed quadrilateral faces (exposed quads) on prism cells. Stair-stepping will prevent pyramids from being created on these exposed quads, which generally would lead to poor quality in the exposed quad location.
            prism_normal_smooth_relaxation_factor : float
                Specify the smoothness factor for normal prism layers. Increasing this value will generate more prism layers especially near sharp corners. Note that this option is only available when Enable Parallel Meshing for Fluids is turned on and when Stairstep is selected for the Post Improvement Method in the Add Boundary Layers task.
            show_sub_tasks : bool

            Returns
            -------
            bool
            """
            class _create_volume_mesh_ftmArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.mesh_quality = self._mesh_quality(self, "mesh_quality", service, rules, path)
                    self.orthogonal_quality = self._orthogonal_quality(self, "orthogonal_quality", service, rules, path)
                    self.enable_parallel = self._enable_parallel(self, "enable_parallel", service, rules, path)
                    self.save_volume_mesh = self._save_volume_mesh(self, "save_volume_mesh", service, rules, path)
                    self.edit_volume_settings = self._edit_volume_settings(self, "edit_volume_settings", service, rules, path)
                    self.region_name_list = self._region_name_list(self, "region_name_list", service, rules, path)
                    self.region_volume_fill_list = self._region_volume_fill_list(self, "region_volume_fill_list", service, rules, path)
                    self.region_size_list = self._region_size_list(self, "region_size_list", service, rules, path)
                    self.old_region_name_list = self._old_region_name_list(self, "old_region_name_list", service, rules, path)
                    self.old_region_volume_fill_list = self._old_region_volume_fill_list(self, "old_region_volume_fill_list", service, rules, path)
                    self.old_region_size_list = self._old_region_size_list(self, "old_region_size_list", service, rules, path)
                    self.all_region_name_list = self._all_region_name_list(self, "all_region_name_list", service, rules, path)
                    self.all_region_volume_fill_list = self._all_region_volume_fill_list(self, "all_region_volume_fill_list", service, rules, path)
                    self.all_region_size_list = self._all_region_size_list(self, "all_region_size_list", service, rules, path)
                    self.fast_ro = self._fast_ro(self, "fast_ro", service, rules, path)
                    self.ro_ref_size = self._ro_ref_size(self, "ro_ref_size", service, rules, path)
                    self.max_cell_level = self._max_cell_level(self, "max_cell_level", service, rules, path)
                    self.max_cell_size = self._max_cell_size(self, "max_cell_size", service, rules, path)
                    self.max_boundary_cell_level = self._max_boundary_cell_level(self, "max_boundary_cell_level", service, rules, path)
                    self.max_boundary_cell_size = self._max_boundary_cell_size(self, "max_boundary_cell_size", service, rules, path)
                    self.ro_curv_switch_angle_criterion = self._ro_curv_switch_angle_criterion(self, "ro_curv_switch_angle_criterion", service, rules, path)
                    self.ro_curv_min_angle = self._ro_curv_min_angle(self, "ro_curv_min_angle", service, rules, path)
                    self.ro_curv_max_angle = self._ro_curv_max_angle(self, "ro_curv_max_angle", service, rules, path)
                    self.advanced_options = self._advanced_options(self, "advanced_options", service, rules, path)
                    self.spike_removal_angle = self._spike_removal_angle(self, "spike_removal_angle", service, rules, path)
                    self.dihedral_min_angle = self._dihedral_min_angle(self, "dihedral_min_angle", service, rules, path)
                    self.quality_method = self._quality_method(self, "quality_method", service, rules, path)
                    self.avoid_hanging_nodes = self._avoid_hanging_nodes(self, "avoid_hanging_nodes", service, rules, path)
                    self.octree_peel_layers = self._octree_peel_layers(self, "octree_peel_layers", service, rules, path)
                    self.fill_with_size_field = self._fill_with_size_field(self, "fill_with_size_field", service, rules, path)
                    self.octree_boundary_face_size_ratio = self._octree_boundary_face_size_ratio(self, "octree_boundary_face_size_ratio", service, rules, path)
                    self.global_buffer_layers = self._global_buffer_layers(self, "global_buffer_layers", service, rules, path)
                    self.tet_poly_growth_rate = self._tet_poly_growth_rate(self, "tet_poly_growth_rate", service, rules, path)
                    self.thin_volume_meshing_max_aspect_ratio = self._thin_volume_meshing_max_aspect_ratio(self, "thin_volume_meshing_max_aspect_ratio", service, rules, path)
                    self.conformal_prism_split = self._conformal_prism_split(self, "conformal_prism_split", service, rules, path)
                    self.tet_prism_stairstep_exposed_quads = self._tet_prism_stairstep_exposed_quads(self, "tet_prism_stairstep_exposed_quads", service, rules, path)
                    self.prism_normal_smooth_relaxation_factor = self._prism_normal_smooth_relaxation_factor(self, "prism_normal_smooth_relaxation_factor", service, rules, path)
                    self.show_sub_tasks = self._show_sub_tasks(self, "show_sub_tasks", service, rules, path)

                class _mesh_quality(PyArgumentsNumericalSubItem):
                    """
                    Argument mesh_quality.
                    """

                class _orthogonal_quality(PyArgumentsNumericalSubItem):
                    """
                    This value sets the threshold for when mesh quality improvements are automatically invoked that employ the orthogonal quality limit, and is recommended to be around 0.04.
                    """

                class _enable_parallel(PyArgumentsParameterSubItem):
                    """
                    Enable this option to perform parallel volume and continuous boundary layer (prism) meshing for fluid region(s). Applicable for poly, hexcore and poly-hexcore volume fill types.
                    """

                class _save_volume_mesh(PyArgumentsParameterSubItem):
                    """
                    Select this option to save the volume mesh.
                    """

                class _edit_volume_settings(PyArgumentsParameterSubItem):
                    """
                    Enable this option to review and/or edit the fill settings for your volume region(s).
                    """

                class _region_name_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_name_list.
                    """

                class _region_volume_fill_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_volume_fill_list.
                    """

                class _region_size_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_size_list.
                    """

                class _old_region_name_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_region_name_list.
                    """

                class _old_region_volume_fill_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_region_volume_fill_list.
                    """

                class _old_region_size_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_region_size_list.
                    """

                class _all_region_name_list(PyArgumentsTextualSubItem):
                    """
                    Argument all_region_name_list.
                    """

                class _all_region_volume_fill_list(PyArgumentsTextualSubItem):
                    """
                    Argument all_region_volume_fill_list.
                    """

                class _all_region_size_list(PyArgumentsTextualSubItem):
                    """
                    Argument all_region_size_list.
                    """

                class _fast_ro(PyArgumentsParameterSubItem):
                    """
                    Argument fast_ro.
                    """

                class _ro_ref_size(PyArgumentsNumericalSubItem):
                    """
                    Argument ro_ref_size.
                    """

                class _max_cell_level(PyArgumentsNumericalSubItem):
                    """
                    Argument max_cell_level.
                    """

                class _max_cell_size(PyArgumentsNumericalSubItem):
                    """
                    Argument max_cell_size.
                    """

                class _max_boundary_cell_level(PyArgumentsNumericalSubItem):
                    """
                    Argument max_boundary_cell_level.
                    """

                class _max_boundary_cell_size(PyArgumentsNumericalSubItem):
                    """
                    Argument max_boundary_cell_size.
                    """

                class _ro_curv_switch_angle_criterion(PyArgumentsNumericalSubItem):
                    """
                    Argument ro_curv_switch_angle_criterion.
                    """

                class _ro_curv_min_angle(PyArgumentsNumericalSubItem):
                    """
                    Argument ro_curv_min_angle.
                    """

                class _ro_curv_max_angle(PyArgumentsNumericalSubItem):
                    """
                    Argument ro_curv_max_angle.
                    """

                class _advanced_options(PyArgumentsParameterSubItem):
                    """
                    Display advanced options that you may want to apply to the task.
                    """

                class _spike_removal_angle(PyArgumentsNumericalSubItem):
                    """
                    Argument spike_removal_angle.
                    """

                class _dihedral_min_angle(PyArgumentsNumericalSubItem):
                    """
                    Argument dihedral_min_angle.
                    """

                class _quality_method(PyArgumentsTextualSubItem):
                    """
                    Choose from different types of mesh quality controls (aspect ratio, change in size, and so on). Choices include Orthogonal (the default for the workflows) and Enhanced Orthogonal. For more information, see  More... .
                    """

                class _avoid_hanging_nodes(PyArgumentsParameterSubItem):
                    """
                    Specify whether or not you want to avoid any potential 1:8 cell transition in the hexcore or polyhexcore region of the volume mesh, replacing any abrupt change in the cell size with tetrahedral or polyhedral cells.
                    """

                class _octree_peel_layers(PyArgumentsNumericalSubItem):
                    """
                    Specify the number of octree layers to be removed between the boundary and the core. The resulting cavity will be filled with tet cells for hexcore meshes and with poly cells for polyhexcore meshes.
                    """

                class _fill_with_size_field(PyArgumentsParameterSubItem):
                    """
                    Determine whether or not you want to use size fields when generating the volume mesh. Generating the volume mesh using size fields can require additional memory as you increase the number of processing cores. This is because the size field is replicated for each core as the size field is not properly distributed. When using size fields, you are limited by the size of the machine. When not using size fields, however, you require less memory and you can use a higher number of cores with limited RAM, leading to a faster mesh generation.
                    """

                class _octree_boundary_face_size_ratio(PyArgumentsNumericalSubItem):
                    """
                    Specify the ratio between the octree face size and the boundary face size. The default is 2.5 such that the octree mesh near the boundary is 2.5 times larger than the boundary mesh.
                    """

                class _global_buffer_layers(PyArgumentsNumericalSubItem):
                    """
                    Specify the number of buffer layers for the octree volume mesh. If size controls have not been defined previously, then the default is 2, otherwise the default is calculated based on the maximum growth size.
                    """

                class _tet_poly_growth_rate(PyArgumentsNumericalSubItem):
                    """
                    Specify the maximum growth rate for tet and poly cells. By default, this corresponds to a growth rate of 1.2.
                    """

                class _thin_volume_meshing_max_aspect_ratio(PyArgumentsNumericalSubItem):
                    """
                    Argument thin_volume_meshing_max_aspect_ratio.
                    """

                class _conformal_prism_split(PyArgumentsParameterSubItem):
                    """
                    Since neighboring zones with different numbers of layers will lead to conformal prism layers between them, use this field to determine whether you want to split the boundary layer cells conformally or not. When this option is set to Yes, the prism sides of the two zones will share nodes. This option is only available when stair-stepping is invoked. Note that adjacent regions should have an even ratio of prism layers when using this option.
                    """

                class _tet_prism_stairstep_exposed_quads(PyArgumentsParameterSubItem):
                    """
                    This option can be used when generating a tetrahedral mesh with prism cells and is set to No by default. Selecting Yes for this option will enable stair-stepping for exposed quadrilateral faces (exposed quads) on prism cells. Stair-stepping will prevent pyramids from being created on these exposed quads, which generally would lead to poor quality in the exposed quad location.
                    """

                class _prism_normal_smooth_relaxation_factor(PyArgumentsNumericalSubItem):
                    """
                    Specify the smoothness factor for normal prism layers. Increasing this value will generate more prism layers especially near sharp corners. Note that this option is only available when Enable Parallel Meshing for Fluids is turned on and when Stairstep is selected for the Post Improvement Method in the Add Boundary Layers task.
                    """

                class _show_sub_tasks(PyArgumentsParameterSubItem):
                    """
                    Argument show_sub_tasks.
                    """

            def create_instance(self) -> _create_volume_mesh_ftmArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_volume_mesh_ftmArguments(*args)

        class create_volume_mesh_wtm(PyCommand):
            """
            Generate a computational mesh for the entire volume within your geometry. As needed, specify and adjust various global properties of the boundary layer and the volume itself to ensure a comprehensive mesh for the entire flow volume. In many cases, the default values will be sufficient.  More...
            Parameters
            ----------
            solver : str
                Specify the target solver for which you want to generate the volume mesh (Fluent or CFX).
            volume_fill : str
                Specify the type of cell to be used in the volumetric mesh: polyhedra (default), poly-hexcore, hexcore, or tetrahedral.
            mesh_fluid_regions : bool
                Choose whether to mesh the fluid regions in addition to the solid regions. This is enabled by default, and can be enabled along with the Mesh Solid Regions option, however, both options cannot be turned off at the same time.
            mesh_solid_regions : bool
                Choose whether to mesh the solid regions in addition to the fluid regions. This is enabled by default, and can be enabled along with the Mesh Fluid Regions option, however, both options cannot be turned off at the same time.
            sizing_method : str
                Choose how the cell sizing controls (such as growth rate and the maximum cell length) will be evaluated: either globally or on a region-by-region basis.
            volume_fill_controls : dict[str, Any]
            region_based_preferences : bool
            re_merge_zones : bool
                After separating zones during surface meshing, here, choose to re-merge the zones prior to creating the volume mesh.
            parallel_meshing : bool
                Allows you to employ parallel settings for quicker and more efficient volume meshing. Disable this option if you are interested in only generating the volume mesh in serial mode.
            decoupled_parallel_meshing : bool
                Allows you to employ parallel settings for quicker and more efficient volume meshing. Disable this option if you are interested in only generating the volume mesh in serial mode.
            prime_meshing : bool
            volume_mesh_preferences : dict[str, Any]
            prism_preferences : dict[str, Any]
                Display global settings for your boundary layers. Note that these settings are not applied for Multizone boundary layers
            global_thin_volume_preferences : dict[str, Any]
            invoke_prims_control : str
            offset_method_type : str
                Choose the type of offset to determine how the mesh cells closest to the boundary are generated.  More...
            number_of_layers : int
                Select the number of boundary layers to be generated.
            first_aspect_ratio : float
                Specify the aspect ratio of the first layer of prism cells that are extruded from the base boundary zone.
            transition_ratio : float
                Specify the rate at which adjacent elements grow, for the smooth transition offset method.
            rate : float
                Specify the rate of growth for the boundary layer.
            first_height : float
                Specify the height of the first layer of cells in the boundary layer.
            mesh_object : str
            mesh_dead_regions : bool
            body_label_list : list[str]
            body_label_body_list : list[str]
            prism_layers : bool
            quad_tet_transition : str
            merge_cell_zones : bool
            face_scope : dict[str, Any]
            region_tet_name_list : list[str]
            region_tet_max_cell_length_list : list[str]
            region_tet_growth_rate_list : list[str]
            region_hex_name_list : list[str]
            region_hex_max_cell_length_list : list[str]
            old_region_tet_max_cell_length_list : list[str]
            old_region_tet_growth_rate_list : list[str]
            old_region_hex_max_cell_length_list : list[str]
            cfd_surface_mesh_controls : dict[str, Any]
            show_solid_fluid_meshed : bool

            Returns
            -------
            bool
            """
            class _create_volume_mesh_wtmArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.solver = self._solver(self, "solver", service, rules, path)
                    self.volume_fill = self._volume_fill(self, "volume_fill", service, rules, path)
                    self.mesh_fluid_regions = self._mesh_fluid_regions(self, "mesh_fluid_regions", service, rules, path)
                    self.mesh_solid_regions = self._mesh_solid_regions(self, "mesh_solid_regions", service, rules, path)
                    self.sizing_method = self._sizing_method(self, "sizing_method", service, rules, path)
                    self.volume_fill_controls = self._volume_fill_controls(self, "volume_fill_controls", service, rules, path)
                    self.region_based_preferences = self._region_based_preferences(self, "region_based_preferences", service, rules, path)
                    self.re_merge_zones = self._re_merge_zones(self, "re_merge_zones", service, rules, path)
                    self.parallel_meshing = self._parallel_meshing(self, "parallel_meshing", service, rules, path)
                    self.decoupled_parallel_meshing = self._decoupled_parallel_meshing(self, "decoupled_parallel_meshing", service, rules, path)
                    self.prime_meshing = self._prime_meshing(self, "prime_meshing", service, rules, path)
                    self.volume_mesh_preferences = self._volume_mesh_preferences(self, "volume_mesh_preferences", service, rules, path)
                    self.prism_preferences = self._prism_preferences(self, "prism_preferences", service, rules, path)
                    self.global_thin_volume_preferences = self._global_thin_volume_preferences(self, "global_thin_volume_preferences", service, rules, path)
                    self.invoke_prims_control = self._invoke_prims_control(self, "invoke_prims_control", service, rules, path)
                    self.offset_method_type = self._offset_method_type(self, "offset_method_type", service, rules, path)
                    self.number_of_layers = self._number_of_layers(self, "number_of_layers", service, rules, path)
                    self.first_aspect_ratio = self._first_aspect_ratio(self, "first_aspect_ratio", service, rules, path)
                    self.transition_ratio = self._transition_ratio(self, "transition_ratio", service, rules, path)
                    self.rate = self._rate(self, "rate", service, rules, path)
                    self.first_height = self._first_height(self, "first_height", service, rules, path)
                    self.mesh_object = self._mesh_object(self, "mesh_object", service, rules, path)
                    self.mesh_dead_regions = self._mesh_dead_regions(self, "mesh_dead_regions", service, rules, path)
                    self.body_label_list = self._body_label_list(self, "body_label_list", service, rules, path)
                    self.body_label_body_list = self._body_label_body_list(self, "body_label_body_list", service, rules, path)
                    self.prism_layers = self._prism_layers(self, "prism_layers", service, rules, path)
                    self.quad_tet_transition = self._quad_tet_transition(self, "quad_tet_transition", service, rules, path)
                    self.merge_cell_zones = self._merge_cell_zones(self, "merge_cell_zones", service, rules, path)
                    self.face_scope = self._face_scope(self, "face_scope", service, rules, path)
                    self.region_tet_name_list = self._region_tet_name_list(self, "region_tet_name_list", service, rules, path)
                    self.region_tet_max_cell_length_list = self._region_tet_max_cell_length_list(self, "region_tet_max_cell_length_list", service, rules, path)
                    self.region_tet_growth_rate_list = self._region_tet_growth_rate_list(self, "region_tet_growth_rate_list", service, rules, path)
                    self.region_hex_name_list = self._region_hex_name_list(self, "region_hex_name_list", service, rules, path)
                    self.region_hex_max_cell_length_list = self._region_hex_max_cell_length_list(self, "region_hex_max_cell_length_list", service, rules, path)
                    self.old_region_tet_max_cell_length_list = self._old_region_tet_max_cell_length_list(self, "old_region_tet_max_cell_length_list", service, rules, path)
                    self.old_region_tet_growth_rate_list = self._old_region_tet_growth_rate_list(self, "old_region_tet_growth_rate_list", service, rules, path)
                    self.old_region_hex_max_cell_length_list = self._old_region_hex_max_cell_length_list(self, "old_region_hex_max_cell_length_list", service, rules, path)
                    self.cfd_surface_mesh_controls = self._cfd_surface_mesh_controls(self, "cfd_surface_mesh_controls", service, rules, path)
                    self.show_solid_fluid_meshed = self._show_solid_fluid_meshed(self, "show_solid_fluid_meshed", service, rules, path)

                class _solver(PyArgumentsTextualSubItem):
                    """
                    Specify the target solver for which you want to generate the volume mesh (Fluent or CFX).
                    """

                class _volume_fill(PyArgumentsTextualSubItem):
                    """
                    Specify the type of cell to be used in the volumetric mesh: polyhedra (default), poly-hexcore, hexcore, or tetrahedral.
                    """

                class _mesh_fluid_regions(PyArgumentsParameterSubItem):
                    """
                    Choose whether to mesh the fluid regions in addition to the solid regions. This is enabled by default, and can be enabled along with the Mesh Solid Regions option, however, both options cannot be turned off at the same time.
                    """

                class _mesh_solid_regions(PyArgumentsParameterSubItem):
                    """
                    Choose whether to mesh the solid regions in addition to the fluid regions. This is enabled by default, and can be enabled along with the Mesh Fluid Regions option, however, both options cannot be turned off at the same time.
                    """

                class _sizing_method(PyArgumentsTextualSubItem):
                    """
                    Choose how the cell sizing controls (such as growth rate and the maximum cell length) will be evaluated: either globally or on a region-by-region basis.
                    """

                class _volume_fill_controls(PyArgumentsSingletonSubItem):
                    """
                    Argument volume_fill_controls.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.type = self._type(self, "type", service, rules, path)
                        self.tet_poly_max_cell_length = self._tet_poly_max_cell_length(self, "tet_poly_max_cell_length", service, rules, path)
                        self.peel_layers = self._peel_layers(self, "peel_layers", service, rules, path)
                        self.hex_min_cell_length = self._hex_min_cell_length(self, "hex_min_cell_length", service, rules, path)
                        self.buffer_layers = self._buffer_layers(self, "buffer_layers", service, rules, path)
                        self.hex_max_cell_length = self._hex_max_cell_length(self, "hex_max_cell_length", service, rules, path)
                        self.cell_sizing = self._cell_sizing(self, "cell_sizing", service, rules, path)
                        self.max_size = self._max_size(self, "max_size", service, rules, path)
                        self.hex_max_size = self._hex_max_size(self, "hex_max_size", service, rules, path)
                        self.growth_rate = self._growth_rate(self, "growth_rate", service, rules, path)

                    class _type(PyArgumentsTextualSubItem):
                        """
                        Argument type.
                        """

                    class _tet_poly_max_cell_length(PyArgumentsNumericalSubItem):
                        """
                        The maximum cell length for either the tetrahedron, polyhedron, or poly-hexcore volume fill types.
                        """

                    class _peel_layers(PyArgumentsNumericalSubItem):
                        """
                        Specify the number of layers that control the gap between the hexahedra core and the geometry.  This distance is assumed to be the height of an ideal tetrahedral cell on the boundary face.
                        """

                    class _hex_min_cell_length(PyArgumentsNumericalSubItem):
                        """
                        The minimum cell length for the hexcore or  poly-hexcore volume fill types.
                        """

                    class _buffer_layers(PyArgumentsNumericalSubItem):
                        """
                        Specify the number of additional layers required to cover the rapid transition between finer cells in the boundary mesh and the coarser cells in the initial Cartesian mesh.
                        """

                    class _hex_max_cell_length(PyArgumentsNumericalSubItem):
                        """
                        The maximum cell length for the hexahedron volume fill type.
                        """

                    class _cell_sizing(PyArgumentsTextualSubItem):
                        """
                        Argument cell_sizing.
                        """

                    class _max_size(PyArgumentsNumericalSubItem):
                        """
                        Argument max_size.
                        """

                    class _hex_max_size(PyArgumentsNumericalSubItem):
                        """
                        Argument hex_max_size.
                        """

                    class _growth_rate(PyArgumentsNumericalSubItem):
                        """
                        Specify the rate of growth for a tetrahedron or polyhedron mesh.
                        """

                class _region_based_preferences(PyArgumentsParameterSubItem):
                    """
                    Argument region_based_preferences.
                    """

                class _re_merge_zones(PyArgumentsParameterSubItem):
                    """
                    After separating zones during surface meshing, here, choose to re-merge the zones prior to creating the volume mesh.
                    """

                class _parallel_meshing(PyArgumentsParameterSubItem):
                    """
                    Allows you to employ parallel settings for quicker and more efficient volume meshing. Disable this option if you are interested in only generating the volume mesh in serial mode.
                    """

                class _decoupled_parallel_meshing(PyArgumentsParameterSubItem):
                    """
                    Allows you to employ parallel settings for quicker and more efficient volume meshing. Disable this option if you are interested in only generating the volume mesh in serial mode.
                    """

                class _prime_meshing(PyArgumentsParameterSubItem):
                    """
                    Argument prime_meshing.
                    """

                class _volume_mesh_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument volume_mesh_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.avoid_1_8_transition = self._avoid_1_8_transition(self, "avoid_1_8_transition", service, rules, path)
                        self.size_field_periodicity = self._size_field_periodicity(self, "size_field_periodicity", service, rules, path)
                        self.check_self_proximity = self._check_self_proximity(self, "check_self_proximity", service, rules, path)
                        self.quality_method = self._quality_method(self, "quality_method", service, rules, path)
                        self.use_size_field_in_solids = self._use_size_field_in_solids(self, "use_size_field_in_solids", service, rules, path)
                        self.min_poly_size = self._min_poly_size(self, "min_poly_size", service, rules, path)
                        self.add_multiple_quality_methods = self._add_multiple_quality_methods(self, "add_multiple_quality_methods", service, rules, path)
                        self.poly_in_solids = self._poly_in_solids(self, "poly_in_solids", service, rules, path)
                        self.tet_in_solids = self._tet_in_solids(self, "tet_in_solids", service, rules, path)
                        self.max_cell_size_change = self._max_cell_size_change(self, "max_cell_size_change", service, rules, path)
                        self.solid_growth_rate = self._solid_growth_rate(self, "solid_growth_rate", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)
                        self.min_face_area = self._min_face_area(self, "min_face_area", service, rules, path)
                        self.min_edge_length = self._min_edge_length(self, "min_edge_length", service, rules, path)
                        self.use_size_field = self._use_size_field(self, "use_size_field", service, rules, path)
                        self.write_prism_control_file = self._write_prism_control_file(self, "write_prism_control_file", service, rules, path)
                        self.quality_warning_limit = self._quality_warning_limit(self, "quality_warning_limit", service, rules, path)
                        self.poly_feature_angle = self._poly_feature_angle(self, "poly_feature_angle", service, rules, path)
                        self.prepare_zone_names = self._prepare_zone_names(self, "prepare_zone_names", service, rules, path)
                        self.merge_body_labels = self._merge_body_labels(self, "merge_body_labels", service, rules, path)

                    class _avoid_1_8_transition(PyArgumentsParameterSubItem):
                        """
                        Indicate whether or not you want to avoid any potential 1:8 cell transition in the hexcore region of the volume mesh, replacing any abrupt change in the cell size with polyhedral cells to improve solver performance in such transitional areas.
                        """

                    class _size_field_periodicity(PyArgumentsParameterSubItem):
                        """
                        You can use the Size Field Periodicity option (set to no by default) to specify how the size field is generated when periodic boundaries are present. Selecting yes for this option will enforce a consistent size field across periodic boundaries. This option should only be enabled if periodic boundaries are well defined prior to generating the surface mesh.
                        """

                    class _check_self_proximity(PyArgumentsParameterSubItem):
                        """
                        Choose whether or not you would like to check for proximity issues (such as overlapping surfaces, very small gaps between surfaces, very sharp angles, etc.). Problematic areas will be highlighted in the graphics window if this option is set to yes.
                        """

                    class _quality_method(PyArgumentsTextualSubItem):
                        """
                        Choose from several different types of mesh quality controls (skewness, aspect ratio, change in size, and so on). Choices include Orthogonal (the default for the workflows), Enhanced Orthogonal, and Skewness. For more information, see  More... .
                        """

                    class _use_size_field_in_solids(PyArgumentsParameterSubItem):
                        """
                        This option is available when both the Use Size Field? and Fill Polyhedra in Solids? options are enabled for the poly-hexcore fill method. By default this option is set to no, which specifies growth-rate-based sizing for polyhedra regions during poly-hexcore generation. Selecting yes for this option specifies the sizing for polyhedra regions to be size-field based and is recommended when BOI(s) or body sizing have been defined that include the polyhedra region.
                        """

                    class _min_poly_size(PyArgumentsNumericalSubItem):
                        """
                        Argument min_poly_size.
                        """

                    class _add_multiple_quality_methods(PyArgumentsTextualSubItem):
                        """
                        Argument add_multiple_quality_methods.
                        """

                    class _poly_in_solids(PyArgumentsParameterSubItem):
                        """
                        Indicate whether or not to fill only polyhedra cells in all solid regions during volume meshing using the poly-hexcore volume fill method.  The default value is no. Setting this to yes may improve meshing efficiency.
                        """

                    class _tet_in_solids(PyArgumentsParameterSubItem):
                        """
                        Argument tet_in_solids.
                        """

                    class _max_cell_size_change(PyArgumentsNumericalSubItem):
                        """
                        Argument max_cell_size_change.
                        """

                    class _solid_growth_rate(PyArgumentsNumericalSubItem):
                        """
                        Specify the rate of growth for a tetrahedron or polyhedron mesh.
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Display advanced options that you may want to apply to the task.
                        """

                    class _min_face_area(PyArgumentsNumericalSubItem):
                        """
                        Argument min_face_area.
                        """

                    class _min_edge_length(PyArgumentsNumericalSubItem):
                        """
                        Argument min_edge_length.
                        """

                    class _use_size_field(PyArgumentsParameterSubItem):
                        """
                        Specify whether or not to use size fields as part of generating the volume mesh. By default, this is set to yes when a BOI or body sizing has been defined in the Add Local Sizing task, however, for large cases, it can be turned off for the hexcore and poly-hexcore volume fill methods.
                        """

                    class _write_prism_control_file(PyArgumentsParameterSubItem):
                        """
                        Indicate whether or not you want to save a .pzmcontrol file to your working folder that will contain the boundary (prism) layer specifications.
                        """

                    class _quality_warning_limit(PyArgumentsNumericalSubItem):
                        """
                        Specify the threshold for when mesh quality improvements are automatically invoked that employ the orthogonal quality limit.
                        """

                    class _poly_feature_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify the angle to preserve features when using a polyhedral-based mesh.
                        """

                    class _prepare_zone_names(PyArgumentsParameterSubItem):
                        """
                        Indicate whether or not you want to persistently rename volume mesh components. This will make zone names equivalent to region names, and will make cell and face zone names unique.  Using this field is highly recommended for any parametric study. Persistent renaming only works if all body names are unique.
                        """

                    class _merge_body_labels(PyArgumentsParameterSubItem):
                        """
                        Determine whether or not you would like to merge bodies that contain multiple body labels when generating the volume mesh (the default is yes)
                        """

                class _prism_preferences(PyArgumentsSingletonSubItem):
                    """
                    Display global settings for your boundary layers. Note that these settings are not applied for Multizone boundary layers
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.prism_stair_step_options = self._prism_stair_step_options(self, "prism_stair_step_options", service, rules, path)
                        self.prism_keep_first_layer = self._prism_keep_first_layer(self, "prism_keep_first_layer", service, rules, path)
                        self.prism_gap_factor = self._prism_gap_factor(self, "prism_gap_factor", service, rules, path)
                        self.prism_adjacent_angle = self._prism_adjacent_angle(self, "prism_adjacent_angle", service, rules, path)
                        self.prism_min_aspect_ratio = self._prism_min_aspect_ratio(self, "prism_min_aspect_ratio", service, rules, path)
                        self.normal_smooth_relaxation_factor = self._normal_smooth_relaxation_factor(self, "normal_smooth_relaxation_factor", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)
                        self.stairstep_exposed_quads = self._stairstep_exposed_quads(self, "stairstep_exposed_quads", service, rules, path)
                        self.ignore_inflation = self._ignore_inflation(self, "ignore_inflation", service, rules, path)
                        self.prism_max_aspect_ratio = self._prism_max_aspect_ratio(self, "prism_max_aspect_ratio", service, rules, path)
                        self.merge_boundary_layers = self._merge_boundary_layers(self, "merge_boundary_layers", service, rules, path)
                        self.stair_step_icem_quality_limit = self._stair_step_icem_quality_limit(self, "stair_step_icem_quality_limit", service, rules, path)

                    class _prism_stair_step_options(PyArgumentsTextualSubItem):
                        """
                        Use this option to reduce the stair-stepping at certain locations based on quality or proximity criteria. By default, Yes allows you to retain the default stair-step handling, otherwise you can also choose No, Exclude proximity check, No, Exclude quality check, or No, Exclude both checks.
                        """

                    class _prism_keep_first_layer(PyArgumentsParameterSubItem):
                        """
                        Specify whether to retain the initial boundary layer height.
                        """

                    class _prism_gap_factor(PyArgumentsNumericalSubItem):
                        """
                        Specify the relative gap-size (based on local mesh size) between two boundary layer caps. If this limit is exceeded, the boundary layer will automatically be compressed.
                        """

                    class _prism_adjacent_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify the angle for which the boundary layer would imprint on an adjacent boundary.
                        """

                    class _prism_min_aspect_ratio(PyArgumentsNumericalSubItem):
                        """
                        Controls the minimum aspect ratio for cells at the boundary of the thin volume mesh regions. By default, this option is set to 0.3, other than for Stacked Plates, where it is set to 0.1. For flat parallel plates (not including stacked plates), it is recommended to use a value of 0.1 to produce a high quality thin volume mesh.
                        """

                    class _normal_smooth_relaxation_factor(PyArgumentsNumericalSubItem):
                        """
                        Specify the smoothness factor for normal prism layers. Increasing this value will generate more prism layers especially near sharp corners.
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Display global settings for your boundary layers. Note that these settings are not applied for Multizone boundary layers
                        """

                    class _stairstep_exposed_quads(PyArgumentsParameterSubItem):
                        """
                        This option can be used when generating a tetrahedral mesh with prism cells and is set to No by default. Selecting Yes for this option will enable stair-stepping for exposed quadrilateral faces (exposed quads) on prism cells. Stair-stepping will prevent pyramids from being created on these exposed quads, which generally would lead to poor quality in the exposed quad location.
                        """

                    class _ignore_inflation(PyArgumentsTextualSubItem):
                        """
                        Specify whether to automatically ignore boundary layers where there is an acute angle.
                        """

                    class _prism_max_aspect_ratio(PyArgumentsNumericalSubItem):
                        """
                        Specify the maximum aspect ratio for the boundary layer when proximity compression is applied.
                        """

                    class _merge_boundary_layers(PyArgumentsParameterSubItem):
                        """
                        Choose whether or not you want to have the boundary layer mesh merged into the bulk mesh.
                        """

                    class _stair_step_icem_quality_limit(PyArgumentsNumericalSubItem):
                        """
                        Argument stair_step_icem_quality_limit.
                        """

                class _global_thin_volume_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument global_thin_volume_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.show_global_thin_volume_preferences = self._show_global_thin_volume_preferences(self, "show_global_thin_volume_preferences", service, rules, path)
                        self.stair_step = self._stair_step(self, "stair_step", service, rules, path)
                        self.min_aspect_ratio = self._min_aspect_ratio(self, "min_aspect_ratio", service, rules, path)
                        self.auto_order_controls = self._auto_order_controls(self, "auto_order_controls", service, rules, path)

                    class _show_global_thin_volume_preferences(PyArgumentsParameterSubItem):
                        """
                        Display global settings for thin volume meshing.
                        """

                    class _stair_step(PyArgumentsTextualSubItem):
                        """
                        Use this option to invoke stair-stepping at thin volume mesh regions.
                        """

                    class _min_aspect_ratio(PyArgumentsNumericalSubItem):
                        """
                        Controls the minimum aspect ratio for cells at the boundary of the thin volume mesh regions. By default, this option is set to 0.3, other than for Stacked Plates, where it is set to 0.1. For flat parallel plates (not including stacked plates), it is recommended to use a value of 0.1 to produce a high quality thin volume mesh.
                        """

                    class _auto_order_controls(PyArgumentsTextualSubItem):
                        """
                        When set to yes, will automatically swap source and target faces in order to increase the success rate of the thin volume mesh generation. This option is set to yes by default for conventional thin volume meshing and is set to no when Stacked Plates is enabled.
                        """

                class _invoke_prims_control(PyArgumentsTextualSubItem):
                    """
                    Argument invoke_prims_control.
                    """

                class _offset_method_type(PyArgumentsTextualSubItem):
                    """
                    Choose the type of offset to determine how the mesh cells closest to the boundary are generated.  More...
                    """

                class _number_of_layers(PyArgumentsNumericalSubItem):
                    """
                    Select the number of boundary layers to be generated.
                    """

                class _first_aspect_ratio(PyArgumentsNumericalSubItem):
                    """
                    Specify the aspect ratio of the first layer of prism cells that are extruded from the base boundary zone.
                    """

                class _transition_ratio(PyArgumentsNumericalSubItem):
                    """
                    Specify the rate at which adjacent elements grow, for the smooth transition offset method.
                    """

                class _rate(PyArgumentsNumericalSubItem):
                    """
                    Specify the rate of growth for the boundary layer.
                    """

                class _first_height(PyArgumentsNumericalSubItem):
                    """
                    Specify the height of the first layer of cells in the boundary layer.
                    """

                class _mesh_object(PyArgumentsTextualSubItem):
                    """
                    Argument mesh_object.
                    """

                class _mesh_dead_regions(PyArgumentsParameterSubItem):
                    """
                    Argument mesh_dead_regions.
                    """

                class _body_label_list(PyArgumentsTextualSubItem):
                    """
                    Argument body_label_list.
                    """

                class _body_label_body_list(PyArgumentsTextualSubItem):
                    """
                    Argument body_label_body_list.
                    """

                class _prism_layers(PyArgumentsParameterSubItem):
                    """
                    Argument prism_layers.
                    """

                class _quad_tet_transition(PyArgumentsTextualSubItem):
                    """
                    Argument quad_tet_transition.
                    """

                class _merge_cell_zones(PyArgumentsParameterSubItem):
                    """
                    Argument merge_cell_zones.
                    """

                class _face_scope(PyArgumentsSingletonSubItem):
                    """
                    Argument face_scope.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.grow_on = self._grow_on(self, "grow_on", service, rules, path)
                        self.regions_type = self._regions_type(self, "regions_type", service, rules, path)
                        self.face_scope_mesh_object = self._face_scope_mesh_object(self, "face_scope_mesh_object", service, rules, path)
                        self.topology_list = self._topology_list(self, "topology_list", service, rules, path)

                    class _grow_on(PyArgumentsTextualSubItem):
                        """
                        Argument grow_on.
                        """

                    class _regions_type(PyArgumentsTextualSubItem):
                        """
                        Argument regions_type.
                        """

                    class _face_scope_mesh_object(PyArgumentsTextualSubItem):
                        """
                        Argument face_scope_mesh_object.
                        """

                    class _topology_list(PyArgumentsTextualSubItem):
                        """
                        Argument topology_list.
                        """

                class _region_tet_name_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_tet_name_list.
                    """

                class _region_tet_max_cell_length_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_tet_max_cell_length_list.
                    """

                class _region_tet_growth_rate_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_tet_growth_rate_list.
                    """

                class _region_hex_name_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_hex_name_list.
                    """

                class _region_hex_max_cell_length_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_hex_max_cell_length_list.
                    """

                class _old_region_tet_max_cell_length_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_region_tet_max_cell_length_list.
                    """

                class _old_region_tet_growth_rate_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_region_tet_growth_rate_list.
                    """

                class _old_region_hex_max_cell_length_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_region_hex_max_cell_length_list.
                    """

                class _cfd_surface_mesh_controls(PyArgumentsSingletonSubItem):
                    """
                    Argument cfd_surface_mesh_controls.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.scope_proximity_to = self._scope_proximity_to(self, "scope_proximity_to", service, rules, path)
                        self.object_based_controls = self._object_based_controls(self, "object_based_controls", service, rules, path)
                        self.draw_size_control = self._draw_size_control(self, "draw_size_control", service, rules, path)
                        self.cells_per_gap = self._cells_per_gap(self, "cells_per_gap", service, rules, path)
                        self.min_size = self._min_size(self, "min_size", service, rules, path)
                        self.preview_sizefield = self._preview_sizefield(self, "preview_sizefield", service, rules, path)
                        self.max_size = self._max_size(self, "max_size", service, rules, path)
                        self.save_size_field = self._save_size_field(self, "save_size_field", service, rules, path)
                        self.remesh_imported_mesh = self._remesh_imported_mesh(self, "remesh_imported_mesh", service, rules, path)
                        self.size_functions = self._size_functions(self, "size_functions", service, rules, path)
                        self.curvature_normal_angle = self._curvature_normal_angle(self, "curvature_normal_angle", service, rules, path)
                        self.growth_rate = self._growth_rate(self, "growth_rate", service, rules, path)
                        self.refacet = self._refacet(self, "refacet", service, rules, path)
                        self.auto_create_scoped_sizing = self._auto_create_scoped_sizing(self, "auto_create_scoped_sizing", service, rules, path)
                        self.size_field_file = self._size_field_file(self, "size_field_file", service, rules, path)
                        self.size_control_file = self._size_control_file(self, "size_control_file", service, rules, path)
                        self.use_size_files = self._use_size_files(self, "use_size_files", service, rules, path)
                        self.save_size_field_file = self._save_size_field_file(self, "save_size_field_file", service, rules, path)
                        self.surface_mesh_method = self._surface_mesh_method(self, "surface_mesh_method", service, rules, path)

                    class _scope_proximity_to(PyArgumentsTextualSubItem):
                        """
                        Argument scope_proximity_to.
                        """

                    class _object_based_controls(PyArgumentsParameterSubItem):
                        """
                        Argument object_based_controls.
                        """

                    class _draw_size_control(PyArgumentsParameterSubItem):
                        """
                        Argument draw_size_control.
                        """

                    class _cells_per_gap(PyArgumentsNumericalSubItem):
                        """
                        Argument cells_per_gap.
                        """

                    class _min_size(PyArgumentsNumericalSubItem):
                        """
                        Argument min_size.
                        """

                    class _preview_sizefield(PyArgumentsParameterSubItem):
                        """
                        Argument preview_sizefield.
                        """

                    class _max_size(PyArgumentsNumericalSubItem):
                        """
                        Argument max_size.
                        """

                    class _save_size_field(PyArgumentsParameterSubItem):
                        """
                        Argument save_size_field.
                        """

                    class _remesh_imported_mesh(PyArgumentsTextualSubItem):
                        """
                        Argument remesh_imported_mesh.
                        """

                    class _size_functions(PyArgumentsTextualSubItem):
                        """
                        Argument size_functions.
                        """

                    class _curvature_normal_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument curvature_normal_angle.
                        """

                    class _growth_rate(PyArgumentsNumericalSubItem):
                        """
                        Specify the rate of growth for a tetrahedron or polyhedron mesh.
                        """

                    class _refacet(PyArgumentsParameterSubItem):
                        """
                        Argument refacet.
                        """

                    class _auto_create_scoped_sizing(PyArgumentsParameterSubItem):
                        """
                        Argument auto_create_scoped_sizing.
                        """

                    class _size_field_file(PyArgumentsTextualSubItem):
                        """
                        Argument size_field_file.
                        """

                    class _size_control_file(PyArgumentsTextualSubItem):
                        """
                        Argument size_control_file.
                        """

                    class _use_size_files(PyArgumentsTextualSubItem):
                        """
                        Argument use_size_files.
                        """

                    class _save_size_field_file(PyArgumentsTextualSubItem):
                        """
                        Argument save_size_field_file.
                        """

                    class _surface_mesh_method(PyArgumentsTextualSubItem):
                        """
                        Argument surface_mesh_method.
                        """

                class _show_solid_fluid_meshed(PyArgumentsParameterSubItem):
                    """
                    Argument show_solid_fluid_meshed.
                    """

            def create_instance(self) -> _create_volume_mesh_wtmArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_volume_mesh_wtmArguments(*args)

        class create_zero_thickness_geometry(PyCommand):
            """
            Add thickness to any zero-thickness portions of your geometry (such as baffles or interior walls) where those portions of the geometry are relevant to your simulation. Not all portions of the geometry require a thickness, however, a more refined surface mesh can be generated if all important and relevant aspects of the geometry have a certain thickness. More...
            Parameters
            ----------
            zero_thickness_name : str
                Specify a name for the thickness control or use the default value.
            selection_type : str
                Choose how you want to make your selection (by object, label, or zone name).
            zone_selection_list : list[str]
                Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_location : list[str]
            object_selection_list : list[str]
                Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            label_selection_list : list[str]
                Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            distance : float
                Specify a value that adds thickness to the selected object. Thickness is applied in the normal direction. Negative values are allowed to preview the opposite/flipped direction. The original face normal will be kept, but you can add thickness in either direction based on a positive or negative value.

            Returns
            -------
            bool
            """
            class _create_zero_thickness_geometryArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.zero_thickness_name = self._zero_thickness_name(self, "zero_thickness_name", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.zone_selection_list = self._zone_selection_list(self, "zone_selection_list", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.object_selection_list = self._object_selection_list(self, "object_selection_list", service, rules, path)
                    self.label_selection_list = self._label_selection_list(self, "label_selection_list", service, rules, path)
                    self.distance = self._distance(self, "distance", service, rules, path)

                class _zero_thickness_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the thickness control or use the default value.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to make your selection (by object, label, or zone name).
                    """

                class _zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _label_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _distance(PyArgumentsNumericalSubItem):
                    """
                    Specify a value that adds thickness to the selected object. Thickness is applied in the normal direction. Negative values are allowed to preview the opposite/flipped direction. The original face normal will be kept, but you can add thickness in either direction based on a positive or negative value.
                    """

            def create_instance(self) -> _create_zero_thickness_geometryArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_zero_thickness_geometryArguments(*args)

        class custom_journal_task(PyCommand):
            """
            Customize your workflow using journaling commands. Use a text editor to copy portions of any of your own journal files, and paste them into this task to perform additional meshing refinements.  More...
            Parameters
            ----------
            journal_string : str
                Enter one or more journal commands.
            python_journal : bool
            prime_journal : bool

            Returns
            -------
            bool
            """
            class _custom_journal_taskArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.journal_string = self._journal_string(self, "journal_string", service, rules, path)
                    self.python_journal = self._python_journal(self, "python_journal", service, rules, path)
                    self.prime_journal = self._prime_journal(self, "prime_journal", service, rules, path)

                class _journal_string(PyArgumentsTextualSubItem):
                    """
                    Enter one or more journal commands.
                    """

                class _python_journal(PyArgumentsParameterSubItem):
                    """
                    Argument python_journal.
                    """

                class _prime_journal(PyArgumentsParameterSubItem):
                    """
                    Argument prime_journal.
                    """

            def create_instance(self) -> _custom_journal_taskArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._custom_journal_taskArguments(*args)

        class define_boundary_layer_controls(PyCommand):
            """
            Improve how the boundary layer flow along the walls of the geometry is captured using specialized boundary layer elements within the volume mesh (also called prisms or inflation layers). You can use this task to assign different fluid regions to have their own boundary layer controls. For more layers (greater than 3), consider adding 1 layer and performing anisotropic adaption in the solver. More...
            Parameters
            ----------
            add_child : bool
                Determine whether or not you want to better capture flow in and around the boundary layer of your fluid regions.
            prisms_settings_name : str
                Specify a name for the boundary layer control or use the default value.
            aspect_ratio : float
                Specify the ratio of the prism base length to the prism layer height.
            growth_rate : float
                Specify the rate of growth of the boundary layer.
            offset_method_type : str
                Choose the method that will be used to create the boundary layer, or prism, controls.
            last_ratio_percentage : float
                Specify the offset height of the last layer as a percentage of the local base mesh size.
            first_height : float
                Specify the height of the first layer of cells in the boundary layer.
            prism_layers : int
                Specify the number of cell layers you require along the boundary.
            region_selection_list : list[str]
                Choose one or more regions from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...

            Returns
            -------
            bool
            """
            class _define_boundary_layer_controlsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.add_child = self._add_child(self, "add_child", service, rules, path)
                    self.prisms_settings_name = self._prisms_settings_name(self, "prisms_settings_name", service, rules, path)
                    self.aspect_ratio = self._aspect_ratio(self, "aspect_ratio", service, rules, path)
                    self.growth_rate = self._growth_rate(self, "growth_rate", service, rules, path)
                    self.offset_method_type = self._offset_method_type(self, "offset_method_type", service, rules, path)
                    self.last_ratio_percentage = self._last_ratio_percentage(self, "last_ratio_percentage", service, rules, path)
                    self.first_height = self._first_height(self, "first_height", service, rules, path)
                    self.prism_layers = self._prism_layers(self, "prism_layers", service, rules, path)
                    self.region_selection_list = self._region_selection_list(self, "region_selection_list", service, rules, path)

                class _add_child(PyArgumentsParameterSubItem):
                    """
                    Determine whether or not you want to better capture flow in and around the boundary layer of your fluid regions.
                    """

                class _prisms_settings_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the boundary layer control or use the default value.
                    """

                class _aspect_ratio(PyArgumentsNumericalSubItem):
                    """
                    Specify the ratio of the prism base length to the prism layer height.
                    """

                class _growth_rate(PyArgumentsNumericalSubItem):
                    """
                    Specify the rate of growth of the boundary layer.
                    """

                class _offset_method_type(PyArgumentsTextualSubItem):
                    """
                    Choose the method that will be used to create the boundary layer, or prism, controls.
                    """

                class _last_ratio_percentage(PyArgumentsNumericalSubItem):
                    """
                    Specify the offset height of the last layer as a percentage of the local base mesh size.
                    """

                class _first_height(PyArgumentsNumericalSubItem):
                    """
                    Specify the height of the first layer of cells in the boundary layer.
                    """

                class _prism_layers(PyArgumentsNumericalSubItem):
                    """
                    Specify the number of cell layers you require along the boundary.
                    """

                class _region_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more regions from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

            def create_instance(self) -> _define_boundary_layer_controlsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._define_boundary_layer_controlsArguments(*args)

        class define_global_sizing(PyCommand):
            """
            Command define_global_sizing.

            Parameters
            ----------
            min_size : float
            max_size : float
            growth_rate : float
            size_functions : str
            curvature_normal_angle : float
            cells_per_gap : float
            scope_proximity_to : str
            mesher : str
            prime_size_control_ids : list[int]
            reverse_edge_zone_orientationfor_persistent : list[int]
            enable_multi_threading : bool
            number_of_multi_threads : int

            Returns
            -------
            bool
            """
            class _define_global_sizingArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.min_size = self._min_size(self, "min_size", service, rules, path)
                    self.max_size = self._max_size(self, "max_size", service, rules, path)
                    self.growth_rate = self._growth_rate(self, "growth_rate", service, rules, path)
                    self.size_functions = self._size_functions(self, "size_functions", service, rules, path)
                    self.curvature_normal_angle = self._curvature_normal_angle(self, "curvature_normal_angle", service, rules, path)
                    self.cells_per_gap = self._cells_per_gap(self, "cells_per_gap", service, rules, path)
                    self.scope_proximity_to = self._scope_proximity_to(self, "scope_proximity_to", service, rules, path)
                    self.mesher = self._mesher(self, "mesher", service, rules, path)
                    self.prime_size_control_ids = self._prime_size_control_ids(self, "prime_size_control_ids", service, rules, path)
                    self.reverse_edge_zone_orientationfor_persistent = self._reverse_edge_zone_orientationfor_persistent(self, "reverse_edge_zone_orientationfor_persistent", service, rules, path)
                    self.enable_multi_threading = self._enable_multi_threading(self, "enable_multi_threading", service, rules, path)
                    self.number_of_multi_threads = self._number_of_multi_threads(self, "number_of_multi_threads", service, rules, path)

                class _min_size(PyArgumentsNumericalSubItem):
                    """
                    Argument min_size.
                    """

                class _max_size(PyArgumentsNumericalSubItem):
                    """
                    Argument max_size.
                    """

                class _growth_rate(PyArgumentsNumericalSubItem):
                    """
                    Argument growth_rate.
                    """

                class _size_functions(PyArgumentsTextualSubItem):
                    """
                    Argument size_functions.
                    """

                class _curvature_normal_angle(PyArgumentsNumericalSubItem):
                    """
                    Argument curvature_normal_angle.
                    """

                class _cells_per_gap(PyArgumentsNumericalSubItem):
                    """
                    Argument cells_per_gap.
                    """

                class _scope_proximity_to(PyArgumentsTextualSubItem):
                    """
                    Argument scope_proximity_to.
                    """

                class _mesher(PyArgumentsTextualSubItem):
                    """
                    Argument mesher.
                    """

                class _prime_size_control_ids(PyArgumentsNumericalSubItem):
                    """
                    Argument prime_size_control_ids.
                    """

                class _reverse_edge_zone_orientationfor_persistent(PyArgumentsNumericalSubItem):
                    """
                    Argument reverse_edge_zone_orientationfor_persistent.
                    """

                class _enable_multi_threading(PyArgumentsParameterSubItem):
                    """
                    Argument enable_multi_threading.
                    """

                class _number_of_multi_threads(PyArgumentsNumericalSubItem):
                    """
                    Argument number_of_multi_threads.
                    """

            def create_instance(self) -> _define_global_sizingArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._define_global_sizingArguments(*args)

        class define_leakage_threshold(PyCommand):
            """
            Define leakage threshold size to fix any potential leakages that may occur due to any missing, misaligned parts, or small imperfections from the imported geometry. These holes may be larger than any of your initial local size controls, resulting in leaks that need to be closed. Use the Preview Leakages button and associated controls repeatedly to identify holes that need to be closed. Leakages can be closed to a void region or inside an object. More...
            Parameters
            ----------
            add_child : bool
                Indicate whether or not you need to define a leakage threshold for one or more regions.
            leakage_name : str
                Specify a name for the leakage threshold or use the default value.
            selection_type : str
                Choose how you want to make your selection (by object or by a previously identified region).
            dead_regions_list : list[str]
                Choose one or more regions from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            region_selection_single : list[str]
                Choose a single region from the list of identified regions below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            dead_regions_size : float
                The leakage threshold size is based on multiples of two. For example, if leaks are detected at 8 but not at 16 (for example, 2*8), then the threshold size is 16, and any leakage smaller than 16 will be closed.
            plane_clipping_value : int
                Use the slider to move the clipping plane along the axis of the selected X, Y, or Z direction.
            plane_direction : str
                Indicates the direction in which the clipping plane faces.
            flip_direction : bool
                Change the orientation of the clipping plane, exposing the mesh on the opposite side.

            Returns
            -------
            bool
            """
            class _define_leakage_thresholdArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.add_child = self._add_child(self, "add_child", service, rules, path)
                    self.leakage_name = self._leakage_name(self, "leakage_name", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.dead_regions_list = self._dead_regions_list(self, "dead_regions_list", service, rules, path)
                    self.region_selection_single = self._region_selection_single(self, "region_selection_single", service, rules, path)
                    self.dead_regions_size = self._dead_regions_size(self, "dead_regions_size", service, rules, path)
                    self.plane_clipping_value = self._plane_clipping_value(self, "plane_clipping_value", service, rules, path)
                    self.plane_direction = self._plane_direction(self, "plane_direction", service, rules, path)
                    self.flip_direction = self._flip_direction(self, "flip_direction", service, rules, path)

                class _add_child(PyArgumentsParameterSubItem):
                    """
                    Indicate whether or not you need to define a leakage threshold for one or more regions.
                    """

                class _leakage_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the leakage threshold or use the default value.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to make your selection (by object or by a previously identified region).
                    """

                class _dead_regions_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more regions from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _region_selection_single(PyArgumentsTextualSubItem):
                    """
                    Choose a single region from the list of identified regions below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _dead_regions_size(PyArgumentsNumericalSubItem):
                    """
                    The leakage threshold size is based on multiples of two. For example, if leaks are detected at 8 but not at 16 (for example, 2\\*8), then the threshold size is 16, and any leakage smaller than 16 will be closed.
                    """

                class _plane_clipping_value(PyArgumentsNumericalSubItem):
                    """
                    Use the slider to move the clipping plane along the axis of the selected X, Y, or Z direction.
                    """

                class _plane_direction(PyArgumentsTextualSubItem):
                    """
                    Indicates the direction in which the clipping plane faces.
                    """

                class _flip_direction(PyArgumentsParameterSubItem):
                    """
                    Change the orientation of the clipping plane, exposing the mesh on the opposite side.
                    """

            def create_instance(self) -> _define_leakage_thresholdArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._define_leakage_thresholdArguments(*args)

        class describe_geometry(PyCommand):
            """
            Specify the type of geometry you are importing: whether it is a solid model a fluid model, or both. The workflow changes based on your selection. Additionally, for fluid volume extraction, you need to indicate whether or not any openings need to be closed.  More...
            Parameters
            ----------
            setup_type : str
                Choose whether your geometry represents only a solid body, only a fluid body, or both a solid and fluid body.
            capping_required : bool
                Choose whether or not you are going to perform any capping operations, thereby enclosing a fluid region.
            wall_to_internal : bool
                Choose whether or not to change interior fluid-fluid boundaries from type "wall" to "internal". Only internal boundaries bounded by two fluid regions are converted into internal zone types. If new fluid regions are assigned, this task is executed after the Update Regions task. Internal boundaries that are designated as "baffles" are retained as walls.
            invoke_share_topology : str
                For CAD assemblies with multiple parts, choose whether or not to identify and close any problematic gaps and whether to join and/or intersect problematic faces. This will add an Apply Share Topology task to your workflow. Note that in situations where you want to use overlapping non-conformal interfaces, you must use the non-conformal option. In all other situations, such as when you have totally disconnected bodies (that is, with no overlap), you should instead elect to choose the Share Topology option even if there is nothing to share.
            non_conformal : bool
                Determine whether or not you want to create non-conformal meshes between the objects in your geometry. Note that in situations where you want to use overlapping non-conformal interfaces, you must use the non-conformal option. In all other situations, such as when you have totally disconnected bodies (that is, with no overlap), you should instead elect to choose the Share Topology option even if there is nothing to share.
            multizone : bool
                Determine whether or not you want to perform multi-zone meshing on your geometry. Selecting Yes will add an Add Multizone Controls task and a Generate Multizone Mesh task to your workflow.
            setup_internals : list[str]
            setup_internal_types : list[str]
            old_zone_list : list[str]
            old_zone_type_list : list[str]
            region_list : list[str]
            edge_zone_list : list[str]
            edge_labels : list[str]
            duplicates : bool
            fluid_regions : list[str]
            improve_surface_mesh_preferences : dict[str, Any]

            Returns
            -------
            bool
            """
            class _describe_geometryArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.setup_type = self._setup_type(self, "setup_type", service, rules, path)
                    self.capping_required = self._capping_required(self, "capping_required", service, rules, path)
                    self.wall_to_internal = self._wall_to_internal(self, "wall_to_internal", service, rules, path)
                    self.invoke_share_topology = self._invoke_share_topology(self, "invoke_share_topology", service, rules, path)
                    self.non_conformal = self._non_conformal(self, "non_conformal", service, rules, path)
                    self.multizone = self._multizone(self, "multizone", service, rules, path)
                    self.setup_internals = self._setup_internals(self, "setup_internals", service, rules, path)
                    self.setup_internal_types = self._setup_internal_types(self, "setup_internal_types", service, rules, path)
                    self.old_zone_list = self._old_zone_list(self, "old_zone_list", service, rules, path)
                    self.old_zone_type_list = self._old_zone_type_list(self, "old_zone_type_list", service, rules, path)
                    self.region_list = self._region_list(self, "region_list", service, rules, path)
                    self.edge_zone_list = self._edge_zone_list(self, "edge_zone_list", service, rules, path)
                    self.edge_labels = self._edge_labels(self, "edge_labels", service, rules, path)
                    self.duplicates = self._duplicates(self, "duplicates", service, rules, path)
                    self.fluid_regions = self._fluid_regions(self, "fluid_regions", service, rules, path)
                    self.improve_surface_mesh_preferences = self._improve_surface_mesh_preferences(self, "improve_surface_mesh_preferences", service, rules, path)

                class _setup_type(PyArgumentsTextualSubItem):
                    """
                    Choose whether your geometry represents only a solid body, only a fluid body, or both a solid and fluid body.
                    """

                class _capping_required(PyArgumentsParameterSubItem):
                    """
                    Choose whether or not you are going to perform any capping operations, thereby enclosing a fluid region.
                    """

                class _wall_to_internal(PyArgumentsParameterSubItem):
                    """
                    Choose whether or not to change interior fluid-fluid boundaries from type "wall" to "internal". Only internal boundaries bounded by two fluid regions are converted into internal zone types. If new fluid regions are assigned, this task is executed after the Update Regions task. Internal boundaries that are designated as "baffles" are retained as walls.
                    """

                class _invoke_share_topology(PyArgumentsTextualSubItem):
                    """
                    For CAD assemblies with multiple parts, choose whether or not to identify and close any problematic gaps and whether to join and/or intersect problematic faces. This will add an Apply Share Topology task to your workflow. Note that in situations where you want to use overlapping non-conformal interfaces, you must use the non-conformal option. In all other situations, such as when you have totally disconnected bodies (that is, with no overlap), you should instead elect to choose the Share Topology option even if there is nothing to share.
                    """

                class _non_conformal(PyArgumentsParameterSubItem):
                    """
                    Determine whether or not you want to create non-conformal meshes between the objects in your geometry. Note that in situations where you want to use overlapping non-conformal interfaces, you must use the non-conformal option. In all other situations, such as when you have totally disconnected bodies (that is, with no overlap), you should instead elect to choose the Share Topology option even if there is nothing to share.
                    """

                class _multizone(PyArgumentsParameterSubItem):
                    """
                    Determine whether or not you want to perform multi-zone meshing on your geometry. Selecting Yes will add an Add Multizone Controls task and a Generate Multizone Mesh task to your workflow.
                    """

                class _setup_internals(PyArgumentsTextualSubItem):
                    """
                    Argument setup_internals.
                    """

                class _setup_internal_types(PyArgumentsTextualSubItem):
                    """
                    Argument setup_internal_types.
                    """

                class _old_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_zone_list.
                    """

                class _old_zone_type_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_zone_type_list.
                    """

                class _region_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_list.
                    """

                class _edge_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument edge_zone_list.
                    """

                class _edge_labels(PyArgumentsTextualSubItem):
                    """
                    Argument edge_labels.
                    """

                class _duplicates(PyArgumentsParameterSubItem):
                    """
                    Argument duplicates.
                    """

                class _fluid_regions(PyArgumentsTextualSubItem):
                    """
                    Argument fluid_regions.
                    """

                class _improve_surface_mesh_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument improve_surface_mesh_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.si_improve_dihedral_angle = self._si_improve_dihedral_angle(self, "si_improve_dihedral_angle", service, rules, path)
                        self.si_quality_iterations = self._si_quality_iterations(self, "si_quality_iterations", service, rules, path)
                        self.advanced_improve = self._advanced_improve(self, "advanced_improve", service, rules, path)
                        self.si_quality_collapse_limit = self._si_quality_collapse_limit(self, "si_quality_collapse_limit", service, rules, path)
                        self.si_step_width = self._si_step_width(self, "si_step_width", service, rules, path)
                        self.si_quality_max_angle = self._si_quality_max_angle(self, "si_quality_max_angle", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)
                        self.si_step_quality_limit = self._si_step_quality_limit(self, "si_step_quality_limit", service, rules, path)
                        self.allow_defeaturing = self._allow_defeaturing(self, "allow_defeaturing", service, rules, path)
                        self.si_dihedral_angle = self._si_dihedral_angle(self, "si_dihedral_angle", service, rules, path)
                        self.si_remove_step = self._si_remove_step(self, "si_remove_step", service, rules, path)

                    class _si_improve_dihedral_angle(PyArgumentsParameterSubItem):
                        """
                        Argument si_improve_dihedral_angle.
                        """

                    class _si_quality_iterations(PyArgumentsNumericalSubItem):
                        """
                        Argument si_quality_iterations.
                        """

                    class _advanced_improve(PyArgumentsParameterSubItem):
                        """
                        Argument advanced_improve.
                        """

                    class _si_quality_collapse_limit(PyArgumentsNumericalSubItem):
                        """
                        Argument si_quality_collapse_limit.
                        """

                    class _si_step_width(PyArgumentsNumericalSubItem):
                        """
                        Argument si_step_width.
                        """

                    class _si_quality_max_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument si_quality_max_angle.
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Argument show_in_gui.
                        """

                    class _si_step_quality_limit(PyArgumentsNumericalSubItem):
                        """
                        Argument si_step_quality_limit.
                        """

                    class _allow_defeaturing(PyArgumentsParameterSubItem):
                        """
                        Argument allow_defeaturing.
                        """

                    class _si_dihedral_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument si_dihedral_angle.
                        """

                    class _si_remove_step(PyArgumentsParameterSubItem):
                        """
                        Argument si_remove_step.
                        """

            def create_instance(self) -> _describe_geometryArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._describe_geometryArguments(*args)

        class describe_geometry_and_flow(PyCommand):
            """
            Specify the type of geometry you have and the type of flow you are trying to simulate. You can determine whether the flow is an external flow around an object, or whether it is an internal flow inside an object. For external flows, you can choose to add an enclosure. For internal flows, you can choose to cover large openings to extract the flow region, or rely on automatically detecting and closing any leaks to the outer domain. In either case, you are also able to add refinement regions in and around your geometry. More...
            Parameters
            ----------
            flow_type : str
                Specify the type of flow you want to simulate: external flow, internal flow, or both. The appropriate Standard Options (for example adding an enclosure, adding caps, etc.) will be selected for you, depending on your choice.
            geometry_options : bool
                Display standard geometry-based options that you may want to apply to the workflow.
            add_enclosure : bool
                Specify whether you are going to need to add an external flow boundary around your imported geometry. If so, this will add a Create External Flow Boundaries task to the workflow.
            close_caps : bool
                Specify whether or not you will need to cover, or cap, and large holes in order to create an internal fluid flow region. If so, this will add an Enclose Fluid Regions (Capping) task to the workflow.
            local_refinement_regions : bool
                Specify whether or not you will need to add local refinement in and around the imported geometry. If so, this will add a Create Local Refinement Regions task to the workflow.
            describe_geometry_and_flow_options : dict[str, Any]
            all_task_list : list[str]

            Returns
            -------
            bool
            """
            class _describe_geometry_and_flowArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.flow_type = self._flow_type(self, "flow_type", service, rules, path)
                    self.geometry_options = self._geometry_options(self, "geometry_options", service, rules, path)
                    self.add_enclosure = self._add_enclosure(self, "add_enclosure", service, rules, path)
                    self.close_caps = self._close_caps(self, "close_caps", service, rules, path)
                    self.local_refinement_regions = self._local_refinement_regions(self, "local_refinement_regions", service, rules, path)
                    self.describe_geometry_and_flow_options = self._describe_geometry_and_flow_options(self, "describe_geometry_and_flow_options", service, rules, path)
                    self.all_task_list = self._all_task_list(self, "all_task_list", service, rules, path)

                class _flow_type(PyArgumentsTextualSubItem):
                    """
                    Specify the type of flow you want to simulate: external flow, internal flow, or both. The appropriate Standard Options (for example adding an enclosure, adding caps, etc.) will be selected for you, depending on your choice.
                    """

                class _geometry_options(PyArgumentsParameterSubItem):
                    """
                    Display standard geometry-based options that you may want to apply to the workflow.
                    """

                class _add_enclosure(PyArgumentsParameterSubItem):
                    """
                    Specify whether you are going to need to add an external flow boundary around your imported geometry. If so, this will add a Create External Flow Boundaries task to the workflow.
                    """

                class _close_caps(PyArgumentsParameterSubItem):
                    """
                    Specify whether or not you will need to cover, or cap, and large holes in order to create an internal fluid flow region. If so, this will add an Enclose Fluid Regions (Capping) task to the workflow.
                    """

                class _local_refinement_regions(PyArgumentsParameterSubItem):
                    """
                    Specify whether or not you will need to add local refinement in and around the imported geometry. If so, this will add a Create Local Refinement Regions task to the workflow.
                    """

                class _describe_geometry_and_flow_options(PyArgumentsSingletonSubItem):
                    """
                    Argument describe_geometry_and_flow_options.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.porous_regions = self._porous_regions(self, "porous_regions", service, rules, path)
                        self.enable_prime_wrapper = self._enable_prime_wrapper(self, "enable_prime_wrapper", service, rules, path)
                        self.advanced_options = self._advanced_options(self, "advanced_options", service, rules, path)
                        self.extract_edge_features = self._extract_edge_features(self, "extract_edge_features", service, rules, path)
                        self.moving_objects = self._moving_objects(self, "moving_objects", service, rules, path)
                        self.zero_thickness = self._zero_thickness(self, "zero_thickness", service, rules, path)
                        self.enable_overset = self._enable_overset(self, "enable_overset", service, rules, path)
                        self.identify_regions = self._identify_regions(self, "identify_regions", service, rules, path)
                        self.close_leakges = self._close_leakges(self, "close_leakges", service, rules, path)
                        self.close_leakages = self._close_leakages(self, "close_leakages", service, rules, path)

                    class _porous_regions(PyArgumentsParameterSubItem):
                        """
                        Specify whether or not you will have any porous regions in your geometry. If so, then a Create Porous Regions task will be added to the workflow. A simple primitive rectangle will be placed over complex and detailed geometry of a porous region (for example, fins and tubes of a heat exchanger).  With buffer layer:
                        """

                    class _enable_prime_wrapper(PyArgumentsParameterSubItem):
                        """
                        Argument enable_prime_wrapper.
                        """

                    class _advanced_options(PyArgumentsParameterSubItem):
                        """
                        Display advanced options that you may want to apply to the workflow.
                        """

                    class _extract_edge_features(PyArgumentsParameterSubItem):
                        """
                        Specify whether or not you will need to extract additional edge features from your imported geometry. These edge features will be captured. If so, then an Extract Edge Features task will be added to the workflow.
                        """

                    class _moving_objects(PyArgumentsParameterSubItem):
                        """
                        Specify whether or not you will need to create or identify any specialized construction surfaces within your geometry or flow that need to be identified (such as capping surfaces or cylindrical surfaces to be used for moving reference frames, etc.). If so, then an Identify Construction Surfaces task will be added to the workflow. More...
                        """

                    class _zero_thickness(PyArgumentsTextualSubItem):
                        """
                        Specify whether or not you will need to account for any portions of your geometry with zero-thickness, and apply thickness to them for a more refined surface mesh. If so, then an Add Thickness task will be added to the workflow.
                        """

                    class _enable_overset(PyArgumentsParameterSubItem):
                        """
                        Specify whether or not you will need to create any overlapping or overset meshes. Such types of meshes can provide better mesh resolution in and around complicated, intersected portions of your geometry.
                        """

                    class _identify_regions(PyArgumentsParameterSubItem):
                        """
                        Specify whether or not you need to specifically identify and analyze particular regions. If so, then an Identify Regions task is added to the workflow.
                        """

                    class _close_leakges(PyArgumentsParameterSubItem):
                        """
                        Specify whether or not your geometry contains any problems (such as gaps or overlapping/intersecting surfaces) that may create leakages that need to be closed. If so, then a Define Leakage Threshold task is added to the workflow.
                        """

                    class _close_leakages(PyArgumentsParameterSubItem):
                        """
                        Argument close_leakages.
                        """

                class _all_task_list(PyArgumentsTextualSubItem):
                    """
                    Argument all_task_list.
                    """

            def create_instance(self) -> _describe_geometry_and_flowArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._describe_geometry_and_flowArguments(*args)

        class describe_overset_features(PyCommand):
            """
            Use this task to determine if specific overset features are required for your workflow. Depending on your simulation requirements, you may or may not need to add an overset collar mesh and/or an overset component mesh to your overall workflow tasks.
            Parameters
            ----------
            advanced_options : bool
            component_grid : bool
                Indicate whether you need to add an overset component mesh task to the workflow.
            collar_grid : bool
                Indicate whether you need to add an overset collar mesh task to the workflow
            background_mesh : bool
            overset_interfaces : bool

            Returns
            -------
            bool
            """
            class _describe_overset_featuresArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.advanced_options = self._advanced_options(self, "advanced_options", service, rules, path)
                    self.component_grid = self._component_grid(self, "component_grid", service, rules, path)
                    self.collar_grid = self._collar_grid(self, "collar_grid", service, rules, path)
                    self.background_mesh = self._background_mesh(self, "background_mesh", service, rules, path)
                    self.overset_interfaces = self._overset_interfaces(self, "overset_interfaces", service, rules, path)

                class _advanced_options(PyArgumentsParameterSubItem):
                    """
                    Argument advanced_options.
                    """

                class _component_grid(PyArgumentsParameterSubItem):
                    """
                    Indicate whether you need to add an overset component mesh task to the workflow.
                    """

                class _collar_grid(PyArgumentsParameterSubItem):
                    """
                    Indicate whether you need to add an overset collar mesh task to the workflow
                    """

                class _background_mesh(PyArgumentsParameterSubItem):
                    """
                    Argument background_mesh.
                    """

                class _overset_interfaces(PyArgumentsParameterSubItem):
                    """
                    Argument overset_interfaces.
                    """

            def create_instance(self) -> _describe_overset_featuresArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._describe_overset_featuresArguments(*args)

        class extract_edge_features(PyCommand):
            """
            Fidelity of the geometry can be improved by extracting feature edges. There are three types of feature edges that can be extracted: edges based on an angle; edges based on a sharp-angle; and edges based on intersections. More...
            Parameters
            ----------
            extract_edges_name : str
                Specify a name for the edge feature extraction or use the default value.
            extract_method_type : str
                Choose how the edge features are to be extracted: either by feature angle, intersection loops, or by sharp angle.
            selection_type : str
                Choose how you want to make your selection (by object, label, or zone name).
            object_selection_list : list[str]
                Select one or more geometry objects from the list below to apply the edge feature extraction to. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            geom_object_selection_list : list[str]
                Select one or more geometry objects from the list below to apply the edge feature extraction to. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_selection_list : list[str]
                Select one or more zones from the list below to apply the edge feature extraction to. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_location : list[str]
            label_selection_list : list[str]
                Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            feature_angle_local : int
                Specify the minimum angle between the feature edges that should be preserved.
            individual_collective : str
                Choose face zone interactivity -  individual: considers intersection of face zones within the object(s) selected; collectively: consider intersection of faces only across selected objects.
            sharp_angle : int
                Use the slider to specify the sharp angle (in degrees) that will be used in the feature extraction.
            complete_object_selection_list : list[str]
                Select one or more geometry objects from the list below to apply the edge feature extraction to. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            complete_geom_object_selection_list : list[str]
                Select one or more geometry objects from the list below to apply the edge feature extraction to. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            non_extracted_objects : list[str]

            Returns
            -------
            bool
            """
            class _extract_edge_featuresArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.extract_edges_name = self._extract_edges_name(self, "extract_edges_name", service, rules, path)
                    self.extract_method_type = self._extract_method_type(self, "extract_method_type", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.object_selection_list = self._object_selection_list(self, "object_selection_list", service, rules, path)
                    self.geom_object_selection_list = self._geom_object_selection_list(self, "geom_object_selection_list", service, rules, path)
                    self.zone_selection_list = self._zone_selection_list(self, "zone_selection_list", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.label_selection_list = self._label_selection_list(self, "label_selection_list", service, rules, path)
                    self.feature_angle_local = self._feature_angle_local(self, "feature_angle_local", service, rules, path)
                    self.individual_collective = self._individual_collective(self, "individual_collective", service, rules, path)
                    self.sharp_angle = self._sharp_angle(self, "sharp_angle", service, rules, path)
                    self.complete_object_selection_list = self._complete_object_selection_list(self, "complete_object_selection_list", service, rules, path)
                    self.complete_geom_object_selection_list = self._complete_geom_object_selection_list(self, "complete_geom_object_selection_list", service, rules, path)
                    self.non_extracted_objects = self._non_extracted_objects(self, "non_extracted_objects", service, rules, path)

                class _extract_edges_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the edge feature extraction or use the default value.
                    """

                class _extract_method_type(PyArgumentsTextualSubItem):
                    """
                    Choose how the edge features are to be extracted: either by feature angle, intersection loops, or by sharp angle.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to make your selection (by object, label, or zone name).
                    """

                class _object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Select one or more geometry objects from the list below to apply the edge feature extraction to. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _geom_object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Select one or more geometry objects from the list below to apply the edge feature extraction to. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Select one or more zones from the list below to apply the edge feature extraction to. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _label_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _feature_angle_local(PyArgumentsNumericalSubItem):
                    """
                    Specify the minimum angle between the feature edges that should be preserved.
                    """

                class _individual_collective(PyArgumentsTextualSubItem):
                    """
                    Choose face zone interactivity -  individual: considers intersection of face zones within the object(s) selected; collectively: consider intersection of faces only across selected objects.
                    """

                class _sharp_angle(PyArgumentsNumericalSubItem):
                    """
                    Use the slider to specify the sharp angle (in degrees) that will be used in the feature extraction.
                    """

                class _complete_object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Select one or more geometry objects from the list below to apply the edge feature extraction to. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _complete_geom_object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Select one or more geometry objects from the list below to apply the edge feature extraction to. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _non_extracted_objects(PyArgumentsTextualSubItem):
                    """
                    Argument non_extracted_objects.
                    """

            def create_instance(self) -> _extract_edge_featuresArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._extract_edge_featuresArguments(*args)

        class extrude_volume_mesh(PyCommand):
            """
            Use this task to extend all or parts of your volume mesh beyond the original domain. 
                           
                            More...
            Parameters
            ----------
            m_ex_control_name : str
                Specify a name for the extrusion or use the default value.
            method : str
                Choose whether you want the extrusion to be based on a specified Total Height value, or one based on a specified First Height value. The relationship between the two is illustrated by:
            selection_type : str
            extend_to_periodic_pair : bool
            preserve_periodic_info : bool
            extrude_normal_based : bool
                Specify whether the volume extrusion is derived from normal-based faceting or direction-based faceting. When enabled (the default), the volume extrusion is derived on normal-based faceting, such that for each layer, the normal is calculated and smoothing occurs, and is suitable for non-planar surfaces. For planar surfaces, disable this option to use a direction-based approach where the direction is chosen based on the average normal of the entire surface, and is used to extrude all layers.
            external_boundary_zone_list : list[str]
                Select one or more boundaries. All selected boundaries must share the same plane. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            topology_list : list[str]
            reverse_direction : bool
            total_height : float
                Specify a value for the total height of the extrusion or use the default value.
            first_height : float
                Specify a value for the height of the first layer of the extrusion or use the default value.
            numberof_layers : int
                Specify the number of extrusion layers.
            growth_rate : float
                Specify how the extrusion layers will grow. For example, a value of 1.2 indicates that each successive layer will grow by 20 percent of the previous layer. 
                                More...
            volume_mesh_extrusion_preferences : dict[str, Any]
            zone_location : list[str]

            Returns
            -------
            bool
            """
            class _extrude_volume_meshArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.m_ex_control_name = self._m_ex_control_name(self, "m_ex_control_name", service, rules, path)
                    self.method = self._method(self, "method", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.extend_to_periodic_pair = self._extend_to_periodic_pair(self, "extend_to_periodic_pair", service, rules, path)
                    self.preserve_periodic_info = self._preserve_periodic_info(self, "preserve_periodic_info", service, rules, path)
                    self.extrude_normal_based = self._extrude_normal_based(self, "extrude_normal_based", service, rules, path)
                    self.external_boundary_zone_list = self._external_boundary_zone_list(self, "external_boundary_zone_list", service, rules, path)
                    self.topology_list = self._topology_list(self, "topology_list", service, rules, path)
                    self.reverse_direction = self._reverse_direction(self, "reverse_direction", service, rules, path)
                    self.total_height = self._total_height(self, "total_height", service, rules, path)
                    self.first_height = self._first_height(self, "first_height", service, rules, path)
                    self.numberof_layers = self._numberof_layers(self, "numberof_layers", service, rules, path)
                    self.growth_rate = self._growth_rate(self, "growth_rate", service, rules, path)
                    self.volume_mesh_extrusion_preferences = self._volume_mesh_extrusion_preferences(self, "volume_mesh_extrusion_preferences", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)

                class _m_ex_control_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the extrusion or use the default value.
                    """

                class _method(PyArgumentsTextualSubItem):
                    """
                    Choose whether you want the extrusion to be based on a specified Total Height value, or one based on a specified First Height value. The relationship between the two is illustrated by:
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Argument selection_type.
                    """

                class _extend_to_periodic_pair(PyArgumentsParameterSubItem):
                    """
                    Argument extend_to_periodic_pair.
                    """

                class _preserve_periodic_info(PyArgumentsParameterSubItem):
                    """
                    Argument preserve_periodic_info.
                    """

                class _extrude_normal_based(PyArgumentsParameterSubItem):
                    """
                    Specify whether the volume extrusion is derived from normal-based faceting or direction-based faceting. When enabled (the default), the volume extrusion is derived on normal-based faceting, such that for each layer, the normal is calculated and smoothing occurs, and is suitable for non-planar surfaces. For planar surfaces, disable this option to use a direction-based approach where the direction is chosen based on the average normal of the entire surface, and is used to extrude all layers.
                    """

                class _external_boundary_zone_list(PyArgumentsTextualSubItem):
                    """
                    Select one or more boundaries. All selected boundaries must share the same plane. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _topology_list(PyArgumentsTextualSubItem):
                    """
                    Argument topology_list.
                    """

                class _reverse_direction(PyArgumentsParameterSubItem):
                    """
                    Argument reverse_direction.
                    """

                class _total_height(PyArgumentsNumericalSubItem):
                    """
                    Specify a value for the total height of the extrusion or use the default value.
                    """

                class _first_height(PyArgumentsNumericalSubItem):
                    """
                    Specify a value for the height of the first layer of the extrusion or use the default value.
                    """

                class _numberof_layers(PyArgumentsNumericalSubItem):
                    """
                    Specify the number of extrusion layers.
                    """

                class _growth_rate(PyArgumentsNumericalSubItem):
                    """
                    Specify how the extrusion layers will grow. For example, a value of 1.2 indicates that each successive layer will grow by 20 percent of the previous layer. 
                                    More...
                    """

                class _volume_mesh_extrusion_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument volume_mesh_extrusion_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)
                        self.bias_method = self._bias_method(self, "bias_method", service, rules, path)
                        self.max_layer_height = self._max_layer_height(self, "max_layer_height", service, rules, path)
                        self.merge_cell_zones = self._merge_cell_zones(self, "merge_cell_zones", service, rules, path)

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Display advanced options that you may want to apply to the task.
                        """

                    class _bias_method(PyArgumentsTextualSubItem):
                        """
                        Select from a choice of patterns that you want to apply to your volume mesh extrusion.
                        """

                    class _max_layer_height(PyArgumentsNumericalSubItem):
                        """
                        Specify the maximum allowed height/thickness for prism layers in this operation.
                        """

                    class _merge_cell_zones(PyArgumentsParameterSubItem):
                        """
                        Indicate whether or not you want to merge the extruded layers with any adjacent regions.
                        """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

            def create_instance(self) -> _extrude_volume_meshArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._extrude_volume_meshArguments(*args)

        class generate_initial_surface_mesh(PyCommand):
            """
            Command generate_initial_surface_mesh.

            Parameters
            ----------
            generate_quads : bool
            project_on_geometry : bool
            enable_multi_threading : bool
            number_of_multi_threads : int
            prism_2d_preferences : dict[str, Any]
            surface_2d_preferences : dict[str, Any]

            Returns
            -------
            bool
            """
            class _generate_initial_surface_meshArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.generate_quads = self._generate_quads(self, "generate_quads", service, rules, path)
                    self.project_on_geometry = self._project_on_geometry(self, "project_on_geometry", service, rules, path)
                    self.enable_multi_threading = self._enable_multi_threading(self, "enable_multi_threading", service, rules, path)
                    self.number_of_multi_threads = self._number_of_multi_threads(self, "number_of_multi_threads", service, rules, path)
                    self.prism_2d_preferences = self._prism_2d_preferences(self, "prism_2d_preferences", service, rules, path)
                    self.surface_2d_preferences = self._surface_2d_preferences(self, "surface_2d_preferences", service, rules, path)

                class _generate_quads(PyArgumentsParameterSubItem):
                    """
                    Argument generate_quads.
                    """

                class _project_on_geometry(PyArgumentsParameterSubItem):
                    """
                    Argument project_on_geometry.
                    """

                class _enable_multi_threading(PyArgumentsParameterSubItem):
                    """
                    Argument enable_multi_threading.
                    """

                class _number_of_multi_threads(PyArgumentsNumericalSubItem):
                    """
                    Argument number_of_multi_threads.
                    """

                class _prism_2d_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument prism_2d_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.split_quads = self._split_quads(self, "split_quads", service, rules, path)
                        self.refine_stretched_quads = self._refine_stretched_quads(self, "refine_stretched_quads", service, rules, path)
                        self.max_face_skew = self._max_face_skew(self, "max_face_skew", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)
                        self.local_remesh = self._local_remesh(self, "local_remesh", service, rules, path)
                        self.max_aspect_ratio = self._max_aspect_ratio(self, "max_aspect_ratio", service, rules, path)
                        self.min_aspect_ratio = self._min_aspect_ratio(self, "min_aspect_ratio", service, rules, path)
                        self.remesh_growth_rate = self._remesh_growth_rate(self, "remesh_growth_rate", service, rules, path)
                        self.n_orthogonal_layers = self._n_orthogonal_layers(self, "n_orthogonal_layers", service, rules, path)
                        self.gap_factor = self._gap_factor(self, "gap_factor", service, rules, path)

                    class _split_quads(PyArgumentsParameterSubItem):
                        """
                        Argument split_quads.
                        """

                    class _refine_stretched_quads(PyArgumentsParameterSubItem):
                        """
                        Argument refine_stretched_quads.
                        """

                    class _max_face_skew(PyArgumentsNumericalSubItem):
                        """
                        Argument max_face_skew.
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Argument show_in_gui.
                        """

                    class _local_remesh(PyArgumentsParameterSubItem):
                        """
                        Argument local_remesh.
                        """

                    class _max_aspect_ratio(PyArgumentsNumericalSubItem):
                        """
                        Argument max_aspect_ratio.
                        """

                    class _min_aspect_ratio(PyArgumentsNumericalSubItem):
                        """
                        Argument min_aspect_ratio.
                        """

                    class _remesh_growth_rate(PyArgumentsNumericalSubItem):
                        """
                        Argument remesh_growth_rate.
                        """

                    class _n_orthogonal_layers(PyArgumentsNumericalSubItem):
                        """
                        Argument n_orthogonal_layers.
                        """

                    class _gap_factor(PyArgumentsNumericalSubItem):
                        """
                        Argument gap_factor.
                        """

                class _surface_2d_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument surface_2d_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.merge_edge_zones_based_on_labels = self._merge_edge_zones_based_on_labels(self, "merge_edge_zones_based_on_labels", service, rules, path)
                        self.merge_face_zones_based_on_labels = self._merge_face_zones_based_on_labels(self, "merge_face_zones_based_on_labels", service, rules, path)
                        self.show_advanced_options = self._show_advanced_options(self, "show_advanced_options", service, rules, path)

                    class _merge_edge_zones_based_on_labels(PyArgumentsParameterSubItem):
                        """
                        Argument merge_edge_zones_based_on_labels.
                        """

                    class _merge_face_zones_based_on_labels(PyArgumentsParameterSubItem):
                        """
                        Argument merge_face_zones_based_on_labels.
                        """

                    class _show_advanced_options(PyArgumentsParameterSubItem):
                        """
                        Argument show_advanced_options.
                        """

            def create_instance(self) -> _generate_initial_surface_meshArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._generate_initial_surface_meshArguments(*args)

        class generate_map_mesh(PyCommand):
            """
            Command generate_map_mesh.

            Parameters
            ----------
            add_child : str
            control_name : str
            sizing_option : str
            constant_size : float
            growth_rate : float
            short_side_divisions : int
            split_quads : bool
            project_on_geometry : bool
            selection_type : str
            face_label_list : list[str]
            face_zone_list : list[str]

            Returns
            -------
            bool
            """
            class _generate_map_meshArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.add_child = self._add_child(self, "add_child", service, rules, path)
                    self.control_name = self._control_name(self, "control_name", service, rules, path)
                    self.sizing_option = self._sizing_option(self, "sizing_option", service, rules, path)
                    self.constant_size = self._constant_size(self, "constant_size", service, rules, path)
                    self.growth_rate = self._growth_rate(self, "growth_rate", service, rules, path)
                    self.short_side_divisions = self._short_side_divisions(self, "short_side_divisions", service, rules, path)
                    self.split_quads = self._split_quads(self, "split_quads", service, rules, path)
                    self.project_on_geometry = self._project_on_geometry(self, "project_on_geometry", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.face_label_list = self._face_label_list(self, "face_label_list", service, rules, path)
                    self.face_zone_list = self._face_zone_list(self, "face_zone_list", service, rules, path)

                class _add_child(PyArgumentsTextualSubItem):
                    """
                    Argument add_child.
                    """

                class _control_name(PyArgumentsTextualSubItem):
                    """
                    Argument control_name.
                    """

                class _sizing_option(PyArgumentsTextualSubItem):
                    """
                    Argument sizing_option.
                    """

                class _constant_size(PyArgumentsNumericalSubItem):
                    """
                    Argument constant_size.
                    """

                class _growth_rate(PyArgumentsNumericalSubItem):
                    """
                    Argument growth_rate.
                    """

                class _short_side_divisions(PyArgumentsNumericalSubItem):
                    """
                    Argument short_side_divisions.
                    """

                class _split_quads(PyArgumentsParameterSubItem):
                    """
                    Argument split_quads.
                    """

                class _project_on_geometry(PyArgumentsParameterSubItem):
                    """
                    Argument project_on_geometry.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Argument selection_type.
                    """

                class _face_label_list(PyArgumentsTextualSubItem):
                    """
                    Argument face_label_list.
                    """

                class _face_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument face_zone_list.
                    """

            def create_instance(self) -> _generate_map_meshArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._generate_map_meshArguments(*args)

        class generate_prism_layers(PyCommand):
            """
            Command generate_prism_layers.

            Parameters
            ----------
            generate_prisms_option : bool

            Returns
            -------
            bool
            """
            class _generate_prism_layersArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.generate_prisms_option = self._generate_prisms_option(self, "generate_prisms_option", service, rules, path)

                class _generate_prisms_option(PyArgumentsParameterSubItem):
                    """
                    Argument generate_prisms_option.
                    """

            def create_instance(self) -> _generate_prism_layersArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._generate_prism_layersArguments(*args)

        class generate_surface_mesh(PyCommand):
            """
            This task will close all the leakages to objects and void regions and then generate only the surface mesh. More...
            Parameters
            ----------
            surface_quality : float
                This is the target maximum surface mesh quality. The recommended value is between 0.7 and 0.85.
            save_surface_mesh : bool
                Select this option to save the surface mesh. Use advanced options to determine whether to save intermediate files or not, and to choose a specific directory to save the mesh.
            advanced_options : bool
                Display advanced options that you may want to apply to the task.
            save_intermediate_files : bool
                Determine whether or not you want to save any intermediate files that are generated during volume meshing. Disabling this option may increase speed and efficiency.
            intermediate_file_name : str
                By default, files are saved in a temporary folder and later deleted once the session is ended. You can also save files in a specified folder. The prefix for the name of the files are taken from the FMD or STL file name.
            separate_surface : bool
                Select Yes if you want to have the final surface mesh to be viewed as separated zones.
            use_size_field_for_prime_wrap : bool
            leak_shield : bool
            auto_region_between_porous : bool
            auto_pairing : bool
                Specify whether or not you want to separate contact pairs between fluids and solids.
            merge_wrapper_at_solid_conacts : bool
                Specify whether or not you want to allow contacts between solid and fluid regions to be merged into the surface mesh wrapper. When enabled, all bounding faces of a fluid region wrap that come into contact with solid regions will be merged into a single zone (using the prefix _contact). Each respective wrapped fluid region will have one _contact zone associated with it.
            parallel_serial_option : bool
                Specify whether or not you want to perform solid meshing using parallel sessions. Select Yes and indicate the Maximum Number of Sessions. The number of parallel sessions that are used will depend upon the number of solid objects that need to be meshed.
            number_of_sessions : int
                Indicate the number of parallel sessions that are to be used, depending upon the number of solid objects that need to be meshed.
            max_island_face : int
                Specify the maximum face count required for isolated areas (islands) to be created during surface mesh generation. Any islands that have a face count smaller than this value will be removed, and only larger islands will remain.
            spike_removal_angle : float
                Specify a value for the minimum spike angle for the specified region. A spike angle of 250 degrees is recommended or use the default value. You should not exceed 260 degrees.
            dihedral_min_angle : float
                Specify a value for the minimum dihedral angle for the specified region. A dihedral angle of 30 degrees are recommended or use the default value. You should not exceed 30 degrees.
            project_on_geometry : bool
                Determine whether, after surface meshing, Fluent will project the mesh nodes back onto to the original CAD model.
            auto_assign_zone_types : bool
                Choose whether or not to automatically assign boundary types to zones.
            advanced_inner_wrap : bool
                Choose whether or not to extend or expand the surface mesh into any interior pockets or cavities.
            gap_cover_zone_recovery : bool
                Determine whether or not to keep or remove the zones representing the cap covers. When set to Yes, the zones representing the gap covers are retained, whereas when set to No (the default), the zones for the gap covers are removed.
            global_min : float
                Specify a global minimum value for the surface mesh. The default minimum value is calculated based on available target and wrap size controls and bodies of influence. 
                                More...
            show_sub_tasks : bool

            Returns
            -------
            bool
            """
            class _generate_surface_meshArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.surface_quality = self._surface_quality(self, "surface_quality", service, rules, path)
                    self.save_surface_mesh = self._save_surface_mesh(self, "save_surface_mesh", service, rules, path)
                    self.advanced_options = self._advanced_options(self, "advanced_options", service, rules, path)
                    self.save_intermediate_files = self._save_intermediate_files(self, "save_intermediate_files", service, rules, path)
                    self.intermediate_file_name = self._intermediate_file_name(self, "intermediate_file_name", service, rules, path)
                    self.separate_surface = self._separate_surface(self, "separate_surface", service, rules, path)
                    self.use_size_field_for_prime_wrap = self._use_size_field_for_prime_wrap(self, "use_size_field_for_prime_wrap", service, rules, path)
                    self.leak_shield = self._leak_shield(self, "leak_shield", service, rules, path)
                    self.auto_region_between_porous = self._auto_region_between_porous(self, "auto_region_between_porous", service, rules, path)
                    self.auto_pairing = self._auto_pairing(self, "auto_pairing", service, rules, path)
                    self.merge_wrapper_at_solid_conacts = self._merge_wrapper_at_solid_conacts(self, "merge_wrapper_at_solid_conacts", service, rules, path)
                    self.parallel_serial_option = self._parallel_serial_option(self, "parallel_serial_option", service, rules, path)
                    self.number_of_sessions = self._number_of_sessions(self, "number_of_sessions", service, rules, path)
                    self.max_island_face = self._max_island_face(self, "max_island_face", service, rules, path)
                    self.spike_removal_angle = self._spike_removal_angle(self, "spike_removal_angle", service, rules, path)
                    self.dihedral_min_angle = self._dihedral_min_angle(self, "dihedral_min_angle", service, rules, path)
                    self.project_on_geometry = self._project_on_geometry(self, "project_on_geometry", service, rules, path)
                    self.auto_assign_zone_types = self._auto_assign_zone_types(self, "auto_assign_zone_types", service, rules, path)
                    self.advanced_inner_wrap = self._advanced_inner_wrap(self, "advanced_inner_wrap", service, rules, path)
                    self.gap_cover_zone_recovery = self._gap_cover_zone_recovery(self, "gap_cover_zone_recovery", service, rules, path)
                    self.global_min = self._global_min(self, "global_min", service, rules, path)
                    self.show_sub_tasks = self._show_sub_tasks(self, "show_sub_tasks", service, rules, path)

                class _surface_quality(PyArgumentsNumericalSubItem):
                    """
                    This is the target maximum surface mesh quality. The recommended value is between 0.7 and 0.85.
                    """

                class _save_surface_mesh(PyArgumentsParameterSubItem):
                    """
                    Select this option to save the surface mesh. Use advanced options to determine whether to save intermediate files or not, and to choose a specific directory to save the mesh.
                    """

                class _advanced_options(PyArgumentsParameterSubItem):
                    """
                    Display advanced options that you may want to apply to the task.
                    """

                class _save_intermediate_files(PyArgumentsParameterSubItem):
                    """
                    Determine whether or not you want to save any intermediate files that are generated during volume meshing. Disabling this option may increase speed and efficiency.
                    """

                class _intermediate_file_name(PyArgumentsTextualSubItem):
                    """
                    By default, files are saved in a temporary folder and later deleted once the session is ended. You can also save files in a specified folder. The prefix for the name of the files are taken from the FMD or STL file name.
                    """

                class _separate_surface(PyArgumentsParameterSubItem):
                    """
                    Select Yes if you want to have the final surface mesh to be viewed as separated zones.
                    """

                class _use_size_field_for_prime_wrap(PyArgumentsParameterSubItem):
                    """
                    Argument use_size_field_for_prime_wrap.
                    """

                class _leak_shield(PyArgumentsParameterSubItem):
                    """
                    Argument leak_shield.
                    """

                class _auto_region_between_porous(PyArgumentsParameterSubItem):
                    """
                    Argument auto_region_between_porous.
                    """

                class _auto_pairing(PyArgumentsParameterSubItem):
                    """
                    Specify whether or not you want to separate contact pairs between fluids and solids.
                    """

                class _merge_wrapper_at_solid_conacts(PyArgumentsParameterSubItem):
                    """
                    Specify whether or not you want to allow contacts between solid and fluid regions to be merged into the surface mesh wrapper. When enabled, all bounding faces of a fluid region wrap that come into contact with solid regions will be merged into a single zone (using the prefix _contact). Each respective wrapped fluid region will have one _contact zone associated with it.
                    """

                class _parallel_serial_option(PyArgumentsParameterSubItem):
                    """
                    Specify whether or not you want to perform solid meshing using parallel sessions. Select Yes and indicate the Maximum Number of Sessions. The number of parallel sessions that are used will depend upon the number of solid objects that need to be meshed.
                    """

                class _number_of_sessions(PyArgumentsNumericalSubItem):
                    """
                    Indicate the number of parallel sessions that are to be used, depending upon the number of solid objects that need to be meshed.
                    """

                class _max_island_face(PyArgumentsNumericalSubItem):
                    """
                    Specify the maximum face count required for isolated areas (islands) to be created during surface mesh generation. Any islands that have a face count smaller than this value will be removed, and only larger islands will remain.
                    """

                class _spike_removal_angle(PyArgumentsNumericalSubItem):
                    """
                    Specify a value for the minimum spike angle for the specified region. A spike angle of 250 degrees is recommended or use the default value. You should not exceed 260 degrees.
                    """

                class _dihedral_min_angle(PyArgumentsNumericalSubItem):
                    """
                    Specify a value for the minimum dihedral angle for the specified region. A dihedral angle of 30 degrees are recommended or use the default value. You should not exceed 30 degrees.
                    """

                class _project_on_geometry(PyArgumentsParameterSubItem):
                    """
                    Determine whether, after surface meshing, Fluent will project the mesh nodes back onto to the original CAD model.
                    """

                class _auto_assign_zone_types(PyArgumentsParameterSubItem):
                    """
                    Choose whether or not to automatically assign boundary types to zones.
                    """

                class _advanced_inner_wrap(PyArgumentsParameterSubItem):
                    """
                    Choose whether or not to extend or expand the surface mesh into any interior pockets or cavities.
                    """

                class _gap_cover_zone_recovery(PyArgumentsParameterSubItem):
                    """
                    Determine whether or not to keep or remove the zones representing the cap covers. When set to Yes, the zones representing the gap covers are retained, whereas when set to No (the default), the zones for the gap covers are removed.
                    """

                class _global_min(PyArgumentsNumericalSubItem):
                    """
                    Specify a global minimum value for the surface mesh. The default minimum value is calculated based on available target and wrap size controls and bodies of influence. 
                                    More...
                    """

                class _show_sub_tasks(PyArgumentsParameterSubItem):
                    """
                    Argument show_sub_tasks.
                    """

            def create_instance(self) -> _generate_surface_meshArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._generate_surface_meshArguments(*args)

        class generate_volume_mesh(PyCommand):
            """
            Command generate_volume_mesh.

            Parameters
            ----------
            mesh_fluid_domain_option : bool

            Returns
            -------
            bool
            """
            class _generate_volume_meshArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.mesh_fluid_domain_option = self._mesh_fluid_domain_option(self, "mesh_fluid_domain_option", service, rules, path)

                class _mesh_fluid_domain_option(PyArgumentsParameterSubItem):
                    """
                    Argument mesh_fluid_domain_option.
                    """

            def create_instance(self) -> _generate_volume_meshArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._generate_volume_meshArguments(*args)

        class identify_construction_surfaces(PyCommand):
            """
            Identify specific portions of your imported geometry that may exist as some form of construction surface, such as capping surface(s), or cylindrical surface(s) (for identifying moving reference frames, for example). You need to identify such objects within your geometry as being construction surfaces so that Fluent can mange those objects accordingly during the meshing process. More...
            Parameters
            ----------
            name : str
                Specify a name for the construction surface or use the default value.
            creation_method : str
                Choose whether to create the construction surface using an Existing object or zone, a bounding Box, or by using an Offset Surface.
            selection_type : str
                Choose how you want to make your selection (by object, label, or zone name).
            object_selection_single : list[str]
                Choose a single object from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_selection_single : list[str]
                Choose a single zone from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            label_selection_single : list[str]
                Choose a single label from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            object_selection_list : list[str]
                Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_selection_list : list[str]
                Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_location : list[str]
            label_selection_list : list[str]
                Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            defeaturing_size : float
                Specify a value that is used to obtain a rough shape of the selected object(s). The larger the value, the more approximate the shape.
            offset_height : float
                Specify the height of the offset construction surface. This is how far from the selected object(s) the rough shape is offset.
            pivot : dict[str, Any]
            axis : dict[str, Any]
            rotation : dict[str, Any]
            cylinder_object : dict[str, Any]
            cylinder_method : str
            bounding_box_object : dict[str, Any]
                View the extents of the bounding box.

            Returns
            -------
            bool
            """
            class _identify_construction_surfacesArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.name = self._name(self, "name", service, rules, path)
                    self.creation_method = self._creation_method(self, "creation_method", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.object_selection_single = self._object_selection_single(self, "object_selection_single", service, rules, path)
                    self.zone_selection_single = self._zone_selection_single(self, "zone_selection_single", service, rules, path)
                    self.label_selection_single = self._label_selection_single(self, "label_selection_single", service, rules, path)
                    self.object_selection_list = self._object_selection_list(self, "object_selection_list", service, rules, path)
                    self.zone_selection_list = self._zone_selection_list(self, "zone_selection_list", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.label_selection_list = self._label_selection_list(self, "label_selection_list", service, rules, path)
                    self.defeaturing_size = self._defeaturing_size(self, "defeaturing_size", service, rules, path)
                    self.offset_height = self._offset_height(self, "offset_height", service, rules, path)
                    self.pivot = self._pivot(self, "pivot", service, rules, path)
                    self.axis = self._axis(self, "axis", service, rules, path)
                    self.rotation = self._rotation(self, "rotation", service, rules, path)
                    self.cylinder_object = self._cylinder_object(self, "cylinder_object", service, rules, path)
                    self.cylinder_method = self._cylinder_method(self, "cylinder_method", service, rules, path)
                    self.bounding_box_object = self._bounding_box_object(self, "bounding_box_object", service, rules, path)

                class _name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the construction surface or use the default value.
                    """

                class _creation_method(PyArgumentsTextualSubItem):
                    """
                    Choose whether to create the construction surface using an Existing object or zone, a bounding Box, or by using an Offset Surface.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to make your selection (by object, label, or zone name).
                    """

                class _object_selection_single(PyArgumentsTextualSubItem):
                    """
                    Choose a single object from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_selection_single(PyArgumentsTextualSubItem):
                    """
                    Choose a single zone from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _label_selection_single(PyArgumentsTextualSubItem):
                    """
                    Choose a single label from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _label_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _defeaturing_size(PyArgumentsNumericalSubItem):
                    """
                    Specify a value that is used to obtain a rough shape of the selected object(s). The larger the value, the more approximate the shape.
                    """

                class _offset_height(PyArgumentsNumericalSubItem):
                    """
                    Specify the height of the offset construction surface. This is how far from the selected object(s) the rough shape is offset.
                    """

                class _pivot(PyArgumentsSingletonSubItem):
                    """
                    Argument pivot.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.y = self._y(self, "y", service, rules, path)
                        self.z = self._z(self, "z", service, rules, path)
                        self.x = self._x(self, "x", service, rules, path)

                    class _y(PyArgumentsNumericalSubItem):
                        """
                        Argument y.
                        """

                    class _z(PyArgumentsNumericalSubItem):
                        """
                        Argument z.
                        """

                    class _x(PyArgumentsNumericalSubItem):
                        """
                        Argument x.
                        """

                class _axis(PyArgumentsSingletonSubItem):
                    """
                    Argument axis.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.z_component = self._z_component(self, "z_component", service, rules, path)
                        self.y_component = self._y_component(self, "y_component", service, rules, path)
                        self.x_component = self._x_component(self, "x_component", service, rules, path)

                    class _z_component(PyArgumentsNumericalSubItem):
                        """
                        Argument z_component.
                        """

                    class _y_component(PyArgumentsNumericalSubItem):
                        """
                        Argument y_component.
                        """

                    class _x_component(PyArgumentsNumericalSubItem):
                        """
                        Argument x_component.
                        """

                class _rotation(PyArgumentsSingletonSubItem):
                    """
                    Argument rotation.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.y_component = self._y_component(self, "y_component", service, rules, path)
                        self.x_component = self._x_component(self, "x_component", service, rules, path)

                    class _y_component(PyArgumentsNumericalSubItem):
                        """
                        Argument y_component.
                        """

                    class _x_component(PyArgumentsNumericalSubItem):
                        """
                        Argument x_component.
                        """

                class _cylinder_object(PyArgumentsSingletonSubItem):
                    """
                    Argument cylinder_object.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.node_2 = self._node_2(self, "node_2", service, rules, path)
                        self.node_3 = self._node_3(self, "node_3", service, rules, path)
                        self.x2 = self._x2(self, "x2", service, rules, path)
                        self.x_offset = self._x_offset(self, "x_offset", service, rules, path)
                        self.x1 = self._x1(self, "x1", service, rules, path)
                        self.height_back_inc = self._height_back_inc(self, "height_back_inc", service, rules, path)
                        self.height_front_inc = self._height_front_inc(self, "height_front_inc", service, rules, path)
                        self.height_node = self._height_node(self, "height_node", service, rules, path)
                        self.z_offset = self._z_offset(self, "z_offset", service, rules, path)
                        self.y_offset = self._y_offset(self, "y_offset", service, rules, path)
                        self.node_1 = self._node_1(self, "node_1", service, rules, path)
                        self.z1 = self._z1(self, "z1", service, rules, path)
                        self.radius_2 = self._radius_2(self, "radius_2", service, rules, path)
                        self.z2 = self._z2(self, "z2", service, rules, path)
                        self.radius_1 = self._radius_1(self, "radius_1", service, rules, path)
                        self.y2 = self._y2(self, "y2", service, rules, path)
                        self.y1 = self._y1(self, "y1", service, rules, path)

                    class _node_2(PyArgumentsTextualSubItem):
                        """
                        Argument node_2.
                        """

                    class _node_3(PyArgumentsTextualSubItem):
                        """
                        Argument node_3.
                        """

                    class _x2(PyArgumentsNumericalSubItem):
                        """
                        Argument x2.
                        """

                    class _x_offset(PyArgumentsNumericalSubItem):
                        """
                        Argument x_offset.
                        """

                    class _x1(PyArgumentsNumericalSubItem):
                        """
                        Argument x1.
                        """

                    class _height_back_inc(PyArgumentsNumericalSubItem):
                        """
                        Argument height_back_inc.
                        """

                    class _height_front_inc(PyArgumentsNumericalSubItem):
                        """
                        Argument height_front_inc.
                        """

                    class _height_node(PyArgumentsTextualSubItem):
                        """
                        Argument height_node.
                        """

                    class _z_offset(PyArgumentsNumericalSubItem):
                        """
                        Argument z_offset.
                        """

                    class _y_offset(PyArgumentsNumericalSubItem):
                        """
                        Argument y_offset.
                        """

                    class _node_1(PyArgumentsTextualSubItem):
                        """
                        Argument node_1.
                        """

                    class _z1(PyArgumentsNumericalSubItem):
                        """
                        Argument z1.
                        """

                    class _radius_2(PyArgumentsNumericalSubItem):
                        """
                        Argument radius_2.
                        """

                    class _z2(PyArgumentsNumericalSubItem):
                        """
                        Argument z2.
                        """

                    class _radius_1(PyArgumentsNumericalSubItem):
                        """
                        Argument radius_1.
                        """

                    class _y2(PyArgumentsNumericalSubItem):
                        """
                        Argument y2.
                        """

                    class _y1(PyArgumentsNumericalSubItem):
                        """
                        Argument y1.
                        """

                class _cylinder_method(PyArgumentsTextualSubItem):
                    """
                    Argument cylinder_method.
                    """

                class _bounding_box_object(PyArgumentsSingletonSubItem):
                    """
                    View the extents of the bounding box.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.zmax = self._zmax(self, "zmax", service, rules, path)
                        self.ymax = self._ymax(self, "ymax", service, rules, path)
                        self.size_relative_length = self._size_relative_length(self, "size_relative_length", service, rules, path)
                        self.xmin_ratio = self._xmin_ratio(self, "xmin_ratio", service, rules, path)
                        self.zmax_ratio = self._zmax_ratio(self, "zmax_ratio", service, rules, path)
                        self.ymin_ratio = self._ymin_ratio(self, "ymin_ratio", service, rules, path)
                        self.zmin_ratio = self._zmin_ratio(self, "zmin_ratio", service, rules, path)
                        self.xmax_ratio = self._xmax_ratio(self, "xmax_ratio", service, rules, path)
                        self.xmin = self._xmin(self, "xmin", service, rules, path)
                        self.zmin = self._zmin(self, "zmin", service, rules, path)
                        self.ymin = self._ymin(self, "ymin", service, rules, path)
                        self.xmax = self._xmax(self, "xmax", service, rules, path)
                        self.ymax_ratio = self._ymax_ratio(self, "ymax_ratio", service, rules, path)

                    class _zmax(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the Z direction by the specified value.
                        """

                    class _ymax(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the Y direction by the specified value.
                        """

                    class _size_relative_length(PyArgumentsTextualSubItem):
                        """
                        Determine if you would like to specify the bounding box for the construction surface as a ratio of the geometry length, or by specifying a specific location for the minimum and maximum coordinates.
                        """

                    class _xmin_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the X direction by the specified value. The value is the ratio relative to the geometry size in the X direction.
                        """

                    class _zmax_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the Z direction by the specified value. The value is the ratio relative to the geometry size in the Z direction.
                        """

                    class _ymin_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the Y direction by the specified value. The value is the ratio relative to the geometry size in the Y direction.
                        """

                    class _zmin_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the Z direction by the specified value. The value is the ratio relative to the geometry size in the Z direction.
                        """

                    class _xmax_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the X direction by the specified value. The value is the ratio relative to the geometry size in the X direction.
                        """

                    class _xmin(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the X direction by the specified value.
                        """

                    class _zmin(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the Z direction by the specified value.
                        """

                    class _ymin(PyArgumentsNumericalSubItem):
                        """
                        Extends the minimum size of the bounding box in the Y direction by the specified value.
                        """

                    class _xmax(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the X direction by the specified value.
                        """

                    class _ymax_ratio(PyArgumentsNumericalSubItem):
                        """
                        Extends the maximum size of the bounding box in the Y direction by the specified value. The value is the ratio relative to the geometry size in the Y direction.
                        """

            def create_instance(self) -> _identify_construction_surfacesArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._identify_construction_surfacesArguments(*args)

        class identify_deviated_faces(PyCommand):
            """
            Use this task to identify how the wrapped surface mesh differs from the original geometry. This task can be useful for identifying deviations in the surface mesh in, for example, geometries with sharp angles.
            Parameters
            ----------
            display_grid_name : str
                Enter a name for the identified deviated faces.
            selection_type : str
                Specify whether the identification of deviated faces is to be applied to an indicated object or zone.
            object_selection_list : list[str]
                Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_selection_list : list[str]
                Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_location : list[str]
            advanced_options : bool
                Enable this option to automatically calculate the minimum and maximum deviation for the selected object(s) or zone(s).
            deviation_min_value : float
                When Auto Compute is disabled, specify a minimum value for the deviation.
            deviation_max_value : float
                When Auto Compute is disabled, specify a maximum value for the deviation.
            overlay : str
                Determine how you want the deviated faces to be displayed (either with the mesh or with the geometry).
            include_gap_cover_geometry : bool
                Determine if you want to include any gap covers in the check for deviated faces. If so, the default minimum and maximum deviation range is automatically calculated.

            Returns
            -------
            bool
            """
            class _identify_deviated_facesArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.display_grid_name = self._display_grid_name(self, "display_grid_name", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.object_selection_list = self._object_selection_list(self, "object_selection_list", service, rules, path)
                    self.zone_selection_list = self._zone_selection_list(self, "zone_selection_list", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.advanced_options = self._advanced_options(self, "advanced_options", service, rules, path)
                    self.deviation_min_value = self._deviation_min_value(self, "deviation_min_value", service, rules, path)
                    self.deviation_max_value = self._deviation_max_value(self, "deviation_max_value", service, rules, path)
                    self.overlay = self._overlay(self, "overlay", service, rules, path)
                    self.include_gap_cover_geometry = self._include_gap_cover_geometry(self, "include_gap_cover_geometry", service, rules, path)

                class _display_grid_name(PyArgumentsTextualSubItem):
                    """
                    Enter a name for the identified deviated faces.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Specify whether the identification of deviated faces is to be applied to an indicated object or zone.
                    """

                class _object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _advanced_options(PyArgumentsParameterSubItem):
                    """
                    Enable this option to automatically calculate the minimum and maximum deviation for the selected object(s) or zone(s).
                    """

                class _deviation_min_value(PyArgumentsNumericalSubItem):
                    """
                    When Auto Compute is disabled, specify a minimum value for the deviation.
                    """

                class _deviation_max_value(PyArgumentsNumericalSubItem):
                    """
                    When Auto Compute is disabled, specify a maximum value for the deviation.
                    """

                class _overlay(PyArgumentsTextualSubItem):
                    """
                    Determine how you want the deviated faces to be displayed (either with the mesh or with the geometry).
                    """

                class _include_gap_cover_geometry(PyArgumentsParameterSubItem):
                    """
                    Determine if you want to include any gap covers in the check for deviated faces. If so, the default minimum and maximum deviation range is automatically calculated.
                    """

            def create_instance(self) -> _identify_deviated_facesArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._identify_deviated_facesArguments(*args)

        class identify_orphans(PyCommand):
            """
            Use this task to isolate and locate any orphan cells in your mesh. 
                            More...
            Parameters
            ----------
            number_of_orphans : str
                Specify the allowable number of orphans to accept in your mesh.
            object_selection_list : list[str]
                Select one or more mesh objects that you would like to identify any potential orphan faces. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            enable_grid_priority : bool
                Controls the ability to prioritize your overset grids (meshes). The priorities of the overset mesh are then carried over into the solver.
            donor_priority_method : str
                Determines the location of the overset mesh. Choose how the mesh donor cells are prioritized - either based on the cell size (proportional to the inverse of the cell volume) or based on the boundary distance (proportional to the inverse of the distance to the closest boundary).
            overlap_boundaries : bool
                Determine if you need to account for any overlapping boundaries that may be present in your overset mesh (due to overlapping geometry and boundaries or those sometimes generated by collar meshes). You can improve the overset performance by setting this option to no.
            check_overset_interface_intersection : bool
                Enabled by default, Fluent checks for any overset interface intersections while identifying orphans. Disable this option to skip the intersection check and increase the speed of identifying orphans.
            region_name_list : list[str]
            region_size_list : list[str]
            old_region_name_list : list[str]
            old_region_size_list : list[str]

            Returns
            -------
            bool
            """
            class _identify_orphansArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.number_of_orphans = self._number_of_orphans(self, "number_of_orphans", service, rules, path)
                    self.object_selection_list = self._object_selection_list(self, "object_selection_list", service, rules, path)
                    self.enable_grid_priority = self._enable_grid_priority(self, "enable_grid_priority", service, rules, path)
                    self.donor_priority_method = self._donor_priority_method(self, "donor_priority_method", service, rules, path)
                    self.overlap_boundaries = self._overlap_boundaries(self, "overlap_boundaries", service, rules, path)
                    self.check_overset_interface_intersection = self._check_overset_interface_intersection(self, "check_overset_interface_intersection", service, rules, path)
                    self.region_name_list = self._region_name_list(self, "region_name_list", service, rules, path)
                    self.region_size_list = self._region_size_list(self, "region_size_list", service, rules, path)
                    self.old_region_name_list = self._old_region_name_list(self, "old_region_name_list", service, rules, path)
                    self.old_region_size_list = self._old_region_size_list(self, "old_region_size_list", service, rules, path)

                class _number_of_orphans(PyArgumentsTextualSubItem):
                    """
                    Specify the allowable number of orphans to accept in your mesh.
                    """

                class _object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Select one or more mesh objects that you would like to identify any potential orphan faces. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _enable_grid_priority(PyArgumentsParameterSubItem):
                    """
                    Controls the ability to prioritize your overset grids (meshes). The priorities of the overset mesh are then carried over into the solver.
                    """

                class _donor_priority_method(PyArgumentsTextualSubItem):
                    """
                    Determines the location of the overset mesh. Choose how the mesh donor cells are prioritized - either based on the cell size (proportional to the inverse of the cell volume) or based on the boundary distance (proportional to the inverse of the distance to the closest boundary).
                    """

                class _overlap_boundaries(PyArgumentsParameterSubItem):
                    """
                    Determine if you need to account for any overlapping boundaries that may be present in your overset mesh (due to overlapping geometry and boundaries or those sometimes generated by collar meshes). You can improve the overset performance by setting this option to no.
                    """

                class _check_overset_interface_intersection(PyArgumentsParameterSubItem):
                    """
                    Enabled by default, Fluent checks for any overset interface intersections while identifying orphans. Disable this option to skip the intersection check and increase the speed of identifying orphans.
                    """

                class _region_name_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_name_list.
                    """

                class _region_size_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_size_list.
                    """

                class _old_region_name_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_region_name_list.
                    """

                class _old_region_size_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_region_size_list.
                    """

            def create_instance(self) -> _identify_orphansArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._identify_orphansArguments(*args)

        class identify_regions(PyCommand):
            """
            Identify specific regions in and around your imported geometry, such as a flow region surrounding a vehicle in an external flow simulation. In this task, you are positioning specific points in the domain where certain regions of interest can be identified and classified for later use in your simulation. More...
            Parameters
            ----------
            add_child : bool
                Determine whether or not you want to specify any fluid or void regions using this task.
            material_points_name : str
                Specify a name for the region that you want to identify or use the default value.
            mpt_method_type : str
                Choose how you want to identify the region: using a distinct numerical input of X, Y, and Z coordinates, using the centroid of the selected object, or by using an offset distance relative to the centroid of selected object/zone.
            new_region_type : str
                Specify the type of region as being fluid, solid, or a void.
            link_construction : bool
                Keep the default value of no for most cases involving a singular fluid region. If you mean to identify an additional fluid region, choose yes to indicate that the current fluid region is either inside or adjacent to a construction surface(s), in order to properly mesh this fluid region accordingly (that is, using a surface mesh).
            selection_type : str
                Choose how you want to make your selection (by object, label, or zone name).
            zone_selection_list : list[str]
                Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_location : list[str]
            label_selection_list : list[str]
                Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            object_selection_list : list[str]
                Choose one or more objects (or voids) from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            graphical_selection : bool
                Enable this option and select a point in the graphics window to be the center of the region.
            show_coordinates : bool
                Enable this option when providing numerical inputs for the region location, and you want to view the exact coordinates.
            x : float
                The x-coordinate of the center of the region.
            y : float
                The y-coordinate of the center of the region.
            z : float
                The z-coordinate of the center of the region.
            offset_x : float
                The x-coordinate of the offset distance relative to the centroid of the selected object/zone.
            offset_y : float
                The y-coordinate of the offset distance relative to the centroid of the selected object/zone.
            offset_z : float
                The z-coordinate of the offset distance relative to the centroid of the selected object/zone.

            Returns
            -------
            bool
            """
            class _identify_regionsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.add_child = self._add_child(self, "add_child", service, rules, path)
                    self.material_points_name = self._material_points_name(self, "material_points_name", service, rules, path)
                    self.mpt_method_type = self._mpt_method_type(self, "mpt_method_type", service, rules, path)
                    self.new_region_type = self._new_region_type(self, "new_region_type", service, rules, path)
                    self.link_construction = self._link_construction(self, "link_construction", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.zone_selection_list = self._zone_selection_list(self, "zone_selection_list", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.label_selection_list = self._label_selection_list(self, "label_selection_list", service, rules, path)
                    self.object_selection_list = self._object_selection_list(self, "object_selection_list", service, rules, path)
                    self.graphical_selection = self._graphical_selection(self, "graphical_selection", service, rules, path)
                    self.show_coordinates = self._show_coordinates(self, "show_coordinates", service, rules, path)
                    self.x = self._x(self, "x", service, rules, path)
                    self.y = self._y(self, "y", service, rules, path)
                    self.z = self._z(self, "z", service, rules, path)
                    self.offset_x = self._offset_x(self, "offset_x", service, rules, path)
                    self.offset_y = self._offset_y(self, "offset_y", service, rules, path)
                    self.offset_z = self._offset_z(self, "offset_z", service, rules, path)

                class _add_child(PyArgumentsParameterSubItem):
                    """
                    Determine whether or not you want to specify any fluid or void regions using this task.
                    """

                class _material_points_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the region that you want to identify or use the default value.
                    """

                class _mpt_method_type(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to identify the region: using a distinct numerical input of X, Y, and Z coordinates, using the centroid of the selected object, or by using an offset distance relative to the centroid of selected object/zone.
                    """

                class _new_region_type(PyArgumentsTextualSubItem):
                    """
                    Specify the type of region as being fluid, solid, or a void.
                    """

                class _link_construction(PyArgumentsParameterSubItem):
                    """
                    Keep the default value of no for most cases involving a singular fluid region. If you mean to identify an additional fluid region, choose yes to indicate that the current fluid region is either inside or adjacent to a construction surface(s), in order to properly mesh this fluid region accordingly (that is, using a surface mesh).
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to make your selection (by object, label, or zone name).
                    """

                class _zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _label_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more objects (or voids) from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _graphical_selection(PyArgumentsParameterSubItem):
                    """
                    Enable this option and select a point in the graphics window to be the center of the region.
                    """

                class _show_coordinates(PyArgumentsParameterSubItem):
                    """
                    Enable this option when providing numerical inputs for the region location, and you want to view the exact coordinates.
                    """

                class _x(PyArgumentsNumericalSubItem):
                    """
                    The x-coordinate of the center of the region.
                    """

                class _y(PyArgumentsNumericalSubItem):
                    """
                    The y-coordinate of the center of the region.
                    """

                class _z(PyArgumentsNumericalSubItem):
                    """
                    The z-coordinate of the center of the region.
                    """

                class _offset_x(PyArgumentsNumericalSubItem):
                    """
                    The x-coordinate of the offset distance relative to the centroid of the selected object/zone.
                    """

                class _offset_y(PyArgumentsNumericalSubItem):
                    """
                    The y-coordinate of the offset distance relative to the centroid of the selected object/zone.
                    """

                class _offset_z(PyArgumentsNumericalSubItem):
                    """
                    The z-coordinate of the offset distance relative to the centroid of the selected object/zone.
                    """

            def create_instance(self) -> _identify_regionsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._identify_regionsArguments(*args)

        class import_boi_geometry(PyCommand):
            """
            Specify the geometry or mesh file(s) that represent the bodies of influence you wish to import into the workflow. Choose from either a CAD file or a surface or volume mesh. For CAD geometries, choose the appropriate units in which the geometry was created. Browse, or specify the file name(s) and location for the CAD geometry or mesh that you are going to import. It is recommended to select units so that the minimum size is between approximately 0.1 and 10.  More...
            Parameters
            ----------
            type : str
                Specify whether you are importing CAD geometry file(s) or whether you are specifying surface or volume mesh file(s) to represent bodies of influence for your simulation. The units for length will be the same as those specified in the Import Geometry task.
            geometry_file_name : str
                Select CAD file(s) to import into your simulation as a body of influence. Supported file types are SpaceClaim (.scdoc) and Workbench (.agdb) files and also .pmdb files. Other supported formats include: *.CATpart, *.prt, *.x_t, *.sat, *.step, and *.iges files)
            mesh_file_name : str
                Select surface or volume mesh file(s) to import into your simulation as a body of influence. Supported file types are: *.msh, *.msh.gz, and *.msh.h5 files).
            imported_objects : list[str]
            length_unit : str
            cad_import_options : dict[str, Any]

            Returns
            -------
            bool
            """
            class _import_boi_geometryArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.type = self._type(self, "type", service, rules, path)
                    self.geometry_file_name = self._geometry_file_name(self, "geometry_file_name", service, rules, path)
                    self.mesh_file_name = self._mesh_file_name(self, "mesh_file_name", service, rules, path)
                    self.imported_objects = self._imported_objects(self, "imported_objects", service, rules, path)
                    self.length_unit = self._length_unit(self, "length_unit", service, rules, path)
                    self.cad_import_options = self._cad_import_options(self, "cad_import_options", service, rules, path)

                class _type(PyArgumentsTextualSubItem):
                    """
                    Specify whether you are importing CAD geometry file(s) or whether you are specifying surface or volume mesh file(s) to represent bodies of influence for your simulation. The units for length will be the same as those specified in the Import Geometry task.
                    """

                class _geometry_file_name(PyArgumentsTextualSubItem):
                    """
                    Select CAD file(s) to import into your simulation as a body of influence. Supported file types are SpaceClaim (.scdoc) and Workbench (.agdb) files and also .pmdb files. Other supported formats include: \\*.CATpart, \\*.prt, \\*.x_t, \\*.sat, \\*.step, and \\*.iges files)
                    """

                class _mesh_file_name(PyArgumentsTextualSubItem):
                    """
                    Select surface or volume mesh file(s) to import into your simulation as a body of influence. Supported file types are: \\*.msh, \\*.msh.gz, and \\*.msh.h5 files).
                    """

                class _imported_objects(PyArgumentsTextualSubItem):
                    """
                    Argument imported_objects.
                    """

                class _length_unit(PyArgumentsTextualSubItem):
                    """
                    Argument length_unit.
                    """

                class _cad_import_options(PyArgumentsSingletonSubItem):
                    """
                    Argument cad_import_options.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.import_part_names = self._import_part_names(self, "import_part_names", service, rules, path)
                        self.extract_features = self._extract_features(self, "extract_features", service, rules, path)
                        self.import_named_selections = self._import_named_selections(self, "import_named_selections", service, rules, path)
                        self.create_cad_assemblies = self._create_cad_assemblies(self, "create_cad_assemblies", service, rules, path)
                        self.use_part_or_body_as_suffix = self._use_part_or_body_as_suffix(self, "use_part_or_body_as_suffix", service, rules, path)
                        self.one_zone_per = self._one_zone_per(self, "one_zone_per", service, rules, path)
                        self.save_pmdb_intermediate_file = self._save_pmdb_intermediate_file(self, "save_pmdb_intermediate_file", service, rules, path)
                        self.open_all_cad_in_subdirectories = self._open_all_cad_in_subdirectories(self, "open_all_cad_in_subdirectories", service, rules, path)
                        self.feature_angle = self._feature_angle(self, "feature_angle", service, rules, path)
                        self.one_object_per = self._one_object_per(self, "one_object_per", service, rules, path)
                        self.import_curvature_data_from_cad = self._import_curvature_data_from_cad(self, "import_curvature_data_from_cad", service, rules, path)

                    class _import_part_names(PyArgumentsParameterSubItem):
                        """
                        Argument import_part_names.
                        """

                    class _extract_features(PyArgumentsParameterSubItem):
                        """
                        Argument extract_features.
                        """

                    class _import_named_selections(PyArgumentsParameterSubItem):
                        """
                        Argument import_named_selections.
                        """

                    class _create_cad_assemblies(PyArgumentsParameterSubItem):
                        """
                        Argument create_cad_assemblies.
                        """

                    class _use_part_or_body_as_suffix(PyArgumentsParameterSubItem):
                        """
                        Argument use_part_or_body_as_suffix.
                        """

                    class _one_zone_per(PyArgumentsTextualSubItem):
                        """
                        Argument one_zone_per.
                        """

                    class _save_pmdb_intermediate_file(PyArgumentsParameterSubItem):
                        """
                        Argument save_pmdb_intermediate_file.
                        """

                    class _open_all_cad_in_subdirectories(PyArgumentsParameterSubItem):
                        """
                        Argument open_all_cad_in_subdirectories.
                        """

                    class _feature_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument feature_angle.
                        """

                    class _one_object_per(PyArgumentsTextualSubItem):
                        """
                        Argument one_object_per.
                        """

                    class _import_curvature_data_from_cad(PyArgumentsParameterSubItem):
                        """
                        Argument import_curvature_data_from_cad.
                        """

            def create_instance(self) -> _import_boi_geometryArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._import_boi_geometryArguments(*args)

        class import_cad_and_part_management(PyCommand):
            """
            Import a CAD geometry (.fmd or .stl), then determine how you want to create your meshing objects: by Part (simple, a mesh object will be created for each of the CAD part), or by Custom where you customize the import process (for complicated, multiple part assemblies, etc.). For a customized approach, you can pick and choose the portions of the CAD model that you want to add to your simulation, and adjust any meshing-related settings for individual objects, before converting them into meshing objects. You can further simplify your CAD model and combine parts and assemblies into a single object. To capture features more effectively, you can increase or decrease the faceting resolution, thereby controlling the surface mesh granularity and therefore influencing the simulation time. More...
            Parameters
            ----------
            file_loaded : bool
            fmd_file_name : str
                Select a CAD file to import into your simulation. Standard Ansys file types, among others, are supported, including .scdoc, .dsco, .agdb, .fmd, .fmdb, .fmd, .pmdb, .tgf, and .msh. To quickly import multiple CAD files, you can use basic wildcard expression patterns such as the * or ? wildcards. More...
            append_file_name : str
                Enable this option and browse/select another CAD file to append to your original geometry. Specify additional CAD files in the Append File field, and use the Append button to load additional CAD files into the tree, after the original CAD objects. To quickly append multiple CAD files, you can use basic wildcard expression patterns such as the * or ? wildcards.
            append : bool
                Enable this field and browse and select additional CAD files. Use the Append button to add the additional CAD components to the bottom of the CAD Model tree upon loading.
            length_unit : str
                Select a suitable unit for display in the graphics window.
            create_object_per : str
                Choose whether to create meshing objects by part, or by selectively customizing the portions of the imported CAD geometry to mesh. If you select by part, then meshing objects are automatically created for you once you import the geometry. Refaceting options are available as well for all meshing objects.
            file_length_unit : str
                Specify the units of length used by this .stl file before loading the CAD file.
            file_length_unit_append : str
                Enable this field and browse and select additional CAD files. Use the Append button to add the additional CAD components to the bottom of the CAD Model tree upon loading.
            route : str
                Provides the recommended route in order to import and load the specified CAD file into this task. The default settings are recommended in most cases.  More...
            route_append : str
                Enable this field and browse and select additional CAD files. Use the Append button to add the additional CAD components to the bottom of the CAD Model tree upon loading.
            jt_lod : int
                Specify the level of detail that you want to include for this .jt file before loading the CAD file.
            jt_lod_append : int
                Enable this field and browse and select additional CAD files. Use the Append button to add the additional CAD components to the bottom of the CAD Model tree upon loading.
            part_per_body : bool
                Enable this option to make all bodies available as individual parts in the CAD Model tree once the CAD file is loaded into the task.
            prefix_parent_name : bool
                This applies the name of the component (or assembly) as a prefix to the individual part names when the geometry is loaded into the task.
            remove_empty_parts : bool
                Enabled by default, this option lets you import your CAD geometry while removing any empty components.
            feature_angle : float
                Specify a rotational angle (in degrees) of transformation.
            one_zone_per : str
                Specify whether to create your meshing zones based on an object, part, body or face. For instance, choosing the face option would create a separate zone for every topological face.
            refaceting : dict[str, Any]
            ignore_solid_names : bool
                Enable this option to import your CAD geometry while ignoring the names assigned to solids. Note that binary STL files contain a single solid and may have an associated solid name, whereas ASCII STL files contain one or more solids and each can have a  solid name. This option allows to control whether or not to use the name contained in the STL file for naming mesh objects and components.
            ignore_solid_names_append : bool
                Enable this field and browse and select additional CAD files. Use the Append button to add the additional CAD components to the bottom of the CAD Model tree upon loading.
            options : dict[str, Any]
            edge_extraction : str
                Choose how edges will be extracted from the CAD geometry. Setting this option to auto will extract edges from the CAD geometry when the number of meshing objects is less than 10,000. If this limit is exceeded, then no edges are extracted. When this option is set to yes, then edges are extracted regardless of the number of meshing objects. No edges are extracted when this option is set to no.
            context : int
            object_setting : str
            refacet_options : dict[str, Any]

            Returns
            -------
            bool
            """
            class _import_cad_and_part_managementArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.file_loaded = self._file_loaded(self, "file_loaded", service, rules, path)
                    self.fmd_file_name = self._fmd_file_name(self, "fmd_file_name", service, rules, path)
                    self.append_file_name = self._append_file_name(self, "append_file_name", service, rules, path)
                    self.append = self._append(self, "append", service, rules, path)
                    self.length_unit = self._length_unit(self, "length_unit", service, rules, path)
                    self.create_object_per = self._create_object_per(self, "create_object_per", service, rules, path)
                    self.file_length_unit = self._file_length_unit(self, "file_length_unit", service, rules, path)
                    self.file_length_unit_append = self._file_length_unit_append(self, "file_length_unit_append", service, rules, path)
                    self.route = self._route(self, "route", service, rules, path)
                    self.route_append = self._route_append(self, "route_append", service, rules, path)
                    self.jt_lod = self._jt_lod(self, "jt_lod", service, rules, path)
                    self.jt_lod_append = self._jt_lod_append(self, "jt_lod_append", service, rules, path)
                    self.part_per_body = self._part_per_body(self, "part_per_body", service, rules, path)
                    self.prefix_parent_name = self._prefix_parent_name(self, "prefix_parent_name", service, rules, path)
                    self.remove_empty_parts = self._remove_empty_parts(self, "remove_empty_parts", service, rules, path)
                    self.feature_angle = self._feature_angle(self, "feature_angle", service, rules, path)
                    self.one_zone_per = self._one_zone_per(self, "one_zone_per", service, rules, path)
                    self.refaceting = self._refaceting(self, "refaceting", service, rules, path)
                    self.ignore_solid_names = self._ignore_solid_names(self, "ignore_solid_names", service, rules, path)
                    self.ignore_solid_names_append = self._ignore_solid_names_append(self, "ignore_solid_names_append", service, rules, path)
                    self.options = self._options(self, "options", service, rules, path)
                    self.edge_extraction = self._edge_extraction(self, "edge_extraction", service, rules, path)
                    self.context = self._context(self, "context", service, rules, path)
                    self.object_setting = self._object_setting(self, "object_setting", service, rules, path)
                    self.refacet_options = self._refacet_options(self, "refacet_options", service, rules, path)

                class _file_loaded(PyArgumentsParameterSubItem):
                    """
                    Argument file_loaded.
                    """

                class _fmd_file_name(PyArgumentsTextualSubItem):
                    """
                    Select a CAD file to import into your simulation. Standard Ansys file types, among others, are supported, including .scdoc, .dsco, .agdb, .fmd, .fmdb, .fmd, .pmdb, .tgf, and .msh. To quickly import multiple CAD files, you can use basic wildcard expression patterns such as the \\* or ? wildcards. More...
                    """

                class _append_file_name(PyArgumentsTextualSubItem):
                    """
                    Enable this option and browse/select another CAD file to append to your original geometry. Specify additional CAD files in the Append File field, and use the Append button to load additional CAD files into the tree, after the original CAD objects. To quickly append multiple CAD files, you can use basic wildcard expression patterns such as the \\* or ? wildcards.
                    """

                class _append(PyArgumentsParameterSubItem):
                    """
                    Enable this field and browse and select additional CAD files. Use the Append button to add the additional CAD components to the bottom of the CAD Model tree upon loading.
                    """

                class _length_unit(PyArgumentsTextualSubItem):
                    """
                    Select a suitable unit for display in the graphics window.
                    """

                class _create_object_per(PyArgumentsTextualSubItem):
                    """
                    Choose whether to create meshing objects by part, or by selectively customizing the portions of the imported CAD geometry to mesh. If you select by part, then meshing objects are automatically created for you once you import the geometry. Refaceting options are available as well for all meshing objects.
                    """

                class _file_length_unit(PyArgumentsTextualSubItem):
                    """
                    Specify the units of length used by this .stl file before loading the CAD file.
                    """

                class _file_length_unit_append(PyArgumentsTextualSubItem):
                    """
                    Enable this field and browse and select additional CAD files. Use the Append button to add the additional CAD components to the bottom of the CAD Model tree upon loading.
                    """

                class _route(PyArgumentsTextualSubItem):
                    """
                    Provides the recommended route in order to import and load the specified CAD file into this task. The default settings are recommended in most cases.  More...
                    """

                class _route_append(PyArgumentsTextualSubItem):
                    """
                    Enable this field and browse and select additional CAD files. Use the Append button to add the additional CAD components to the bottom of the CAD Model tree upon loading.
                    """

                class _jt_lod(PyArgumentsNumericalSubItem):
                    """
                    Specify the level of detail that you want to include for this .jt file before loading the CAD file.
                    """

                class _jt_lod_append(PyArgumentsNumericalSubItem):
                    """
                    Enable this field and browse and select additional CAD files. Use the Append button to add the additional CAD components to the bottom of the CAD Model tree upon loading.
                    """

                class _part_per_body(PyArgumentsParameterSubItem):
                    """
                    Enable this option to make all bodies available as individual parts in the CAD Model tree once the CAD file is loaded into the task.
                    """

                class _prefix_parent_name(PyArgumentsParameterSubItem):
                    """
                    This applies the name of the component (or assembly) as a prefix to the individual part names when the geometry is loaded into the task.
                    """

                class _remove_empty_parts(PyArgumentsParameterSubItem):
                    """
                    Enabled by default, this option lets you import your CAD geometry while removing any empty components.
                    """

                class _feature_angle(PyArgumentsNumericalSubItem):
                    """
                    Specify a rotational angle (in degrees) of transformation.
                    """

                class _one_zone_per(PyArgumentsTextualSubItem):
                    """
                    Specify whether to create your meshing zones based on an object, part, body or face. For instance, choosing the face option would create a separate zone for every topological face.
                    """

                class _refaceting(PyArgumentsSingletonSubItem):
                    """
                    Argument refaceting.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.deviation = self._deviation(self, "deviation", service, rules, path)
                        self.max_size = self._max_size(self, "max_size", service, rules, path)
                        self.normal_angle = self._normal_angle(self, "normal_angle", service, rules, path)
                        self.facet_max_edge_length = self._facet_max_edge_length(self, "facet_max_edge_length", service, rules, path)
                        self.max_edge_length_factor = self._max_edge_length_factor(self, "max_edge_length_factor", service, rules, path)
                        self.refacet = self._refacet(self, "refacet", service, rules, path)

                    class _deviation(PyArgumentsNumericalSubItem):
                        """
                        Specify the distance between facet edges and the geometry edges. Decreasing this value will result in more facets along curved edges.
                        """

                    class _max_size(PyArgumentsNumericalSubItem):
                        """
                        Specify a maximum element size for the imported model to avoid very large facets during the file import.
                        """

                    class _normal_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify a rotational angle (in degrees) of transformation.
                        """

                    class _facet_max_edge_length(PyArgumentsTextualSubItem):
                        """
                        Controls the edge size of facets, ensuring that no facet edge exceeds the specified length. The max edge length size (Max Size) can either be specified directly by selecting Absolute or specified as a factor (Max Edge Length Factor) relative to the bounding box of the geometry by selecting Relative (Bounding Box).
                        """

                    class _max_edge_length_factor(PyArgumentsNumericalSubItem):
                        """
                        Specifies the maximum size of the facets relative to the bounding box of the geometry.
                        """

                    class _refacet(PyArgumentsParameterSubItem):
                        """
                        Select this option when you want to change faceting of the selected object. Refaceting will refacet the original CAD geometry. Only the faceted CAD geometry is used during the meshing process. The refaceting settings control how far the facet edges are from the model and the size of the facets.  More...
                        """

                class _ignore_solid_names(PyArgumentsParameterSubItem):
                    """
                    Enable this option to import your CAD geometry while ignoring the names assigned to solids. Note that binary STL files contain a single solid and may have an associated solid name, whereas ASCII STL files contain one or more solids and each can have a  solid name. This option allows to control whether or not to use the name contained in the STL file for naming mesh objects and components.
                    """

                class _ignore_solid_names_append(PyArgumentsParameterSubItem):
                    """
                    Enable this field and browse and select additional CAD files. Use the Append button to add the additional CAD components to the bottom of the CAD Model tree upon loading.
                    """

                class _options(PyArgumentsSingletonSubItem):
                    """
                    Argument options.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.line = self._line(self, "line", service, rules, path)
                        self.solid = self._solid(self, "solid", service, rules, path)
                        self.surface = self._surface(self, "surface", service, rules, path)

                    class _line(PyArgumentsParameterSubItem):
                        """
                        Enable this option to import line bodies along with your CAD geometry.
                        """

                    class _solid(PyArgumentsParameterSubItem):
                        """
                        Enable this option to import solid bodies along with your CAD geometry.
                        """

                    class _surface(PyArgumentsParameterSubItem):
                        """
                        Enable this option to import surface bodies along with your CAD geometry.
                        """

                class _edge_extraction(PyArgumentsTextualSubItem):
                    """
                    Choose how edges will be extracted from the CAD geometry. Setting this option to auto will extract edges from the CAD geometry when the number of meshing objects is less than 10,000. If this limit is exceeded, then no edges are extracted. When this option is set to yes, then edges are extracted regardless of the number of meshing objects. No edges are extracted when this option is set to no.
                    """

                class _context(PyArgumentsNumericalSubItem):
                    """
                    Argument context.
                    """

                class _object_setting(PyArgumentsTextualSubItem):
                    """
                    Argument object_setting.
                    """

                class _refacet_options(PyArgumentsSingletonSubItem):
                    """
                    Argument refacet_options.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.max_size = self._max_size(self, "max_size", service, rules, path)
                        self.normal_angle = self._normal_angle(self, "normal_angle", service, rules, path)
                        self.refacet_during_load = self._refacet_during_load(self, "refacet_during_load", service, rules, path)
                        self.deviation = self._deviation(self, "deviation", service, rules, path)

                    class _max_size(PyArgumentsNumericalSubItem):
                        """
                        Specify a maximum element size for the imported model to avoid very large facets during the file import.
                        """

                    class _normal_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify a rotational angle (in degrees) of transformation.
                        """

                    class _refacet_during_load(PyArgumentsParameterSubItem):
                        """
                        This option is available when DSCO is selected for the Import Route. When enabled, this option will refacet the geometry as it is converted to a .fmd file. This option eliminates the need for any refaceting operation after the geometry is loaded, which can be expensive.
                        """

                    class _deviation(PyArgumentsNumericalSubItem):
                        """
                        Specify the distance between facet edges and the geometry edges. Decreasing this value will result in more facets along curved edges.
                        """

            def create_instance(self) -> _import_cad_and_part_managementArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._import_cad_and_part_managementArguments(*args)

        class import_geometry(PyCommand):
            """
            Specify the CAD geometry that you want to work with. Choose from either a CAD file or a surface or volume mesh. Choose the appropriate units in which the geometry or mesh was created. Choose any advanced options (such as faceting controls) that you want to take effect upon import. Browse, or specify the file name and location for the CAD geometry that you are going to import. It is recommended to select units so that the minimum size is between approximately 0.1 and 10.  More...
            Parameters
            ----------
            file_format : str
                Indicate whether the imported geometry is a CAD File or a Mesh (either a surface or volume mesh).
            import_type : str
                When the File Format is set to CAD, use the Import Type field to import a Single File (the default), or Multiple Files. When importing multiple files, the Select File dialog allows you to make multiple selections, as long as the files are in the same directory and are of the same CAD format.
            length_unit : str
                Select a suitable working unit for the meshing operation, with a min size of the order of 1. The model will be automatically scaled to meters when switching to the solver. It is recommended to select units so that the minimum size is between approximately 0.1 - 10. If the minimum size falls outside of this range, then you should change the units.
            mesh_unit : str
                Specify the units in which the surface or volume mesh was created in.
            use_body_labels : bool
                Specify that you want to use any composite body labels that are defined in your imported CAD geometry by choosing Yes. If the imported CAD file does not contain any body labels, then this will automatically be set to No.
            import_cad_preferences : dict[str, Any]
            file_name : str
                Select a CAD file to import into your simulation. Supported file types are SpaceClaim (.scdoc) and Workbench (.agdb) files and also .pmdb files. Other supported formats include: *.CATpart, *.prt, *.x_t, *.sat, *.step, and *.iges files).
            file_names : str
                Select multiple CAD files to import into your simulation. When importing multiple files, use the browse button (...) to open the Select File dialog that allows you to make multiple selections, as long as the files are in the same directory and are of the same CAD format. Supported file types are SpaceClaim (.scdoc) and Workbench (.agdb) files and also .pmdb files. Other supported formats include: *.CATpart, *.prt, *.x_t, *.sat, *.step, and *.iges files).
            mesh_file_name : str
                Select a CAD file to import into your simulation. Supported file types are SpaceClaim (.scdoc) and Workbench (.agdb) files and also .pmdb files. Other supported formats include: *.CATpart, *.prt, *.x_t, *.sat, *.step, and *.iges files).
            num_parts : float
            append_mesh : bool
            directory : str
            pattern : str
            cad_import_options : dict[str, Any]

            Returns
            -------
            bool
            """
            class _import_geometryArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.file_format = self._file_format(self, "file_format", service, rules, path)
                    self.import_type = self._import_type(self, "import_type", service, rules, path)
                    self.length_unit = self._length_unit(self, "length_unit", service, rules, path)
                    self.mesh_unit = self._mesh_unit(self, "mesh_unit", service, rules, path)
                    self.use_body_labels = self._use_body_labels(self, "use_body_labels", service, rules, path)
                    self.import_cad_preferences = self._import_cad_preferences(self, "import_cad_preferences", service, rules, path)
                    self.file_name = self._file_name(self, "file_name", service, rules, path)
                    self.file_names = self._file_names(self, "file_names", service, rules, path)
                    self.mesh_file_name = self._mesh_file_name(self, "mesh_file_name", service, rules, path)
                    self.num_parts = self._num_parts(self, "num_parts", service, rules, path)
                    self.append_mesh = self._append_mesh(self, "append_mesh", service, rules, path)
                    self.directory = self._directory(self, "directory", service, rules, path)
                    self.pattern = self._pattern(self, "pattern", service, rules, path)
                    self.cad_import_options = self._cad_import_options(self, "cad_import_options", service, rules, path)

                class _file_format(PyArgumentsTextualSubItem):
                    """
                    Indicate whether the imported geometry is a CAD File or a Mesh (either a surface or volume mesh).
                    """

                class _import_type(PyArgumentsTextualSubItem):
                    """
                    When the File Format is set to CAD, use the Import Type field to import a Single File (the default), or Multiple Files. When importing multiple files, the Select File dialog allows you to make multiple selections, as long as the files are in the same directory and are of the same CAD format.
                    """

                class _length_unit(PyArgumentsTextualSubItem):
                    """
                    Select a suitable working unit for the meshing operation, with a min size of the order of 1. The model will be automatically scaled to meters when switching to the solver. It is recommended to select units so that the minimum size is between approximately 0.1 - 10. If the minimum size falls outside of this range, then you should change the units.
                    """

                class _mesh_unit(PyArgumentsTextualSubItem):
                    """
                    Specify the units in which the surface or volume mesh was created in.
                    """

                class _use_body_labels(PyArgumentsParameterSubItem):
                    """
                    Specify that you want to use any composite body labels that are defined in your imported CAD geometry by choosing Yes. If the imported CAD file does not contain any body labels, then this will automatically be set to No.
                    """

                class _import_cad_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument import_cad_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.separate_zone_by = self._separate_zone_by(self, "separate_zone_by", service, rules, path)
                        self.tolerance = self._tolerance(self, "tolerance", service, rules, path)
                        self.edge_label = self._edge_label(self, "edge_label", service, rules, path)
                        self.faceted_bodies = self._faceted_bodies(self, "faceted_bodies", service, rules, path)
                        self.max_facet_length = self._max_facet_length(self, "max_facet_length", service, rules, path)
                        self.extract_angle = self._extract_angle(self, "extract_angle", service, rules, path)
                        self.max_facet_length_option = self._max_facet_length_option(self, "max_facet_length_option", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)
                        self.automatic_object_creation = self._automatic_object_creation(self, "automatic_object_creation", service, rules, path)
                        self.max_facet_length_ratio = self._max_facet_length_ratio(self, "max_facet_length_ratio", service, rules, path)
                        self.merge_nodes = self._merge_nodes(self, "merge_nodes", service, rules, path)
                        self.separation_angle = self._separation_angle(self, "separation_angle", service, rules, path)
                        self.refaceting = self._refaceting(self, "refaceting", service, rules, path)

                    class _separate_zone_by(PyArgumentsTextualSubItem):
                        """
                        Choose whether or not you are going to separate zones upon import based on a region, a region and a specified separation angle, a face, or neither. This is required to select faces for local sizing. If Named Selections have already been defined at these locations, then separation is not needed.
                        """

                    class _tolerance(PyArgumentsNumericalSubItem):
                        """
                        Specify the level of facet refinement during import. A value approximately 1/10 of the intended minimum size is recommended. Using a value of 0 results in the coarsest possible faceting.
                        """

                    class _edge_label(PyArgumentsParameterSubItem):
                        """
                        Specify whether or not the imported CAD geometry already includes specific edges with assigned names (named selections). These named edges can be available later in the workflow when you are adding local size controls.
                        """

                    class _faceted_bodies(PyArgumentsParameterSubItem):
                        """
                        When performing faceting and wrapping operations in your CAD tool lead to non-CAD geometries, set this option to yes to be able to use such geometries in the workflow. To ensure a relatively good quality surface mesh, you should shrink wrap any faceted bodies. In addition, each shrink-wrapped faceted body should be defined in its own unique component within the CAD environment.
                        """

                    class _max_facet_length(PyArgumentsNumericalSubItem):
                        """
                        Enables you to specify a maximum facet size for the imported model to avoid very large facets during the file import. Depending on the CAD geometry, this may yield more accuracy.
                        """

                    class _extract_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument extract_angle.
                        """

                    class _max_facet_length_option(PyArgumentsTextualSubItem):
                        """
                        Set a maximum allowed edge length for faceted CAD import. Enabling this option helps limit overly long triangles during tessellation.
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Display advanced options that you may want to apply to the task.
                        """

                    class _automatic_object_creation(PyArgumentsParameterSubItem):
                        """
                        Determine whether or not mesh objects and labels are automatically created upon import, potentially and dramatically increasing the mesh import speed for very large cases. By default, this is set to yes however, if it is set to no, then no labels are created and a single mesh object is created employing all zones.
                        """

                    class _max_facet_length_ratio(PyArgumentsNumericalSubItem):
                        """
                        Specify a factor that scales the target size to compute the maximum facet edge length during tessellation. Larger factors allow longer facet edges.
                        """

                    class _merge_nodes(PyArgumentsParameterSubItem):
                        """
                        Argument merge_nodes.
                        """

                    class _separation_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify the angle at which features will be extracted from the CAD model on import. Assigning a smaller separation angle will produce more zones.
                        """

                    class _refaceting(PyArgumentsParameterSubItem):
                        """
                        Enable this option to be able to set the Tolerance and the Max Facet Length custom faceting options for the imported geometry.
                        """

                class _file_name(PyArgumentsTextualSubItem):
                    """
                    Select a CAD file to import into your simulation. Supported file types are SpaceClaim (.scdoc) and Workbench (.agdb) files and also .pmdb files. Other supported formats include: \\*.CATpart, \\*.prt, \\*.x_t, \\*.sat, \\*.step, and \\*.iges files).
                    """

                class _file_names(PyArgumentsTextualSubItem):
                    """
                    Select multiple CAD files to import into your simulation. When importing multiple files, use the browse button (...) to open the Select File dialog that allows you to make multiple selections, as long as the files are in the same directory and are of the same CAD format. Supported file types are SpaceClaim (.scdoc) and Workbench (.agdb) files and also .pmdb files. Other supported formats include: \\*.CATpart, \\*.prt, \\*.x_t, \\*.sat, \\*.step, and \\*.iges files).
                    """

                class _mesh_file_name(PyArgumentsTextualSubItem):
                    """
                    Select a CAD file to import into your simulation. Supported file types are SpaceClaim (.scdoc) and Workbench (.agdb) files and also .pmdb files. Other supported formats include: \\*.CATpart, \\*.prt, \\*.x_t, \\*.sat, \\*.step, and \\*.iges files).
                    """

                class _num_parts(PyArgumentsNumericalSubItem):
                    """
                    Argument num_parts.
                    """

                class _append_mesh(PyArgumentsParameterSubItem):
                    """
                    Argument append_mesh.
                    """

                class _directory(PyArgumentsTextualSubItem):
                    """
                    Argument directory.
                    """

                class _pattern(PyArgumentsTextualSubItem):
                    """
                    Argument pattern.
                    """

                class _cad_import_options(PyArgumentsSingletonSubItem):
                    """
                    Argument cad_import_options.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.import_part_names = self._import_part_names(self, "import_part_names", service, rules, path)
                        self.extract_features = self._extract_features(self, "extract_features", service, rules, path)
                        self.import_named_selections = self._import_named_selections(self, "import_named_selections", service, rules, path)
                        self.create_cad_assemblies = self._create_cad_assemblies(self, "create_cad_assemblies", service, rules, path)
                        self.use_part_or_body_as_suffix = self._use_part_or_body_as_suffix(self, "use_part_or_body_as_suffix", service, rules, path)
                        self.one_zone_per = self._one_zone_per(self, "one_zone_per", service, rules, path)
                        self.save_pmdb_intermediate_file = self._save_pmdb_intermediate_file(self, "save_pmdb_intermediate_file", service, rules, path)
                        self.open_all_cad_in_subdirectories = self._open_all_cad_in_subdirectories(self, "open_all_cad_in_subdirectories", service, rules, path)
                        self.one_object_per = self._one_object_per(self, "one_object_per", service, rules, path)
                        self.feature_angle = self._feature_angle(self, "feature_angle", service, rules, path)
                        self.import_curvature_data_from_cad = self._import_curvature_data_from_cad(self, "import_curvature_data_from_cad", service, rules, path)

                    class _import_part_names(PyArgumentsParameterSubItem):
                        """
                        Argument import_part_names.
                        """

                    class _extract_features(PyArgumentsParameterSubItem):
                        """
                        Argument extract_features.
                        """

                    class _import_named_selections(PyArgumentsParameterSubItem):
                        """
                        Argument import_named_selections.
                        """

                    class _create_cad_assemblies(PyArgumentsParameterSubItem):
                        """
                        Argument create_cad_assemblies.
                        """

                    class _use_part_or_body_as_suffix(PyArgumentsParameterSubItem):
                        """
                        Argument use_part_or_body_as_suffix.
                        """

                    class _one_zone_per(PyArgumentsTextualSubItem):
                        """
                        Argument one_zone_per.
                        """

                    class _save_pmdb_intermediate_file(PyArgumentsParameterSubItem):
                        """
                        Argument save_pmdb_intermediate_file.
                        """

                    class _open_all_cad_in_subdirectories(PyArgumentsParameterSubItem):
                        """
                        Argument open_all_cad_in_subdirectories.
                        """

                    class _one_object_per(PyArgumentsTextualSubItem):
                        """
                        Argument one_object_per.
                        """

                    class _feature_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument feature_angle.
                        """

                    class _import_curvature_data_from_cad(PyArgumentsParameterSubItem):
                        """
                        Argument import_curvature_data_from_cad.
                        """

            def create_instance(self) -> _import_geometryArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._import_geometryArguments(*args)

        class improve_surface_mesh(PyCommand):
            """
            Perform immediate improvements to the quality of the existing surface mesh by adjusting various parameters such as the face quality limit, as well as maximum angle and face skewness.  More...
            Parameters
            ----------
            mesh_object : str
            face_quality_limit : float
                Use the specified value to improve the surface mesh. Note that this control can aggressively change your surface mesh when applied.
            min_size : float
            scope_improve_to : str
            improve_surface_mesh_preferences : dict[str, Any]

            Returns
            -------
            bool
            """
            class _improve_surface_meshArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.mesh_object = self._mesh_object(self, "mesh_object", service, rules, path)
                    self.face_quality_limit = self._face_quality_limit(self, "face_quality_limit", service, rules, path)
                    self.min_size = self._min_size(self, "min_size", service, rules, path)
                    self.scope_improve_to = self._scope_improve_to(self, "scope_improve_to", service, rules, path)
                    self.improve_surface_mesh_preferences = self._improve_surface_mesh_preferences(self, "improve_surface_mesh_preferences", service, rules, path)

                class _mesh_object(PyArgumentsTextualSubItem):
                    """
                    Argument mesh_object.
                    """

                class _face_quality_limit(PyArgumentsNumericalSubItem):
                    """
                    Use the specified value to improve the surface mesh. Note that this control can aggressively change your surface mesh when applied.
                    """

                class _min_size(PyArgumentsNumericalSubItem):
                    """
                    Argument min_size.
                    """

                class _scope_improve_to(PyArgumentsTextualSubItem):
                    """
                    Argument scope_improve_to.
                    """

                class _improve_surface_mesh_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument improve_surface_mesh_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.si_improve_dihedral_angle = self._si_improve_dihedral_angle(self, "si_improve_dihedral_angle", service, rules, path)
                        self.si_quality_iterations = self._si_quality_iterations(self, "si_quality_iterations", service, rules, path)
                        self.advanced_improve = self._advanced_improve(self, "advanced_improve", service, rules, path)
                        self.si_quality_collapse_limit = self._si_quality_collapse_limit(self, "si_quality_collapse_limit", service, rules, path)
                        self.si_step_width = self._si_step_width(self, "si_step_width", service, rules, path)
                        self.si_quality_max_angle = self._si_quality_max_angle(self, "si_quality_max_angle", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)
                        self.allow_defeaturing = self._allow_defeaturing(self, "allow_defeaturing", service, rules, path)
                        self.si_remove_step = self._si_remove_step(self, "si_remove_step", service, rules, path)
                        self.si_step_quality_limit = self._si_step_quality_limit(self, "si_step_quality_limit", service, rules, path)
                        self.si_dihedral_angle = self._si_dihedral_angle(self, "si_dihedral_angle", service, rules, path)

                    class _si_improve_dihedral_angle(PyArgumentsParameterSubItem):
                        """
                        Argument si_improve_dihedral_angle.
                        """

                    class _si_quality_iterations(PyArgumentsNumericalSubItem):
                        """
                        Specify the number of iterations that will be performed to improve the mesh.
                        """

                    class _advanced_improve(PyArgumentsParameterSubItem):
                        """
                        Argument advanced_improve.
                        """

                    class _si_quality_collapse_limit(PyArgumentsNumericalSubItem):
                        """
                        Specify the limiting skewness value for cell collapse to improve the mesh. The default value changes automatically when you change the Face Quality Limit.
                        """

                    class _si_step_width(PyArgumentsNumericalSubItem):
                        """
                        Specify the width of the step that you wish to remove.
                        """

                    class _si_quality_max_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify the maximum angle between the normals of adjacent faces during mesh improvement. This quality measure is useful in locating sharp corners in complicated geometries. The angle value ranges from 0-180 degrees.
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Display advanced options that you may want to apply to the task.
                        """

                    class _allow_defeaturing(PyArgumentsParameterSubItem):
                        """
                        Argument allow_defeaturing.
                        """

                    class _si_remove_step(PyArgumentsParameterSubItem):
                        """
                        Indicate if there are any small imperfections (ledge or step artifacts from the original CAD geometry) that can be removed as part of this task. If you select yes, then you must specify a Max Step Width and the Step Skewness Quality Limit.
                        """

                    class _si_step_quality_limit(PyArgumentsNumericalSubItem):
                        """
                        Specify the limiting skewness quality for the step(s) to be removed.
                        """

                    class _si_dihedral_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument si_dihedral_angle.
                        """

            def create_instance(self) -> _improve_surface_meshArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._improve_surface_meshArguments(*args)

        class improve_volume_mesh(PyCommand):
            """
            Perform immediate improvements to the quality of the existing volume mesh by adjusting various parameters such as the cell quality limit, as well as minimum angle and the ability to ignore problematic features.  More...
            Parameters
            ----------
            quality_method : str
                Choose from several different types of mesh quality controls (skewness, aspect ratio, change in size, and so on). Choices include Orthogonal (the default for the workflows), Enhanced Orthogonal, and Skewness. For more information, see  More... .
            cell_quality_limit : float
                Use the specified value to improve the volume mesh. Note that this control can aggressively change your volume mesh when applied.
            add_multiple_quality_methods : bool
                Use this option to specify quality criteria for multiple quality methods.
            quality_method_list : list[str]
            quality_criteria_list : list[str]
            old_quality_method_list : list[str]
            old_quality_criteria_list : list[str]
            improve_volume_mesh_preferences : dict[str, Any]

            Returns
            -------
            bool
            """
            class _improve_volume_meshArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.quality_method = self._quality_method(self, "quality_method", service, rules, path)
                    self.cell_quality_limit = self._cell_quality_limit(self, "cell_quality_limit", service, rules, path)
                    self.add_multiple_quality_methods = self._add_multiple_quality_methods(self, "add_multiple_quality_methods", service, rules, path)
                    self.quality_method_list = self._quality_method_list(self, "quality_method_list", service, rules, path)
                    self.quality_criteria_list = self._quality_criteria_list(self, "quality_criteria_list", service, rules, path)
                    self.old_quality_method_list = self._old_quality_method_list(self, "old_quality_method_list", service, rules, path)
                    self.old_quality_criteria_list = self._old_quality_criteria_list(self, "old_quality_criteria_list", service, rules, path)
                    self.improve_volume_mesh_preferences = self._improve_volume_mesh_preferences(self, "improve_volume_mesh_preferences", service, rules, path)

                class _quality_method(PyArgumentsTextualSubItem):
                    """
                    Choose from several different types of mesh quality controls (skewness, aspect ratio, change in size, and so on). Choices include Orthogonal (the default for the workflows), Enhanced Orthogonal, and Skewness. For more information, see  More... .
                    """

                class _cell_quality_limit(PyArgumentsNumericalSubItem):
                    """
                    Use the specified value to improve the volume mesh. Note that this control can aggressively change your volume mesh when applied.
                    """

                class _add_multiple_quality_methods(PyArgumentsParameterSubItem):
                    """
                    Use this option to specify quality criteria for multiple quality methods.
                    """

                class _quality_method_list(PyArgumentsTextualSubItem):
                    """
                    Argument quality_method_list.
                    """

                class _quality_criteria_list(PyArgumentsTextualSubItem):
                    """
                    Argument quality_criteria_list.
                    """

                class _old_quality_method_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_quality_method_list.
                    """

                class _old_quality_criteria_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_quality_criteria_list.
                    """

                class _improve_volume_mesh_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument improve_volume_mesh_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.iterations = self._iterations(self, "iterations", service, rules, path)
                        self.smooth_remaining_bad_cells = self._smooth_remaining_bad_cells(self, "smooth_remaining_bad_cells", service, rules, path)
                        self.min_angle = self._min_angle(self, "min_angle", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)

                    class _iterations(PyArgumentsNumericalSubItem):
                        """
                        Specify the number of iterations that will be performed to improve the mesh.
                        """

                    class _smooth_remaining_bad_cells(PyArgumentsParameterSubItem):
                        """
                        Choose whether or not to ignore geometric features that are related to any remaining problematic cells in the volume mesh.
                        """

                    class _min_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify the minimum angle between the normals of adjacent faces during mesh improvement. This quality measure is useful in locating sharp corners in complicated geometries. The angle value ranges from 0 to 180 degrees.
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Display advanced options that you may want to apply to the task.
                        """

            def create_instance(self) -> _improve_volume_meshArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._improve_volume_meshArguments(*args)

        class load_cad_geometry(PyCommand):
            """
            Command load_cad_geometry.

            Parameters
            ----------
            file_name : str
            length_unit : str
            route : str
            use_prime_geometry_kernel : bool
            faceting_tolerance : float
            create_object_per : str
            num_parts : float
            refaceting : dict[str, Any]

            Returns
            -------
            bool
            """
            class _load_cad_geometryArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.file_name = self._file_name(self, "file_name", service, rules, path)
                    self.length_unit = self._length_unit(self, "length_unit", service, rules, path)
                    self.route = self._route(self, "route", service, rules, path)
                    self.use_prime_geometry_kernel = self._use_prime_geometry_kernel(self, "use_prime_geometry_kernel", service, rules, path)
                    self.faceting_tolerance = self._faceting_tolerance(self, "faceting_tolerance", service, rules, path)
                    self.create_object_per = self._create_object_per(self, "create_object_per", service, rules, path)
                    self.num_parts = self._num_parts(self, "num_parts", service, rules, path)
                    self.refaceting = self._refaceting(self, "refaceting", service, rules, path)

                class _file_name(PyArgumentsTextualSubItem):
                    """
                    Argument file_name.
                    """

                class _length_unit(PyArgumentsTextualSubItem):
                    """
                    Argument length_unit.
                    """

                class _route(PyArgumentsTextualSubItem):
                    """
                    Argument route.
                    """

                class _use_prime_geometry_kernel(PyArgumentsParameterSubItem):
                    """
                    Argument use_prime_geometry_kernel.
                    """

                class _faceting_tolerance(PyArgumentsNumericalSubItem):
                    """
                    Argument faceting_tolerance.
                    """

                class _create_object_per(PyArgumentsTextualSubItem):
                    """
                    Argument create_object_per.
                    """

                class _num_parts(PyArgumentsNumericalSubItem):
                    """
                    Argument num_parts.
                    """

                class _refaceting(PyArgumentsSingletonSubItem):
                    """
                    Argument refaceting.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.facet_resolution = self._facet_resolution(self, "facet_resolution", service, rules, path)
                        self.max_edge_length_factor = self._max_edge_length_factor(self, "max_edge_length_factor", service, rules, path)
                        self.facet_max_edge_length = self._facet_max_edge_length(self, "facet_max_edge_length", service, rules, path)
                        self.deviation = self._deviation(self, "deviation", service, rules, path)
                        self.custom_deviation = self._custom_deviation(self, "custom_deviation", service, rules, path)
                        self.max_edge_length = self._max_edge_length(self, "max_edge_length", service, rules, path)
                        self.normal_angle = self._normal_angle(self, "normal_angle", service, rules, path)
                        self.custom_normal_angle = self._custom_normal_angle(self, "custom_normal_angle", service, rules, path)
                        self.refacet = self._refacet(self, "refacet", service, rules, path)

                    class _facet_resolution(PyArgumentsTextualSubItem):
                        """
                        Argument facet_resolution.
                        """

                    class _max_edge_length_factor(PyArgumentsNumericalSubItem):
                        """
                        Argument max_edge_length_factor.
                        """

                    class _facet_max_edge_length(PyArgumentsTextualSubItem):
                        """
                        Argument facet_max_edge_length.
                        """

                    class _deviation(PyArgumentsNumericalSubItem):
                        """
                        Argument deviation.
                        """

                    class _custom_deviation(PyArgumentsNumericalSubItem):
                        """
                        Argument custom_deviation.
                        """

                    class _max_edge_length(PyArgumentsNumericalSubItem):
                        """
                        Argument max_edge_length.
                        """

                    class _normal_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument normal_angle.
                        """

                    class _custom_normal_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument custom_normal_angle.
                        """

                    class _refacet(PyArgumentsParameterSubItem):
                        """
                        Argument refacet.
                        """

            def create_instance(self) -> _load_cad_geometryArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._load_cad_geometryArguments(*args)

        class manage_zones_ftm(PyCommand):
            """
            Use this task to perform common operations on cell zones or face zones, Prior to generating the volume mesh, you can perform operations such as separating zones, splitting cylindrical regions, or extracting edges. After generating your volume mesh, you can perform operations such as renaming, changing prefixes, and merging zones. Especially useful for complex models with numerous zones.  More...
            Parameters
            ----------
            type : str
                Indicate whether you are going to operate on Cell Zones or Face Zones. If your imported CAD geometry contains bodies with multiple body labels, you can also choose Body Labels.
            zone_filter : str
                Choose the type of zone. For cell zones, choose from Fluid, Solid, or All. For face zones, choose from Internal, Fluid-Fluid, Solid-Fluid, Fluid-Solid, External-Solid, External-Fluid, or External.
            size_filter : str
                Indicate how you would like to filter the list of zones: All, Less than, More than, or Equal to the indicated value for the Volume (cell zone) or Area (face zone).
            area : float
            volume : float
            equal_range : float
                Specify a percentage range to maintain equivalency for the cell zone volume value or the face zone area value.
            zone_or_label : str
                Choose how you want to make your selection (by label or zone name).
            label_list : list[str]
                Choose from the list of labels, or enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            topology_list : list[str]
            manage_face_zone_list : list[str]
                Choose from the list of face zones, or enter a text string to filter out the list of face zones. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            manage_cell_zone_list : list[str]
                Choose from the list of cell zones, or enter a text string to filter out the list of cell zones. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            body_label_list : list[str]
                Choose from the list of labels, or enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            operation : str
                Indicate the operation you wish to perform on the zones. When the task is located prior volume meshing: Separate Zones, Split Cylinders, Split normal to X, Split normal to Y, Split normal to Z, or Extract Edges. When the task is located after volume meshing: Change prefix, Rename, Merge, or Separate Zones. If your imported CAD geometry contains bodies with multiple body labels, you can also choose Merge cells within each body label
            operation_name : str
                The text string to be applied to this zone operation.
            control_name : str
                Specify a name for the managed zone control or use the default value.
            add_prefix_name : str
                The text string to be applied to this zone operation.
            face_merge : bool
                Indicate whether or not you want to merge faces as part of the zone operation.
            angle : float
                Specify a value for the separation angle for determining separation. Assigning a smaller separation angle will produce more zones.
            zone_list : list[str]
            complete_zone_list : list[str]
            complete_label_list : list[str]
                Choose from the list of labels, or enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_location : list[str]

            Returns
            -------
            bool
            """
            class _manage_zones_ftmArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.type = self._type(self, "type", service, rules, path)
                    self.zone_filter = self._zone_filter(self, "zone_filter", service, rules, path)
                    self.size_filter = self._size_filter(self, "size_filter", service, rules, path)
                    self.area = self._area(self, "area", service, rules, path)
                    self.volume = self._volume(self, "volume", service, rules, path)
                    self.equal_range = self._equal_range(self, "equal_range", service, rules, path)
                    self.zone_or_label = self._zone_or_label(self, "zone_or_label", service, rules, path)
                    self.label_list = self._label_list(self, "label_list", service, rules, path)
                    self.topology_list = self._topology_list(self, "topology_list", service, rules, path)
                    self.manage_face_zone_list = self._manage_face_zone_list(self, "manage_face_zone_list", service, rules, path)
                    self.manage_cell_zone_list = self._manage_cell_zone_list(self, "manage_cell_zone_list", service, rules, path)
                    self.body_label_list = self._body_label_list(self, "body_label_list", service, rules, path)
                    self.operation = self._operation(self, "operation", service, rules, path)
                    self.operation_name = self._operation_name(self, "operation_name", service, rules, path)
                    self.control_name = self._control_name(self, "control_name", service, rules, path)
                    self.add_prefix_name = self._add_prefix_name(self, "add_prefix_name", service, rules, path)
                    self.face_merge = self._face_merge(self, "face_merge", service, rules, path)
                    self.angle = self._angle(self, "angle", service, rules, path)
                    self.zone_list = self._zone_list(self, "zone_list", service, rules, path)
                    self.complete_zone_list = self._complete_zone_list(self, "complete_zone_list", service, rules, path)
                    self.complete_label_list = self._complete_label_list(self, "complete_label_list", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)

                class _type(PyArgumentsTextualSubItem):
                    """
                    Indicate whether you are going to operate on Cell Zones or Face Zones. If your imported CAD geometry contains bodies with multiple body labels, you can also choose Body Labels.
                    """

                class _zone_filter(PyArgumentsTextualSubItem):
                    """
                    Choose the type of zone. For cell zones, choose from Fluid, Solid, or All. For face zones, choose from Internal, Fluid-Fluid, Solid-Fluid, Fluid-Solid, External-Solid, External-Fluid, or External.
                    """

                class _size_filter(PyArgumentsTextualSubItem):
                    """
                    Indicate how you would like to filter the list of zones: All, Less than, More than, or Equal to the indicated value for the Volume (cell zone) or Area (face zone).
                    """

                class _area(PyArgumentsNumericalSubItem):
                    """
                    Argument area.
                    """

                class _volume(PyArgumentsNumericalSubItem):
                    """
                    Argument volume.
                    """

                class _equal_range(PyArgumentsNumericalSubItem):
                    """
                    Specify a percentage range to maintain equivalency for the cell zone volume value or the face zone area value.
                    """

                class _zone_or_label(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to make your selection (by label or zone name).
                    """

                class _label_list(PyArgumentsTextualSubItem):
                    """
                    Choose from the list of labels, or enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _topology_list(PyArgumentsTextualSubItem):
                    """
                    Argument topology_list.
                    """

                class _manage_face_zone_list(PyArgumentsTextualSubItem):
                    """
                    Choose from the list of face zones, or enter a text string to filter out the list of face zones. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _manage_cell_zone_list(PyArgumentsTextualSubItem):
                    """
                    Choose from the list of cell zones, or enter a text string to filter out the list of cell zones. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _body_label_list(PyArgumentsTextualSubItem):
                    """
                    Choose from the list of labels, or enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _operation(PyArgumentsTextualSubItem):
                    """
                    Indicate the operation you wish to perform on the zones. When the task is located prior volume meshing: Separate Zones, Split Cylinders, Split normal to X, Split normal to Y, Split normal to Z, or Extract Edges. When the task is located after volume meshing: Change prefix, Rename, Merge, or Separate Zones. If your imported CAD geometry contains bodies with multiple body labels, you can also choose Merge cells within each body label
                    """

                class _operation_name(PyArgumentsTextualSubItem):
                    """
                    The text string to be applied to this zone operation.
                    """

                class _control_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the managed zone control or use the default value.
                    """

                class _add_prefix_name(PyArgumentsTextualSubItem):
                    """
                    The text string to be applied to this zone operation.
                    """

                class _face_merge(PyArgumentsParameterSubItem):
                    """
                    Indicate whether or not you want to merge faces as part of the zone operation.
                    """

                class _angle(PyArgumentsNumericalSubItem):
                    """
                    Specify a value for the separation angle for determining separation. Assigning a smaller separation angle will produce more zones.
                    """

                class _zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument zone_list.
                    """

                class _complete_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument complete_zone_list.
                    """

                class _complete_label_list(PyArgumentsTextualSubItem):
                    """
                    Choose from the list of labels, or enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

            def create_instance(self) -> _manage_zones_ftmArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._manage_zones_ftmArguments(*args)

        class mesh_controls_table(PyCommand):
            """
            Review the mesh control settings, such as the Minimum Size, the Maximum Size, and the Growth Rate, as well as a table of common settings.
            Parameters
            ----------
            global_min : float
            global_max : float
            target_growth_rate : float
            draw_size_control : bool
                Enable this field to display the size boxes in the graphics window.
            initial_size_control : bool
                Enable this field to display the initial size control in the graphics window.
            target_size_control : bool
                Enable this field to display the target size control in the graphics window.
            size_control_interval : float
                Specify the amount of size control boxes to display.
            size_control_parameters : dict[str, Any]

            Returns
            -------
            bool
            """
            class _mesh_controls_tableArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.global_min = self._global_min(self, "global_min", service, rules, path)
                    self.global_max = self._global_max(self, "global_max", service, rules, path)
                    self.target_growth_rate = self._target_growth_rate(self, "target_growth_rate", service, rules, path)
                    self.draw_size_control = self._draw_size_control(self, "draw_size_control", service, rules, path)
                    self.initial_size_control = self._initial_size_control(self, "initial_size_control", service, rules, path)
                    self.target_size_control = self._target_size_control(self, "target_size_control", service, rules, path)
                    self.size_control_interval = self._size_control_interval(self, "size_control_interval", service, rules, path)
                    self.size_control_parameters = self._size_control_parameters(self, "size_control_parameters", service, rules, path)

                class _global_min(PyArgumentsNumericalSubItem):
                    """
                    Argument global_min.
                    """

                class _global_max(PyArgumentsNumericalSubItem):
                    """
                    Argument global_max.
                    """

                class _target_growth_rate(PyArgumentsNumericalSubItem):
                    """
                    Argument target_growth_rate.
                    """

                class _draw_size_control(PyArgumentsParameterSubItem):
                    """
                    Enable this field to display the size boxes in the graphics window.
                    """

                class _initial_size_control(PyArgumentsParameterSubItem):
                    """
                    Enable this field to display the initial size control in the graphics window.
                    """

                class _target_size_control(PyArgumentsParameterSubItem):
                    """
                    Enable this field to display the target size control in the graphics window.
                    """

                class _size_control_interval(PyArgumentsNumericalSubItem):
                    """
                    Specify the amount of size control boxes to display.
                    """

                class _size_control_parameters(PyArgumentsSingletonSubItem):
                    """
                    Argument size_control_parameters.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.new_labels = self._new_labels(self, "new_labels", service, rules, path)
                        self.new_label_type = self._new_label_type(self, "new_label_type", service, rules, path)
                        self.new_label_curvature = self._new_label_curvature(self, "new_label_curvature", service, rules, path)
                        self.new_label_resolution = self._new_label_resolution(self, "new_label_resolution", service, rules, path)
                        self.new_label_max = self._new_label_max(self, "new_label_max", service, rules, path)
                        self.new_label_min = self._new_label_min(self, "new_label_min", service, rules, path)
                        self.new_label_cells = self._new_label_cells(self, "new_label_cells", service, rules, path)
                        self.new_label_objects = self._new_label_objects(self, "new_label_objects", service, rules, path)
                        self.new_zone_type = self._new_zone_type(self, "new_zone_type", service, rules, path)

                    class _new_labels(PyArgumentsTextualSubItem):
                        """
                        Argument new_labels.
                        """

                    class _new_label_type(PyArgumentsTextualSubItem):
                        """
                        Argument new_label_type.
                        """

                    class _new_label_curvature(PyArgumentsTextualSubItem):
                        """
                        Argument new_label_curvature.
                        """

                    class _new_label_resolution(PyArgumentsTextualSubItem):
                        """
                        Argument new_label_resolution.
                        """

                    class _new_label_max(PyArgumentsTextualSubItem):
                        """
                        Argument new_label_max.
                        """

                    class _new_label_min(PyArgumentsTextualSubItem):
                        """
                        Argument new_label_min.
                        """

                    class _new_label_cells(PyArgumentsTextualSubItem):
                        """
                        Argument new_label_cells.
                        """

                    class _new_label_objects(PyArgumentsTextualSubItem):
                        """
                        Argument new_label_objects.
                        """

                    class _new_zone_type(PyArgumentsTextualSubItem):
                        """
                        Argument new_zone_type.
                        """

            def create_instance(self) -> _mesh_controls_tableArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._mesh_controls_tableArguments(*args)

        class modify_mesh_refinement(PyCommand):
            """
            Perform individual modifications to the surface mesh by creating mesh refinement objects and sequences. Assign a name, a remeshing sequence if desired, along with local sizing parameters. Create as many refinement controls as needed in order to modify the surface mesh to your needs. Choose any advanced options that you want to take effect upon updating the task.  More...
            Parameters
            ----------
            mesh_object : str
            remesh_execution : str
                Specify whether to just add the current size control to the workflow, or to add the size control and perform a remeshing operation immediately thereafter.
            remesh_control_name : str
                Provide a name for this specific size control.
            local_size : float
                Specify a value for the local sizing parameter to be applied to the indicated zone.
            face_zone_or_label : str
                Specify whether the size control is to be applied to an indicated zone or a label.
            remesh_face_zone_list : list[str]
                Choose from the list of zones, or enter a text string to filter out the list of face zones. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            remesh_face_label_list : list[str]
                Choose from the list of zone labels, or enter a text string to filter out the list of face zone labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            sizing_type : str
            local_min_size : float
            local_max_size : float
            remesh_growth_rate : float
            remesh_curvature_normal_angle : float
            remesh_cells_per_gap : float
            cfd_surface_mesh_controls : dict[str, Any]
            remesh_preferences : dict[str, Any]

            Returns
            -------
            bool
            """
            class _modify_mesh_refinementArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.mesh_object = self._mesh_object(self, "mesh_object", service, rules, path)
                    self.remesh_execution = self._remesh_execution(self, "remesh_execution", service, rules, path)
                    self.remesh_control_name = self._remesh_control_name(self, "remesh_control_name", service, rules, path)
                    self.local_size = self._local_size(self, "local_size", service, rules, path)
                    self.face_zone_or_label = self._face_zone_or_label(self, "face_zone_or_label", service, rules, path)
                    self.remesh_face_zone_list = self._remesh_face_zone_list(self, "remesh_face_zone_list", service, rules, path)
                    self.remesh_face_label_list = self._remesh_face_label_list(self, "remesh_face_label_list", service, rules, path)
                    self.sizing_type = self._sizing_type(self, "sizing_type", service, rules, path)
                    self.local_min_size = self._local_min_size(self, "local_min_size", service, rules, path)
                    self.local_max_size = self._local_max_size(self, "local_max_size", service, rules, path)
                    self.remesh_growth_rate = self._remesh_growth_rate(self, "remesh_growth_rate", service, rules, path)
                    self.remesh_curvature_normal_angle = self._remesh_curvature_normal_angle(self, "remesh_curvature_normal_angle", service, rules, path)
                    self.remesh_cells_per_gap = self._remesh_cells_per_gap(self, "remesh_cells_per_gap", service, rules, path)
                    self.cfd_surface_mesh_controls = self._cfd_surface_mesh_controls(self, "cfd_surface_mesh_controls", service, rules, path)
                    self.remesh_preferences = self._remesh_preferences(self, "remesh_preferences", service, rules, path)

                class _mesh_object(PyArgumentsTextualSubItem):
                    """
                    Argument mesh_object.
                    """

                class _remesh_execution(PyArgumentsTextualSubItem):
                    """
                    Specify whether to just add the current size control to the workflow, or to add the size control and perform a remeshing operation immediately thereafter.
                    """

                class _remesh_control_name(PyArgumentsTextualSubItem):
                    """
                    Provide a name for this specific size control.
                    """

                class _local_size(PyArgumentsNumericalSubItem):
                    """
                    Specify a value for the local sizing parameter to be applied to the indicated zone.
                    """

                class _face_zone_or_label(PyArgumentsTextualSubItem):
                    """
                    Specify whether the size control is to be applied to an indicated zone or a label.
                    """

                class _remesh_face_zone_list(PyArgumentsTextualSubItem):
                    """
                    Choose from the list of zones, or enter a text string to filter out the list of face zones. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _remesh_face_label_list(PyArgumentsTextualSubItem):
                    """
                    Choose from the list of zone labels, or enter a text string to filter out the list of face zone labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _sizing_type(PyArgumentsTextualSubItem):
                    """
                    Argument sizing_type.
                    """

                class _local_min_size(PyArgumentsNumericalSubItem):
                    """
                    Argument local_min_size.
                    """

                class _local_max_size(PyArgumentsNumericalSubItem):
                    """
                    Argument local_max_size.
                    """

                class _remesh_growth_rate(PyArgumentsNumericalSubItem):
                    """
                    Argument remesh_growth_rate.
                    """

                class _remesh_curvature_normal_angle(PyArgumentsNumericalSubItem):
                    """
                    Argument remesh_curvature_normal_angle.
                    """

                class _remesh_cells_per_gap(PyArgumentsNumericalSubItem):
                    """
                    Argument remesh_cells_per_gap.
                    """

                class _cfd_surface_mesh_controls(PyArgumentsSingletonSubItem):
                    """
                    Argument cfd_surface_mesh_controls.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.scope_proximity_to = self._scope_proximity_to(self, "scope_proximity_to", service, rules, path)
                        self.object_based_controls = self._object_based_controls(self, "object_based_controls", service, rules, path)
                        self.draw_size_control = self._draw_size_control(self, "draw_size_control", service, rules, path)
                        self.cells_per_gap = self._cells_per_gap(self, "cells_per_gap", service, rules, path)
                        self.min_size = self._min_size(self, "min_size", service, rules, path)
                        self.preview_sizefield = self._preview_sizefield(self, "preview_sizefield", service, rules, path)
                        self.max_size = self._max_size(self, "max_size", service, rules, path)
                        self.size_functions = self._size_functions(self, "size_functions", service, rules, path)
                        self.remesh_imported_mesh = self._remesh_imported_mesh(self, "remesh_imported_mesh", service, rules, path)
                        self.save_size_field = self._save_size_field(self, "save_size_field", service, rules, path)
                        self.curvature_normal_angle = self._curvature_normal_angle(self, "curvature_normal_angle", service, rules, path)
                        self.refacet = self._refacet(self, "refacet", service, rules, path)
                        self.growth_rate = self._growth_rate(self, "growth_rate", service, rules, path)
                        self.auto_create_scoped_sizing = self._auto_create_scoped_sizing(self, "auto_create_scoped_sizing", service, rules, path)
                        self.size_field_file = self._size_field_file(self, "size_field_file", service, rules, path)
                        self.size_control_file = self._size_control_file(self, "size_control_file", service, rules, path)
                        self.use_size_files = self._use_size_files(self, "use_size_files", service, rules, path)
                        self.save_size_field_file = self._save_size_field_file(self, "save_size_field_file", service, rules, path)
                        self.surface_mesh_method = self._surface_mesh_method(self, "surface_mesh_method", service, rules, path)

                    class _scope_proximity_to(PyArgumentsTextualSubItem):
                        """
                        Argument scope_proximity_to.
                        """

                    class _object_based_controls(PyArgumentsParameterSubItem):
                        """
                        Argument object_based_controls.
                        """

                    class _draw_size_control(PyArgumentsParameterSubItem):
                        """
                        Enable this field to display the size boxes in the graphics window.
                        """

                    class _cells_per_gap(PyArgumentsNumericalSubItem):
                        """
                        Argument cells_per_gap.
                        """

                    class _min_size(PyArgumentsNumericalSubItem):
                        """
                        Argument min_size.
                        """

                    class _preview_sizefield(PyArgumentsParameterSubItem):
                        """
                        Argument preview_sizefield.
                        """

                    class _max_size(PyArgumentsNumericalSubItem):
                        """
                        Argument max_size.
                        """

                    class _size_functions(PyArgumentsTextualSubItem):
                        """
                        Argument size_functions.
                        """

                    class _remesh_imported_mesh(PyArgumentsTextualSubItem):
                        """
                        Argument remesh_imported_mesh.
                        """

                    class _save_size_field(PyArgumentsParameterSubItem):
                        """
                        Argument save_size_field.
                        """

                    class _curvature_normal_angle(PyArgumentsNumericalSubItem):
                        """
                        Argument curvature_normal_angle.
                        """

                    class _refacet(PyArgumentsParameterSubItem):
                        """
                        Argument refacet.
                        """

                    class _growth_rate(PyArgumentsNumericalSubItem):
                        """
                        Argument growth_rate.
                        """

                    class _auto_create_scoped_sizing(PyArgumentsParameterSubItem):
                        """
                        Argument auto_create_scoped_sizing.
                        """

                    class _size_field_file(PyArgumentsTextualSubItem):
                        """
                        Argument size_field_file.
                        """

                    class _size_control_file(PyArgumentsTextualSubItem):
                        """
                        Argument size_control_file.
                        """

                    class _use_size_files(PyArgumentsTextualSubItem):
                        """
                        Argument use_size_files.
                        """

                    class _save_size_field_file(PyArgumentsTextualSubItem):
                        """
                        Argument save_size_field_file.
                        """

                    class _surface_mesh_method(PyArgumentsTextualSubItem):
                        """
                        Argument surface_mesh_method.
                        """

                class _remesh_preferences(PyArgumentsSingletonSubItem):
                    """
                    Argument remesh_preferences.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.corner_angle = self._corner_angle(self, "corner_angle", service, rules, path)
                        self.feature_max_angle = self._feature_max_angle(self, "feature_max_angle", service, rules, path)
                        self.remesh_feature_min_angle = self._remesh_feature_min_angle(self, "remesh_feature_min_angle", service, rules, path)
                        self.show_in_gui = self._show_in_gui(self, "show_in_gui", service, rules, path)

                    class _corner_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify the corner angle for remeshing.
                        """

                    class _feature_max_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify the maximum angle for which features will be preserved upon remeshing.
                        """

                    class _remesh_feature_min_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify the minimum angle for which features will be preserved upon remeshing.
                        """

                    class _show_in_gui(PyArgumentsParameterSubItem):
                        """
                        Display advanced options that you may want to apply to the task.
                        """

            def create_instance(self) -> _modify_mesh_refinementArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._modify_mesh_refinementArguments(*args)

        class part_replacement_options(PyCommand):
            """
            After creating a volume mesh, use this task to append, add, remove, or replace portions of your original geometry with other CAD parts. By applying localized surface mesh or volume mesh based analyses, you can use this task to quickly update the volume mesh to easily see how geometry changes impact the volume mesh.
            Parameters
            ----------
            add_part_management : bool
                Determine whether or not you will be appending new CAD parts to your original geometry. Answering Yes will add an Import CAD and Part Management task.
            add_part_replacement : bool
            add_local_sizing : bool
                Determine whether or not you will need to apply local sizing controls. Answering Yes will add an Add Local Sizing for Part Replacement task.
            add_boundary_layer : bool
                Determine whether or not you will need to apply boundary layer (prism controls) to your replacement parts. Answering Yes will add an Add Boundary Layers for Part Replacement task.
            add_update_the_volume_mesh : bool
                Use this task to remove the existing volume mesh and to update the volume mesh with your new part replacement changes.

            Returns
            -------
            bool
            """
            class _part_replacement_optionsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.add_part_management = self._add_part_management(self, "add_part_management", service, rules, path)
                    self.add_part_replacement = self._add_part_replacement(self, "add_part_replacement", service, rules, path)
                    self.add_local_sizing = self._add_local_sizing(self, "add_local_sizing", service, rules, path)
                    self.add_boundary_layer = self._add_boundary_layer(self, "add_boundary_layer", service, rules, path)
                    self.add_update_the_volume_mesh = self._add_update_the_volume_mesh(self, "add_update_the_volume_mesh", service, rules, path)

                class _add_part_management(PyArgumentsParameterSubItem):
                    """
                    Determine whether or not you will be appending new CAD parts to your original geometry. Answering Yes will add an Import CAD and Part Management task.
                    """

                class _add_part_replacement(PyArgumentsParameterSubItem):
                    """
                    Argument add_part_replacement.
                    """

                class _add_local_sizing(PyArgumentsParameterSubItem):
                    """
                    Determine whether or not you will need to apply local sizing controls. Answering Yes will add an Add Local Sizing for Part Replacement task.
                    """

                class _add_boundary_layer(PyArgumentsParameterSubItem):
                    """
                    Determine whether or not you will need to apply boundary layer (prism controls) to your replacement parts. Answering Yes will add an Add Boundary Layers for Part Replacement task.
                    """

                class _add_update_the_volume_mesh(PyArgumentsParameterSubItem):
                    """
                    Use this task to remove the existing volume mesh and to update the volume mesh with your new part replacement changes.
                    """

            def create_instance(self) -> _part_replacement_optionsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._part_replacement_optionsArguments(*args)

        class part_replacement_settings(PyCommand):
            """
            Use this task to define particular details for the part replacement operation where you can choose to add, remove, or replace one or more portions of your original imported geometry.
            Parameters
            ----------
            part_replacement_name : str
                Enter a name for the part replacement object, or keep the default value.
            management_method : str
                Choose whether the part replacement operation will be an Addition, Replacement, or Removal of a part.
            creation_method : str
                Choose the approach for handling meshing for the part replacement task: Surface Mesh Based or Volume Mesh Based. The volume mesh based approach defines a separate region for the area of interest surrounding the part replacement. Volume meshing is performed only in this region and thus is much faster than generating the volume mesh in the entire domain.  The surface mesh approach requires the remeshing of all volume regions.
            old_object_selection_list : list[str]
                For part replacement or removal, use this list to pick the original object(s) that you wish to replace or remove. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []).
            new_object_selection_list : list[str]
                For part replacement or addition, use this list to pick the new object(s) that you wish to replace or add. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []).
            advanced_options : bool
                Display advanced options that you may want to apply to the task.
            scaling_factor : float
                Specify a factor to change the size of the bounding box surrounding the selected object(s) for part replacement.
            mpt_method_type : str
                Choose how you are going to determine the location of the region around the replacement part - by using numerical inputs directly, or by using the region around the selected object(s).
            graphical_selection : bool
                Use this option to have the numerical inputs be automatically filled out based on the centroid of the object(s) selected in the graphics window.
            show_coordinates : bool
                Use this option to see the exact coordinate values of the current location point.
            x : float
                Indicates the x-coordinate of the current point location.
            y : float
                Indicates the y-coordinate of the current point location.
            z : float
                Indicates the z-coordinate of the current point location.

            Returns
            -------
            bool
            """
            class _part_replacement_settingsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.part_replacement_name = self._part_replacement_name(self, "part_replacement_name", service, rules, path)
                    self.management_method = self._management_method(self, "management_method", service, rules, path)
                    self.creation_method = self._creation_method(self, "creation_method", service, rules, path)
                    self.old_object_selection_list = self._old_object_selection_list(self, "old_object_selection_list", service, rules, path)
                    self.new_object_selection_list = self._new_object_selection_list(self, "new_object_selection_list", service, rules, path)
                    self.advanced_options = self._advanced_options(self, "advanced_options", service, rules, path)
                    self.scaling_factor = self._scaling_factor(self, "scaling_factor", service, rules, path)
                    self.mpt_method_type = self._mpt_method_type(self, "mpt_method_type", service, rules, path)
                    self.graphical_selection = self._graphical_selection(self, "graphical_selection", service, rules, path)
                    self.show_coordinates = self._show_coordinates(self, "show_coordinates", service, rules, path)
                    self.x = self._x(self, "x", service, rules, path)
                    self.y = self._y(self, "y", service, rules, path)
                    self.z = self._z(self, "z", service, rules, path)

                class _part_replacement_name(PyArgumentsTextualSubItem):
                    """
                    Enter a name for the part replacement object, or keep the default value.
                    """

                class _management_method(PyArgumentsTextualSubItem):
                    """
                    Choose whether the part replacement operation will be an Addition, Replacement, or Removal of a part.
                    """

                class _creation_method(PyArgumentsTextualSubItem):
                    """
                    Choose the approach for handling meshing for the part replacement task: Surface Mesh Based or Volume Mesh Based. The volume mesh based approach defines a separate region for the area of interest surrounding the part replacement. Volume meshing is performed only in this region and thus is much faster than generating the volume mesh in the entire domain.  The surface mesh approach requires the remeshing of all volume regions.
                    """

                class _old_object_selection_list(PyArgumentsTextualSubItem):
                    """
                    For part replacement or removal, use this list to pick the original object(s) that you wish to replace or remove. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []).
                    """

                class _new_object_selection_list(PyArgumentsTextualSubItem):
                    """
                    For part replacement or addition, use this list to pick the new object(s) that you wish to replace or add. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []).
                    """

                class _advanced_options(PyArgumentsParameterSubItem):
                    """
                    Display advanced options that you may want to apply to the task.
                    """

                class _scaling_factor(PyArgumentsNumericalSubItem):
                    """
                    Specify a factor to change the size of the bounding box surrounding the selected object(s) for part replacement.
                    """

                class _mpt_method_type(PyArgumentsTextualSubItem):
                    """
                    Choose how you are going to determine the location of the region around the replacement part - by using numerical inputs directly, or by using the region around the selected object(s).
                    """

                class _graphical_selection(PyArgumentsParameterSubItem):
                    """
                    Use this option to have the numerical inputs be automatically filled out based on the centroid of the object(s) selected in the graphics window.
                    """

                class _show_coordinates(PyArgumentsParameterSubItem):
                    """
                    Use this option to see the exact coordinate values of the current location point.
                    """

                class _x(PyArgumentsNumericalSubItem):
                    """
                    Indicates the x-coordinate of the current point location.
                    """

                class _y(PyArgumentsNumericalSubItem):
                    """
                    Indicates the y-coordinate of the current point location.
                    """

                class _z(PyArgumentsNumericalSubItem):
                    """
                    Indicates the z-coordinate of the current point location.
                    """

            def create_instance(self) -> _part_replacement_settingsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._part_replacement_settingsArguments(*args)

        class prepare_for_volume_meshing(PyCommand):
            """
            Command prepare_for_volume_meshing.

            Parameters
            ----------
            merge_zones_based_on_labels : bool
            soft_target_skewness : float
            hard_target_skewness : float

            Returns
            -------
            bool
            """
            class _prepare_for_volume_meshingArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.merge_zones_based_on_labels = self._merge_zones_based_on_labels(self, "merge_zones_based_on_labels", service, rules, path)
                    self.soft_target_skewness = self._soft_target_skewness(self, "soft_target_skewness", service, rules, path)
                    self.hard_target_skewness = self._hard_target_skewness(self, "hard_target_skewness", service, rules, path)

                class _merge_zones_based_on_labels(PyArgumentsParameterSubItem):
                    """
                    Argument merge_zones_based_on_labels.
                    """

                class _soft_target_skewness(PyArgumentsNumericalSubItem):
                    """
                    Argument soft_target_skewness.
                    """

                class _hard_target_skewness(PyArgumentsNumericalSubItem):
                    """
                    Argument hard_target_skewness.
                    """

            def create_instance(self) -> _prepare_for_volume_meshingArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._prepare_for_volume_meshingArguments(*args)

        class remesh_surface(PyCommand):
            """
            Command remesh_surface.

            Parameters
            ----------
            remesh_surface_option : bool

            Returns
            -------
            bool
            """
            class _remesh_surfaceArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.remesh_surface_option = self._remesh_surface_option(self, "remesh_surface_option", service, rules, path)

                class _remesh_surface_option(PyArgumentsParameterSubItem):
                    """
                    Argument remesh_surface_option.
                    """

            def create_instance(self) -> _remesh_surfaceArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._remesh_surfaceArguments(*args)

        class separate_contacts(PyCommand):
            """
            Enable or disable the ability to separate any existing contacts between surfaces.
            Parameters
            ----------
            separate_contacts_option : bool
                Use this option to enable or disable the ability to separate any existing contacts between surfaces.

            Returns
            -------
            bool
            """
            class _separate_contactsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.separate_contacts_option = self._separate_contacts_option(self, "separate_contacts_option", service, rules, path)

                class _separate_contacts_option(PyArgumentsParameterSubItem):
                    """
                    Use this option to enable or disable the ability to separate any existing contacts between surfaces.
                    """

            def create_instance(self) -> _separate_contactsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._separate_contactsArguments(*args)

        class set_up_rotational_periodic_boundaries(PyCommand):
            """
            Define boundaries suited for rotational periodicity. The task will remesh a single periodic face to exactly match its reference side, as well as create the corresponding periodic and shadow boundary types for use in the Fluent solver.   More...
            Parameters
            ----------
            mesh_object : str
            type : str
                Choose the type of periodicity: rotational or translational.
            method : str
                Choose the method for how you are going to define the periodic boundary. Automatic requires you to select two zones or labels. Manual requires only one zone or label.
            periodicity_angle : float
                Specify the angle at which periodicity occurs.
            rotation_axis_origin : dict[str, Any]
                The X, Y, and Z components of the origin point for the periodic boundary.
            rotation_axis_direction : dict[str, Any]
                The X, Y, and Z components of the vector for the periodic boundary.
            trans_shift : dict[str, Any]
            selection_type : str
                Specify whether the periodic boundary is to be applied to an indicated zone or a label.
            zone_list : list[str]
                Choose from the list of zones, or enter a text string to filter out the list of face zones. Provide text and/or regular expressions in filtering the list (for example, using *, ?, and []).  More...
            label_list : list[str]
                Choose from the list of zone labels, or enter a text string to filter out the list of face zone labels. Provide text and/or regular expressions in filtering the list (for example, using *, ?, and []).  More...
            topology_list : list[str]
            remesh_boundaries_option : str
                Enable this option to remesh boundaries when there is an asymmetric mesh on the periodic faces.
            zone_location : list[str]
            list_all_label_toggle : bool
                View more labels in the table, such as those for fluid-fluid internal boundaries, in addition to external boundaries.
            auto_multiple_periodic : bool
            multiple_option : str

            Returns
            -------
            bool
            """
            class _set_up_rotational_periodic_boundariesArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.mesh_object = self._mesh_object(self, "mesh_object", service, rules, path)
                    self.type = self._type(self, "type", service, rules, path)
                    self.method = self._method(self, "method", service, rules, path)
                    self.periodicity_angle = self._periodicity_angle(self, "periodicity_angle", service, rules, path)
                    self.rotation_axis_origin = self._rotation_axis_origin(self, "rotation_axis_origin", service, rules, path)
                    self.rotation_axis_direction = self._rotation_axis_direction(self, "rotation_axis_direction", service, rules, path)
                    self.trans_shift = self._trans_shift(self, "trans_shift", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.zone_list = self._zone_list(self, "zone_list", service, rules, path)
                    self.label_list = self._label_list(self, "label_list", service, rules, path)
                    self.topology_list = self._topology_list(self, "topology_list", service, rules, path)
                    self.remesh_boundaries_option = self._remesh_boundaries_option(self, "remesh_boundaries_option", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.list_all_label_toggle = self._list_all_label_toggle(self, "list_all_label_toggle", service, rules, path)
                    self.auto_multiple_periodic = self._auto_multiple_periodic(self, "auto_multiple_periodic", service, rules, path)
                    self.multiple_option = self._multiple_option(self, "multiple_option", service, rules, path)

                class _mesh_object(PyArgumentsTextualSubItem):
                    """
                    Argument mesh_object.
                    """

                class _type(PyArgumentsTextualSubItem):
                    """
                    Choose the type of periodicity: rotational or translational.
                    """

                class _method(PyArgumentsTextualSubItem):
                    """
                    Choose the method for how you are going to define the periodic boundary. Automatic requires you to select two zones or labels. Manual requires only one zone or label.
                    """

                class _periodicity_angle(PyArgumentsNumericalSubItem):
                    """
                    Specify the angle at which periodicity occurs.
                    """

                class _rotation_axis_origin(PyArgumentsSingletonSubItem):
                    """
                    The X, Y, and Z components of the origin point for the periodic boundary.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.y = self._y(self, "y", service, rules, path)
                        self.z = self._z(self, "z", service, rules, path)
                        self.x = self._x(self, "x", service, rules, path)

                    class _y(PyArgumentsNumericalSubItem):
                        """
                        The Y component of the origin point for the periodic boundary.
                        """

                    class _z(PyArgumentsNumericalSubItem):
                        """
                        The Z component of the origin point for the periodic boundary.
                        """

                    class _x(PyArgumentsNumericalSubItem):
                        """
                        The X component of the origin point for the periodic boundary.
                        """

                class _rotation_axis_direction(PyArgumentsSingletonSubItem):
                    """
                    The X, Y, and Z components of the vector for the periodic boundary.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.y = self._y(self, "y", service, rules, path)
                        self.z = self._z(self, "z", service, rules, path)
                        self.x = self._x(self, "x", service, rules, path)

                    class _y(PyArgumentsNumericalSubItem):
                        """
                        The Y component of the vector for the periodic boundary.
                        """

                    class _z(PyArgumentsNumericalSubItem):
                        """
                        The Z component of the vector for the periodic boundary.
                        """

                    class _x(PyArgumentsNumericalSubItem):
                        """
                        The X component of the vector for the periodic boundary.
                        """

                class _trans_shift(PyArgumentsSingletonSubItem):
                    """
                    Argument trans_shift.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.y = self._y(self, "y", service, rules, path)
                        self.z = self._z(self, "z", service, rules, path)
                        self.x = self._x(self, "x", service, rules, path)

                    class _y(PyArgumentsNumericalSubItem):
                        """
                        Specify the Y-coordinate of the translational shift.
                        """

                    class _z(PyArgumentsNumericalSubItem):
                        """
                        Specify the Z-coordinate of the translational shift.
                        """

                    class _x(PyArgumentsNumericalSubItem):
                        """
                        Specify the X-coordinate of the translational shift.
                        """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Specify whether the periodic boundary is to be applied to an indicated zone or a label.
                    """

                class _zone_list(PyArgumentsTextualSubItem):
                    """
                    Choose from the list of zones, or enter a text string to filter out the list of face zones. Provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []).  More...
                    """

                class _label_list(PyArgumentsTextualSubItem):
                    """
                    Choose from the list of zone labels, or enter a text string to filter out the list of face zone labels. Provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []).  More...
                    """

                class _topology_list(PyArgumentsTextualSubItem):
                    """
                    Argument topology_list.
                    """

                class _remesh_boundaries_option(PyArgumentsTextualSubItem):
                    """
                    Enable this option to remesh boundaries when there is an asymmetric mesh on the periodic faces.
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _list_all_label_toggle(PyArgumentsParameterSubItem):
                    """
                    View more labels in the table, such as those for fluid-fluid internal boundaries, in addition to external boundaries.
                    """

                class _auto_multiple_periodic(PyArgumentsParameterSubItem):
                    """
                    Argument auto_multiple_periodic.
                    """

                class _multiple_option(PyArgumentsTextualSubItem):
                    """
                    Argument multiple_option.
                    """

            def create_instance(self) -> _set_up_rotational_periodic_boundariesArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._set_up_rotational_periodic_boundariesArguments(*args)

        class setup_size_controls(PyCommand):
            """
            Create individual sizing controls for your mesh. For every size control that you create, it is added to the workflow as a subtask. More...
            Parameters
            ----------
            local_settings_name : str
                Specify a name for the size control or use the default value.
            compute_for_solid_only : str
            selection_type : str
                Choose how you want to make your selection (by object, label, or zone name).
            object_selection_list : list[str]
                Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            label_selection_list : list[str]
                Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_selection_list : list[str]
                Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            zone_location : list[str]
            edge_selection_list : list[str]
                Choose one or more edge zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            local_size_control_parameters : dict[str, Any]
            value_changed : str
            complete_zone_selection_list : list[str]
                Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            complete_label_selection_list : list[str]
                Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            complete_object_selection_list : list[str]
                Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            complete_edge_selection_list : list[str]
                Choose one or more edge zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...

            Returns
            -------
            bool
            """
            class _setup_size_controlsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.local_settings_name = self._local_settings_name(self, "local_settings_name", service, rules, path)
                    self.compute_for_solid_only = self._compute_for_solid_only(self, "compute_for_solid_only", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.object_selection_list = self._object_selection_list(self, "object_selection_list", service, rules, path)
                    self.label_selection_list = self._label_selection_list(self, "label_selection_list", service, rules, path)
                    self.zone_selection_list = self._zone_selection_list(self, "zone_selection_list", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.edge_selection_list = self._edge_selection_list(self, "edge_selection_list", service, rules, path)
                    self.local_size_control_parameters = self._local_size_control_parameters(self, "local_size_control_parameters", service, rules, path)
                    self.value_changed = self._value_changed(self, "value_changed", service, rules, path)
                    self.complete_zone_selection_list = self._complete_zone_selection_list(self, "complete_zone_selection_list", service, rules, path)
                    self.complete_label_selection_list = self._complete_label_selection_list(self, "complete_label_selection_list", service, rules, path)
                    self.complete_object_selection_list = self._complete_object_selection_list(self, "complete_object_selection_list", service, rules, path)
                    self.complete_edge_selection_list = self._complete_edge_selection_list(self, "complete_edge_selection_list", service, rules, path)

                class _local_settings_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the size control or use the default value.
                    """

                class _compute_for_solid_only(PyArgumentsTextualSubItem):
                    """
                    Argument compute_for_solid_only.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Choose how you want to make your selection (by object, label, or zone name).
                    """

                class _object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _label_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _edge_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more edge zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _local_size_control_parameters(PyArgumentsSingletonSubItem):
                    """
                    Argument local_size_control_parameters.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.scope_proximity_to = self._scope_proximity_to(self, "scope_proximity_to", service, rules, path)
                        self.cells_per_gap = self._cells_per_gap(self, "cells_per_gap", service, rules, path)
                        self.advanced_options = self._advanced_options(self, "advanced_options", service, rules, path)
                        self.initial_size_control = self._initial_size_control(self, "initial_size_control", service, rules, path)
                        self.min_size = self._min_size(self, "min_size", service, rules, path)
                        self.wrap_cells_per_gap = self._wrap_cells_per_gap(self, "wrap_cells_per_gap", service, rules, path)
                        self.max_size = self._max_size(self, "max_size", service, rules, path)
                        self.wrap_max = self._wrap_max(self, "wrap_max", service, rules, path)
                        self.wrap_curvature_normal_angle = self._wrap_curvature_normal_angle(self, "wrap_curvature_normal_angle", service, rules, path)
                        self.curvature_normal_angle = self._curvature_normal_angle(self, "curvature_normal_angle", service, rules, path)
                        self.growth_rate = self._growth_rate(self, "growth_rate", service, rules, path)
                        self.wrap_growth_rate = self._wrap_growth_rate(self, "wrap_growth_rate", service, rules, path)
                        self.ignore_self = self._ignore_self(self, "ignore_self", service, rules, path)
                        self.target_size_control = self._target_size_control(self, "target_size_control", service, rules, path)
                        self.wrap_min = self._wrap_min(self, "wrap_min", service, rules, path)
                        self.sizing_type = self._sizing_type(self, "sizing_type", service, rules, path)

                    class _scope_proximity_to(PyArgumentsTextualSubItem):
                        """
                        Set proximity based refinement. The edges option considers edge-to-edge proximity, while faces considers face-to-face proximity, and faces and edges considers both. Note that when you use the faces and edges option, you can only select objects.
                        """

                    class _cells_per_gap(PyArgumentsNumericalSubItem):
                        """
                        Specify the minimum number of layers of elements to be generated in the gaps. The number of cells per gap can be a real value, with a minimum value of 0.01.
                        """

                    class _advanced_options(PyArgumentsParameterSubItem):
                        """
                        Display advanced wrap-specific options that are also applied to the task. See this description  for more information about wrap (and target) mesh size controls.
                        """

                    class _initial_size_control(PyArgumentsParameterSubItem):
                        """
                        Enable this field to display the initial size control in the graphics window.
                        """

                    class _min_size(PyArgumentsNumericalSubItem):
                        """
                        Specify the minimum size of the elements for the surface mesh.
                        """

                    class _wrap_cells_per_gap(PyArgumentsNumericalSubItem):
                        """
                        Specify the minimum number of layers of elements to be generated in the gaps. The number of cells per gap can be a real value, with a minimum value of 0.01.
                        """

                    class _max_size(PyArgumentsNumericalSubItem):
                        """
                        Specify the maximum size of the elements for the surface mesh.
                        """

                    class _wrap_max(PyArgumentsNumericalSubItem):
                        """
                        Specify a value for the maximum wrapping size for the size control. It will wrap with this maximum size and later coarsen through remeshing to the given target size.
                        """

                    class _wrap_curvature_normal_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify the maximum allowable angle (from 0 to 180 degrees) that one element edge is allowed to span given a particular geometry curvature. You can use this field to limit the number of elements that are generated along a curve or surface if the minimum size is too small for that particular curve.
                        """

                    class _curvature_normal_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify the maximum allowable angle (from 0 to 180 degrees) that one element edge is allowed to span given a particular geometry curvature. You can use this field to limit the number of elements that are generated along a curve or surface if the minimum size is too small for that particular curve.
                        """

                    class _growth_rate(PyArgumentsNumericalSubItem):
                        """
                        Specify the increase in element edge length with each succeeding layer of elements.
                        """

                    class _wrap_growth_rate(PyArgumentsNumericalSubItem):
                        """
                        Specify the increase in element edge length with each succeeding layer of elements.
                        """

                    class _ignore_self(PyArgumentsParameterSubItem):
                        """
                        Select this option to ignore the proximity computation between facets within a face zone, and avoid over-refinement.
                        """

                    class _target_size_control(PyArgumentsParameterSubItem):
                        """
                        Enable this field to display the target size control in the graphics window.
                        """

                    class _wrap_min(PyArgumentsNumericalSubItem):
                        """
                        Specify a value for the minimum wrapping size for the size control. It will wrap with this minimum size and later coarsen through remeshing to the given target size. One of the advantages of the wrapper is that it can automatically de-feature unnecessary small details. The wrap size is used to wrap the geometry and target size is used to remesh. Feature capturing highly depends on the value of the wrap size. The default wrap size is 1/1.5 times smaller than the target size, and you can change the value.
                        """

                    class _sizing_type(PyArgumentsTextualSubItem):
                        """
                        Choose the type of sizing control (curvature, proximity, soft, or boi).
                        """

                class _value_changed(PyArgumentsTextualSubItem):
                    """
                    Argument value_changed.
                    """

                class _complete_zone_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _complete_label_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _complete_object_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _complete_edge_selection_list(PyArgumentsTextualSubItem):
                    """
                    Choose one or more edge zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

            def create_instance(self) -> _setup_size_controlsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._setup_size_controlsArguments(*args)

        class switch_to_solution(PyCommand):
            """
            Command switch_to_solution.


            Returns
            -------
            None
            """
            class _switch_to_solutionArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)

            def create_instance(self) -> _switch_to_solutionArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._switch_to_solutionArguments(*args)

        class transform_volume_mesh(PyCommand):
            """
            Use this task to create and apply either a translational or a rotational transformation to the volume mesh (or to one or more copies of the volume mesh). 
                           
                            More...
            Parameters
            ----------
            control_name : str
                Specify a name for the transformation or use the default value.
            type : str
                Indicate the type of transformation: translational or rotational
            method : str
                By default, the Manual method is utilized, however, when periodics are detected, then Automatic - use existing periodics is the default.
            selection_type : str
                Indicate the type of transformation: translational or rotational
            topo_body_list : list[str]
            cell_zone_list : list[str]
                Select one or more objects from the list to which you will apply the transformation. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using *, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or * in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
            rotation_axis_origin : dict[str, Any]
                Specify the coordinates of the rotational origin.
            rotation_axis_direction : dict[str, Any]
                Specify the coordinates of the rotational vector.
            trans_shift : dict[str, Any]
                Specify the coordinates of the translational shift.
            angle : float
                Specify a value for the angle of rotation for this transformation.
            copy : str
                Indicate whether or not to make a copy of the volume mesh and apply the transformation to the copy.
            num_of_copies : int
                Specify the number of copies that you want to make for this transformation.
            merge : str
                Indicate whether or not you want to merge cell and face zones prior to transforming the volume mesh, in order to avoid duplication.
            rename : bool
                Indicate whether or not you want to rename cell and face zones prior to transforming the volume mesh.
            merge_boundaries : list[str]

            Returns
            -------
            bool
            """
            class _transform_volume_meshArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.control_name = self._control_name(self, "control_name", service, rules, path)
                    self.type = self._type(self, "type", service, rules, path)
                    self.method = self._method(self, "method", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.topo_body_list = self._topo_body_list(self, "topo_body_list", service, rules, path)
                    self.cell_zone_list = self._cell_zone_list(self, "cell_zone_list", service, rules, path)
                    self.rotation_axis_origin = self._rotation_axis_origin(self, "rotation_axis_origin", service, rules, path)
                    self.rotation_axis_direction = self._rotation_axis_direction(self, "rotation_axis_direction", service, rules, path)
                    self.trans_shift = self._trans_shift(self, "trans_shift", service, rules, path)
                    self.angle = self._angle(self, "angle", service, rules, path)
                    self.copy = self._copy(self, "copy", service, rules, path)
                    self.num_of_copies = self._num_of_copies(self, "num_of_copies", service, rules, path)
                    self.merge = self._merge(self, "merge", service, rules, path)
                    self.rename = self._rename(self, "rename", service, rules, path)
                    self.merge_boundaries = self._merge_boundaries(self, "merge_boundaries", service, rules, path)

                class _control_name(PyArgumentsTextualSubItem):
                    """
                    Specify a name for the transformation or use the default value.
                    """

                class _type(PyArgumentsTextualSubItem):
                    """
                    Indicate the type of transformation: translational or rotational
                    """

                class _method(PyArgumentsTextualSubItem):
                    """
                    By default, the Manual method is utilized, however, when periodics are detected, then Automatic - use existing periodics is the default.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Indicate the type of transformation: translational or rotational
                    """

                class _topo_body_list(PyArgumentsTextualSubItem):
                    """
                    Argument topo_body_list.
                    """

                class _cell_zone_list(PyArgumentsTextualSubItem):
                    """
                    Select one or more objects from the list to which you will apply the transformation. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                    """

                class _rotation_axis_origin(PyArgumentsSingletonSubItem):
                    """
                    Specify the coordinates of the rotational origin.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.y = self._y(self, "y", service, rules, path)
                        self.z = self._z(self, "z", service, rules, path)
                        self.x = self._x(self, "x", service, rules, path)

                    class _y(PyArgumentsNumericalSubItem):
                        """
                        Specify the Y-coordinate of the rotational origin.
                        """

                    class _z(PyArgumentsNumericalSubItem):
                        """
                        Specify the Z-coordinate of the rotational origin.
                        """

                    class _x(PyArgumentsNumericalSubItem):
                        """
                        Specify the X-coordinate of the rotational origin.
                        """

                class _rotation_axis_direction(PyArgumentsSingletonSubItem):
                    """
                    Specify the coordinates of the rotational vector.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.y = self._y(self, "y", service, rules, path)
                        self.z = self._z(self, "z", service, rules, path)
                        self.x = self._x(self, "x", service, rules, path)

                    class _y(PyArgumentsNumericalSubItem):
                        """
                        Specify the Y-coordinate of the rotational vector.
                        """

                    class _z(PyArgumentsNumericalSubItem):
                        """
                        Specify the Z-coordinate of the rotational vector.
                        """

                    class _x(PyArgumentsNumericalSubItem):
                        """
                        Specify the X-coordinate of the rotational vector.
                        """

                class _trans_shift(PyArgumentsSingletonSubItem):
                    """
                    Specify the coordinates of the translational shift.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.y = self._y(self, "y", service, rules, path)
                        self.z = self._z(self, "z", service, rules, path)
                        self.x = self._x(self, "x", service, rules, path)

                    class _y(PyArgumentsNumericalSubItem):
                        """
                        Specify the Y-coordinate of the translational shift.
                        """

                    class _z(PyArgumentsNumericalSubItem):
                        """
                        Specify the Z-coordinate of the translational shift.
                        """

                    class _x(PyArgumentsNumericalSubItem):
                        """
                        Specify the X-coordinate of the translational shift.
                        """

                class _angle(PyArgumentsNumericalSubItem):
                    """
                    Specify a value for the angle of rotation for this transformation.
                    """

                class _copy(PyArgumentsTextualSubItem):
                    """
                    Indicate whether or not to make a copy of the volume mesh and apply the transformation to the copy.
                    """

                class _num_of_copies(PyArgumentsNumericalSubItem):
                    """
                    Specify the number of copies that you want to make for this transformation.
                    """

                class _merge(PyArgumentsTextualSubItem):
                    """
                    Indicate whether or not you want to merge cell and face zones prior to transforming the volume mesh, in order to avoid duplication.
                    """

                class _rename(PyArgumentsParameterSubItem):
                    """
                    Indicate whether or not you want to rename cell and face zones prior to transforming the volume mesh.
                    """

                class _merge_boundaries(PyArgumentsTextualSubItem):
                    """
                    Argument merge_boundaries.
                    """

            def create_instance(self) -> _transform_volume_meshArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._transform_volume_meshArguments(*args)

        class update_boundaries(PyCommand):
            """
            Use the table to review a summary of all of your defined boundaries, and their assigned types, and make revisions as needed. Rename a boundary by double-clicking its name in the list and providing another name. Reassign the type for a specific boundary by clicking the type designation and using the drop-down menu that appears.  More...
            Parameters
            ----------
            mesh_object : str
            selection_type : str
                Choose how boundaries are displayed in the table.
            boundary_label_list : list[str]
            boundary_label_type_list : list[str]
            boundary_zone_list : list[str]
            boundary_zone_type_list : list[str]
            old_boundary_label_list : list[str]
            old_boundary_label_type_list : list[str]
            old_boundary_zone_list : list[str]
            old_boundary_zone_type_list : list[str]
            old_label_zone_list : list[str]
            list_all_boundaries_toggle : bool
                View more boundaries in the table, such as fluid-fluid internal boundaries, in addition to external boundaries.
            zone_location : list[str]
            topology_list : list[str]
            topology_type_list : list[str]
            old_topology_list : list[str]
            old_topology_type_list : list[str]
            topology_body_list : list[str]
            boundary_current_list : list[str]
            boundary_current_type_list : list[str]
            boundary_allowed_type_list : list[str]

            Returns
            -------
            bool
            """
            class _update_boundariesArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.mesh_object = self._mesh_object(self, "mesh_object", service, rules, path)
                    self.selection_type = self._selection_type(self, "selection_type", service, rules, path)
                    self.boundary_label_list = self._boundary_label_list(self, "boundary_label_list", service, rules, path)
                    self.boundary_label_type_list = self._boundary_label_type_list(self, "boundary_label_type_list", service, rules, path)
                    self.boundary_zone_list = self._boundary_zone_list(self, "boundary_zone_list", service, rules, path)
                    self.boundary_zone_type_list = self._boundary_zone_type_list(self, "boundary_zone_type_list", service, rules, path)
                    self.old_boundary_label_list = self._old_boundary_label_list(self, "old_boundary_label_list", service, rules, path)
                    self.old_boundary_label_type_list = self._old_boundary_label_type_list(self, "old_boundary_label_type_list", service, rules, path)
                    self.old_boundary_zone_list = self._old_boundary_zone_list(self, "old_boundary_zone_list", service, rules, path)
                    self.old_boundary_zone_type_list = self._old_boundary_zone_type_list(self, "old_boundary_zone_type_list", service, rules, path)
                    self.old_label_zone_list = self._old_label_zone_list(self, "old_label_zone_list", service, rules, path)
                    self.list_all_boundaries_toggle = self._list_all_boundaries_toggle(self, "list_all_boundaries_toggle", service, rules, path)
                    self.zone_location = self._zone_location(self, "zone_location", service, rules, path)
                    self.topology_list = self._topology_list(self, "topology_list", service, rules, path)
                    self.topology_type_list = self._topology_type_list(self, "topology_type_list", service, rules, path)
                    self.old_topology_list = self._old_topology_list(self, "old_topology_list", service, rules, path)
                    self.old_topology_type_list = self._old_topology_type_list(self, "old_topology_type_list", service, rules, path)
                    self.topology_body_list = self._topology_body_list(self, "topology_body_list", service, rules, path)
                    self.boundary_current_list = self._boundary_current_list(self, "boundary_current_list", service, rules, path)
                    self.boundary_current_type_list = self._boundary_current_type_list(self, "boundary_current_type_list", service, rules, path)
                    self.boundary_allowed_type_list = self._boundary_allowed_type_list(self, "boundary_allowed_type_list", service, rules, path)

                class _mesh_object(PyArgumentsTextualSubItem):
                    """
                    Argument mesh_object.
                    """

                class _selection_type(PyArgumentsTextualSubItem):
                    """
                    Choose how boundaries are displayed in the table.
                    """

                class _boundary_label_list(PyArgumentsTextualSubItem):
                    """
                    Argument boundary_label_list.
                    """

                class _boundary_label_type_list(PyArgumentsTextualSubItem):
                    """
                    Argument boundary_label_type_list.
                    """

                class _boundary_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument boundary_zone_list.
                    """

                class _boundary_zone_type_list(PyArgumentsTextualSubItem):
                    """
                    Argument boundary_zone_type_list.
                    """

                class _old_boundary_label_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_boundary_label_list.
                    """

                class _old_boundary_label_type_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_boundary_label_type_list.
                    """

                class _old_boundary_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_boundary_zone_list.
                    """

                class _old_boundary_zone_type_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_boundary_zone_type_list.
                    """

                class _old_label_zone_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_label_zone_list.
                    """

                class _list_all_boundaries_toggle(PyArgumentsParameterSubItem):
                    """
                    View more boundaries in the table, such as fluid-fluid internal boundaries, in addition to external boundaries.
                    """

                class _zone_location(PyArgumentsTextualSubItem):
                    """
                    Argument zone_location.
                    """

                class _topology_list(PyArgumentsTextualSubItem):
                    """
                    Argument topology_list.
                    """

                class _topology_type_list(PyArgumentsTextualSubItem):
                    """
                    Argument topology_type_list.
                    """

                class _old_topology_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_topology_list.
                    """

                class _old_topology_type_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_topology_type_list.
                    """

                class _topology_body_list(PyArgumentsTextualSubItem):
                    """
                    Argument topology_body_list.
                    """

                class _boundary_current_list(PyArgumentsTextualSubItem):
                    """
                    Argument boundary_current_list.
                    """

                class _boundary_current_type_list(PyArgumentsTextualSubItem):
                    """
                    Argument boundary_current_type_list.
                    """

                class _boundary_allowed_type_list(PyArgumentsTextualSubItem):
                    """
                    Argument boundary_allowed_type_list.
                    """

            def create_instance(self) -> _update_boundariesArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._update_boundariesArguments(*args)

        class update_region_settings(PyCommand):
            """
            Review the settings assigned to the regions in your simulation. Use the table to reassign their extraction techniques, region types, volume meshing cell types, or leakage size settings. More...
            Parameters
            ----------
            main_fluid_region : str
                Identify the main fluid region for your simulation.
            filter_category : str
                Select how your regions will be displayed in the table. You can choose to view all regions, or specifically identified regions, or only object-based regions.
            region_name_list : list[str]
            region_mesh_method_list : list[str]
            region_type_list : list[str]
            region_volume_fill_list : list[str]
            region_leakage_size_list : list[str]
            region_overset_componen_list : list[str]
            old_region_name_list : list[str]
            old_region_mesh_method_list : list[str]
            old_region_type_list : list[str]
            old_region_volume_fill_list : list[str]
            old_region_leakage_size_list : list[str]
            old_region_overset_componen_list : list[str]
            all_region_name_list : list[str]
            all_region_mesh_method_list : list[str]
            all_region_type_list : list[str]
            all_region_volume_fill_list : list[str]
            all_region_leakage_size_list : list[str]
            all_region_overset_componen_list : list[str]
            all_region_linked_construction_surface_list : list[str]
            all_region_source_list : list[str]
            all_region_filter_categories : list[str]

            Returns
            -------
            bool
            """
            class _update_region_settingsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.main_fluid_region = self._main_fluid_region(self, "main_fluid_region", service, rules, path)
                    self.filter_category = self._filter_category(self, "filter_category", service, rules, path)
                    self.region_name_list = self._region_name_list(self, "region_name_list", service, rules, path)
                    self.region_mesh_method_list = self._region_mesh_method_list(self, "region_mesh_method_list", service, rules, path)
                    self.region_type_list = self._region_type_list(self, "region_type_list", service, rules, path)
                    self.region_volume_fill_list = self._region_volume_fill_list(self, "region_volume_fill_list", service, rules, path)
                    self.region_leakage_size_list = self._region_leakage_size_list(self, "region_leakage_size_list", service, rules, path)
                    self.region_overset_componen_list = self._region_overset_componen_list(self, "region_overset_componen_list", service, rules, path)
                    self.old_region_name_list = self._old_region_name_list(self, "old_region_name_list", service, rules, path)
                    self.old_region_mesh_method_list = self._old_region_mesh_method_list(self, "old_region_mesh_method_list", service, rules, path)
                    self.old_region_type_list = self._old_region_type_list(self, "old_region_type_list", service, rules, path)
                    self.old_region_volume_fill_list = self._old_region_volume_fill_list(self, "old_region_volume_fill_list", service, rules, path)
                    self.old_region_leakage_size_list = self._old_region_leakage_size_list(self, "old_region_leakage_size_list", service, rules, path)
                    self.old_region_overset_componen_list = self._old_region_overset_componen_list(self, "old_region_overset_componen_list", service, rules, path)
                    self.all_region_name_list = self._all_region_name_list(self, "all_region_name_list", service, rules, path)
                    self.all_region_mesh_method_list = self._all_region_mesh_method_list(self, "all_region_mesh_method_list", service, rules, path)
                    self.all_region_type_list = self._all_region_type_list(self, "all_region_type_list", service, rules, path)
                    self.all_region_volume_fill_list = self._all_region_volume_fill_list(self, "all_region_volume_fill_list", service, rules, path)
                    self.all_region_leakage_size_list = self._all_region_leakage_size_list(self, "all_region_leakage_size_list", service, rules, path)
                    self.all_region_overset_componen_list = self._all_region_overset_componen_list(self, "all_region_overset_componen_list", service, rules, path)
                    self.all_region_linked_construction_surface_list = self._all_region_linked_construction_surface_list(self, "all_region_linked_construction_surface_list", service, rules, path)
                    self.all_region_source_list = self._all_region_source_list(self, "all_region_source_list", service, rules, path)
                    self.all_region_filter_categories = self._all_region_filter_categories(self, "all_region_filter_categories", service, rules, path)

                class _main_fluid_region(PyArgumentsTextualSubItem):
                    """
                    Identify the main fluid region for your simulation.
                    """

                class _filter_category(PyArgumentsTextualSubItem):
                    """
                    Select how your regions will be displayed in the table. You can choose to view all regions, or specifically identified regions, or only object-based regions.
                    """

                class _region_name_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_name_list.
                    """

                class _region_mesh_method_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_mesh_method_list.
                    """

                class _region_type_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_type_list.
                    """

                class _region_volume_fill_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_volume_fill_list.
                    """

                class _region_leakage_size_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_leakage_size_list.
                    """

                class _region_overset_componen_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_overset_componen_list.
                    """

                class _old_region_name_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_region_name_list.
                    """

                class _old_region_mesh_method_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_region_mesh_method_list.
                    """

                class _old_region_type_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_region_type_list.
                    """

                class _old_region_volume_fill_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_region_volume_fill_list.
                    """

                class _old_region_leakage_size_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_region_leakage_size_list.
                    """

                class _old_region_overset_componen_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_region_overset_componen_list.
                    """

                class _all_region_name_list(PyArgumentsTextualSubItem):
                    """
                    Argument all_region_name_list.
                    """

                class _all_region_mesh_method_list(PyArgumentsTextualSubItem):
                    """
                    Argument all_region_mesh_method_list.
                    """

                class _all_region_type_list(PyArgumentsTextualSubItem):
                    """
                    Argument all_region_type_list.
                    """

                class _all_region_volume_fill_list(PyArgumentsTextualSubItem):
                    """
                    Argument all_region_volume_fill_list.
                    """

                class _all_region_leakage_size_list(PyArgumentsTextualSubItem):
                    """
                    Argument all_region_leakage_size_list.
                    """

                class _all_region_overset_componen_list(PyArgumentsTextualSubItem):
                    """
                    Argument all_region_overset_componen_list.
                    """

                class _all_region_linked_construction_surface_list(PyArgumentsTextualSubItem):
                    """
                    Argument all_region_linked_construction_surface_list.
                    """

                class _all_region_source_list(PyArgumentsTextualSubItem):
                    """
                    Argument all_region_source_list.
                    """

                class _all_region_filter_categories(PyArgumentsTextualSubItem):
                    """
                    Argument all_region_filter_categories.
                    """

            def create_instance(self) -> _update_region_settingsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._update_region_settingsArguments(*args)

        class update_regions(PyCommand):
            """
            Use the table to review a summary of all of your defined regions, and their assigned types, and make revisions as needed. Rename a region by double-clicking its name in the list and providing another name. Reassign the type for a specific region by clicking the type designation and using the drop-down menu that appears. Dead regions are the same as a void or a pocket in the domain, and are not transferred to the Fluent solver.  More...
            Parameters
            ----------
            mesh_object : str
            region_name_list : list[str]
            region_type_list : list[str]
            old_region_name_list : list[str]
            old_region_type_list : list[str]
            region_internals : list[str]
            region_internal_types : list[str]
            region_current_list : list[str]
            region_current_type_list : list[str]
            number_of_listed_regions : int

            Returns
            -------
            bool
            """
            class _update_regionsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.mesh_object = self._mesh_object(self, "mesh_object", service, rules, path)
                    self.region_name_list = self._region_name_list(self, "region_name_list", service, rules, path)
                    self.region_type_list = self._region_type_list(self, "region_type_list", service, rules, path)
                    self.old_region_name_list = self._old_region_name_list(self, "old_region_name_list", service, rules, path)
                    self.old_region_type_list = self._old_region_type_list(self, "old_region_type_list", service, rules, path)
                    self.region_internals = self._region_internals(self, "region_internals", service, rules, path)
                    self.region_internal_types = self._region_internal_types(self, "region_internal_types", service, rules, path)
                    self.region_current_list = self._region_current_list(self, "region_current_list", service, rules, path)
                    self.region_current_type_list = self._region_current_type_list(self, "region_current_type_list", service, rules, path)
                    self.number_of_listed_regions = self._number_of_listed_regions(self, "number_of_listed_regions", service, rules, path)

                class _mesh_object(PyArgumentsTextualSubItem):
                    """
                    Argument mesh_object.
                    """

                class _region_name_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_name_list.
                    """

                class _region_type_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_type_list.
                    """

                class _old_region_name_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_region_name_list.
                    """

                class _old_region_type_list(PyArgumentsTextualSubItem):
                    """
                    Argument old_region_type_list.
                    """

                class _region_internals(PyArgumentsTextualSubItem):
                    """
                    Argument region_internals.
                    """

                class _region_internal_types(PyArgumentsTextualSubItem):
                    """
                    Argument region_internal_types.
                    """

                class _region_current_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_current_list.
                    """

                class _region_current_type_list(PyArgumentsTextualSubItem):
                    """
                    Argument region_current_type_list.
                    """

                class _number_of_listed_regions(PyArgumentsNumericalSubItem):
                    """
                    Argument number_of_listed_regions.
                    """

            def create_instance(self) -> _update_regionsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._update_regionsArguments(*args)

        class update_volume_mesh(PyCommand):
            """
            Use this task to remove the existing volume mesh and to update the volume mesh with your new part replacement changes.
            Parameters
            ----------
            enable_parallel : bool
                Enable this option to perform parallel volume and continuous boundary layer (prism) meshing for fluid region(s). Applicable for poly, hexcore and poly-hexcore volume fill types.

            Returns
            -------
            bool
            """
            class _update_volume_meshArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.enable_parallel = self._enable_parallel(self, "enable_parallel", service, rules, path)

                class _enable_parallel(PyArgumentsParameterSubItem):
                    """
                    Enable this option to perform parallel volume and continuous boundary layer (prism) meshing for fluid region(s). Applicable for poly, hexcore and poly-hexcore volume fill types.
                    """

            def create_instance(self) -> _update_volume_meshArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._update_volume_meshArguments(*args)

        class wrap_main(PyCommand):
            """
            Command wrap_main.

            Parameters
            ----------
            wrap_regions_name : str

            Returns
            -------
            bool
            """
            class _wrap_mainArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.wrap_regions_name = self._wrap_regions_name(self, "wrap_regions_name", service, rules, path)

                class _wrap_regions_name(PyArgumentsTextualSubItem):
                    """
                    Argument wrap_regions_name.
                    """

            def create_instance(self) -> _wrap_mainArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._wrap_mainArguments(*args)

        class write_2d_mesh(PyCommand):
            """
            Command write_2d_mesh.

            Parameters
            ----------
            file_name : str
            skip_export : bool

            Returns
            -------
            bool
            """
            class _write_2d_meshArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.file_name = self._file_name(self, "file_name", service, rules, path)
                    self.skip_export = self._skip_export(self, "skip_export", service, rules, path)

                class _file_name(PyArgumentsTextualSubItem):
                    """
                    Argument file_name.
                    """

                class _skip_export(PyArgumentsParameterSubItem):
                    """
                    Argument skip_export.
                    """

            def create_instance(self) -> _write_2d_meshArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._write_2d_meshArguments(*args)

        class write_skin(PyCommand):
            """
            Command write_skin.

            Parameters
            ----------
            file_name : str

            Returns
            -------
            bool
            """
            class _write_skinArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.file_name = self._file_name(self, "file_name", service, rules, path)

                class _file_name(PyArgumentsTextualSubItem):
                    """
                    Argument file_name.
                    """

            def create_instance(self) -> _write_skinArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._write_skinArguments(*args)

    class general(PyMenu):
        """
        Singleton general.
        """
        def __init__(self, service, rules, path):
            self.workflow = self.__class__.workflow(service, rules, path + [("workflow", "")])
            self.create_composite_task = self.__class__.create_composite_task(service, rules, "create_composite_task", path)
            self.create_new_workflow = self.__class__.create_new_workflow(service, rules, "create_new_workflow", path)
            self.delete_tasks = self.__class__.delete_tasks(service, rules, "delete_tasks", path)
            self.initialize_workflow = self.__class__.initialize_workflow(service, rules, "initialize_workflow", path)
            self.insert_new_task = self.__class__.insert_new_task(service, rules, "insert_new_task", path)
            self.load_state = self.__class__.load_state(service, rules, "load_state", path)
            self.load_workflow = self.__class__.load_workflow(service, rules, "load_workflow", path)
            self.reset_workflow = self.__class__.reset_workflow(service, rules, "reset_workflow", path)
            self.save_workflow = self.__class__.save_workflow(service, rules, "save_workflow", path)
            super().__init__(service, rules, path)

        class workflow(PyMenu):
            """
            Singleton workflow.
            """
            def __init__(self, service, rules, path):
                self.current_task = self.__class__.current_task(service, rules, path + [("current_task", "")])
                self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                self.workflow_type = self.__class__.workflow_type(service, rules, path + [("workflow_type", "")])
                super().__init__(service, rules, path)

            class current_task(PyTextual):
                """
                Parameter current_task of value type str.
                """
                pass

            class inactive_task_list(PyTextual):
                """
                Parameter inactive_task_list of value type list[str].
                """
                pass

            class task_list(PyTextual):
                """
                Parameter task_list of value type list[str].
                """
                pass

            class workflow_type(PyTextual):
                """
                Parameter workflow_type of value type str.
                """
                pass

        class create_composite_task(PyCommand):
            """
            Command create_composite_task.

            Parameters
            ----------
            list_of_tasks : list[str]

            Returns
            -------
            bool
            """
            class _create_composite_taskArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.list_of_tasks = self._list_of_tasks(self, "list_of_tasks", service, rules, path)

                class _list_of_tasks(PyArgumentsTextualSubItem):
                    """
                    Argument list_of_tasks.
                    """

            def create_instance(self) -> _create_composite_taskArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_composite_taskArguments(*args)

        class create_new_workflow(PyCommand):
            """
            Command create_new_workflow.


            Returns
            -------
            bool
            """
            class _create_new_workflowArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)

            def create_instance(self) -> _create_new_workflowArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_new_workflowArguments(*args)

        class delete_tasks(PyCommand):
            """
            Command delete_tasks.

            Parameters
            ----------
            list_of_tasks : list[str]

            Returns
            -------
            bool
            """
            class _delete_tasksArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.list_of_tasks = self._list_of_tasks(self, "list_of_tasks", service, rules, path)

                class _list_of_tasks(PyArgumentsTextualSubItem):
                    """
                    Argument list_of_tasks.
                    """

            def create_instance(self) -> _delete_tasksArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._delete_tasksArguments(*args)

        class initialize_workflow(PyCommand):
            """
            Command initialize_workflow.

            Parameters
            ----------
            workflow_type : str

            Returns
            -------
            bool
            """
            class _initialize_workflowArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.workflow_type = self._workflow_type(self, "workflow_type", service, rules, path)

                class _workflow_type(PyArgumentsTextualSubItem):
                    """
                    Argument workflow_type.
                    """

            def create_instance(self) -> _initialize_workflowArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._initialize_workflowArguments(*args)

        class insert_new_task(PyCommand):
            """
            Command insert_new_task.

            Parameters
            ----------
            command_name : str

            Returns
            -------
            bool
            """
            class _insert_new_taskArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.command_name = self._command_name(self, "command_name", service, rules, path)

                class _command_name(PyArgumentsTextualSubItem):
                    """
                    Argument command_name.
                    """

            def create_instance(self) -> _insert_new_taskArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._insert_new_taskArguments(*args)

        class load_state(PyCommand):
            """
            Command load_state.

            Parameters
            ----------
            list_of_roots : list[str]

            Returns
            -------
            bool
            """
            class _load_stateArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.list_of_roots = self._list_of_roots(self, "list_of_roots", service, rules, path)

                class _list_of_roots(PyArgumentsTextualSubItem):
                    """
                    Argument list_of_roots.
                    """

            def create_instance(self) -> _load_stateArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._load_stateArguments(*args)

        class load_workflow(PyCommand):
            """
            Command load_workflow.

            Parameters
            ----------
            file_path : str

            Returns
            -------
            bool
            """
            class _load_workflowArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.file_path = self._file_path(self, "file_path", service, rules, path)

                class _file_path(PyArgumentsTextualSubItem):
                    """
                    Argument file_path.
                    """

            def create_instance(self) -> _load_workflowArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._load_workflowArguments(*args)

        class reset_workflow(PyCommand):
            """
            Command reset_workflow.


            Returns
            -------
            bool
            """
            class _reset_workflowArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)

            def create_instance(self) -> _reset_workflowArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._reset_workflowArguments(*args)

        class save_workflow(PyCommand):
            """
            Command save_workflow.

            Parameters
            ----------
            file_path : str

            Returns
            -------
            bool
            """
            class _save_workflowArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.file_path = self._file_path(self, "file_path", service, rules, path)

                class _file_path(PyArgumentsTextualSubItem):
                    """
                    Argument file_path.
                    """

            def create_instance(self) -> _save_workflowArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._save_workflowArguments(*args)

    class parts(PyMenu):
        """
        Singleton parts.
        """
        def __init__(self, service, rules, path):
            self.assembly_node = self.__class__.assembly_node(service, rules, path + [("assembly_node", "")])
            self.mirror = self.__class__.mirror(service, rules, path + [("mirror", "")])
            self.node = self.__class__.node(service, rules, path + [("node", "")])
            self.object_setting = self.__class__.object_setting(service, rules, path + [("object_setting", "")])
            self.refaceting = self.__class__.refaceting(service, rules, path + [("refaceting", "")])
            self.rotate = self.__class__.rotate(service, rules, path + [("rotate", "")])
            self.rotate_about_axis = self.__class__.rotate_about_axis(service, rules, path + [("rotate_about_axis", "")])
            self.scaling = self.__class__.scaling(service, rules, path + [("scaling", "")])
            self.transform = self.__class__.transform(service, rules, path + [("transform", "")])
            self.transform_base = self.__class__.transform_base(service, rules, path + [("transform_base", "")])
            self.translate = self.__class__.translate(service, rules, path + [("translate", "")])
            self.global_settings = self.__class__.global_settings(service, rules, path + [("global_settings", "")])
            self.meshing_operations = self.__class__.meshing_operations(service, rules, path + [("meshing_operations", "")])
            self.object_setting_operations = self.__class__.object_setting_operations(service, rules, path + [("object_setting_operations", "")])
            self.refaceting_operations = self.__class__.refaceting_operations(service, rules, path + [("refaceting_operations", "")])
            self.transform_operations = self.__class__.transform_operations(service, rules, path + [("transform_operations", "")])
            self.append_fmd_files = self.__class__.append_fmd_files(service, rules, "append_fmd_files", path)
            self.change_file_length_unit = self.__class__.change_file_length_unit(service, rules, "change_file_length_unit", path)
            self.change_length_unit = self.__class__.change_length_unit(service, rules, "change_length_unit", path)
            self.create_obj_for_each_part = self.__class__.create_obj_for_each_part(service, rules, "create_obj_for_each_part", path)
            self.create_objects = self.__class__.create_objects(service, rules, "create_objects", path)
            self.delete = self.__class__.delete(service, rules, "delete", path)
            self.delete_paths = self.__class__.delete_paths(service, rules, "delete_paths", path)
            self.initialize_template = self.__class__.initialize_template(service, rules, "initialize_template", path)
            self.input_file_changed = self.__class__.input_file_changed(service, rules, "input_file_changed", path)
            self.list_meshing_operations = self.__class__.list_meshing_operations(service, rules, "list_meshing_operations", path)
            self.load_fmd_file = self.__class__.load_fmd_file(service, rules, "load_fmd_file", path)
            self.load_template = self.__class__.load_template(service, rules, "load_template", path)
            self.mark_objects_outof_date = self.__class__.mark_objects_outof_date(service, rules, "mark_objects_outof_date", path)
            self.move_cad_components_to_new_object = self.__class__.move_cad_components_to_new_object(service, rules, "move_cad_components_to_new_object", path)
            self.move_to_new_subobject = self.__class__.move_to_new_subobject(service, rules, "move_to_new_subobject", path)
            self.move_to_object = self.__class__.move_to_object(service, rules, "move_to_object", path)
            self.redo_all_transforms = self.__class__.redo_all_transforms(service, rules, "redo_all_transforms", path)
            self.reset_template = self.__class__.reset_template(service, rules, "reset_template", path)
            self.save_fmd_file = self.__class__.save_fmd_file(service, rules, "save_fmd_file", path)
            self.save_template = self.__class__.save_template(service, rules, "save_template", path)
            self.suppress_node_objects = self.__class__.suppress_node_objects(service, rules, "suppress_node_objects", path)
            self.undo_all_transforms = self.__class__.undo_all_transforms(service, rules, "undo_all_transforms", path)
            super().__init__(service, rules, path)

        class assembly_node(PyNamedObjectContainer):
            """
            .
            """
            class _assembly_node(PyMenu):
                """
                Singleton _assembly_node.
                """
                def __init__(self, service, rules, path):
                    self.refaceting = self.__class__.refaceting(service, rules, path + [("refaceting", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.children = self.__class__.children(service, rules, path + [("children", "")])
                    self.context = self.__class__.context(service, rules, path + [("context", "")])
                    self.edge_extraction = self.__class__.edge_extraction(service, rules, path + [("edge_extraction", "")])
                    self.feature_angle = self.__class__.feature_angle(service, rules, path + [("feature_angle", "")])
                    self.is_children_settings_changed = self.__class__.is_children_settings_changed(service, rules, path + [("is_children_settings_changed", "")])
                    self.key_id = self.__class__.key_id(service, rules, path + [("key_id", "")])
                    self.merge_children = self.__class__.merge_children(service, rules, path + [("merge_children", "")])
                    self.name = self.__class__.name(service, rules, path + [("name", "")])
                    self.one_zone_per = self.__class__.one_zone_per(service, rules, path + [("one_zone_per", "")])
                    self.parent = self.__class__.parent(service, rules, path + [("parent", "")])
                    self.prefix_object_name = self.__class__.prefix_object_name(service, rules, path + [("prefix_object_name", "")])
                    self.refacet_operation = self.__class__.refacet_operation(service, rules, path + [("refacet_operation", "")])
                    self.transformations = self.__class__.transformations(service, rules, path + [("transformations", "")])
                    self.change_children_settings = self.__class__.change_children_settings(service, rules, "change_children_settings", path)
                    self.copy = self.__class__.copy(service, rules, "copy", path)
                    self.create_child = self.__class__.create_child(service, rules, "create_child", path)
                    self.move = self.__class__.move(service, rules, "move", path)
                    self.re_facet = self.__class__.re_facet(service, rules, "re_facet", path)
                    self.re_facet_now = self.__class__.re_facet_now(service, rules, "re_facet_now", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    super().__init__(service, rules, path)

                class refaceting(PyMenu):
                    """
                    Singleton refaceting.
                    """
                    def __init__(self, service, rules, path):
                        self.deviation = self.__class__.deviation(service, rules, path + [("deviation", "")])
                        self.max_size = self.__class__.max_size(service, rules, path + [("max_size", "")])
                        self.normal_angle = self.__class__.normal_angle(service, rules, path + [("normal_angle", "")])
                        self.refacet = self.__class__.refacet(service, rules, path + [("refacet", "")])
                        super().__init__(service, rules, path)

                    class deviation(PyNumerical):
                        """
                        Specify the distance between facet edges and the geometry edges. Decreasing this value will result in more facets along curved edges.
                        """
                        pass

                    class max_size(PyNumerical):
                        """
                        Specify a maximum element size for the imported model to avoid very large facets during the file import.
                        """
                        pass

                    class normal_angle(PyNumerical):
                        """
                        Specify a rotational angle (in degrees) of transformation.
                        """
                        pass

                    class refacet(PyParameter):
                        """
                        Select this option when you want to change faceting of the selected object. Refaceting will refacet the original CAD geometry. Only the faceted CAD geometry is used during the meshing process. The refaceting settings control how far the facet edges are from the model and the size of the facets.  More...
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class children(PyTextual):
                    """
                    Parameter children of value type list[str].
                    """
                    pass

                class context(PyNumerical):
                    """
                    Parameter context of value type int.
                    """
                    pass

                class edge_extraction(PyTextual):
                    """
                    Choose how edges will be extracted from the CAD geometry. Setting this option to auto will extract edges from the CAD geometry when the number of meshing objects is less than 10,000. If this limit is exceeded, then no edges are extracted. When this option is set to yes, then edges are extracted regardless of the number of meshing objects. No edges are extracted when this option is set to no.
                    """
                    pass

                class feature_angle(PyNumerical):
                    """
                    Specify a rotational angle (in degrees) of transformation.
                    """
                    pass

                class is_children_settings_changed(PyParameter):
                    """
                    Parameter is_children_settings_changed of value type bool.
                    """
                    pass

                class key_id(PyNumerical):
                    """
                    Parameter key_id of value type int.
                    """
                    pass

                class merge_children(PyParameter):
                    """
                    This option is only available when there are nested objects in the Meshing Model tree, and you want to assign object property settings to the top-level object. Upon updating the task, disabling this option ensures that each nested sub-object becomes its own geometry object, whereas enabling this option merges all child sub-objects into a single geometry object.
                    """
                    pass

                class name(PyTextual):
                    """
                    Parameter name of value type str.
                    """
                    pass

                class one_zone_per(PyTextual):
                    """
                    Specify whether to create your meshing zones based on an object, part, body or face. For instance, choosing the face option would create a separate zone for every topological face.
                    """
                    pass

                class parent(PyTextual):
                    """
                    Parameter parent of value type str.
                    """
                    pass

                class prefix_object_name(PyParameter):
                    """
                    Append the name of the object to the beginning of the name of the zone.
                    """
                    pass

                class refacet_operation(PyTextual):
                    """
                    Parameter refacet_operation of value type str.
                    """
                    pass

                class transformations(PyTextual):
                    """
                    Parameter transformations of value type list[str].
                    """
                    pass

                class change_children_settings(PyCommand):
                    """
                    Command change_children_settings.


                    Returns
                    -------
                    bool
                    """
                    class _change_children_settingsArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _change_children_settingsArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._change_children_settingsArguments(*args)

                class copy(PyCommand):
                    """
                    Command copy.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _copyArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _copyArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._copyArguments(*args)

                class create_child(PyCommand):
                    """
                    Command create_child.

                    Parameters
                    ----------
                    child_name : str

                    Returns
                    -------
                    bool
                    """
                    class _create_childArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.child_name = self._child_name(self, "child_name", service, rules, path)

                        class _child_name(PyArgumentsTextualSubItem):
                            """
                            Argument child_name.
                            """

                    def create_instance(self) -> _create_childArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._create_childArguments(*args)

                class move(PyCommand):
                    """
                    Command move.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _moveArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _moveArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._moveArguments(*args)

                class re_facet(PyCommand):
                    """
                    Select this option when you want to change faceting of the selected object. Refaceting will refacet the original CAD geometry. Only the faceted CAD geometry is used during the meshing process. The refaceting settings control how far the facet edges are from the model and the size of the facets.  More...
                    Parameters
                    ----------
                    deviation : float
                        Specify the distance between facet edges and the geometry edges. Decreasing this value will result in more facets along curved edges.
                    normal_angle : float
                        Specify a rotational angle (in degrees) of transformation.
                    max_size : float
                        Specify a maximum element size for the imported model to avoid very large facets during the file import.

                    Returns
                    -------
                    bool
                    """
                    class _re_facetArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.deviation = self._deviation(self, "deviation", service, rules, path)
                            self.normal_angle = self._normal_angle(self, "normal_angle", service, rules, path)
                            self.max_size = self._max_size(self, "max_size", service, rules, path)

                        class _deviation(PyArgumentsNumericalSubItem):
                            """
                            Specify the distance between facet edges and the geometry edges. Decreasing this value will result in more facets along curved edges.
                            """

                        class _normal_angle(PyArgumentsNumericalSubItem):
                            """
                            Specify a rotational angle (in degrees) of transformation.
                            """

                        class _max_size(PyArgumentsNumericalSubItem):
                            """
                            Specify a maximum element size for the imported model to avoid very large facets during the file import.
                            """

                    def create_instance(self) -> _re_facetArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._re_facetArguments(*args)

                class re_facet_now(PyCommand):
                    """
                    Command re_facet_now.


                    Returns
                    -------
                    bool
                    """
                    class _re_facet_nowArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _re_facet_nowArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._re_facet_nowArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

            def __getitem__(self, key: str) -> _assembly_node:
                return super().__getitem__(key)

        class mirror(PyNamedObjectContainer):
            """
            .
            """
            class _mirror(PyMenu):
                """
                Singleton _mirror.
                """
                def __init__(self, service, rules, path):
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.applied = self.__class__.applied(service, rules, path + [("applied", "")])
                    self.children = self.__class__.children(service, rules, path + [("children", "")])
                    self.context = self.__class__.context(service, rules, path + [("context", "")])
                    self.coordinate_system = self.__class__.coordinate_system(service, rules, path + [("coordinate_system", "")])
                    self.mirror_about = self.__class__.mirror_about(service, rules, path + [("mirror_about", "")])
                    self.name = self.__class__.name(service, rules, path + [("name", "")])
                    self.type = self.__class__.type(service, rules, path + [("type", "")])
                    self.add = self.__class__.add(service, rules, "add", path)
                    self.apply = self.__class__.apply(service, rules, "apply", path)
                    self.remove = self.__class__.remove(service, rules, "remove", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.undo = self.__class__.undo(service, rules, "undo", path)
                    self.update = self.__class__.update(service, rules, "update", path)
                    super().__init__(service, rules, path)

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class applied(PyParameter):
                    """
                    Parameter applied of value type bool.
                    """
                    pass

                class children(PyTextual):
                    """
                    Parameter children of value type list[str].
                    """
                    pass

                class context(PyNumerical):
                    """
                    Parameter context of value type int.
                    """
                    pass

                class coordinate_system(PyTextual):
                    """
                    Specify whether to apply the transformation to the Local or Global coordinate system. The local coordinate system is one that is associated with the individual CAD geometry as it is being created, where one chooses to re-orient that CAD sketch and create the model. Its orientation can vary based on its placement in an assembly of the entire model (for example, tires for a car). The global coordinate system has a fixed orientation, whereas the local coordinate system will have a different orientation. If, however, the CAD part was created without changing the coordinate systems, then there will be no difference between the local and global coordinate systems.
                    """
                    pass

                class mirror_about(PyTextual):
                    """
                    Specify the plane about which the geometry will be mirrored (either XY, YZ, or ZX).
                    """
                    pass

                class name(PyTextual):
                    """
                    Parameter name of value type str.
                    """
                    pass

                class type(PyTextual):
                    """
                    Specify whether to apply a translational or a rotational transformation.
                    """
                    pass

                class add(PyCommand):
                    """
                    Command add.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _addArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _addArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._addArguments(*args)

                class apply(PyCommand):
                    """
                    Command apply.


                    Returns
                    -------
                    bool
                    """
                    class _applyArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _applyArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._applyArguments(*args)

                class remove(PyCommand):
                    """
                    Command remove.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _removeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _removeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._removeArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class undo(PyCommand):
                    """
                    Command undo.


                    Returns
                    -------
                    bool
                    """
                    class _undoArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _undoArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._undoArguments(*args)

                class update(PyCommand):
                    """
                    Command update.


                    Returns
                    -------
                    bool
                    """
                    class _updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._updateArguments(*args)

            def __getitem__(self, key: str) -> _mirror:
                return super().__getitem__(key)

        class node(PyNamedObjectContainer):
            """
            .
            """
            class _node(PyMenu):
                """
                Singleton _node.
                """
                def __init__(self, service, rules, path):
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.children = self.__class__.children(service, rules, path + [("children", "")])
                    self.context = self.__class__.context(service, rules, path + [("context", "")])
                    self.key_id = self.__class__.key_id(service, rules, path + [("key_id", "")])
                    self.name = self.__class__.name(service, rules, path + [("name", "")])
                    self.object_setting = self.__class__.object_setting(service, rules, path + [("object_setting", "")])
                    self.parent = self.__class__.parent(service, rules, path + [("parent", "")])
                    self.refacet_operation = self.__class__.refacet_operation(service, rules, path + [("refacet_operation", "")])
                    self.suppress = self.__class__.suppress(service, rules, path + [("suppress", "")])
                    self.transformations = self.__class__.transformations(service, rules, path + [("transformations", "")])
                    self.updated = self.__class__.updated(service, rules, path + [("updated", "")])
                    self.copy = self.__class__.copy(service, rules, "copy", path)
                    self.create_child = self.__class__.create_child(service, rules, "create_child", path)
                    self.move = self.__class__.move(service, rules, "move", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.wildcard_copy = self.__class__.wildcard_copy(service, rules, "wildcard_copy", path)
                    super().__init__(service, rules, path)

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class children(PyTextual):
                    """
                    Parameter children of value type list[str].
                    """
                    pass

                class context(PyNumerical):
                    """
                    Parameter context of value type int.
                    """
                    pass

                class key_id(PyNumerical):
                    """
                    Parameter key_id of value type int.
                    """
                    pass

                class name(PyTextual):
                    """
                    Parameter name of value type str.
                    """
                    pass

                class object_setting(PyTextual):
                    """
                    Parameter object_setting of value type str.
                    """
                    pass

                class parent(PyTextual):
                    """
                    Parameter parent of value type str.
                    """
                    pass

                class refacet_operation(PyTextual):
                    """
                    Parameter refacet_operation of value type str.
                    """
                    pass

                class suppress(PyParameter):
                    """
                    Parameter suppress of value type bool.
                    """
                    pass

                class transformations(PyTextual):
                    """
                    Parameter transformations of value type list[str].
                    """
                    pass

                class updated(PyParameter):
                    """
                    Parameter updated of value type bool.
                    """
                    pass

                class copy(PyCommand):
                    """
                    Command copy.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _copyArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _copyArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._copyArguments(*args)

                class create_child(PyCommand):
                    """
                    Command create_child.

                    Parameters
                    ----------
                    child_name : str

                    Returns
                    -------
                    bool
                    """
                    class _create_childArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.child_name = self._child_name(self, "child_name", service, rules, path)

                        class _child_name(PyArgumentsTextualSubItem):
                            """
                            Argument child_name.
                            """

                    def create_instance(self) -> _create_childArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._create_childArguments(*args)

                class move(PyCommand):
                    """
                    Command move.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _moveArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _moveArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._moveArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class wildcard_copy(PyCommand):
                    """
                    Command wildcard_copy.

                    Parameters
                    ----------
                    pattern : str

                    Returns
                    -------
                    bool
                    """
                    class _wildcard_copyArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.pattern = self._pattern(self, "pattern", service, rules, path)

                        class _pattern(PyArgumentsTextualSubItem):
                            """
                            Argument pattern.
                            """

                    def create_instance(self) -> _wildcard_copyArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._wildcard_copyArguments(*args)

            def __getitem__(self, key: str) -> _node:
                return super().__getitem__(key)

        class object_setting(PyNamedObjectContainer):
            """
            .
            """
            class _object_setting(PyMenu):
                """
                Singleton _object_setting.
                """
                def __init__(self, service, rules, path):
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.children = self.__class__.children(service, rules, path + [("children", "")])
                    self.context = self.__class__.context(service, rules, path + [("context", "")])
                    self.edge_extraction = self.__class__.edge_extraction(service, rules, path + [("edge_extraction", "")])
                    self.feature_angle = self.__class__.feature_angle(service, rules, path + [("feature_angle", "")])
                    self.merge_children = self.__class__.merge_children(service, rules, path + [("merge_children", "")])
                    self.name = self.__class__.name(service, rules, path + [("name", "")])
                    self.one_zone_per = self.__class__.one_zone_per(service, rules, path + [("one_zone_per", "")])
                    self.prefix_object_name = self.__class__.prefix_object_name(service, rules, path + [("prefix_object_name", "")])
                    self.use_default_settings = self.__class__.use_default_settings(service, rules, path + [("use_default_settings", "")])
                    self.add = self.__class__.add(service, rules, "add", path)
                    self.remove = self.__class__.remove(service, rules, "remove", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    super().__init__(service, rules, path)

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class children(PyTextual):
                    """
                    Parameter children of value type list[str].
                    """
                    pass

                class context(PyNumerical):
                    """
                    Parameter context of value type int.
                    """
                    pass

                class edge_extraction(PyTextual):
                    """
                    Choose how edges will be extracted from the CAD geometry. Setting this option to auto will extract edges from the CAD geometry when the number of meshing objects is less than 10,000. If this limit is exceeded, then no edges are extracted. When this option is set to yes, then edges are extracted regardless of the number of meshing objects. No edges are extracted when this option is set to no.
                    """
                    pass

                class feature_angle(PyNumerical):
                    """
                    Specify a rotational angle (in degrees) of transformation.
                    """
                    pass

                class merge_children(PyParameter):
                    """
                    This option is only available when there are nested objects in the Meshing Model tree, and you want to assign object property settings to the top-level object. Upon updating the task, disabling this option ensures that each nested sub-object becomes its own geometry object, whereas enabling this option merges all child sub-objects into a single geometry object.
                    """
                    pass

                class name(PyTextual):
                    """
                    Parameter name of value type str.
                    """
                    pass

                class one_zone_per(PyTextual):
                    """
                    Specify whether to create your meshing zones based on an object, part, body or face. For instance, choosing the face option would create a separate zone for every topological face.
                    """
                    pass

                class prefix_object_name(PyParameter):
                    """
                    Append the name of the object to the beginning of the name of the zone.
                    """
                    pass

                class use_default_settings(PyParameter):
                    """
                    This option is only available when there are nested objects in the Meshing Model tree, and you want to assign object property settings to the top-level object. Upon updating the task, enabling this option applies the top-level (or the default) object settings to all child sub-objects, whereas disabling this option lets you define separate object settings for your individual sub-objects.
                    """
                    pass

                class add(PyCommand):
                    """
                    Command add.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _addArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _addArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._addArguments(*args)

                class remove(PyCommand):
                    """
                    Command remove.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _removeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _removeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._removeArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

            def __getitem__(self, key: str) -> _object_setting:
                return super().__getitem__(key)

        class refaceting(PyNamedObjectContainer):
            """
            .
            """
            class _refaceting(PyMenu):
                """
                Singleton _refaceting.
                """
                def __init__(self, service, rules, path):
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.applied = self.__class__.applied(service, rules, path + [("applied", "")])
                    self.children = self.__class__.children(service, rules, path + [("children", "")])
                    self.context = self.__class__.context(service, rules, path + [("context", "")])
                    self.deviation = self.__class__.deviation(service, rules, path + [("deviation", "")])
                    self.facet_max_edge_length = self.__class__.facet_max_edge_length(service, rules, path + [("facet_max_edge_length", "")])
                    self.max_edge_length_factor = self.__class__.max_edge_length_factor(service, rules, path + [("max_edge_length_factor", "")])
                    self.max_size = self.__class__.max_size(service, rules, path + [("max_size", "")])
                    self.name = self.__class__.name(service, rules, path + [("name", "")])
                    self.normal_angle = self.__class__.normal_angle(service, rules, path + [("normal_angle", "")])
                    self.add = self.__class__.add(service, rules, "add", path)
                    self.apply = self.__class__.apply(service, rules, "apply", path)
                    self.delete = self.__class__.delete(service, rules, "delete", path)
                    self.edit = self.__class__.edit(service, rules, "edit", path)
                    self.remove = self.__class__.remove(service, rules, "remove", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    super().__init__(service, rules, path)

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class applied(PyParameter):
                    """
                    Parameter applied of value type bool.
                    """
                    pass

                class children(PyTextual):
                    """
                    Parameter children of value type list[str].
                    """
                    pass

                class context(PyNumerical):
                    """
                    Parameter context of value type int.
                    """
                    pass

                class deviation(PyNumerical):
                    """
                    Specify the distance between facet edges and the geometry edges. Decreasing this value will result in more facets along curved edges.
                    """
                    pass

                class facet_max_edge_length(PyTextual):
                    """
                    Controls the edge size of facets, ensuring that no facet edge exceeds the specified length. The max edge length size (Max Size) can either be specified directly by selecting Absolute or specified as a factor (Max Edge Length Factor) relative to the bounding box of the geometry by selecting Relative (Bounding Box).
                    """
                    pass

                class max_edge_length_factor(PyNumerical):
                    """
                    Specifies the maximum size of the facets relative to the bounding box of the geometry.
                    """
                    pass

                class max_size(PyNumerical):
                    """
                    Specify a maximum element size for the imported model to avoid very large facets during the file import.
                    """
                    pass

                class name(PyTextual):
                    """
                    Parameter name of value type str.
                    """
                    pass

                class normal_angle(PyNumerical):
                    """
                    Specify a rotational angle (in degrees) of transformation.
                    """
                    pass

                class add(PyCommand):
                    """
                    Command add.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _addArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _addArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._addArguments(*args)

                class apply(PyCommand):
                    """
                    Command apply.


                    Returns
                    -------
                    bool
                    """
                    class _applyArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _applyArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._applyArguments(*args)

                class delete(PyCommand):
                    """
                    Command delete.


                    Returns
                    -------
                    bool
                    """
                    class _deleteArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _deleteArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._deleteArguments(*args)

                class edit(PyCommand):
                    """
                    Command edit.


                    Returns
                    -------
                    bool
                    """
                    class _editArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _editArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._editArguments(*args)

                class remove(PyCommand):
                    """
                    Command remove.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _removeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _removeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._removeArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

            def __getitem__(self, key: str) -> _refaceting:
                return super().__getitem__(key)

        class rotate(PyNamedObjectContainer):
            """
            .
            """
            class _rotate(PyMenu):
                """
                Singleton _rotate.
                """
                def __init__(self, service, rules, path):
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.applied = self.__class__.applied(service, rules, path + [("applied", "")])
                    self.children = self.__class__.children(service, rules, path + [("children", "")])
                    self.context = self.__class__.context(service, rules, path + [("context", "")])
                    self.coordinate_system = self.__class__.coordinate_system(service, rules, path + [("coordinate_system", "")])
                    self.name = self.__class__.name(service, rules, path + [("name", "")])
                    self.rotate_x = self.__class__.rotate_x(service, rules, path + [("rotate_x", "")])
                    self.rotate_y = self.__class__.rotate_y(service, rules, path + [("rotate_y", "")])
                    self.rotate_z = self.__class__.rotate_z(service, rules, path + [("rotate_z", "")])
                    self.type = self.__class__.type(service, rules, path + [("type", "")])
                    self.add = self.__class__.add(service, rules, "add", path)
                    self.apply = self.__class__.apply(service, rules, "apply", path)
                    self.remove = self.__class__.remove(service, rules, "remove", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.undo = self.__class__.undo(service, rules, "undo", path)
                    self.update = self.__class__.update(service, rules, "update", path)
                    super().__init__(service, rules, path)

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class applied(PyParameter):
                    """
                    Parameter applied of value type bool.
                    """
                    pass

                class children(PyTextual):
                    """
                    Parameter children of value type list[str].
                    """
                    pass

                class context(PyNumerical):
                    """
                    Parameter context of value type int.
                    """
                    pass

                class coordinate_system(PyTextual):
                    """
                    Specify whether to apply the transformation to the Local or Global coordinate system. The local coordinate system is one that is associated with the individual CAD geometry as it is being created, where one chooses to re-orient that CAD sketch and create the model. Its orientation can vary based on its placement in an assembly of the entire model (for example, tires for a car). The global coordinate system has a fixed orientation, whereas the local coordinate system will have a different orientation. If, however, the CAD part was created without changing the coordinate systems, then there will be no difference between the local and global coordinate systems.
                    """
                    pass

                class name(PyTextual):
                    """
                    Parameter name of value type str.
                    """
                    pass

                class rotate_x(PyNumerical):
                    """
                    Specify the angle of rotation (in degrees) around the X axis that you want to apply to the transformation.
                    """
                    pass

                class rotate_y(PyNumerical):
                    """
                    Specify the angle of rotation (in degrees) around the Y axis that you want to apply to the transformation.
                    """
                    pass

                class rotate_z(PyNumerical):
                    """
                    Specify the angle of rotation (in degrees) around the Z axis that you want to apply to the transformation.
                    """
                    pass

                class type(PyTextual):
                    """
                    Specify whether to apply a translational or a rotational transformation.
                    """
                    pass

                class add(PyCommand):
                    """
                    Command add.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _addArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _addArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._addArguments(*args)

                class apply(PyCommand):
                    """
                    Command apply.


                    Returns
                    -------
                    bool
                    """
                    class _applyArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _applyArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._applyArguments(*args)

                class remove(PyCommand):
                    """
                    Command remove.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _removeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _removeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._removeArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class undo(PyCommand):
                    """
                    Command undo.


                    Returns
                    -------
                    bool
                    """
                    class _undoArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _undoArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._undoArguments(*args)

                class update(PyCommand):
                    """
                    Command update.


                    Returns
                    -------
                    bool
                    """
                    class _updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._updateArguments(*args)

            def __getitem__(self, key: str) -> _rotate:
                return super().__getitem__(key)

        class rotate_about_axis(PyNamedObjectContainer):
            """
            .
            """
            class _rotate_about_axis(PyMenu):
                """
                Singleton _rotate_about_axis.
                """
                def __init__(self, service, rules, path):
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.angle = self.__class__.angle(service, rules, path + [("angle", "")])
                    self.applied = self.__class__.applied(service, rules, path + [("applied", "")])
                    self.axis_x = self.__class__.axis_x(service, rules, path + [("axis_x", "")])
                    self.axis_y = self.__class__.axis_y(service, rules, path + [("axis_y", "")])
                    self.axis_z = self.__class__.axis_z(service, rules, path + [("axis_z", "")])
                    self.children = self.__class__.children(service, rules, path + [("children", "")])
                    self.context = self.__class__.context(service, rules, path + [("context", "")])
                    self.coordinate_system = self.__class__.coordinate_system(service, rules, path + [("coordinate_system", "")])
                    self.name = self.__class__.name(service, rules, path + [("name", "")])
                    self.pivot_x = self.__class__.pivot_x(service, rules, path + [("pivot_x", "")])
                    self.pivot_y = self.__class__.pivot_y(service, rules, path + [("pivot_y", "")])
                    self.pivot_z = self.__class__.pivot_z(service, rules, path + [("pivot_z", "")])
                    self.type = self.__class__.type(service, rules, path + [("type", "")])
                    self.add = self.__class__.add(service, rules, "add", path)
                    self.apply = self.__class__.apply(service, rules, "apply", path)
                    self.remove = self.__class__.remove(service, rules, "remove", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.undo = self.__class__.undo(service, rules, "undo", path)
                    self.update = self.__class__.update(service, rules, "update", path)
                    super().__init__(service, rules, path)

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class angle(PyNumerical):
                    """
                    Specify a rotational angle (in degrees) of transformation.
                    """
                    pass

                class applied(PyParameter):
                    """
                    Parameter applied of value type bool.
                    """
                    pass

                class axis_x(PyNumerical):
                    """
                    Specify the X component of the rotational axis, based on the specified coordinate system.
                    """
                    pass

                class axis_y(PyNumerical):
                    """
                    Specify the Y component of the rotational axis, based on the specified coordinate system.
                    """
                    pass

                class axis_z(PyNumerical):
                    """
                    Specify the Z component of the rotational axis, based on the specified coordinate system.
                    """
                    pass

                class children(PyTextual):
                    """
                    Parameter children of value type list[str].
                    """
                    pass

                class context(PyNumerical):
                    """
                    Parameter context of value type int.
                    """
                    pass

                class coordinate_system(PyTextual):
                    """
                    Specify whether to apply the transformation to the Local or Global coordinate system. The local coordinate system is one that is associated with the individual CAD geometry as it is being created, where one chooses to re-orient that CAD sketch and create the model. Its orientation can vary based on its placement in an assembly of the entire model (for example, tires for a car). The global coordinate system has a fixed orientation, whereas the local coordinate system will have a different orientation. If, however, the CAD part was created without changing the coordinate systems, then there will be no difference between the local and global coordinate systems.
                    """
                    pass

                class name(PyTextual):
                    """
                    Parameter name of value type str.
                    """
                    pass

                class pivot_x(PyNumerical):
                    """
                    Specify the X coordinate (using display units) of the pivot point, based on the specified coordinate system.
                    """
                    pass

                class pivot_y(PyNumerical):
                    """
                    Specify the Y coordinate (using display units) of the pivot point, based on the specified coordinate system.
                    """
                    pass

                class pivot_z(PyNumerical):
                    """
                    Specify the Z coordinate (using display units) of the pivot point, based on the specified coordinate system.
                    """
                    pass

                class type(PyTextual):
                    """
                    Specify whether to apply a translational or a rotational transformation.
                    """
                    pass

                class add(PyCommand):
                    """
                    Command add.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _addArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _addArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._addArguments(*args)

                class apply(PyCommand):
                    """
                    Command apply.


                    Returns
                    -------
                    bool
                    """
                    class _applyArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _applyArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._applyArguments(*args)

                class remove(PyCommand):
                    """
                    Command remove.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _removeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _removeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._removeArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class undo(PyCommand):
                    """
                    Command undo.


                    Returns
                    -------
                    bool
                    """
                    class _undoArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _undoArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._undoArguments(*args)

                class update(PyCommand):
                    """
                    Command update.


                    Returns
                    -------
                    bool
                    """
                    class _updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._updateArguments(*args)

            def __getitem__(self, key: str) -> _rotate_about_axis:
                return super().__getitem__(key)

        class scaling(PyNamedObjectContainer):
            """
            .
            """
            class _scaling(PyMenu):
                """
                Singleton _scaling.
                """
                def __init__(self, service, rules, path):
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.applied = self.__class__.applied(service, rules, path + [("applied", "")])
                    self.children = self.__class__.children(service, rules, path + [("children", "")])
                    self.context = self.__class__.context(service, rules, path + [("context", "")])
                    self.coordinate_system = self.__class__.coordinate_system(service, rules, path + [("coordinate_system", "")])
                    self.name = self.__class__.name(service, rules, path + [("name", "")])
                    self.scale_x = self.__class__.scale_x(service, rules, path + [("scale_x", "")])
                    self.scale_y = self.__class__.scale_y(service, rules, path + [("scale_y", "")])
                    self.scale_z = self.__class__.scale_z(service, rules, path + [("scale_z", "")])
                    self.type = self.__class__.type(service, rules, path + [("type", "")])
                    self.add = self.__class__.add(service, rules, "add", path)
                    self.apply = self.__class__.apply(service, rules, "apply", path)
                    self.remove = self.__class__.remove(service, rules, "remove", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.undo = self.__class__.undo(service, rules, "undo", path)
                    self.update = self.__class__.update(service, rules, "update", path)
                    super().__init__(service, rules, path)

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class applied(PyParameter):
                    """
                    Parameter applied of value type bool.
                    """
                    pass

                class children(PyTextual):
                    """
                    Parameter children of value type list[str].
                    """
                    pass

                class context(PyNumerical):
                    """
                    Parameter context of value type int.
                    """
                    pass

                class coordinate_system(PyTextual):
                    """
                    Specify whether to apply the transformation to the Local or Global coordinate system. The local coordinate system is one that is associated with the individual CAD geometry as it is being created, where one chooses to re-orient that CAD sketch and create the model. Its orientation can vary based on its placement in an assembly of the entire model (for example, tires for a car). The global coordinate system has a fixed orientation, whereas the local coordinate system will have a different orientation. If, however, the CAD part was created without changing the coordinate systems, then there will be no difference between the local and global coordinate systems.
                    """
                    pass

                class name(PyTextual):
                    """
                    Parameter name of value type str.
                    """
                    pass

                class scale_x(PyNumerical):
                    """
                    Specify the X component of the scale factor, based on the specified coordinate system.
                    """
                    pass

                class scale_y(PyNumerical):
                    """
                    Specify the Y component of the scale factor, based on the specified coordinate system.
                    """
                    pass

                class scale_z(PyNumerical):
                    """
                    Specify the Z component of the scale factor, based on the specified coordinate system.
                    """
                    pass

                class type(PyTextual):
                    """
                    Specify whether to apply a translational or a rotational transformation.
                    """
                    pass

                class add(PyCommand):
                    """
                    Command add.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _addArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _addArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._addArguments(*args)

                class apply(PyCommand):
                    """
                    Command apply.


                    Returns
                    -------
                    bool
                    """
                    class _applyArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _applyArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._applyArguments(*args)

                class remove(PyCommand):
                    """
                    Command remove.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _removeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _removeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._removeArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class undo(PyCommand):
                    """
                    Command undo.


                    Returns
                    -------
                    bool
                    """
                    class _undoArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _undoArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._undoArguments(*args)

                class update(PyCommand):
                    """
                    Command update.


                    Returns
                    -------
                    bool
                    """
                    class _updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._updateArguments(*args)

            def __getitem__(self, key: str) -> _scaling:
                return super().__getitem__(key)

        class transform(PyNamedObjectContainer):
            """
            .
            """
            class _transform(PyMenu):
                """
                Singleton _transform.
                """
                def __init__(self, service, rules, path):
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.applied = self.__class__.applied(service, rules, path + [("applied", "")])
                    self.children = self.__class__.children(service, rules, path + [("children", "")])
                    self.context = self.__class__.context(service, rules, path + [("context", "")])
                    self.coordinate_system = self.__class__.coordinate_system(service, rules, path + [("coordinate_system", "")])
                    self.name = self.__class__.name(service, rules, path + [("name", "")])
                    self.rotate_x = self.__class__.rotate_x(service, rules, path + [("rotate_x", "")])
                    self.rotate_y = self.__class__.rotate_y(service, rules, path + [("rotate_y", "")])
                    self.rotate_z = self.__class__.rotate_z(service, rules, path + [("rotate_z", "")])
                    self.translate_x = self.__class__.translate_x(service, rules, path + [("translate_x", "")])
                    self.translate_y = self.__class__.translate_y(service, rules, path + [("translate_y", "")])
                    self.translate_z = self.__class__.translate_z(service, rules, path + [("translate_z", "")])
                    self.type = self.__class__.type(service, rules, path + [("type", "")])
                    self.add = self.__class__.add(service, rules, "add", path)
                    self.apply = self.__class__.apply(service, rules, "apply", path)
                    self.delete = self.__class__.delete(service, rules, "delete", path)
                    self.remove = self.__class__.remove(service, rules, "remove", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.undo = self.__class__.undo(service, rules, "undo", path)
                    self.update = self.__class__.update(service, rules, "update", path)
                    super().__init__(service, rules, path)

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class applied(PyParameter):
                    """
                    Parameter applied of value type bool.
                    """
                    pass

                class children(PyTextual):
                    """
                    Parameter children of value type list[str].
                    """
                    pass

                class context(PyNumerical):
                    """
                    Parameter context of value type int.
                    """
                    pass

                class coordinate_system(PyTextual):
                    """
                    Specify whether to apply the transformation to the Local or Global coordinate system. The local coordinate system is one that is associated with the individual CAD geometry as it is being created, where one chooses to re-orient that CAD sketch and create the model. Its orientation can vary based on its placement in an assembly of the entire model (for example, tires for a car). The global coordinate system has a fixed orientation, whereas the local coordinate system will have a different orientation. If, however, the CAD part was created without changing the coordinate systems, then there will be no difference between the local and global coordinate systems.
                    """
                    pass

                class name(PyTextual):
                    """
                    Parameter name of value type str.
                    """
                    pass

                class rotate_x(PyNumerical):
                    """
                    Specify the angle of rotation (in degrees) around the X axis that you want to apply to the transformation.
                    """
                    pass

                class rotate_y(PyNumerical):
                    """
                    Specify the angle of rotation (in degrees) around the Y axis that you want to apply to the transformation.
                    """
                    pass

                class rotate_z(PyNumerical):
                    """
                    Specify the angle of rotation (in degrees) around the Z axis that you want to apply to the transformation.
                    """
                    pass

                class translate_x(PyNumerical):
                    """
                    Specify the distance (using display units) along the X axis to apply the translation.
                    """
                    pass

                class translate_y(PyNumerical):
                    """
                    Specify the distance (using display units) along the Y axis to apply the translation.
                    """
                    pass

                class translate_z(PyNumerical):
                    """
                    Specify the distance (using display units) along the Z axis to apply the translation.
                    """
                    pass

                class type(PyTextual):
                    """
                    Specify whether to apply a translational or a rotational transformation.
                    """
                    pass

                class add(PyCommand):
                    """
                    Command add.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _addArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _addArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._addArguments(*args)

                class apply(PyCommand):
                    """
                    Command apply.


                    Returns
                    -------
                    bool
                    """
                    class _applyArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _applyArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._applyArguments(*args)

                class delete(PyCommand):
                    """
                    Command delete.

                    Parameters
                    ----------
                    path : str

                    Returns
                    -------
                    bool
                    """
                    class _deleteArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.path = self._path(self, "path", service, rules, path)

                        class _path(PyArgumentsTextualSubItem):
                            """
                            Argument path.
                            """

                    def create_instance(self) -> _deleteArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._deleteArguments(*args)

                class remove(PyCommand):
                    """
                    Command remove.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _removeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _removeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._removeArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class undo(PyCommand):
                    """
                    Command undo.


                    Returns
                    -------
                    bool
                    """
                    class _undoArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _undoArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._undoArguments(*args)

                class update(PyCommand):
                    """
                    Command update.


                    Returns
                    -------
                    bool
                    """
                    class _updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._updateArguments(*args)

            def __getitem__(self, key: str) -> _transform:
                return super().__getitem__(key)

        class transform_base(PyNamedObjectContainer):
            """
            .
            """
            class _transform_base(PyMenu):
                """
                Singleton _transform_base.
                """
                def __init__(self, service, rules, path):
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.applied = self.__class__.applied(service, rules, path + [("applied", "")])
                    self.children = self.__class__.children(service, rules, path + [("children", "")])
                    self.context = self.__class__.context(service, rules, path + [("context", "")])
                    self.coordinate_system = self.__class__.coordinate_system(service, rules, path + [("coordinate_system", "")])
                    self.name = self.__class__.name(service, rules, path + [("name", "")])
                    self.type = self.__class__.type(service, rules, path + [("type", "")])
                    self.add = self.__class__.add(service, rules, "add", path)
                    self.apply = self.__class__.apply(service, rules, "apply", path)
                    self.remove = self.__class__.remove(service, rules, "remove", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.undo = self.__class__.undo(service, rules, "undo", path)
                    self.update = self.__class__.update(service, rules, "update", path)
                    super().__init__(service, rules, path)

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class applied(PyParameter):
                    """
                    Parameter applied of value type bool.
                    """
                    pass

                class children(PyTextual):
                    """
                    Parameter children of value type list[str].
                    """
                    pass

                class context(PyNumerical):
                    """
                    Parameter context of value type int.
                    """
                    pass

                class coordinate_system(PyTextual):
                    """
                    Specify whether to apply the transformation to the Local or Global coordinate system. The local coordinate system is one that is associated with the individual CAD geometry as it is being created, where one chooses to re-orient that CAD sketch and create the model. Its orientation can vary based on its placement in an assembly of the entire model (for example, tires for a car). The global coordinate system has a fixed orientation, whereas the local coordinate system will have a different orientation. If, however, the CAD part was created without changing the coordinate systems, then there will be no difference between the local and global coordinate systems.
                    """
                    pass

                class name(PyTextual):
                    """
                    Parameter name of value type str.
                    """
                    pass

                class type(PyTextual):
                    """
                    Specify whether to apply a translational or a rotational transformation.
                    """
                    pass

                class add(PyCommand):
                    """
                    Command add.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _addArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _addArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._addArguments(*args)

                class apply(PyCommand):
                    """
                    Command apply.


                    Returns
                    -------
                    bool
                    """
                    class _applyArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _applyArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._applyArguments(*args)

                class remove(PyCommand):
                    """
                    Command remove.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _removeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _removeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._removeArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class undo(PyCommand):
                    """
                    Command undo.


                    Returns
                    -------
                    bool
                    """
                    class _undoArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _undoArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._undoArguments(*args)

                class update(PyCommand):
                    """
                    Command update.


                    Returns
                    -------
                    bool
                    """
                    class _updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._updateArguments(*args)

            def __getitem__(self, key: str) -> _transform_base:
                return super().__getitem__(key)

        class translate(PyNamedObjectContainer):
            """
            .
            """
            class _translate(PyMenu):
                """
                Singleton _translate.
                """
                def __init__(self, service, rules, path):
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.applied = self.__class__.applied(service, rules, path + [("applied", "")])
                    self.children = self.__class__.children(service, rules, path + [("children", "")])
                    self.context = self.__class__.context(service, rules, path + [("context", "")])
                    self.coordinate_system = self.__class__.coordinate_system(service, rules, path + [("coordinate_system", "")])
                    self.name = self.__class__.name(service, rules, path + [("name", "")])
                    self.translate_x = self.__class__.translate_x(service, rules, path + [("translate_x", "")])
                    self.translate_y = self.__class__.translate_y(service, rules, path + [("translate_y", "")])
                    self.translate_z = self.__class__.translate_z(service, rules, path + [("translate_z", "")])
                    self.type = self.__class__.type(service, rules, path + [("type", "")])
                    self.add = self.__class__.add(service, rules, "add", path)
                    self.apply = self.__class__.apply(service, rules, "apply", path)
                    self.remove = self.__class__.remove(service, rules, "remove", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.undo = self.__class__.undo(service, rules, "undo", path)
                    self.update = self.__class__.update(service, rules, "update", path)
                    super().__init__(service, rules, path)

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class applied(PyParameter):
                    """
                    Parameter applied of value type bool.
                    """
                    pass

                class children(PyTextual):
                    """
                    Parameter children of value type list[str].
                    """
                    pass

                class context(PyNumerical):
                    """
                    Parameter context of value type int.
                    """
                    pass

                class coordinate_system(PyTextual):
                    """
                    Specify whether to apply the transformation to the Local or Global coordinate system. The local coordinate system is one that is associated with the individual CAD geometry as it is being created, where one chooses to re-orient that CAD sketch and create the model. Its orientation can vary based on its placement in an assembly of the entire model (for example, tires for a car). The global coordinate system has a fixed orientation, whereas the local coordinate system will have a different orientation. If, however, the CAD part was created without changing the coordinate systems, then there will be no difference between the local and global coordinate systems.
                    """
                    pass

                class name(PyTextual):
                    """
                    Parameter name of value type str.
                    """
                    pass

                class translate_x(PyNumerical):
                    """
                    Specify the distance (using display units) along the X axis to apply the translation.
                    """
                    pass

                class translate_y(PyNumerical):
                    """
                    Specify the distance (using display units) along the Y axis to apply the translation.
                    """
                    pass

                class translate_z(PyNumerical):
                    """
                    Specify the distance (using display units) along the Z axis to apply the translation.
                    """
                    pass

                class type(PyTextual):
                    """
                    Specify whether to apply a translational or a rotational transformation.
                    """
                    pass

                class add(PyCommand):
                    """
                    Command add.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _addArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _addArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._addArguments(*args)

                class apply(PyCommand):
                    """
                    Command apply.


                    Returns
                    -------
                    bool
                    """
                    class _applyArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _applyArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._applyArguments(*args)

                class remove(PyCommand):
                    """
                    Command remove.

                    Parameters
                    ----------
                    paths : list[str]

                    Returns
                    -------
                    bool
                    """
                    class _removeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.paths = self._paths(self, "paths", service, rules, path)

                        class _paths(PyArgumentsTextualSubItem):
                            """
                            Argument paths.
                            """

                    def create_instance(self) -> _removeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._removeArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class undo(PyCommand):
                    """
                    Command undo.


                    Returns
                    -------
                    bool
                    """
                    class _undoArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _undoArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._undoArguments(*args)

                class update(PyCommand):
                    """
                    Command update.


                    Returns
                    -------
                    bool
                    """
                    class _updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._updateArguments(*args)

            def __getitem__(self, key: str) -> _translate:
                return super().__getitem__(key)

        class global_settings(PyMenu):
            """
            Singleton global_settings.
            """
            def __init__(self, service, rules, path):
                self.current_context = self.__class__.current_context(service, rules, path + [("current_context", "")])
                self.current_node = self.__class__.current_node(service, rules, path + [("current_node", "")])
                self.display_bounding_box = self.__class__.display_bounding_box(service, rules, path + [("display_bounding_box", "")])
                self.length_unit = self.__class__.length_unit(service, rules, path + [("length_unit", "")])
                super().__init__(service, rules, path)

            class current_context(PyNumerical):
                """
                Parameter current_context of value type int.
                """
                pass

            class current_node(PyTextual):
                """
                Parameter current_node of value type str.
                """
                pass

            class display_bounding_box(PyParameter):
                """
                Parameter display_bounding_box of value type bool.
                """
                pass

            class length_unit(PyTextual):
                """
                Select a suitable unit for display in the graphics window.
                """
                pass

        class meshing_operations(PyMenu):
            """
            Singleton meshing_operations.
            """
            def __init__(self, service, rules, path):
                self.children = self.__class__.children(service, rules, path + [("children", "")])
                self.name = self.__class__.name(service, rules, path + [("name", "")])
                self.delete_all_operations = self.__class__.delete_all_operations(service, rules, "delete_all_operations", path)
                self.update_all_operations = self.__class__.update_all_operations(service, rules, "update_all_operations", path)
                super().__init__(service, rules, path)

            class children(PyTextual):
                """
                Parameter children of value type list[str].
                """
                pass

            class name(PyTextual):
                """
                Parameter name of value type str.
                """
                pass

            class delete_all_operations(PyCommand):
                """
                Command delete_all_operations.


                Returns
                -------
                bool
                """
                class _delete_all_operationsArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _delete_all_operationsArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._delete_all_operationsArguments(*args)

            class update_all_operations(PyCommand):
                """
                Command update_all_operations.


                Returns
                -------
                bool
                """
                class _update_all_operationsArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _update_all_operationsArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._update_all_operationsArguments(*args)

        class object_setting_operations(PyMenu):
            """
            Singleton object_setting_operations.
            """
            def __init__(self, service, rules, path):
                self.children = self.__class__.children(service, rules, path + [("children", "")])
                self.name = self.__class__.name(service, rules, path + [("name", "")])
                self.create_object_setting = self.__class__.create_object_setting(service, rules, "create_object_setting", path)
                self.delete_all_object_setting = self.__class__.delete_all_object_setting(service, rules, "delete_all_object_setting", path)
                self.delete_object_setting = self.__class__.delete_object_setting(service, rules, "delete_object_setting", path)
                super().__init__(service, rules, path)

            class children(PyTextual):
                """
                Parameter children of value type list[str].
                """
                pass

            class name(PyTextual):
                """
                Parameter name of value type str.
                """
                pass

            class create_object_setting(PyCommand):
                """
                Command create_object_setting.

                Parameters
                ----------
                paths : list[str]

                Returns
                -------
                bool
                """
                class _create_object_settingArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.paths = self._paths(self, "paths", service, rules, path)

                    class _paths(PyArgumentsTextualSubItem):
                        """
                        Argument paths.
                        """

                def create_instance(self) -> _create_object_settingArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._create_object_settingArguments(*args)

            class delete_all_object_setting(PyCommand):
                """
                Command delete_all_object_setting.


                Returns
                -------
                bool
                """
                class _delete_all_object_settingArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _delete_all_object_settingArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._delete_all_object_settingArguments(*args)

            class delete_object_setting(PyCommand):
                """
                Command delete_object_setting.

                Parameters
                ----------
                paths : list[str]

                Returns
                -------
                bool
                """
                class _delete_object_settingArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.paths = self._paths(self, "paths", service, rules, path)

                    class _paths(PyArgumentsTextualSubItem):
                        """
                        Argument paths.
                        """

                def create_instance(self) -> _delete_object_settingArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._delete_object_settingArguments(*args)

        class refaceting_operations(PyMenu):
            """
            Singleton refaceting_operations.
            """
            def __init__(self, service, rules, path):
                self.children = self.__class__.children(service, rules, path + [("children", "")])
                self.name = self.__class__.name(service, rules, path + [("name", "")])
                self.create_refacet = self.__class__.create_refacet(service, rules, "create_refacet", path)
                self.delete_all_refacets = self.__class__.delete_all_refacets(service, rules, "delete_all_refacets", path)
                self.delete_refacet = self.__class__.delete_refacet(service, rules, "delete_refacet", path)
                self.update_all_refacets = self.__class__.update_all_refacets(service, rules, "update_all_refacets", path)
                super().__init__(service, rules, path)

            class children(PyTextual):
                """
                Parameter children of value type list[str].
                """
                pass

            class name(PyTextual):
                """
                Parameter name of value type str.
                """
                pass

            class create_refacet(PyCommand):
                """
                Select this option when you want to change faceting of the selected object. Refaceting will refacet the original CAD geometry. Only the faceted CAD geometry is used during the meshing process. The refaceting settings control how far the facet edges are from the model and the size of the facets.  More...
                Parameters
                ----------
                paths : list[str]

                Returns
                -------
                bool
                """
                class _create_refacetArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.paths = self._paths(self, "paths", service, rules, path)

                    class _paths(PyArgumentsTextualSubItem):
                        """
                        Argument paths.
                        """

                def create_instance(self) -> _create_refacetArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._create_refacetArguments(*args)

            class delete_all_refacets(PyCommand):
                """
                Command delete_all_refacets.


                Returns
                -------
                bool
                """
                class _delete_all_refacetsArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _delete_all_refacetsArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._delete_all_refacetsArguments(*args)

            class delete_refacet(PyCommand):
                """
                Select this option when you want to change faceting of the selected object. Refaceting will refacet the original CAD geometry. Only the faceted CAD geometry is used during the meshing process. The refaceting settings control how far the facet edges are from the model and the size of the facets.  More...
                Parameters
                ----------
                paths : list[str]

                Returns
                -------
                bool
                """
                class _delete_refacetArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.paths = self._paths(self, "paths", service, rules, path)

                    class _paths(PyArgumentsTextualSubItem):
                        """
                        Argument paths.
                        """

                def create_instance(self) -> _delete_refacetArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._delete_refacetArguments(*args)

            class update_all_refacets(PyCommand):
                """
                Command update_all_refacets.


                Returns
                -------
                bool
                """
                class _update_all_refacetsArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _update_all_refacetsArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._update_all_refacetsArguments(*args)

        class transform_operations(PyMenu):
            """
            Singleton transform_operations.
            """
            def __init__(self, service, rules, path):
                self.children = self.__class__.children(service, rules, path + [("children", "")])
                self.name = self.__class__.name(service, rules, path + [("name", "")])
                self.create_transform = self.__class__.create_transform(service, rules, "create_transform", path)
                self.create_transform_type = self.__class__.create_transform_type(service, rules, "create_transform_type", path)
                self.delete_all_transforms = self.__class__.delete_all_transforms(service, rules, "delete_all_transforms", path)
                self.delete_transform = self.__class__.delete_transform(service, rules, "delete_transform", path)
                self.update_all_transforms = self.__class__.update_all_transforms(service, rules, "update_all_transforms", path)
                super().__init__(service, rules, path)

            class children(PyTextual):
                """
                Parameter children of value type list[str].
                """
                pass

            class name(PyTextual):
                """
                Parameter name of value type str.
                """
                pass

            class create_transform(PyCommand):
                """
                Command create_transform.

                Parameters
                ----------
                paths : list[str]

                Returns
                -------
                bool
                """
                class _create_transformArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.paths = self._paths(self, "paths", service, rules, path)

                    class _paths(PyArgumentsTextualSubItem):
                        """
                        Argument paths.
                        """

                def create_instance(self) -> _create_transformArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._create_transformArguments(*args)

            class create_transform_type(PyCommand):
                """
                Specify whether to apply a translational or a rotational transformation.
                Parameters
                ----------
                type : str
                    Specify whether to apply a translational or a rotational transformation.
                paths : list[str]

                Returns
                -------
                bool
                """
                class _create_transform_typeArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.type = self._type(self, "type", service, rules, path)
                        self.paths = self._paths(self, "paths", service, rules, path)

                    class _type(PyArgumentsTextualSubItem):
                        """
                        Specify whether to apply a translational or a rotational transformation.
                        """

                    class _paths(PyArgumentsTextualSubItem):
                        """
                        Argument paths.
                        """

                def create_instance(self) -> _create_transform_typeArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._create_transform_typeArguments(*args)

            class delete_all_transforms(PyCommand):
                """
                Command delete_all_transforms.


                Returns
                -------
                bool
                """
                class _delete_all_transformsArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _delete_all_transformsArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._delete_all_transformsArguments(*args)

            class delete_transform(PyCommand):
                """
                Command delete_transform.

                Parameters
                ----------
                paths : list[str]

                Returns
                -------
                bool
                """
                class _delete_transformArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.paths = self._paths(self, "paths", service, rules, path)

                    class _paths(PyArgumentsTextualSubItem):
                        """
                        Argument paths.
                        """

                def create_instance(self) -> _delete_transformArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._delete_transformArguments(*args)

            class update_all_transforms(PyCommand):
                """
                Command update_all_transforms.


                Returns
                -------
                bool
                """
                class _update_all_transformsArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _update_all_transformsArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._update_all_transformsArguments(*args)

        class append_fmd_files(PyCommand):
            """
            Command append_fmd_files.

            Parameters
            ----------
            file_path : list[str]
            assembly_parent_node : int
            file_unit : str
            route : str
                Provides the recommended route in order to import and load the specified CAD file into this task. The default settings are recommended in most cases.  More...
            jt_lod : str
                Specify the level of detail that you want to include for this .jt file before loading the CAD file.
            part_per_body : bool
                Enable this option to make all bodies available as individual parts in the CAD Model tree once the CAD file is loaded into the task.
            prefix_parent_name : bool
                This applies the name of the component (or assembly) as a prefix to the individual part names when the geometry is loaded into the task.
            remove_empty_parts : bool
                Enabled by default, this option lets you import your CAD geometry while removing any empty components.
            ignore_solid_names_append : bool
                Enable this field and browse and select additional CAD files. Use the Append button to add the additional CAD components to the bottom of the CAD Model tree upon loading.
            options : dict[str, Any]
            refacet_options : dict[str, Any]

            Returns
            -------
            bool
            """
            class _append_fmd_filesArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.file_path = self._file_path(self, "file_path", service, rules, path)
                    self.assembly_parent_node = self._assembly_parent_node(self, "assembly_parent_node", service, rules, path)
                    self.file_unit = self._file_unit(self, "file_unit", service, rules, path)
                    self.route = self._route(self, "route", service, rules, path)
                    self.jt_lod = self._jt_lod(self, "jt_lod", service, rules, path)
                    self.part_per_body = self._part_per_body(self, "part_per_body", service, rules, path)
                    self.prefix_parent_name = self._prefix_parent_name(self, "prefix_parent_name", service, rules, path)
                    self.remove_empty_parts = self._remove_empty_parts(self, "remove_empty_parts", service, rules, path)
                    self.ignore_solid_names_append = self._ignore_solid_names_append(self, "ignore_solid_names_append", service, rules, path)
                    self.options = self._options(self, "options", service, rules, path)
                    self.refacet_options = self._refacet_options(self, "refacet_options", service, rules, path)

                class _file_path(PyArgumentsTextualSubItem):
                    """
                    Argument file_path.
                    """

                class _assembly_parent_node(PyArgumentsNumericalSubItem):
                    """
                    Argument assembly_parent_node.
                    """

                class _file_unit(PyArgumentsTextualSubItem):
                    """
                    Argument file_unit.
                    """

                class _route(PyArgumentsTextualSubItem):
                    """
                    Provides the recommended route in order to import and load the specified CAD file into this task. The default settings are recommended in most cases.  More...
                    """

                class _jt_lod(PyArgumentsTextualSubItem):
                    """
                    Specify the level of detail that you want to include for this .jt file before loading the CAD file.
                    """

                class _part_per_body(PyArgumentsParameterSubItem):
                    """
                    Enable this option to make all bodies available as individual parts in the CAD Model tree once the CAD file is loaded into the task.
                    """

                class _prefix_parent_name(PyArgumentsParameterSubItem):
                    """
                    This applies the name of the component (or assembly) as a prefix to the individual part names when the geometry is loaded into the task.
                    """

                class _remove_empty_parts(PyArgumentsParameterSubItem):
                    """
                    Enabled by default, this option lets you import your CAD geometry while removing any empty components.
                    """

                class _ignore_solid_names_append(PyArgumentsParameterSubItem):
                    """
                    Enable this field and browse and select additional CAD files. Use the Append button to add the additional CAD components to the bottom of the CAD Model tree upon loading.
                    """

                class _options(PyArgumentsSingletonSubItem):
                    """
                    Argument options.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.line = self._line(self, "line", service, rules, path)
                        self.solid = self._solid(self, "solid", service, rules, path)
                        self.surface = self._surface(self, "surface", service, rules, path)

                    class _line(PyArgumentsParameterSubItem):
                        """
                        Enable this option to import line bodies along with your CAD geometry.
                        """

                    class _solid(PyArgumentsParameterSubItem):
                        """
                        Enable this option to import solid bodies along with your CAD geometry.
                        """

                    class _surface(PyArgumentsParameterSubItem):
                        """
                        Enable this option to import surface bodies along with your CAD geometry.
                        """

                class _refacet_options(PyArgumentsSingletonSubItem):
                    """
                    Argument refacet_options.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.max_size = self._max_size(self, "max_size", service, rules, path)
                        self.normal_angle = self._normal_angle(self, "normal_angle", service, rules, path)
                        self.refacet_during_load = self._refacet_during_load(self, "refacet_during_load", service, rules, path)
                        self.deviation = self._deviation(self, "deviation", service, rules, path)

                    class _max_size(PyArgumentsNumericalSubItem):
                        """
                        Specify a maximum element size for the imported model to avoid very large facets during the file import.
                        """

                    class _normal_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify a rotational angle (in degrees) of transformation.
                        """

                    class _refacet_during_load(PyArgumentsParameterSubItem):
                        """
                        This option is available when DSCO is selected for the Import Route. When enabled, this option will refacet the geometry as it is converted to a .fmd file. This option eliminates the need for any refaceting operation after the geometry is loaded, which can be expensive.
                        """

                    class _deviation(PyArgumentsNumericalSubItem):
                        """
                        Specify the distance between facet edges and the geometry edges. Decreasing this value will result in more facets along curved edges.
                        """

            def create_instance(self) -> _append_fmd_filesArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._append_fmd_filesArguments(*args)

        class change_file_length_unit(PyCommand):
            """
            Specify the units of length used by this .stl file before loading the CAD file.
            Parameters
            ----------
            length_unit : str
                Select a suitable unit for display in the graphics window.

            Returns
            -------
            bool
            """
            class _change_file_length_unitArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.length_unit = self._length_unit(self, "length_unit", service, rules, path)

                class _length_unit(PyArgumentsTextualSubItem):
                    """
                    Select a suitable unit for display in the graphics window.
                    """

            def create_instance(self) -> _change_file_length_unitArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._change_file_length_unitArguments(*args)

        class change_length_unit(PyCommand):
            """
            Select a suitable unit for display in the graphics window.
            Parameters
            ----------
            length_unit : str
                Select a suitable unit for display in the graphics window.

            Returns
            -------
            bool
            """
            class _change_length_unitArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.length_unit = self._length_unit(self, "length_unit", service, rules, path)

                class _length_unit(PyArgumentsTextualSubItem):
                    """
                    Select a suitable unit for display in the graphics window.
                    """

            def create_instance(self) -> _change_length_unitArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._change_length_unitArguments(*args)

        class create_obj_for_each_part(PyCommand):
            """
            Command create_obj_for_each_part.

            Parameters
            ----------
            paths : list[str]

            Returns
            -------
            bool
            """
            class _create_obj_for_each_partArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.paths = self._paths(self, "paths", service, rules, path)

                class _paths(PyArgumentsTextualSubItem):
                    """
                    Argument paths.
                    """

            def create_instance(self) -> _create_obj_for_each_partArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_obj_for_each_partArguments(*args)

        class create_objects(PyCommand):
            """
            Command create_objects.


            Returns
            -------
            bool
            """
            class _create_objectsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)

            def create_instance(self) -> _create_objectsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._create_objectsArguments(*args)

        class delete(PyCommand):
            """
            Command delete.

            Parameters
            ----------
            path : str

            Returns
            -------
            bool
            """
            class _deleteArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.path = self._path(self, "path", service, rules, path)

                class _path(PyArgumentsTextualSubItem):
                    """
                    Argument path.
                    """

            def create_instance(self) -> _deleteArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._deleteArguments(*args)

        class delete_paths(PyCommand):
            """
            Command delete_paths.

            Parameters
            ----------
            paths : list[str]

            Returns
            -------
            bool
            """
            class _delete_pathsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.paths = self._paths(self, "paths", service, rules, path)

                class _paths(PyArgumentsTextualSubItem):
                    """
                    Argument paths.
                    """

            def create_instance(self) -> _delete_pathsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._delete_pathsArguments(*args)

        class initialize_template(PyCommand):
            """
            Command initialize_template.

            Parameters
            ----------
            template_type : str
                Specify whether to apply a translational or a rotational transformation.

            Returns
            -------
            bool
            """
            class _initialize_templateArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.template_type = self._template_type(self, "template_type", service, rules, path)

                class _template_type(PyArgumentsTextualSubItem):
                    """
                    Specify whether to apply a translational or a rotational transformation.
                    """

            def create_instance(self) -> _initialize_templateArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._initialize_templateArguments(*args)

        class input_file_changed(PyCommand):
            """
            Command input_file_changed.

            Parameters
            ----------
            file_path : str
            part_per_body : bool
                Enable this option to make all bodies available as individual parts in the CAD Model tree once the CAD file is loaded into the task.
            prefix_parent_name : bool
                This applies the name of the component (or assembly) as a prefix to the individual part names when the geometry is loaded into the task.
            remove_empty_parts : bool
                Enabled by default, this option lets you import your CAD geometry while removing any empty components.
            ignore_solid_names : bool
                Enable this option to import your CAD geometry while ignoring the names assigned to solids. Note that binary STL files contain a single solid and may have an associated solid name, whereas ASCII STL files contain one or more solids and each can have a  solid name. This option allows to control whether or not to use the name contained in the STL file for naming mesh objects and components.
            file_length_unit : str
                Specify the units of length used by this .stl file before loading the CAD file.
            jt_lod : str
                Specify the level of detail that you want to include for this .jt file before loading the CAD file.
            options : dict[str, Any]
            refacet_options : dict[str, Any]

            Returns
            -------
            bool
            """
            class _input_file_changedArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.file_path = self._file_path(self, "file_path", service, rules, path)
                    self.part_per_body = self._part_per_body(self, "part_per_body", service, rules, path)
                    self.prefix_parent_name = self._prefix_parent_name(self, "prefix_parent_name", service, rules, path)
                    self.remove_empty_parts = self._remove_empty_parts(self, "remove_empty_parts", service, rules, path)
                    self.ignore_solid_names = self._ignore_solid_names(self, "ignore_solid_names", service, rules, path)
                    self.file_length_unit = self._file_length_unit(self, "file_length_unit", service, rules, path)
                    self.jt_lod = self._jt_lod(self, "jt_lod", service, rules, path)
                    self.options = self._options(self, "options", service, rules, path)
                    self.refacet_options = self._refacet_options(self, "refacet_options", service, rules, path)

                class _file_path(PyArgumentsTextualSubItem):
                    """
                    Argument file_path.
                    """

                class _part_per_body(PyArgumentsParameterSubItem):
                    """
                    Enable this option to make all bodies available as individual parts in the CAD Model tree once the CAD file is loaded into the task.
                    """

                class _prefix_parent_name(PyArgumentsParameterSubItem):
                    """
                    This applies the name of the component (or assembly) as a prefix to the individual part names when the geometry is loaded into the task.
                    """

                class _remove_empty_parts(PyArgumentsParameterSubItem):
                    """
                    Enabled by default, this option lets you import your CAD geometry while removing any empty components.
                    """

                class _ignore_solid_names(PyArgumentsParameterSubItem):
                    """
                    Enable this option to import your CAD geometry while ignoring the names assigned to solids. Note that binary STL files contain a single solid and may have an associated solid name, whereas ASCII STL files contain one or more solids and each can have a  solid name. This option allows to control whether or not to use the name contained in the STL file for naming mesh objects and components.
                    """

                class _file_length_unit(PyArgumentsTextualSubItem):
                    """
                    Specify the units of length used by this .stl file before loading the CAD file.
                    """

                class _jt_lod(PyArgumentsTextualSubItem):
                    """
                    Specify the level of detail that you want to include for this .jt file before loading the CAD file.
                    """

                class _options(PyArgumentsSingletonSubItem):
                    """
                    Argument options.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.line = self._line(self, "line", service, rules, path)
                        self.solid = self._solid(self, "solid", service, rules, path)
                        self.surface = self._surface(self, "surface", service, rules, path)

                    class _line(PyArgumentsParameterSubItem):
                        """
                        Enable this option to import line bodies along with your CAD geometry.
                        """

                    class _solid(PyArgumentsParameterSubItem):
                        """
                        Enable this option to import solid bodies along with your CAD geometry.
                        """

                    class _surface(PyArgumentsParameterSubItem):
                        """
                        Enable this option to import surface bodies along with your CAD geometry.
                        """

                class _refacet_options(PyArgumentsSingletonSubItem):
                    """
                    Argument refacet_options.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.max_size = self._max_size(self, "max_size", service, rules, path)
                        self.normal_angle = self._normal_angle(self, "normal_angle", service, rules, path)
                        self.refacet_during_load = self._refacet_during_load(self, "refacet_during_load", service, rules, path)
                        self.deviation = self._deviation(self, "deviation", service, rules, path)

                    class _max_size(PyArgumentsNumericalSubItem):
                        """
                        Specify a maximum element size for the imported model to avoid very large facets during the file import.
                        """

                    class _normal_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify a rotational angle (in degrees) of transformation.
                        """

                    class _refacet_during_load(PyArgumentsParameterSubItem):
                        """
                        This option is available when DSCO is selected for the Import Route. When enabled, this option will refacet the geometry as it is converted to a .fmd file. This option eliminates the need for any refaceting operation after the geometry is loaded, which can be expensive.
                        """

                    class _deviation(PyArgumentsNumericalSubItem):
                        """
                        Specify the distance between facet edges and the geometry edges. Decreasing this value will result in more facets along curved edges.
                        """

            def create_instance(self) -> _input_file_changedArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._input_file_changedArguments(*args)

        class list_meshing_operations(PyCommand):
            """
            Command list_meshing_operations.

            Parameters
            ----------
            path : str

            Returns
            -------
            bool
            """
            class _list_meshing_operationsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.path = self._path(self, "path", service, rules, path)

                class _path(PyArgumentsTextualSubItem):
                    """
                    Argument path.
                    """

            def create_instance(self) -> _list_meshing_operationsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._list_meshing_operationsArguments(*args)

        class load_fmd_file(PyCommand):
            """
            Command load_fmd_file.

            Parameters
            ----------
            file_path : str
            file_unit : str
            route : str
                Provides the recommended route in order to import and load the specified CAD file into this task. The default settings are recommended in most cases.  More...
            jt_lod : str
                Specify the level of detail that you want to include for this .jt file before loading the CAD file.
            part_per_body : bool
                Enable this option to make all bodies available as individual parts in the CAD Model tree once the CAD file is loaded into the task.
            prefix_parent_name : bool
                This applies the name of the component (or assembly) as a prefix to the individual part names when the geometry is loaded into the task.
            remove_empty_parts : bool
                Enabled by default, this option lets you import your CAD geometry while removing any empty components.
            ignore_solid_names : bool
                Enable this option to import your CAD geometry while ignoring the names assigned to solids. Note that binary STL files contain a single solid and may have an associated solid name, whereas ASCII STL files contain one or more solids and each can have a  solid name. This option allows to control whether or not to use the name contained in the STL file for naming mesh objects and components.
            options : dict[str, Any]
            refacet_options : dict[str, Any]

            Returns
            -------
            bool
            """
            class _load_fmd_fileArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.file_path = self._file_path(self, "file_path", service, rules, path)
                    self.file_unit = self._file_unit(self, "file_unit", service, rules, path)
                    self.route = self._route(self, "route", service, rules, path)
                    self.jt_lod = self._jt_lod(self, "jt_lod", service, rules, path)
                    self.part_per_body = self._part_per_body(self, "part_per_body", service, rules, path)
                    self.prefix_parent_name = self._prefix_parent_name(self, "prefix_parent_name", service, rules, path)
                    self.remove_empty_parts = self._remove_empty_parts(self, "remove_empty_parts", service, rules, path)
                    self.ignore_solid_names = self._ignore_solid_names(self, "ignore_solid_names", service, rules, path)
                    self.options = self._options(self, "options", service, rules, path)
                    self.refacet_options = self._refacet_options(self, "refacet_options", service, rules, path)

                class _file_path(PyArgumentsTextualSubItem):
                    """
                    Argument file_path.
                    """

                class _file_unit(PyArgumentsTextualSubItem):
                    """
                    Argument file_unit.
                    """

                class _route(PyArgumentsTextualSubItem):
                    """
                    Provides the recommended route in order to import and load the specified CAD file into this task. The default settings are recommended in most cases.  More...
                    """

                class _jt_lod(PyArgumentsTextualSubItem):
                    """
                    Specify the level of detail that you want to include for this .jt file before loading the CAD file.
                    """

                class _part_per_body(PyArgumentsParameterSubItem):
                    """
                    Enable this option to make all bodies available as individual parts in the CAD Model tree once the CAD file is loaded into the task.
                    """

                class _prefix_parent_name(PyArgumentsParameterSubItem):
                    """
                    This applies the name of the component (or assembly) as a prefix to the individual part names when the geometry is loaded into the task.
                    """

                class _remove_empty_parts(PyArgumentsParameterSubItem):
                    """
                    Enabled by default, this option lets you import your CAD geometry while removing any empty components.
                    """

                class _ignore_solid_names(PyArgumentsParameterSubItem):
                    """
                    Enable this option to import your CAD geometry while ignoring the names assigned to solids. Note that binary STL files contain a single solid and may have an associated solid name, whereas ASCII STL files contain one or more solids and each can have a  solid name. This option allows to control whether or not to use the name contained in the STL file for naming mesh objects and components.
                    """

                class _options(PyArgumentsSingletonSubItem):
                    """
                    Argument options.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.line = self._line(self, "line", service, rules, path)
                        self.solid = self._solid(self, "solid", service, rules, path)
                        self.surface = self._surface(self, "surface", service, rules, path)

                    class _line(PyArgumentsParameterSubItem):
                        """
                        Enable this option to import line bodies along with your CAD geometry.
                        """

                    class _solid(PyArgumentsParameterSubItem):
                        """
                        Enable this option to import solid bodies along with your CAD geometry.
                        """

                    class _surface(PyArgumentsParameterSubItem):
                        """
                        Enable this option to import surface bodies along with your CAD geometry.
                        """

                class _refacet_options(PyArgumentsSingletonSubItem):
                    """
                    Argument refacet_options.
                    """

                    def __init__(self, parent, attr, service, rules, path):
                        super().__init__(parent, attr, service, rules, path)
                        self.max_size = self._max_size(self, "max_size", service, rules, path)
                        self.normal_angle = self._normal_angle(self, "normal_angle", service, rules, path)
                        self.refacet_during_load = self._refacet_during_load(self, "refacet_during_load", service, rules, path)
                        self.deviation = self._deviation(self, "deviation", service, rules, path)

                    class _max_size(PyArgumentsNumericalSubItem):
                        """
                        Specify a maximum element size for the imported model to avoid very large facets during the file import.
                        """

                    class _normal_angle(PyArgumentsNumericalSubItem):
                        """
                        Specify a rotational angle (in degrees) of transformation.
                        """

                    class _refacet_during_load(PyArgumentsParameterSubItem):
                        """
                        This option is available when DSCO is selected for the Import Route. When enabled, this option will refacet the geometry as it is converted to a .fmd file. This option eliminates the need for any refaceting operation after the geometry is loaded, which can be expensive.
                        """

                    class _deviation(PyArgumentsNumericalSubItem):
                        """
                        Specify the distance between facet edges and the geometry edges. Decreasing this value will result in more facets along curved edges.
                        """

            def create_instance(self) -> _load_fmd_fileArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._load_fmd_fileArguments(*args)

        class load_template(PyCommand):
            """
            Command load_template.

            Parameters
            ----------
            file_path : str

            Returns
            -------
            bool
            """
            class _load_templateArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.file_path = self._file_path(self, "file_path", service, rules, path)

                class _file_path(PyArgumentsTextualSubItem):
                    """
                    Argument file_path.
                    """

            def create_instance(self) -> _load_templateArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._load_templateArguments(*args)

        class mark_objects_outof_date(PyCommand):
            """
            Command mark_objects_outof_date.

            Parameters
            ----------
            paths : list[str]

            Returns
            -------
            bool
            """
            class _mark_objects_outof_dateArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.paths = self._paths(self, "paths", service, rules, path)

                class _paths(PyArgumentsTextualSubItem):
                    """
                    Argument paths.
                    """

            def create_instance(self) -> _mark_objects_outof_dateArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._mark_objects_outof_dateArguments(*args)

        class move_cad_components_to_new_object(PyCommand):
            """
            Command move_cad_components_to_new_object.

            Parameters
            ----------
            paths : list[str]

            Returns
            -------
            bool
            """
            class _move_cad_components_to_new_objectArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.paths = self._paths(self, "paths", service, rules, path)

                class _paths(PyArgumentsTextualSubItem):
                    """
                    Argument paths.
                    """

            def create_instance(self) -> _move_cad_components_to_new_objectArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._move_cad_components_to_new_objectArguments(*args)

        class move_to_new_subobject(PyCommand):
            """
            Command move_to_new_subobject.

            Parameters
            ----------
            paths : list[str]

            Returns
            -------
            bool
            """
            class _move_to_new_subobjectArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.paths = self._paths(self, "paths", service, rules, path)

                class _paths(PyArgumentsTextualSubItem):
                    """
                    Argument paths.
                    """

            def create_instance(self) -> _move_to_new_subobjectArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._move_to_new_subobjectArguments(*args)

        class move_to_object(PyCommand):
            """
            Command move_to_object.

            Parameters
            ----------
            paths : list[str]

            Returns
            -------
            bool
            """
            class _move_to_objectArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.paths = self._paths(self, "paths", service, rules, path)

                class _paths(PyArgumentsTextualSubItem):
                    """
                    Argument paths.
                    """

            def create_instance(self) -> _move_to_objectArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._move_to_objectArguments(*args)

        class redo_all_transforms(PyCommand):
            """
            Command redo_all_transforms.


            Returns
            -------
            bool
            """
            class _redo_all_transformsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)

            def create_instance(self) -> _redo_all_transformsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._redo_all_transformsArguments(*args)

        class reset_template(PyCommand):
            """
            Command reset_template.


            Returns
            -------
            bool
            """
            class _reset_templateArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)

            def create_instance(self) -> _reset_templateArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._reset_templateArguments(*args)

        class save_fmd_file(PyCommand):
            """
            Command save_fmd_file.

            Parameters
            ----------
            file_path : str

            Returns
            -------
            bool
            """
            class _save_fmd_fileArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.file_path = self._file_path(self, "file_path", service, rules, path)

                class _file_path(PyArgumentsTextualSubItem):
                    """
                    Argument file_path.
                    """

            def create_instance(self) -> _save_fmd_fileArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._save_fmd_fileArguments(*args)

        class save_template(PyCommand):
            """
            Command save_template.

            Parameters
            ----------
            file_path : str

            Returns
            -------
            bool
            """
            class _save_templateArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.file_path = self._file_path(self, "file_path", service, rules, path)

                class _file_path(PyArgumentsTextualSubItem):
                    """
                    Argument file_path.
                    """

            def create_instance(self) -> _save_templateArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._save_templateArguments(*args)

        class suppress_node_objects(PyCommand):
            """
            Command suppress_node_objects.

            Parameters
            ----------
            paths : list[str]
            suppress : bool

            Returns
            -------
            bool
            """
            class _suppress_node_objectsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)
                    self.paths = self._paths(self, "paths", service, rules, path)
                    self.suppress = self._suppress(self, "suppress", service, rules, path)

                class _paths(PyArgumentsTextualSubItem):
                    """
                    Argument paths.
                    """

                class _suppress(PyArgumentsParameterSubItem):
                    """
                    Argument suppress.
                    """

            def create_instance(self) -> _suppress_node_objectsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._suppress_node_objectsArguments(*args)

        class undo_all_transforms(PyCommand):
            """
            Command undo_all_transforms.


            Returns
            -------
            bool
            """
            class _undo_all_transformsArguments(PyArguments):
                def __init__(self, service, rules, command, path, id):
                    super().__init__(service, rules, command, path, id)

            def create_instance(self) -> _undo_all_transformsArguments:
                args = self._get_create_instance_args()
                if args is not None:
                    return self._undo_all_transformsArguments(*args)

    class parts_files(PyMenu):
        """
        Singleton parts_files.
        """
        def __init__(self, service, rules, path):
            self.file = self.__class__.file(service, rules, path + [("file", "")])
            self.file_manager = self.__class__.file_manager(service, rules, path + [("file_manager", "")])
            super().__init__(service, rules, path)

        class file(PyNamedObjectContainer):
            """
            .
            """
            class _file(PyMenu):
                """
                Singleton _file.
                """
                def __init__(self, service, rules, path):
                    self.options = self.__class__.options(service, rules, path + [("options", "")])
                    self.refacet_options = self.__class__.refacet_options(service, rules, path + [("refacet_options", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.append = self.__class__.append(service, rules, path + [("append", "")])
                    self.converted_path = self.__class__.converted_path(service, rules, path + [("converted_path", "")])
                    self.dummy = self.__class__.dummy(service, rules, path + [("dummy", "")])
                    self.file_unit = self.__class__.file_unit(service, rules, path + [("file_unit", "")])
                    self.ignore_solid_names = self.__class__.ignore_solid_names(service, rules, path + [("ignore_solid_names", "")])
                    self.jt_lod = self.__class__.jt_lod(service, rules, path + [("jt_lod", "")])
                    self.keys = self.__class__.keys(service, rules, path + [("keys", "")])
                    self.name = self.__class__.name(service, rules, path + [("name", "")])
                    self.part_per_body = self.__class__.part_per_body(service, rules, path + [("part_per_body", "")])
                    self.path = self.__class__.path(service, rules, path + [("path", "")])
                    self.prefix_parent_name = self.__class__.prefix_parent_name(service, rules, path + [("prefix_parent_name", "")])
                    self.remove_empty_parts = self.__class__.remove_empty_parts(service, rules, path + [("remove_empty_parts", "")])
                    self.route = self.__class__.route(service, rules, path + [("route", "")])
                    self.updated = self.__class__.updated(service, rules, path + [("updated", "")])
                    super().__init__(service, rules, path)

                class options(PyMenu):
                    """
                    Singleton options.
                    """
                    def __init__(self, service, rules, path):
                        self.line = self.__class__.line(service, rules, path + [("line", "")])
                        self.solid = self.__class__.solid(service, rules, path + [("solid", "")])
                        self.surface = self.__class__.surface(service, rules, path + [("surface", "")])
                        super().__init__(service, rules, path)

                    class line(PyParameter):
                        """
                        Parameter line of value type bool.
                        """
                        pass

                    class solid(PyParameter):
                        """
                        Parameter solid of value type bool.
                        """
                        pass

                    class surface(PyParameter):
                        """
                        Parameter surface of value type bool.
                        """
                        pass

                class refacet_options(PyMenu):
                    """
                    Singleton refacet_options.
                    """
                    def __init__(self, service, rules, path):
                        self.deviation = self.__class__.deviation(service, rules, path + [("deviation", "")])
                        self.max_size = self.__class__.max_size(service, rules, path + [("max_size", "")])
                        self.normal_angle = self.__class__.normal_angle(service, rules, path + [("normal_angle", "")])
                        self.refacet_during_load = self.__class__.refacet_during_load(service, rules, path + [("refacet_during_load", "")])
                        super().__init__(service, rules, path)

                    class deviation(PyNumerical):
                        """
                        Parameter deviation of value type float.
                        """
                        pass

                    class max_size(PyNumerical):
                        """
                        Parameter max_size of value type float.
                        """
                        pass

                    class normal_angle(PyNumerical):
                        """
                        Parameter normal_angle of value type float.
                        """
                        pass

                    class refacet_during_load(PyParameter):
                        """
                        Parameter refacet_during_load of value type bool.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class append(PyParameter):
                    """
                    Parameter append of value type bool.
                    """
                    pass

                class converted_path(PyTextual):
                    """
                    Parameter converted_path of value type str.
                    """
                    pass

                class dummy(PyParameter):
                    """
                    Parameter dummy of value type bool.
                    """
                    pass

                class file_unit(PyTextual):
                    """
                    Parameter file_unit of value type str.
                    """
                    pass

                class ignore_solid_names(PyParameter):
                    """
                    Parameter ignore_solid_names of value type bool.
                    """
                    pass

                class jt_lod(PyTextual):
                    """
                    Parameter jt_lod of value type str.
                    """
                    pass

                class keys(PyParameter):
                    """
                    Parameter keys of value type list[int].
                    """
                    pass

                class name(PyTextual):
                    """
                    Parameter name of value type str.
                    """
                    pass

                class part_per_body(PyParameter):
                    """
                    Parameter part_per_body of value type bool.
                    """
                    pass

                class path(PyTextual):
                    """
                    Parameter path of value type str.
                    """
                    pass

                class prefix_parent_name(PyParameter):
                    """
                    Parameter prefix_parent_name of value type bool.
                    """
                    pass

                class remove_empty_parts(PyParameter):
                    """
                    Parameter remove_empty_parts of value type bool.
                    """
                    pass

                class route(PyTextual):
                    """
                    Parameter route of value type str.
                    """
                    pass

                class updated(PyParameter):
                    """
                    Parameter updated of value type bool.
                    """
                    pass

            def __getitem__(self, key: str) -> _file:
                return super().__getitem__(key)

        class file_manager(PyMenu):
            """
            Singleton file_manager.
            """
            def __init__(self, service, rules, path):
                self.children = self.__class__.children(service, rules, path + [("children", "")])
                self.name = self.__class__.name(service, rules, path + [("name", "")])
                self.delete_cad_key = self.__class__.delete_cad_key(service, rules, "delete_cad_key", path)
                self.load_files = self.__class__.load_files(service, rules, "load_files", path)
                self.reload = self.__class__.reload(service, rules, "reload", path)
                self.unload = self.__class__.unload(service, rules, "unload", path)
                super().__init__(service, rules, path)

            class children(PyTextual):
                """
                Parameter children of value type list[str].
                """
                pass

            class name(PyTextual):
                """
                Parameter name of value type str.
                """
                pass

            class delete_cad_key(PyCommand):
                """
                Command delete_cad_key.

                Parameters
                ----------
                key : int

                Returns
                -------
                bool
                """
                class _delete_cad_keyArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.key = self._key(self, "key", service, rules, path)

                    class _key(PyArgumentsNumericalSubItem):
                        """
                        Argument key.
                        """

                def create_instance(self) -> _delete_cad_keyArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._delete_cad_keyArguments(*args)

            class load_files(PyCommand):
                """
                Command load_files.


                Returns
                -------
                bool
                """
                class _load_filesArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)

                def create_instance(self) -> _load_filesArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._load_filesArguments(*args)

            class reload(PyCommand):
                """
                Command reload.

                Parameters
                ----------
                file_name : str

                Returns
                -------
                bool
                """
                class _reloadArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.file_name = self._file_name(self, "file_name", service, rules, path)

                    class _file_name(PyArgumentsTextualSubItem):
                        """
                        Argument file_name.
                        """

                def create_instance(self) -> _reloadArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._reloadArguments(*args)

            class unload(PyCommand):
                """
                Command unload.

                Parameters
                ----------
                file_name : str

                Returns
                -------
                bool
                """
                class _unloadArguments(PyArguments):
                    def __init__(self, service, rules, command, path, id):
                        super().__init__(service, rules, command, path, id)
                        self.file_name = self._file_name(self, "file_name", service, rules, path)

                    class _file_name(PyArgumentsTextualSubItem):
                        """
                        Argument file_name.
                        """

                def create_instance(self) -> _unloadArguments:
                    args = self._get_create_instance_args()
                    if args is not None:
                        return self._unloadArguments(*args)

    class task_object(PyMenu):
        """
        Task objects.
        """
        def __init__(self, service, rules, path):
            self.add_2d_boundary_layers = self.__class__.add_2d_boundary_layers(service, rules, path + [("add_2d_boundary_layers", "")])
            self.add_boundary_layers = self.__class__.add_boundary_layers(service, rules, path + [("add_boundary_layers", "")])
            self.add_boundary_layers_for_part_replacement = self.__class__.add_boundary_layers_for_part_replacement(service, rules, path + [("add_boundary_layers_for_part_replacement", "")])
            self.add_boundary_type = self.__class__.add_boundary_type(service, rules, path + [("add_boundary_type", "")])
            self.add_linear_mesh_pattern = self.__class__.add_linear_mesh_pattern(service, rules, path + [("add_linear_mesh_pattern", "")])
            self.add_local_sizing_wtm = self.__class__.add_local_sizing_wtm(service, rules, path + [("add_local_sizing_wtm", "")])
            self.add_multizone_controls = self.__class__.add_multizone_controls(service, rules, path + [("add_multizone_controls", "")])
            self.add_shell_boundary_layers = self.__class__.add_shell_boundary_layers(service, rules, path + [("add_shell_boundary_layers", "")])
            self.add_thin_volume_meshing_controls = self.__class__.add_thin_volume_meshing_controls(service, rules, path + [("add_thin_volume_meshing_controls", "")])
            self.add_virtual_topology = self.__class__.add_virtual_topology(service, rules, path + [("add_virtual_topology", "")])
            self.apply_share_topology = self.__class__.apply_share_topology(service, rules, path + [("apply_share_topology", "")])
            self.axisymmetric_sweep = self.__class__.axisymmetric_sweep(service, rules, path + [("axisymmetric_sweep", "")])
            self.capping = self.__class__.capping(service, rules, path + [("capping", "")])
            self.check_mesh = self.__class__.check_mesh(service, rules, path + [("check_mesh", "")])
            self.check_surface_quality = self.__class__.check_surface_quality(service, rules, path + [("check_surface_quality", "")])
            self.check_volume_quality = self.__class__.check_volume_quality(service, rules, path + [("check_volume_quality", "")])
            self.choose_mesh_control_options = self.__class__.choose_mesh_control_options(service, rules, path + [("choose_mesh_control_options", "")])
            self.close_leakage = self.__class__.close_leakage(service, rules, path + [("close_leakage", "")])
            self.compute_regions = self.__class__.compute_regions(service, rules, path + [("compute_regions", "")])
            self.compute_size_fields = self.__class__.compute_size_fields(service, rules, path + [("compute_size_fields", "")])
            self.create_collar_mesh = self.__class__.create_collar_mesh(service, rules, path + [("create_collar_mesh", "")])
            self.create_component_mesh = self.__class__.create_component_mesh(service, rules, path + [("create_component_mesh", "")])
            self.create_contact_patch = self.__class__.create_contact_patch(service, rules, path + [("create_contact_patch", "")])
            self.create_external_flow_boundaries = self.__class__.create_external_flow_boundaries(service, rules, path + [("create_external_flow_boundaries", "")])
            self.create_gap_cover = self.__class__.create_gap_cover(service, rules, path + [("create_gap_cover", "")])
            self.create_group = self.__class__.create_group(service, rules, path + [("create_group", "")])
            self.create_leak_shield = self.__class__.create_leak_shield(service, rules, path + [("create_leak_shield", "")])
            self.create_local_refinement_regions = self.__class__.create_local_refinement_regions(service, rules, path + [("create_local_refinement_regions", "")])
            self.create_mesh_objects = self.__class__.create_mesh_objects(service, rules, path + [("create_mesh_objects", "")])
            self.create_multizone_mesh = self.__class__.create_multizone_mesh(service, rules, path + [("create_multizone_mesh", "")])
            self.create_overset_mesh = self.__class__.create_overset_mesh(service, rules, path + [("create_overset_mesh", "")])
            self.create_porous_regions = self.__class__.create_porous_regions(service, rules, path + [("create_porous_regions", "")])
            self.create_regions = self.__class__.create_regions(service, rules, path + [("create_regions", "")])
            self.create_surface_mesh = self.__class__.create_surface_mesh(service, rules, path + [("create_surface_mesh", "")])
            self.create_volume_mesh_ftm = self.__class__.create_volume_mesh_ftm(service, rules, path + [("create_volume_mesh_ftm", "")])
            self.create_volume_mesh_wtm = self.__class__.create_volume_mesh_wtm(service, rules, path + [("create_volume_mesh_wtm", "")])
            self.create_zero_thickness_geometry = self.__class__.create_zero_thickness_geometry(service, rules, path + [("create_zero_thickness_geometry", "")])
            self.custom_journal_task = self.__class__.custom_journal_task(service, rules, path + [("custom_journal_task", "")])
            self.define_boundary_layer_controls = self.__class__.define_boundary_layer_controls(service, rules, path + [("define_boundary_layer_controls", "")])
            self.define_global_sizing = self.__class__.define_global_sizing(service, rules, path + [("define_global_sizing", "")])
            self.define_leakage_threshold = self.__class__.define_leakage_threshold(service, rules, path + [("define_leakage_threshold", "")])
            self.describe_geometry = self.__class__.describe_geometry(service, rules, path + [("describe_geometry", "")])
            self.describe_geometry_and_flow = self.__class__.describe_geometry_and_flow(service, rules, path + [("describe_geometry_and_flow", "")])
            self.describe_overset_features = self.__class__.describe_overset_features(service, rules, path + [("describe_overset_features", "")])
            self.extract_edge_features = self.__class__.extract_edge_features(service, rules, path + [("extract_edge_features", "")])
            self.extrude_volume_mesh = self.__class__.extrude_volume_mesh(service, rules, path + [("extrude_volume_mesh", "")])
            self.generate_initial_surface_mesh = self.__class__.generate_initial_surface_mesh(service, rules, path + [("generate_initial_surface_mesh", "")])
            self.generate_map_mesh = self.__class__.generate_map_mesh(service, rules, path + [("generate_map_mesh", "")])
            self.generate_prism_layers = self.__class__.generate_prism_layers(service, rules, path + [("generate_prism_layers", "")])
            self.generate_surface_mesh = self.__class__.generate_surface_mesh(service, rules, path + [("generate_surface_mesh", "")])
            self.generate_volume_mesh = self.__class__.generate_volume_mesh(service, rules, path + [("generate_volume_mesh", "")])
            self.identify_construction_surfaces = self.__class__.identify_construction_surfaces(service, rules, path + [("identify_construction_surfaces", "")])
            self.identify_deviated_faces = self.__class__.identify_deviated_faces(service, rules, path + [("identify_deviated_faces", "")])
            self.identify_orphans = self.__class__.identify_orphans(service, rules, path + [("identify_orphans", "")])
            self.identify_regions = self.__class__.identify_regions(service, rules, path + [("identify_regions", "")])
            self.import_boi_geometry = self.__class__.import_boi_geometry(service, rules, path + [("import_boi_geometry", "")])
            self.import_cad_and_part_management = self.__class__.import_cad_and_part_management(service, rules, path + [("import_cad_and_part_management", "")])
            self.import_geometry = self.__class__.import_geometry(service, rules, path + [("import_geometry", "")])
            self.improve_surface_mesh = self.__class__.improve_surface_mesh(service, rules, path + [("improve_surface_mesh", "")])
            self.improve_volume_mesh = self.__class__.improve_volume_mesh(service, rules, path + [("improve_volume_mesh", "")])
            self.load_cad_geometry = self.__class__.load_cad_geometry(service, rules, path + [("load_cad_geometry", "")])
            self.manage_zones_ftm = self.__class__.manage_zones_ftm(service, rules, path + [("manage_zones_ftm", "")])
            self.mesh_controls_table = self.__class__.mesh_controls_table(service, rules, path + [("mesh_controls_table", "")])
            self.modify_mesh_refinement = self.__class__.modify_mesh_refinement(service, rules, path + [("modify_mesh_refinement", "")])
            self.part_replacement_options = self.__class__.part_replacement_options(service, rules, path + [("part_replacement_options", "")])
            self.part_replacement_settings = self.__class__.part_replacement_settings(service, rules, path + [("part_replacement_settings", "")])
            self.prepare_for_volume_meshing = self.__class__.prepare_for_volume_meshing(service, rules, path + [("prepare_for_volume_meshing", "")])
            self.remesh_surface = self.__class__.remesh_surface(service, rules, path + [("remesh_surface", "")])
            self.separate_contacts = self.__class__.separate_contacts(service, rules, path + [("separate_contacts", "")])
            self.set_up_rotational_periodic_boundaries = self.__class__.set_up_rotational_periodic_boundaries(service, rules, path + [("set_up_rotational_periodic_boundaries", "")])
            self.setup_size_controls = self.__class__.setup_size_controls(service, rules, path + [("setup_size_controls", "")])
            self.switch_to_solution = self.__class__.switch_to_solution(service, rules, path + [("switch_to_solution", "")])
            self.transform_volume_mesh = self.__class__.transform_volume_mesh(service, rules, path + [("transform_volume_mesh", "")])
            self.update_boundaries = self.__class__.update_boundaries(service, rules, path + [("update_boundaries", "")])
            self.update_region_settings = self.__class__.update_region_settings(service, rules, path + [("update_region_settings", "")])
            self.update_regions = self.__class__.update_regions(service, rules, path + [("update_regions", "")])
            self.update_volume_mesh = self.__class__.update_volume_mesh(service, rules, path + [("update_volume_mesh", "")])
            self.wrap_main = self.__class__.wrap_main(service, rules, path + [("wrap_main", "")])
            self.write_2d_mesh = self.__class__.write_2d_mesh(service, rules, path + [("write_2d_mesh", "")])
            self.write_skin = self.__class__.write_skin(service, rules, path + [("write_skin", "")])
            super().__init__(service, rules, path)

        class add_2d_boundary_layers(PyNamedObjectContainer):
            """
            .
            """
            class _add_2d_boundary_layers(PyMenu):
                """
                Singleton _add_2d_boundary_layers.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.shell_bl_advanced_options = self.__class__.shell_bl_advanced_options(service, rules, path + [("shell_bl_advanced_options", "")])
                        self.add_child = self.__class__.add_child(service, rules, path + [("add_child", "")])
                        self.addin = self.__class__.addin(service, rules, path + [("addin", "")])
                        self.control_name = self.__class__.control_name(service, rules, path + [("control_name", "")])
                        self.edge_label_list = self.__class__.edge_label_list(service, rules, path + [("edge_label_list", "")])
                        self.edge_zone_list = self.__class__.edge_zone_list(service, rules, path + [("edge_zone_list", "")])
                        self.face_label_list = self.__class__.face_label_list(service, rules, path + [("face_label_list", "")])
                        self.first_aspect_ratio = self.__class__.first_aspect_ratio(service, rules, path + [("first_aspect_ratio", "")])
                        self.first_layer_height = self.__class__.first_layer_height(service, rules, path + [("first_layer_height", "")])
                        self.grow_on = self.__class__.grow_on(service, rules, path + [("grow_on", "")])
                        self.last_aspect_ratio = self.__class__.last_aspect_ratio(service, rules, path + [("last_aspect_ratio", "")])
                        self.max_layer_height = self.__class__.max_layer_height(service, rules, path + [("max_layer_height", "")])
                        self.number_of_layers = self.__class__.number_of_layers(service, rules, path + [("number_of_layers", "")])
                        self.offset_method_type = self.__class__.offset_method_type(service, rules, path + [("offset_method_type", "")])
                        self.rate = self.__class__.rate(service, rules, path + [("rate", "")])
                        self.transition_ratio = self.__class__.transition_ratio(service, rules, path + [("transition_ratio", "")])
                        super().__init__(service, rules, path)

                    class shell_bl_advanced_options(PyMenu):
                        """
                        Singleton shell_bl_advanced_options.
                        """
                        def __init__(self, service, rules, path):
                            self.adjacent_attach_angle = self.__class__.adjacent_attach_angle(service, rules, path + [("adjacent_attach_angle", "")])
                            self.expose_side = self.__class__.expose_side(service, rules, path + [("expose_side", "")])
                            self.gap_factor = self.__class__.gap_factor(service, rules, path + [("gap_factor", "")])
                            self.last_ratio_num_layers = self.__class__.last_ratio_num_layers(service, rules, path + [("last_ratio_num_layers", "")])
                            self.last_ratio_percentage = self.__class__.last_ratio_percentage(service, rules, path + [("last_ratio_percentage", "")])
                            self.max_aspect_ratio = self.__class__.max_aspect_ratio(service, rules, path + [("max_aspect_ratio", "")])
                            self.min_aspect_ratio = self.__class__.min_aspect_ratio(service, rules, path + [("min_aspect_ratio", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            super().__init__(service, rules, path)

                        class adjacent_attach_angle(PyNumerical):
                            """
                            Parameter adjacent_attach_angle of value type float.
                            """
                            pass

                        class expose_side(PyParameter):
                            """
                            Parameter expose_side of value type bool.
                            """
                            pass

                        class gap_factor(PyNumerical):
                            """
                            Parameter gap_factor of value type float.
                            """
                            pass

                        class last_ratio_num_layers(PyNumerical):
                            """
                            Parameter last_ratio_num_layers of value type int.
                            """
                            pass

                        class last_ratio_percentage(PyNumerical):
                            """
                            Parameter last_ratio_percentage of value type float.
                            """
                            pass

                        class max_aspect_ratio(PyNumerical):
                            """
                            Parameter max_aspect_ratio of value type float.
                            """
                            pass

                        class min_aspect_ratio(PyNumerical):
                            """
                            Parameter min_aspect_ratio of value type float.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Parameter show_in_gui of value type bool.
                            """
                            pass

                    class add_child(PyParameter):
                        """
                        Parameter add_child of value type bool.
                        """
                        pass

                    class addin(PyTextual):
                        """
                        Parameter addin of value type str.
                        """
                        pass

                    class control_name(PyTextual):
                        """
                        Parameter control_name of value type str.
                        """
                        pass

                    class edge_label_list(PyTextual):
                        """
                        Parameter edge_label_list of value type list[str].
                        """
                        pass

                    class edge_zone_list(PyTextual):
                        """
                        Parameter edge_zone_list of value type list[str].
                        """
                        pass

                    class face_label_list(PyTextual):
                        """
                        Parameter face_label_list of value type list[str].
                        """
                        pass

                    class first_aspect_ratio(PyNumerical):
                        """
                        Parameter first_aspect_ratio of value type float.
                        """
                        pass

                    class first_layer_height(PyNumerical):
                        """
                        Parameter first_layer_height of value type float.
                        """
                        pass

                    class grow_on(PyTextual):
                        """
                        Parameter grow_on of value type str.
                        """
                        pass

                    class last_aspect_ratio(PyNumerical):
                        """
                        Parameter last_aspect_ratio of value type float.
                        """
                        pass

                    class max_layer_height(PyNumerical):
                        """
                        Parameter max_layer_height of value type float.
                        """
                        pass

                    class number_of_layers(PyNumerical):
                        """
                        Parameter number_of_layers of value type int.
                        """
                        pass

                    class offset_method_type(PyTextual):
                        """
                        Parameter offset_method_type of value type str.
                        """
                        pass

                    class rate(PyNumerical):
                        """
                        Parameter rate of value type float.
                        """
                        pass

                    class transition_ratio(PyNumerical):
                        """
                        Parameter transition_ratio of value type float.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _add_2d_boundary_layers:
                return super().__getitem__(key)

        class add_boundary_layers(PyNamedObjectContainer):
            """
            .
            """
            class _add_boundary_layers(PyMenu):
                """
                Singleton _add_boundary_layers.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.face_scope = self.__class__.face_scope(service, rules, path + [("face_scope", "")])
                        self.local_prism_preferences = self.__class__.local_prism_preferences(service, rules, path + [("local_prism_preferences", "")])
                        self.add_child = self.__class__.add_child(service, rules, path + [("add_child", "")])
                        self.bl_label_list = self.__class__.bl_label_list(service, rules, path + [("bl_label_list", "")])
                        self.complete_bl_label_list = self.__class__.complete_bl_label_list(service, rules, path + [("complete_bl_label_list", "")])
                        self.complete_bl_region_list = self.__class__.complete_bl_region_list(service, rules, path + [("complete_bl_region_list", "")])
                        self.complete_bl_zone_list = self.__class__.complete_bl_zone_list(service, rules, path + [("complete_bl_zone_list", "")])
                        self.complete_label_selection_list = self.__class__.complete_label_selection_list(service, rules, path + [("complete_label_selection_list", "")])
                        self.complete_region_scope = self.__class__.complete_region_scope(service, rules, path + [("complete_region_scope", "")])
                        self.complete_zone_selection_list = self.__class__.complete_zone_selection_list(service, rules, path + [("complete_zone_selection_list", "")])
                        self.control_name = self.__class__.control_name(service, rules, path + [("control_name", "")])
                        self.first_aspect_ratio = self.__class__.first_aspect_ratio(service, rules, path + [("first_aspect_ratio", "")])
                        self.first_height = self.__class__.first_height(service, rules, path + [("first_height", "")])
                        self.invalid_added = self.__class__.invalid_added(service, rules, path + [("invalid_added", "")])
                        self.max_layer_height = self.__class__.max_layer_height(service, rules, path + [("max_layer_height", "")])
                        self.number_of_layers = self.__class__.number_of_layers(service, rules, path + [("number_of_layers", "")])
                        self.offset_method_type = self.__class__.offset_method_type(service, rules, path + [("offset_method_type", "")])
                        self.rate = self.__class__.rate(service, rules, path + [("rate", "")])
                        self.read_prism_control_file = self.__class__.read_prism_control_file(service, rules, path + [("read_prism_control_file", "")])
                        self.region_list = self.__class__.region_list(service, rules, path + [("region_list", "")])
                        self.region_scope = self.__class__.region_scope(service, rules, path + [("region_scope", "")])
                        self.transition_ratio = self.__class__.transition_ratio(service, rules, path + [("transition_ratio", "")])
                        self.zone_list = self.__class__.zone_list(service, rules, path + [("zone_list", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        self.zone_selection_list = self.__class__.zone_selection_list(service, rules, path + [("zone_selection_list", "")])
                        super().__init__(service, rules, path)

                    class face_scope(PyMenu):
                        """
                        Singleton face_scope.
                        """
                        def __init__(self, service, rules, path):
                            self.face_scope_mesh_object = self.__class__.face_scope_mesh_object(service, rules, path + [("face_scope_mesh_object", "")])
                            self.grow_on = self.__class__.grow_on(service, rules, path + [("grow_on", "")])
                            self.regions_type = self.__class__.regions_type(service, rules, path + [("regions_type", "")])
                            self.topology_list = self.__class__.topology_list(service, rules, path + [("topology_list", "")])
                            super().__init__(service, rules, path)

                        class face_scope_mesh_object(PyTextual):
                            """
                            Parameter face_scope_mesh_object of value type str.
                            """
                            pass

                        class grow_on(PyTextual):
                            """
                            Specify where you would like to develop the boundary layers: either along only walls, all zones, along solid-fluid interfaces, or specifically selected zones or labels.
                            """
                            pass

                        class regions_type(PyTextual):
                            """
                            Specify what regions you would like to add the boundary layers: solid regions, fluid regions, or specifically named regions.
                            """
                            pass

                        class topology_list(PyTextual):
                            """
                            Parameter topology_list of value type list[str].
                            """
                            pass

                    class local_prism_preferences(PyMenu):
                        """
                        Singleton local_prism_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.additional_ignored_layers = self.__class__.additional_ignored_layers(service, rules, path + [("additional_ignored_layers", "")])
                            self.allowed_tangency_at_invalid_normals = self.__class__.allowed_tangency_at_invalid_normals(service, rules, path + [("allowed_tangency_at_invalid_normals", "")])
                            self.continuous = self.__class__.continuous(service, rules, path + [("continuous", "")])
                            self.ignore_boundary_layers = self.__class__.ignore_boundary_layers(service, rules, path + [("ignore_boundary_layers", "")])
                            self.invalid_normal_method = self.__class__.invalid_normal_method(service, rules, path + [("invalid_normal_method", "")])
                            self.last_ratio = self.__class__.last_ratio(service, rules, path + [("last_ratio", "")])
                            self.last_ratio_num_layers = self.__class__.last_ratio_num_layers(service, rules, path + [("last_ratio_num_layers", "")])
                            self.modify_at_invalid_normals = self.__class__.modify_at_invalid_normals(service, rules, path + [("modify_at_invalid_normals", "")])
                            self.number_of_split_layers = self.__class__.number_of_split_layers(service, rules, path + [("number_of_split_layers", "")])
                            self.remesh_at_invalid_normals = self.__class__.remesh_at_invalid_normals(service, rules, path + [("remesh_at_invalid_normals", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            self.smooth_rings_at_invalid_normals = self.__class__.smooth_rings_at_invalid_normals(service, rules, path + [("smooth_rings_at_invalid_normals", "")])
                            self.sphere_radius_factor_at_invalid_normals = self.__class__.sphere_radius_factor_at_invalid_normals(service, rules, path + [("sphere_radius_factor_at_invalid_normals", "")])
                            self.split_prism = self.__class__.split_prism(service, rules, path + [("split_prism", "")])
                            super().__init__(service, rules, path)

                        class additional_ignored_layers(PyNumerical):
                            """
                            Indicate the number of buffer layers that can be placed around ignored boundary layer faces, extending the ignored regions around sharp angles. Increasing the value increases the number of faces for which the boundary layer will be ignored at acute angles.
                            """
                            pass

                        class allowed_tangency_at_invalid_normals(PyNumerical):
                            """
                            Controls the tangency of the invalid normal faces. An invalid normal location with all 90 degree angles has a tangency of 1. So, faces are still treated as an invalid normal even if the angle deviates slightly from 90 degrees (resulting in a tangency of 0.98).
                            """
                            pass

                        class continuous(PyTextual):
                            """
                            Specify how you would like to improve the generated boundary layer: as a continuous or stair-stepped boundary layer in the specified area(s).
                            """
                            pass

                        class ignore_boundary_layers(PyParameter):
                            """
                            Specify whether to automatically ignore boundary layers where there is an acute angle. Note that if there are sharp angles adjacent to other regions with boundary layers, some boundary layer removal may occur in those adjacent regions.
                            """
                            pass

                        class invalid_normal_method(PyTextual):
                            """
                            Parameter invalid_normal_method of value type str.
                            """
                            pass

                        class last_ratio(PyNumerical):
                            """
                            Parameter last_ratio of value type float.
                            """
                            pass

                        class last_ratio_num_layers(PyNumerical):
                            """
                            Parameter last_ratio_num_layers of value type int.
                            """
                            pass

                        class modify_at_invalid_normals(PyParameter):
                            """
                            Specify whether to automatically change the surface mesh where invalid normal faces are detected. To grow the boundary layer mesh in the proper direction (away from the boundary), normal vectors (valid) are required at the boundary face nodes of the surface mesh. More...
                            """
                            pass

                        class number_of_split_layers(PyNumerical):
                            """
                            Indicate the number of split prism layers you wish to apply to each layer that you specified for the boundary layer definition.
                            """
                            pass

                        class remesh_at_invalid_normals(PyParameter):
                            """
                            Specify whether or not to remesh around the area of the invalid normal(s). When enabled, a local (non-size function-based) remeshing procedure is performed to obtain similar sizes around the sphere with a reasonable transition to the surrounding mesh.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Display advanced options that you may want to apply to this task.
                            """
                            pass

                        class smooth_rings_at_invalid_normals(PyNumerical):
                            """
                            Parameter smooth_rings_at_invalid_normals of value type int.
                            """
                            pass

                        class sphere_radius_factor_at_invalid_normals(PyNumerical):
                            """
                            This factor is used to determine the size of the spheres created at the invalid normal location. The spheres have a radius of one half of the average mesh edge length adjacent to the invalid location. The default factor of 0.8 ensures a sphere size that is slightly smaller than that.
                            """
                            pass

                        class split_prism(PyParameter):
                            """
                            Choose whether or not to add split prisms to each layer along the boundary. Not available when the Offset Method Type is set to last-ratio.
                            """
                            pass

                    class add_child(PyTextual):
                        """
                        Determine whether (yes) or not (no) you want to specify one or more boundary layers for your simulation. If none are yet defined, you can choose yes, using prism control file and read in a prism control file that holds the boundary layer definition.
                        """
                        pass

                    class bl_label_list(PyTextual):
                        """
                        Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class complete_bl_label_list(PyTextual):
                        """
                        Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class complete_bl_region_list(PyTextual):
                        """
                        Parameter complete_bl_region_list of value type list[str].
                        """
                        pass

                    class complete_bl_zone_list(PyTextual):
                        """
                        Parameter complete_bl_zone_list of value type list[str].
                        """
                        pass

                    class complete_label_selection_list(PyTextual):
                        """
                        Parameter complete_label_selection_list of value type list[str].
                        """
                        pass

                    class complete_region_scope(PyTextual):
                        """
                        Select the named region(s) from the list to which you would like to add a boundary layer. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class complete_zone_selection_list(PyTextual):
                        """
                        Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class control_name(PyTextual):
                        """
                        Specify a name for the boundary layer control or use the default value.
                        """
                        pass

                    class first_aspect_ratio(PyNumerical):
                        """
                        Specify the aspect ratio of the first layer of prism cells that are extruded from the base boundary zone.
                        """
                        pass

                    class first_height(PyNumerical):
                        """
                        Specify the height of the first layer of cells in the boundary layer.
                        """
                        pass

                    class invalid_added(PyTextual):
                        """
                        Parameter invalid_added of value type str.
                        """
                        pass

                    class max_layer_height(PyNumerical):
                        """
                        Parameter max_layer_height of value type float.
                        """
                        pass

                    class number_of_layers(PyNumerical):
                        """
                        Select the number of boundary layers to be generated.
                        """
                        pass

                    class offset_method_type(PyTextual):
                        """
                        Choose the type of offset to determine how the mesh cells closest to the boundary are generated.  More...
                        """
                        pass

                    class rate(PyNumerical):
                        """
                        Specify the rate of growth for the boundary layer.
                        """
                        pass

                    class read_prism_control_file(PyTextual):
                        """
                        Specify (or browse for) a .pzmcontrol file that contains the boundary (prism) layer specifications.
                        """
                        pass

                    class region_list(PyTextual):
                        """
                        Parameter region_list of value type list[str].
                        """
                        pass

                    class region_scope(PyTextual):
                        """
                        Select the named region(s) from the list to which you would like to add a boundary layer. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class transition_ratio(PyNumerical):
                        """
                        For the smooth transition offset method, specify the rate at which adjacent elements grow. For the last-ratio offset method, specify the factor by which the thickness of each subsequent boundary layer increases or decreases compared to the previous layer.
                        """
                        pass

                    class zone_list(PyTextual):
                        """
                        Parameter zone_list of value type list[str].
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                    class zone_selection_list(PyTextual):
                        """
                        Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _add_boundary_layers:
                return super().__getitem__(key)

        class add_boundary_layers_for_part_replacement(PyNamedObjectContainer):
            """
            .
            """
            class _add_boundary_layers_for_part_replacement(PyMenu):
                """
                Singleton _add_boundary_layers_for_part_replacement.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.face_scope = self.__class__.face_scope(service, rules, path + [("face_scope", "")])
                        self.local_prism_preferences = self.__class__.local_prism_preferences(service, rules, path + [("local_prism_preferences", "")])
                        self.add_child = self.__class__.add_child(service, rules, path + [("add_child", "")])
                        self.bl_region_list = self.__class__.bl_region_list(service, rules, path + [("bl_region_list", "")])
                        self.bl_zone_list = self.__class__.bl_zone_list(service, rules, path + [("bl_zone_list", "")])
                        self.complete_bl_label_list = self.__class__.complete_bl_label_list(service, rules, path + [("complete_bl_label_list", "")])
                        self.complete_bl_region_list = self.__class__.complete_bl_region_list(service, rules, path + [("complete_bl_region_list", "")])
                        self.complete_bl_zone_list = self.__class__.complete_bl_zone_list(service, rules, path + [("complete_bl_zone_list", "")])
                        self.complete_label_selection_list = self.__class__.complete_label_selection_list(service, rules, path + [("complete_label_selection_list", "")])
                        self.complete_region_scope = self.__class__.complete_region_scope(service, rules, path + [("complete_region_scope", "")])
                        self.complete_zone_selection_list = self.__class__.complete_zone_selection_list(service, rules, path + [("complete_zone_selection_list", "")])
                        self.control_name = self.__class__.control_name(service, rules, path + [("control_name", "")])
                        self.first_aspect_ratio = self.__class__.first_aspect_ratio(service, rules, path + [("first_aspect_ratio", "")])
                        self.first_height = self.__class__.first_height(service, rules, path + [("first_height", "")])
                        self.label_list = self.__class__.label_list(service, rules, path + [("label_list", "")])
                        self.max_layer_height = self.__class__.max_layer_height(service, rules, path + [("max_layer_height", "")])
                        self.number_of_layers = self.__class__.number_of_layers(service, rules, path + [("number_of_layers", "")])
                        self.offset_method_type = self.__class__.offset_method_type(service, rules, path + [("offset_method_type", "")])
                        self.rate = self.__class__.rate(service, rules, path + [("rate", "")])
                        self.read_prism_control_file = self.__class__.read_prism_control_file(service, rules, path + [("read_prism_control_file", "")])
                        self.region_scope = self.__class__.region_scope(service, rules, path + [("region_scope", "")])
                        self.transition_ratio = self.__class__.transition_ratio(service, rules, path + [("transition_ratio", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        self.zone_selection_list = self.__class__.zone_selection_list(service, rules, path + [("zone_selection_list", "")])
                        super().__init__(service, rules, path)

                    class face_scope(PyMenu):
                        """
                        Singleton face_scope.
                        """
                        def __init__(self, service, rules, path):
                            self.face_scope_mesh_object = self.__class__.face_scope_mesh_object(service, rules, path + [("face_scope_mesh_object", "")])
                            self.grow_on = self.__class__.grow_on(service, rules, path + [("grow_on", "")])
                            self.regions_type = self.__class__.regions_type(service, rules, path + [("regions_type", "")])
                            self.topology_list = self.__class__.topology_list(service, rules, path + [("topology_list", "")])
                            super().__init__(service, rules, path)

                        class face_scope_mesh_object(PyTextual):
                            """
                            Parameter face_scope_mesh_object of value type str.
                            """
                            pass

                        class grow_on(PyTextual):
                            """
                            Specify where you would like to develop the boundary layers: either along only walls, all zones, along solid-fluid interfaces, or specifically selected zones or labels.
                            """
                            pass

                        class regions_type(PyTextual):
                            """
                            Specify what regions you would like to add the boundary layers: solid regions, fluid regions, or specifically named regions.
                            """
                            pass

                        class topology_list(PyTextual):
                            """
                            Parameter topology_list of value type list[str].
                            """
                            pass

                    class local_prism_preferences(PyMenu):
                        """
                        Singleton local_prism_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.additional_ignored_layers = self.__class__.additional_ignored_layers(service, rules, path + [("additional_ignored_layers", "")])
                            self.allowed_tangency_at_invalid_normals = self.__class__.allowed_tangency_at_invalid_normals(service, rules, path + [("allowed_tangency_at_invalid_normals", "")])
                            self.continuous = self.__class__.continuous(service, rules, path + [("continuous", "")])
                            self.ignore_boundary_layers = self.__class__.ignore_boundary_layers(service, rules, path + [("ignore_boundary_layers", "")])
                            self.invalid_normal_method = self.__class__.invalid_normal_method(service, rules, path + [("invalid_normal_method", "")])
                            self.last_ratio = self.__class__.last_ratio(service, rules, path + [("last_ratio", "")])
                            self.last_ratio_num_layers = self.__class__.last_ratio_num_layers(service, rules, path + [("last_ratio_num_layers", "")])
                            self.modify_at_invalid_normals = self.__class__.modify_at_invalid_normals(service, rules, path + [("modify_at_invalid_normals", "")])
                            self.number_of_split_layers = self.__class__.number_of_split_layers(service, rules, path + [("number_of_split_layers", "")])
                            self.remesh_at_invalid_normals = self.__class__.remesh_at_invalid_normals(service, rules, path + [("remesh_at_invalid_normals", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            self.smooth_rings_at_invalid_normals = self.__class__.smooth_rings_at_invalid_normals(service, rules, path + [("smooth_rings_at_invalid_normals", "")])
                            self.sphere_radius_factor_at_invalid_normals = self.__class__.sphere_radius_factor_at_invalid_normals(service, rules, path + [("sphere_radius_factor_at_invalid_normals", "")])
                            self.split_prism = self.__class__.split_prism(service, rules, path + [("split_prism", "")])
                            super().__init__(service, rules, path)

                        class additional_ignored_layers(PyNumerical):
                            """
                            Indicate the number of buffer layers that can be placed around ignored boundary layer faces, extending the ignored regions around sharp angles. Increasing the value increases the number of faces for which the boundary layer will be ignored at acute angles.
                            """
                            pass

                        class allowed_tangency_at_invalid_normals(PyNumerical):
                            """
                            Controls the tangency of the invalid normal faces. An invalid normal location with all 90 degree angles has a tangency of 1. So, faces are still treated as an invalid normal even if the angle deviates slightly from 90 degrees (resulting in a tangency of 0.98).
                            """
                            pass

                        class continuous(PyTextual):
                            """
                            Specify how you would like to improve the generated boundary layer: as a continuous or stair-stepped boundary layer in the specified area(s).
                            """
                            pass

                        class ignore_boundary_layers(PyParameter):
                            """
                            Specify whether to automatically ignore boundary layers where there is an acute angle. Note that if there are sharp angles adjacent to other regions with boundary layers, some boundary layer removal may occur in those adjacent regions.
                            """
                            pass

                        class invalid_normal_method(PyTextual):
                            """
                            Parameter invalid_normal_method of value type str.
                            """
                            pass

                        class last_ratio(PyNumerical):
                            """
                            Parameter last_ratio of value type float.
                            """
                            pass

                        class last_ratio_num_layers(PyNumerical):
                            """
                            Parameter last_ratio_num_layers of value type int.
                            """
                            pass

                        class modify_at_invalid_normals(PyParameter):
                            """
                            Specify whether to automatically change the surface mesh where invalid normal faces are detected. To grow the boundary layer mesh in the proper direction (away from the boundary), normal vectors (valid) are required at the boundary face nodes of the surface mesh. More...
                            """
                            pass

                        class number_of_split_layers(PyNumerical):
                            """
                            Indicate the number of split prism layers you wish to apply to each layer that you specified for the boundary layer definition.
                            """
                            pass

                        class remesh_at_invalid_normals(PyParameter):
                            """
                            Specify whether or not to remesh around the area of the invalid normal(s). When enabled, a local (non-size function-based) remeshing procedure is performed to obtain similar sizes around the sphere with a reasonable transition to the surrounding mesh.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Display advanced options that you may want to apply to this task.
                            """
                            pass

                        class smooth_rings_at_invalid_normals(PyNumerical):
                            """
                            Parameter smooth_rings_at_invalid_normals of value type int.
                            """
                            pass

                        class sphere_radius_factor_at_invalid_normals(PyNumerical):
                            """
                            This factor is used to determine the size of the spheres created at the invalid normal location. The spheres have a radius of one half of the average mesh edge length adjacent to the invalid location. The default factor of 0.8 ensures a sphere size that is slightly smaller than that.
                            """
                            pass

                        class split_prism(PyParameter):
                            """
                            Choose whether or not to add split prisms to each layer along the boundary. Not available when the Offset Method Type is set to last-ratio.
                            """
                            pass

                    class add_child(PyTextual):
                        """
                        Determine whether (yes) or not (no) you want to specify one or more boundary layers for your simulation. If none are yet defined, you can choose yes, using prism control file and read in a prism control file that holds the boundary layer definition.
                        """
                        pass

                    class bl_region_list(PyTextual):
                        """
                        Parameter bl_region_list of value type list[str].
                        """
                        pass

                    class bl_zone_list(PyTextual):
                        """
                        Parameter bl_zone_list of value type list[str].
                        """
                        pass

                    class complete_bl_label_list(PyTextual):
                        """
                        Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class complete_bl_region_list(PyTextual):
                        """
                        Parameter complete_bl_region_list of value type list[str].
                        """
                        pass

                    class complete_bl_zone_list(PyTextual):
                        """
                        Parameter complete_bl_zone_list of value type list[str].
                        """
                        pass

                    class complete_label_selection_list(PyTextual):
                        """
                        Parameter complete_label_selection_list of value type list[str].
                        """
                        pass

                    class complete_region_scope(PyTextual):
                        """
                        Select the named region(s) from the list to which you would like to add a boundary layer. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class complete_zone_selection_list(PyTextual):
                        """
                        Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class control_name(PyTextual):
                        """
                        Specify a name for the boundary layer control or use the default value.
                        """
                        pass

                    class first_aspect_ratio(PyNumerical):
                        """
                        Specify the aspect ratio of the first layer of prism cells that are extruded from the base boundary zone.
                        """
                        pass

                    class first_height(PyNumerical):
                        """
                        Specify the height of the first layer of cells in the boundary layer.
                        """
                        pass

                    class label_list(PyTextual):
                        """
                        Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class max_layer_height(PyNumerical):
                        """
                        Parameter max_layer_height of value type float.
                        """
                        pass

                    class number_of_layers(PyNumerical):
                        """
                        Select the number of boundary layers to be generated.
                        """
                        pass

                    class offset_method_type(PyTextual):
                        """
                        Choose the type of offset to determine how the mesh cells closest to the boundary are generated.  More...
                        """
                        pass

                    class rate(PyNumerical):
                        """
                        Specify the rate of growth for the boundary layer.
                        """
                        pass

                    class read_prism_control_file(PyTextual):
                        """
                        Specify (or browse for) a .pzmcontrol file that contains the boundary (prism) layer specifications.
                        """
                        pass

                    class region_scope(PyTextual):
                        """
                        Select the named region(s) from the list to which you would like to add a boundary layer. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class transition_ratio(PyNumerical):
                        """
                        For the smooth transition offset method, specify the rate at which adjacent elements grow. For the last-ratio offset method, specify the factor by which the thickness of each subsequent boundary layer increases or decreases compared to the previous layer.
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                    class zone_selection_list(PyTextual):
                        """
                        Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _add_boundary_layers_for_part_replacement:
                return super().__getitem__(key)

        class add_boundary_type(PyNamedObjectContainer):
            """
            .
            """
            class _add_boundary_type(PyMenu):
                """
                Singleton _add_boundary_type.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.boundary_face_zone_list = self.__class__.boundary_face_zone_list(service, rules, path + [("boundary_face_zone_list", "")])
                        self.merge = self.__class__.merge(service, rules, path + [("merge", "")])
                        self.mesh_object = self.__class__.mesh_object(service, rules, path + [("mesh_object", "")])
                        self.new_boundary_label_name = self.__class__.new_boundary_label_name(service, rules, path + [("new_boundary_label_name", "")])
                        self.new_boundary_type = self.__class__.new_boundary_type(service, rules, path + [("new_boundary_type", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.topology_list = self.__class__.topology_list(service, rules, path + [("topology_list", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        super().__init__(service, rules, path)

                    class boundary_face_zone_list(PyTextual):
                        """
                        Enter a text string to filter out the list of zones. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class merge(PyParameter):
                        """
                        Determine whether or not to merge the selected zones (set to yes by default).
                        """
                        pass

                    class mesh_object(PyTextual):
                        """
                        Parameter mesh_object of value type str.
                        """
                        pass

                    class new_boundary_label_name(PyTextual):
                        """
                        Specify a name for the boundary type.
                        """
                        pass

                    class new_boundary_type(PyTextual):
                        """
                        Choose a boundary type from the available options.
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Parameter selection_type of value type str.
                        """
                        pass

                    class topology_list(PyTextual):
                        """
                        Parameter topology_list of value type list[str].
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _add_boundary_type:
                return super().__getitem__(key)

        class add_linear_mesh_pattern(PyNamedObjectContainer):
            """
            .
            """
            class _add_linear_mesh_pattern(PyMenu):
                """
                Singleton _add_linear_mesh_pattern.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.axis_direction = self.__class__.axis_direction(service, rules, path + [("axis_direction", "")])
                        self.battery_modeling_options = self.__class__.battery_modeling_options(service, rules, path + [("battery_modeling_options", "")])
                        self.auto_populate_vector = self.__class__.auto_populate_vector(service, rules, path + [("auto_populate_vector", "")])
                        self.check_overlapping_faces = self.__class__.check_overlapping_faces(service, rules, path + [("check_overlapping_faces", "")])
                        self.child_name = self.__class__.child_name(service, rules, path + [("child_name", "")])
                        self.number_of_units = self.__class__.number_of_units(service, rules, path + [("number_of_units", "")])
                        self.object_list = self.__class__.object_list(service, rules, path + [("object_list", "")])
                        self.pitch = self.__class__.pitch(service, rules, path + [("pitch", "")])
                        super().__init__(service, rules, path)

                    class axis_direction(PyMenu):
                        """
                        Specify a name for the mesh pattern or use the default value.
                        """
                        def __init__(self, service, rules, path):
                            self.x = self.__class__.x(service, rules, path + [("x", "")])
                            self.y = self.__class__.y(service, rules, path + [("y", "")])
                            self.z = self.__class__.z(service, rules, path + [("z", "")])
                            super().__init__(service, rules, path)

                        class x(PyNumerical):
                            """
                            Specify the X component of the axis orientation/direction.
                            """
                            pass

                        class y(PyNumerical):
                            """
                            Specify the Y component of the axis orientation/direction.
                            """
                            pass

                        class z(PyNumerical):
                            """
                            Specify the Z component of the axis orientation/direction.
                            """
                            pass

                    class battery_modeling_options(PyMenu):
                        """
                        Singleton battery_modeling_options.
                        """
                        def __init__(self, service, rules, path):
                            self.custom_pattern_string = self.__class__.custom_pattern_string(service, rules, path + [("custom_pattern_string", "")])
                            self.first_number = self.__class__.first_number(service, rules, path + [("first_number", "")])
                            self.invoke_battery_modeling_options = self.__class__.invoke_battery_modeling_options(service, rules, path + [("invoke_battery_modeling_options", "")])
                            self.nb_cells_per_unit = self.__class__.nb_cells_per_unit(service, rules, path + [("nb_cells_per_unit", "")])
                            self.use_custom_pattern = self.__class__.use_custom_pattern(service, rules, path + [("use_custom_pattern", "")])
                            super().__init__(service, rules, path)

                        class custom_pattern_string(PyTextual):
                            """
                            Parameter custom_pattern_string of value type str.
                            """
                            pass

                        class first_number(PyNumerical):
                            """
                            Specify the numerical value that will be appended to the name of the first unit associated with the meshing pattern object. This value also dictates the labeling for mesh objects associated with this mesh pattern.  More...
                            """
                            pass

                        class invoke_battery_modeling_options(PyParameter):
                            """
                            Specify whether or not you are interested in creating a pattern based on custom numbering/labeling and setting dual unit labeling options (often useful in battery modeling).   More...
                            """
                            pass

                        class nb_cells_per_unit(PyNumerical):
                            """
                            Specify the numerical value that will be appended to the name of the first unit associated with the meshing pattern object. This value also dictates the labeling for mesh objects associated with this mesh pattern.   More...
                            """
                            pass

                        class use_custom_pattern(PyParameter):
                            """
                            Indicate whether or not you want to create a customized pattern based on your own specifications. Enter the pattern specification in the field below.  More...
                            """
                            pass

                    class auto_populate_vector(PyTextual):
                        """
                        Indicate whether or not you want Fluent to approximate both the axes orientation and the pitch value, or whether you want to estimate the Pitch Only (default). This estimation only takes place once, either when the object is selected, or when the option is changed.
                        """
                        pass

                    class check_overlapping_faces(PyParameter):
                        """
                        Graphically highlights the mesh pattern units so that you can visualize them and make sure they are properly aligned. Misaligned units can cause a failure in the share topology of the battery cells.
                        """
                        pass

                    class child_name(PyTextual):
                        """
                        Specify a name for the mesh pattern or use the default value.
                        """
                        pass

                    class number_of_units(PyNumerical):
                        """
                        Indicate the overall number of instances that the pattern will use.
                        """
                        pass

                    class object_list(PyTextual):
                        """
                        Select one or more parts from the list below that you want to use for creating the mesh pattern. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class pitch(PyNumerical):
                        """
                        Specify a value for the pitch, or displacement factor, or use the default value.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _add_linear_mesh_pattern:
                return super().__getitem__(key)

        class add_local_sizing_wtm(PyNamedObjectContainer):
            """
            .
            """
            class _add_local_sizing_wtm(PyMenu):
                """
                Singleton _add_local_sizing_wtm.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.add_child = self.__class__.add_child(service, rules, path + [("add_child", "")])
                        self.assign_size_using = self.__class__.assign_size_using(service, rules, path + [("assign_size_using", "")])
                        self.bias_factor = self.__class__.bias_factor(service, rules, path + [("bias_factor", "")])
                        self.boi_cells_per_gap = self.__class__.boi_cells_per_gap(service, rules, path + [("boi_cells_per_gap", "")])
                        self.boi_control_name = self.__class__.boi_control_name(service, rules, path + [("boi_control_name", "")])
                        self.boi_curvature_normal_angle = self.__class__.boi_curvature_normal_angle(service, rules, path + [("boi_curvature_normal_angle", "")])
                        self.boi_execution = self.__class__.boi_execution(service, rules, path + [("boi_execution", "")])
                        self.boi_face_label_list = self.__class__.boi_face_label_list(service, rules, path + [("boi_face_label_list", "")])
                        self.boi_face_zone_list = self.__class__.boi_face_zone_list(service, rules, path + [("boi_face_zone_list", "")])
                        self.boi_growth_rate = self.__class__.boi_growth_rate(service, rules, path + [("boi_growth_rate", "")])
                        self.boi_max_size = self.__class__.boi_max_size(service, rules, path + [("boi_max_size", "")])
                        self.boi_min_size = self.__class__.boi_min_size(service, rules, path + [("boi_min_size", "")])
                        self.boi_patchingtoggle = self.__class__.boi_patchingtoggle(service, rules, path + [("boi_patchingtoggle", "")])
                        self.boi_scope_to = self.__class__.boi_scope_to(service, rules, path + [("boi_scope_to", "")])
                        self.boi_size = self.__class__.boi_size(service, rules, path + [("boi_size", "")])
                        self.boi_zoneor_label = self.__class__.boi_zoneor_label(service, rules, path + [("boi_zoneor_label", "")])
                        self.complete_edge_label_list = self.__class__.complete_edge_label_list(service, rules, path + [("complete_edge_label_list", "")])
                        self.complete_face_label_list = self.__class__.complete_face_label_list(service, rules, path + [("complete_face_label_list", "")])
                        self.complete_face_zone_list = self.__class__.complete_face_zone_list(service, rules, path + [("complete_face_zone_list", "")])
                        self.complete_topology_list = self.__class__.complete_topology_list(service, rules, path + [("complete_topology_list", "")])
                        self.draw_size_control = self.__class__.draw_size_control(service, rules, path + [("draw_size_control", "")])
                        self.edge_label_list = self.__class__.edge_label_list(service, rules, path + [("edge_label_list", "")])
                        self.edge_zone_list = self.__class__.edge_zone_list(service, rules, path + [("edge_zone_list", "")])
                        self.growth_method = self.__class__.growth_method(service, rules, path + [("growth_method", "")])
                        self.growth_pattern = self.__class__.growth_pattern(service, rules, path + [("growth_pattern", "")])
                        self.ignore_orientation = self.__class__.ignore_orientation(service, rules, path + [("ignore_orientation", "")])
                        self.ignore_proximity_across_objects = self.__class__.ignore_proximity_across_objects(service, rules, path + [("ignore_proximity_across_objects", "")])
                        self.numberof_layers = self.__class__.numberof_layers(service, rules, path + [("numberof_layers", "")])
                        self.prime_size_control_id = self.__class__.prime_size_control_id(service, rules, path + [("prime_size_control_id", "")])
                        self.reverse_edge_zone_list = self.__class__.reverse_edge_zone_list(service, rules, path + [("reverse_edge_zone_list", "")])
                        self.reverse_edge_zone_orientation = self.__class__.reverse_edge_zone_orientation(service, rules, path + [("reverse_edge_zone_orientation", "")])
                        self.smallest_height = self.__class__.smallest_height(service, rules, path + [("smallest_height", "")])
                        self.topology_list = self.__class__.topology_list(service, rules, path + [("topology_list", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        super().__init__(service, rules, path)

                    class add_child(PyParameter):
                        """
                        Choose whether or not you want to add local size controls in order to create the surface mesh.
                        """
                        pass

                    class assign_size_using(PyTextual):
                        """
                        Parameter assign_size_using of value type str.
                        """
                        pass

                    class bias_factor(PyNumerical):
                        """
                        Parameter bias_factor of value type float.
                        """
                        pass

                    class boi_cells_per_gap(PyNumerical):
                        """
                        Specify the minimum number of layers of elements to be generated in the gaps. The number of cells per gap can be a real value, with a minimum value of 0.01.
                        """
                        pass

                    class boi_control_name(PyTextual):
                        """
                        Provide a name for this specific size control.
                        """
                        pass

                    class boi_curvature_normal_angle(PyNumerical):
                        """
                        Specify the maximum allowable angle (from 0 to 180 degrees) that one element edge is allowed to span given a particular geometry curvature. You can use this field to limit the number of elements that are generated along a curve or surface if the minimum size is too small for that particular curve.
                        """
                        pass

                    class boi_execution(PyTextual):
                        """
                        Choose whether the size control is to be applied to a local edge size, a local face size, a local body size, a body of influence, a face of influence, curvature, or proximity.
                        """
                        pass

                    class boi_face_label_list(PyTextual):
                        """
                        Choose one or more face zone labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class boi_face_zone_list(PyTextual):
                        """
                        Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class boi_growth_rate(PyNumerical):
                        """
                        Specify the increase in element edge length with each succeeding layer of elements.
                        """
                        pass

                    class boi_max_size(PyNumerical):
                        """
                        Specify the maximum size of the elements for the surface mesh.
                        """
                        pass

                    class boi_min_size(PyNumerical):
                        """
                        Specify the minimum size of the elements for the surface mesh.
                        """
                        pass

                    class boi_patchingtoggle(PyParameter):
                        """
                        Enable this option to repair any openings that may still exist in the body of influence-based local sizing control.
                        """
                        pass

                    class boi_scope_to(PyTextual):
                        """
                        Set curvature or proximity based refinement. The edges option considers edge-to-edge proximity, while faces considers face-to-face proximity, and faces and edges considers both. The edge labels option considers edge sizing based on edge labels. Note that when you use the edges or the faces and edges options, you can only select face zones or face labels. Also, saving a size control file after using either of these two options will not be persistent.
                        """
                        pass

                    class boi_size(PyNumerical):
                        """
                        Specify a value for the desired size of the local sizing (or body/face of influence) to be applied to the indicated label(s) or zone(s).
                        """
                        pass

                    class boi_zoneor_label(PyTextual):
                        """
                        Choose how you want to select your surface (by label or by zone).
                        """
                        pass

                    class complete_edge_label_list(PyTextual):
                        """
                        Parameter complete_edge_label_list of value type list[str].
                        """
                        pass

                    class complete_face_label_list(PyTextual):
                        """
                        Parameter complete_face_label_list of value type list[str].
                        """
                        pass

                    class complete_face_zone_list(PyTextual):
                        """
                        Parameter complete_face_zone_list of value type list[str].
                        """
                        pass

                    class complete_topology_list(PyTextual):
                        """
                        Parameter complete_topology_list of value type list[str].
                        """
                        pass

                    class draw_size_control(PyParameter):
                        """
                        Enable this field to display the size boxes in the graphics window.
                        """
                        pass

                    class edge_label_list(PyTextual):
                        """
                        Parameter edge_label_list of value type list[str].
                        """
                        pass

                    class edge_zone_list(PyTextual):
                        """
                        Parameter edge_zone_list of value type list[str].
                        """
                        pass

                    class growth_method(PyTextual):
                        """
                        Parameter growth_method of value type str.
                        """
                        pass

                    class growth_pattern(PyTextual):
                        """
                        Parameter growth_pattern of value type str.
                        """
                        pass

                    class ignore_orientation(PyParameter):
                        """
                        Specify whether or not you need to apply additional refinement in and around thin areas (such as between plates), without over-refinement. This ignores face proximity within voids and will not allow you to refine in thin voids, but will allow refinement in gaps. This should be used in predominantly fluid regions with no thin solid regions.
                        """
                        pass

                    class ignore_proximity_across_objects(PyParameter):
                        """
                        Enable to prevent proximity sizing from considering gaps to other separate objects, which can reduce over-refinement between distinct parts.
                        """
                        pass

                    class numberof_layers(PyNumerical):
                        """
                        Parameter numberof_layers of value type int.
                        """
                        pass

                    class prime_size_control_id(PyNumerical):
                        """
                        Parameter prime_size_control_id of value type int.
                        """
                        pass

                    class reverse_edge_zone_list(PyTextual):
                        """
                        Parameter reverse_edge_zone_list of value type list[str].
                        """
                        pass

                    class reverse_edge_zone_orientation(PyParameter):
                        """
                        Parameter reverse_edge_zone_orientation of value type bool.
                        """
                        pass

                    class smallest_height(PyNumerical):
                        """
                        Parameter smallest_height of value type float.
                        """
                        pass

                    class topology_list(PyTextual):
                        """
                        Parameter topology_list of value type list[str].
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _add_local_sizing_wtm:
                return super().__getitem__(key)

        class add_multizone_controls(PyNamedObjectContainer):
            """
            .
            """
            class _add_multizone_controls(PyMenu):
                """
                Singleton _add_multizone_controls.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.cfd_surface_mesh_controls = self.__class__.cfd_surface_mesh_controls(service, rules, path + [("cfd_surface_mesh_controls", "")])
                        self.assign_size_using = self.__class__.assign_size_using(service, rules, path + [("assign_size_using", "")])
                        self.bias_factor = self.__class__.bias_factor(service, rules, path + [("bias_factor", "")])
                        self.bias_method = self.__class__.bias_method(service, rules, path + [("bias_method", "")])
                        self.complete_edge_scope = self.__class__.complete_edge_scope(service, rules, path + [("complete_edge_scope", "")])
                        self.complete_region_scope = self.__class__.complete_region_scope(service, rules, path + [("complete_region_scope", "")])
                        self.control_type = self.__class__.control_type(service, rules, path + [("control_type", "")])
                        self.edge_label_list = self.__class__.edge_label_list(service, rules, path + [("edge_label_list", "")])
                        self.edge_label_selection = self.__class__.edge_label_selection(service, rules, path + [("edge_label_selection", "")])
                        self.fill_with = self.__class__.fill_with(service, rules, path + [("fill_with", "")])
                        self.growth_method = self.__class__.growth_method(service, rules, path + [("growth_method", "")])
                        self.growth_rate = self.__class__.growth_rate(service, rules, path + [("growth_rate", "")])
                        self.intervals = self.__class__.intervals(service, rules, path + [("intervals", "")])
                        self.label_source_list = self.__class__.label_source_list(service, rules, path + [("label_source_list", "")])
                        self.max_sweep_size = self.__class__.max_sweep_size(service, rules, path + [("max_sweep_size", "")])
                        self.mesh_method = self.__class__.mesh_method(service, rules, path + [("mesh_method", "")])
                        self.multi_z_name = self.__class__.multi_z_name(service, rules, path + [("multi_z_name", "")])
                        self.parallel_selection = self.__class__.parallel_selection(service, rules, path + [("parallel_selection", "")])
                        self.region_scope = self.__class__.region_scope(service, rules, path + [("region_scope", "")])
                        self.show_edge_biasing = self.__class__.show_edge_biasing(service, rules, path + [("show_edge_biasing", "")])
                        self.size = self.__class__.size(service, rules, path + [("size", "")])
                        self.smallest_height = self.__class__.smallest_height(service, rules, path + [("smallest_height", "")])
                        self.source_method = self.__class__.source_method(service, rules, path + [("source_method", "")])
                        self.topo_source_list = self.__class__.topo_source_list(service, rules, path + [("topo_source_list", "")])
                        self.use_sweep_size = self.__class__.use_sweep_size(service, rules, path + [("use_sweep_size", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        self.zone_source_list = self.__class__.zone_source_list(service, rules, path + [("zone_source_list", "")])
                        super().__init__(service, rules, path)

                    class cfd_surface_mesh_controls(PyMenu):
                        """
                        Singleton cfd_surface_mesh_controls.
                        """
                        def __init__(self, service, rules, path):
                            self.auto_create_scoped_sizing = self.__class__.auto_create_scoped_sizing(service, rules, path + [("auto_create_scoped_sizing", "")])
                            self.cells_per_gap = self.__class__.cells_per_gap(service, rules, path + [("cells_per_gap", "")])
                            self.curvature_normal_angle = self.__class__.curvature_normal_angle(service, rules, path + [("curvature_normal_angle", "")])
                            self.draw_size_control = self.__class__.draw_size_control(service, rules, path + [("draw_size_control", "")])
                            self.growth_rate = self.__class__.growth_rate(service, rules, path + [("growth_rate", "")])
                            self.max_size = self.__class__.max_size(service, rules, path + [("max_size", "")])
                            self.min_size = self.__class__.min_size(service, rules, path + [("min_size", "")])
                            self.object_based_controls = self.__class__.object_based_controls(service, rules, path + [("object_based_controls", "")])
                            self.preview_sizefield = self.__class__.preview_sizefield(service, rules, path + [("preview_sizefield", "")])
                            self.refacet = self.__class__.refacet(service, rules, path + [("refacet", "")])
                            self.remesh_imported_mesh = self.__class__.remesh_imported_mesh(service, rules, path + [("remesh_imported_mesh", "")])
                            self.save_size_field = self.__class__.save_size_field(service, rules, path + [("save_size_field", "")])
                            self.save_size_field_file = self.__class__.save_size_field_file(service, rules, path + [("save_size_field_file", "")])
                            self.scope_proximity_to = self.__class__.scope_proximity_to(service, rules, path + [("scope_proximity_to", "")])
                            self.size_control_file = self.__class__.size_control_file(service, rules, path + [("size_control_file", "")])
                            self.size_field_file = self.__class__.size_field_file(service, rules, path + [("size_field_file", "")])
                            self.size_functions = self.__class__.size_functions(service, rules, path + [("size_functions", "")])
                            self.surface_mesh_method = self.__class__.surface_mesh_method(service, rules, path + [("surface_mesh_method", "")])
                            self.use_size_files = self.__class__.use_size_files(service, rules, path + [("use_size_files", "")])
                            super().__init__(service, rules, path)

                        class auto_create_scoped_sizing(PyParameter):
                            """
                            Parameter auto_create_scoped_sizing of value type bool.
                            """
                            pass

                        class cells_per_gap(PyNumerical):
                            """
                            Parameter cells_per_gap of value type float.
                            """
                            pass

                        class curvature_normal_angle(PyNumerical):
                            """
                            Parameter curvature_normal_angle of value type float.
                            """
                            pass

                        class draw_size_control(PyParameter):
                            """
                            Parameter draw_size_control of value type bool.
                            """
                            pass

                        class growth_rate(PyNumerical):
                            """
                            Specify a value for the growth rate for the multizone, or use the default value.
                            """
                            pass

                        class max_size(PyNumerical):
                            """
                            Specify the minimum size for the edge-based multizone control.
                            """
                            pass

                        class min_size(PyNumerical):
                            """
                            Specify the minimum size for the edge-based multizone control.
                            """
                            pass

                        class object_based_controls(PyParameter):
                            """
                            Parameter object_based_controls of value type bool.
                            """
                            pass

                        class preview_sizefield(PyParameter):
                            """
                            Parameter preview_sizefield of value type bool.
                            """
                            pass

                        class refacet(PyParameter):
                            """
                            Parameter refacet of value type bool.
                            """
                            pass

                        class remesh_imported_mesh(PyTextual):
                            """
                            Parameter remesh_imported_mesh of value type str.
                            """
                            pass

                        class save_size_field(PyParameter):
                            """
                            Parameter save_size_field of value type bool.
                            """
                            pass

                        class save_size_field_file(PyTextual):
                            """
                            Parameter save_size_field_file of value type str.
                            """
                            pass

                        class scope_proximity_to(PyTextual):
                            """
                            Parameter scope_proximity_to of value type str.
                            """
                            pass

                        class size_control_file(PyTextual):
                            """
                            Parameter size_control_file of value type str.
                            """
                            pass

                        class size_field_file(PyTextual):
                            """
                            Parameter size_field_file of value type str.
                            """
                            pass

                        class size_functions(PyTextual):
                            """
                            Parameter size_functions of value type str.
                            """
                            pass

                        class surface_mesh_method(PyTextual):
                            """
                            Choose a multi-zone meshing technique: Standard or the Thin volume technique (for only a single layer)
                            """
                            pass

                        class use_size_files(PyTextual):
                            """
                            Parameter use_size_files of value type str.
                            """
                            pass

                    class assign_size_using(PyTextual):
                        """
                        For edge-based multizone controls, you can choose from Interval, Size, or Smallest Height. If double graded biasing is used and the Interval is set to an odd number (or the Size or Smallest Height results in an odd number Interval), the interval will automatically be increased by one.
                        """
                        pass

                    class bias_factor(PyNumerical):
                        """
                        Specify a value for the bias factor for the multizone, or use the default value. The Bias Factor is the ratio of the largest to the smallest segment on the edge.
                        """
                        pass

                    class bias_method(PyTextual):
                        """
                        Select from a choice of patterns that you want to apply to your edge-based multizone control.
                        """
                        pass

                    class complete_edge_scope(PyTextual):
                        """
                        Parameter complete_edge_scope of value type list[str].
                        """
                        pass

                    class complete_region_scope(PyTextual):
                        """
                        Select the named region(s) from the list to which you would like to create the multi-zone control. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class control_type(PyTextual):
                        """
                        Determine if you want to define the multi-zone control by selecting regions or edges.
                        """
                        pass

                    class edge_label_list(PyTextual):
                        """
                        Choose one or more edge labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class edge_label_selection(PyTextual):
                        """
                        Parameter edge_label_selection of value type list[str].
                        """
                        pass

                    class fill_with(PyTextual):
                        """
                        Choose a multi-zone meshing fill type: Hex-Pave, Hex-Map, Prism, or Mixed.
                        """
                        pass

                    class growth_method(PyTextual):
                        """
                        For edge-based multizone controls when using variable Growth Patterns, determine how you would like to determine the growth: either as a Growth Rate or as Bias Factor.
                        """
                        pass

                    class growth_rate(PyNumerical):
                        """
                        Specify a value for the growth rate for the multizone, or use the default value.
                        """
                        pass

                    class intervals(PyNumerical):
                        """
                        Specify the number of intervals for the edge-based multizone control. If double graded biasing is used and the Interval is set to an odd number (or the Size or Smallest Height results in an odd number Interval), the interval will automatically be increased by one.
                        """
                        pass

                    class label_source_list(PyTextual):
                        """
                        Choose one or more face zone labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class max_sweep_size(PyNumerical):
                        """
                        Indicates the maximum value for the sweep size.
                        """
                        pass

                    class mesh_method(PyTextual):
                        """
                        Choose a multi-zone meshing technique: Standard or the Thin volume technique (for only a single layer)
                        """
                        pass

                    class multi_z_name(PyTextual):
                        """
                        Enter a name for the multi-zone mesh control, or use the default.
                        """
                        pass

                    class parallel_selection(PyParameter):
                        """
                        When your desired zones are aligned with the global x,y, or z plane, enable this checkbox to automatically select all parallel zones in  the selected region(s).
                        """
                        pass

                    class region_scope(PyTextual):
                        """
                        Select the named region(s) from the list to which you would like to create the multi-zone control. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class show_edge_biasing(PyTextual):
                        """
                        If edge labels are automatically created on all edges, preserving the face/edge topology, use this field to determine if you want to save time and preview any edge biasing, since when many edges are selected, there can be many nodes and biases that can take additional time. Choices include yes, selected to only preview the selected edge, yes, all to preview all edges, and no to not preview edge biasing.
                        """
                        pass

                    class size(PyNumerical):
                        """
                        Specify the minimum size for the edge-based multizone control.
                        """
                        pass

                    class smallest_height(PyNumerical):
                        """
                        Specify a value for the smallest height for the edge-based multizone control.
                        """
                        pass

                    class source_method(PyTextual):
                        """
                        Choose one or more face zones or labels from the list below. You can also provide the ability to select all source-target zones that are parallel to a global plane by choosing Zones parallel to XY plane, Zones parallel to XZ plane, or Zones parallel to YZ plane. For zones or labels. use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class topo_source_list(PyTextual):
                        """
                        Parameter topo_source_list of value type list[str].
                        """
                        pass

                    class use_sweep_size(PyParameter):
                        """
                        Specify the minimum size for the edge-based multizone control.
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                    class zone_source_list(PyTextual):
                        """
                        Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _add_multizone_controls:
                return super().__getitem__(key)

        class add_shell_boundary_layers(PyNamedObjectContainer):
            """
            .
            """
            class _add_shell_boundary_layers(PyMenu):
                """
                Singleton _add_shell_boundary_layers.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.shell_bl_advanced_options = self.__class__.shell_bl_advanced_options(service, rules, path + [("shell_bl_advanced_options", "")])
                        self.add_child = self.__class__.add_child(service, rules, path + [("add_child", "")])
                        self.control_name = self.__class__.control_name(service, rules, path + [("control_name", "")])
                        self.edge_label_list = self.__class__.edge_label_list(service, rules, path + [("edge_label_list", "")])
                        self.edge_selection_type = self.__class__.edge_selection_type(service, rules, path + [("edge_selection_type", "")])
                        self.edge_zone_list = self.__class__.edge_zone_list(service, rules, path + [("edge_zone_list", "")])
                        self.face_label_list = self.__class__.face_label_list(service, rules, path + [("face_label_list", "")])
                        self.face_zone_list = self.__class__.face_zone_list(service, rules, path + [("face_zone_list", "")])
                        self.first_aspect_ratio = self.__class__.first_aspect_ratio(service, rules, path + [("first_aspect_ratio", "")])
                        self.first_layer_height = self.__class__.first_layer_height(service, rules, path + [("first_layer_height", "")])
                        self.grow_on = self.__class__.grow_on(service, rules, path + [("grow_on", "")])
                        self.last_aspect_ratio = self.__class__.last_aspect_ratio(service, rules, path + [("last_aspect_ratio", "")])
                        self.max_layer_height = self.__class__.max_layer_height(service, rules, path + [("max_layer_height", "")])
                        self.number_of_layers = self.__class__.number_of_layers(service, rules, path + [("number_of_layers", "")])
                        self.offset_method_type = self.__class__.offset_method_type(service, rules, path + [("offset_method_type", "")])
                        self.rate = self.__class__.rate(service, rules, path + [("rate", "")])
                        super().__init__(service, rules, path)

                    class shell_bl_advanced_options(PyMenu):
                        """
                        Singleton shell_bl_advanced_options.
                        """
                        def __init__(self, service, rules, path):
                            self.adjacent_attach_angle = self.__class__.adjacent_attach_angle(service, rules, path + [("adjacent_attach_angle", "")])
                            self.expose_side = self.__class__.expose_side(service, rules, path + [("expose_side", "")])
                            self.gap_factor = self.__class__.gap_factor(service, rules, path + [("gap_factor", "")])
                            self.last_ratio_num_layers = self.__class__.last_ratio_num_layers(service, rules, path + [("last_ratio_num_layers", "")])
                            self.last_ratio_percentage = self.__class__.last_ratio_percentage(service, rules, path + [("last_ratio_percentage", "")])
                            self.max_aspect_ratio = self.__class__.max_aspect_ratio(service, rules, path + [("max_aspect_ratio", "")])
                            self.min_aspect_ratio = self.__class__.min_aspect_ratio(service, rules, path + [("min_aspect_ratio", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            super().__init__(service, rules, path)

                        class adjacent_attach_angle(PyNumerical):
                            """
                            Parameter adjacent_attach_angle of value type float.
                            """
                            pass

                        class expose_side(PyParameter):
                            """
                            Parameter expose_side of value type bool.
                            """
                            pass

                        class gap_factor(PyNumerical):
                            """
                            Parameter gap_factor of value type float.
                            """
                            pass

                        class last_ratio_num_layers(PyNumerical):
                            """
                            Parameter last_ratio_num_layers of value type int.
                            """
                            pass

                        class last_ratio_percentage(PyNumerical):
                            """
                            Parameter last_ratio_percentage of value type float.
                            """
                            pass

                        class max_aspect_ratio(PyNumerical):
                            """
                            Parameter max_aspect_ratio of value type float.
                            """
                            pass

                        class min_aspect_ratio(PyNumerical):
                            """
                            Parameter min_aspect_ratio of value type float.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Parameter show_in_gui of value type bool.
                            """
                            pass

                    class add_child(PyParameter):
                        """
                        Parameter add_child of value type bool.
                        """
                        pass

                    class control_name(PyTextual):
                        """
                        Parameter control_name of value type str.
                        """
                        pass

                    class edge_label_list(PyTextual):
                        """
                        Parameter edge_label_list of value type list[str].
                        """
                        pass

                    class edge_selection_type(PyTextual):
                        """
                        Parameter edge_selection_type of value type str.
                        """
                        pass

                    class edge_zone_list(PyTextual):
                        """
                        Parameter edge_zone_list of value type list[str].
                        """
                        pass

                    class face_label_list(PyTextual):
                        """
                        Parameter face_label_list of value type list[str].
                        """
                        pass

                    class face_zone_list(PyTextual):
                        """
                        Parameter face_zone_list of value type list[str].
                        """
                        pass

                    class first_aspect_ratio(PyNumerical):
                        """
                        Parameter first_aspect_ratio of value type float.
                        """
                        pass

                    class first_layer_height(PyNumerical):
                        """
                        Parameter first_layer_height of value type float.
                        """
                        pass

                    class grow_on(PyTextual):
                        """
                        Parameter grow_on of value type str.
                        """
                        pass

                    class last_aspect_ratio(PyNumerical):
                        """
                        Parameter last_aspect_ratio of value type float.
                        """
                        pass

                    class max_layer_height(PyNumerical):
                        """
                        Parameter max_layer_height of value type float.
                        """
                        pass

                    class number_of_layers(PyNumerical):
                        """
                        Parameter number_of_layers of value type int.
                        """
                        pass

                    class offset_method_type(PyTextual):
                        """
                        Parameter offset_method_type of value type str.
                        """
                        pass

                    class rate(PyNumerical):
                        """
                        Parameter rate of value type float.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _add_shell_boundary_layers:
                return super().__getitem__(key)

        class add_thin_volume_meshing_controls(PyNamedObjectContainer):
            """
            .
            """
            class _add_thin_volume_meshing_controls(PyMenu):
                """
                Singleton _add_thin_volume_meshing_controls.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.thin_volume_preferences = self.__class__.thin_volume_preferences(service, rules, path + [("thin_volume_preferences", "")])
                        self.assign_size_using = self.__class__.assign_size_using(service, rules, path + [("assign_size_using", "")])
                        self.auto_control_creation = self.__class__.auto_control_creation(service, rules, path + [("auto_control_creation", "")])
                        self.complete_label_source_list = self.__class__.complete_label_source_list(service, rules, path + [("complete_label_source_list", "")])
                        self.complete_label_target_list = self.__class__.complete_label_target_list(service, rules, path + [("complete_label_target_list", "")])
                        self.complete_region_scope = self.__class__.complete_region_scope(service, rules, path + [("complete_region_scope", "")])
                        self.complete_topo_source_list = self.__class__.complete_topo_source_list(service, rules, path + [("complete_topo_source_list", "")])
                        self.complete_zone_source_list = self.__class__.complete_zone_source_list(service, rules, path + [("complete_zone_source_list", "")])
                        self.complete_zone_target_list = self.__class__.complete_zone_target_list(service, rules, path + [("complete_zone_target_list", "")])
                        self.double_biasing = self.__class__.double_biasing(service, rules, path + [("double_biasing", "")])
                        self.growth_rate = self.__class__.growth_rate(service, rules, path + [("growth_rate", "")])
                        self.intervals = self.__class__.intervals(service, rules, path + [("intervals", "")])
                        self.label_source_list = self.__class__.label_source_list(service, rules, path + [("label_source_list", "")])
                        self.label_target_list = self.__class__.label_target_list(service, rules, path + [("label_target_list", "")])
                        self.max_number_of_intervals = self.__class__.max_number_of_intervals(service, rules, path + [("max_number_of_intervals", "")])
                        self.objects = self.__class__.objects(service, rules, path + [("objects", "")])
                        self.parallel_source = self.__class__.parallel_source(service, rules, path + [("parallel_source", "")])
                        self.parallel_target = self.__class__.parallel_target(service, rules, path + [("parallel_target", "")])
                        self.region_scope = self.__class__.region_scope(service, rules, path + [("region_scope", "")])
                        self.remesh_overlapping = self.__class__.remesh_overlapping(service, rules, path + [("remesh_overlapping", "")])
                        self.select_source_by = self.__class__.select_source_by(service, rules, path + [("select_source_by", "")])
                        self.select_target_by = self.__class__.select_target_by(service, rules, path + [("select_target_by", "")])
                        self.side_imprints = self.__class__.side_imprints(service, rules, path + [("side_imprints", "")])
                        self.size = self.__class__.size(service, rules, path + [("size", "")])
                        self.stacked_plates = self.__class__.stacked_plates(service, rules, path + [("stacked_plates", "")])
                        self.thin_meshing_name = self.__class__.thin_meshing_name(service, rules, path + [("thin_meshing_name", "")])
                        self.thin_vol_regs = self.__class__.thin_vol_regs(service, rules, path + [("thin_vol_regs", "")])
                        self.topo_source_list = self.__class__.topo_source_list(service, rules, path + [("topo_source_list", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        self.zone_location_2 = self.__class__.zone_location_2(service, rules, path + [("zone_location_2", "")])
                        self.zone_source_list = self.__class__.zone_source_list(service, rules, path + [("zone_source_list", "")])
                        self.zone_target_list = self.__class__.zone_target_list(service, rules, path + [("zone_target_list", "")])
                        super().__init__(service, rules, path)

                    class thin_volume_preferences(PyMenu):
                        """
                        Singleton thin_volume_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.ignore_extra_sources = self.__class__.ignore_extra_sources(service, rules, path + [("ignore_extra_sources", "")])
                            self.include_adjacent = self.__class__.include_adjacent(service, rules, path + [("include_adjacent", "")])
                            self.max_gap_size = self.__class__.max_gap_size(service, rules, path + [("max_gap_size", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            self.stacked_plate_tolerance = self.__class__.stacked_plate_tolerance(service, rules, path + [("stacked_plate_tolerance", "")])
                            super().__init__(service, rules, path)

                        class ignore_extra_sources(PyTextual):
                            """
                            Choose to have Standard or Aggressive unstructured fill. This option applies unstructured meshing in complex regions of the thin volume mesh.
                            """
                            pass

                        class include_adjacent(PyParameter):
                            """
                            Specify whether or not adjacent stacked plate(s) are included in the thin mesh. This option is set to Yes by default.
                            """
                            pass

                        class max_gap_size(PyNumerical):
                            """
                            The maximum gap distance between thin mesh layers. This size is will default to 0 mm when Auto Control Creation is disabled and will default to 1 mm when Auto Control Creation is turned on. When auto control creation is disabled, note that the default value of 0 mm indicates automatic computation. When auto control creation is enabled, although the default value is 1 mm, this value should be manually specified based on plate thickness. Any plates thicker than the specified value will be excluded from thin meshing.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Advanced settings for thin volume meshing controls.
                            """
                            pass

                        class stacked_plate_tolerance(PyNumerical):
                            """
                            Specifies the tolerance to include adjacent source faces.
                            """
                            pass

                    class assign_size_using(PyTextual):
                        """
                        Specify the sizing of the mesh layers to be based on Intervals or based on the Size of the plates.
                        """
                        pass

                    class auto_control_creation(PyParameter):
                        """
                        enter the Size of each thin mesh layer or use the default.
                        """
                        pass

                    class complete_label_source_list(PyTextual):
                        """
                        Select the label(s) to use as the source.
                        """
                        pass

                    class complete_label_target_list(PyTextual):
                        """
                        Select the label(s) to use as the target.
                        """
                        pass

                    class complete_region_scope(PyTextual):
                        """
                        Specify the Region(s) where the thin volume meshing controls will be applied.
                        """
                        pass

                    class complete_topo_source_list(PyTextual):
                        """
                        Parameter complete_topo_source_list of value type list[str].
                        """
                        pass

                    class complete_zone_source_list(PyTextual):
                        """
                        Select the zone(s) to use as the source.
                        """
                        pass

                    class complete_zone_target_list(PyTextual):
                        """
                        Select the zone(s) to use as the target.
                        """
                        pass

                    class double_biasing(PyParameter):
                        """
                        Enable the Doubling biasing option to invoke double biasing on edges of the thin volume mesh layers. Enabling double biasing will automatically set the Growth Rate to 1.3. When disabled, the thin volume mesh can only be graded from the Source to the Target.
                        """
                        pass

                    class growth_rate(PyNumerical):
                        """
                        Specify the Growth Rate which is the expansion rate of the extrusion for each thin volume mesh layer and is set to 1 by default. A growth rate of 1.2 for example will expand each layer of the extrusion by 20 percent of the previous length.
                        """
                        pass

                    class intervals(PyNumerical):
                        """
                        Specifies the minimum number of mesh layers to be created within the thin volume mesh.
                        """
                        pass

                    class label_source_list(PyTextual):
                        """
                        Select the label(s) to use as the source.
                        """
                        pass

                    class label_target_list(PyTextual):
                        """
                        Select the label(s) to use as the target.
                        """
                        pass

                    class max_number_of_intervals(PyNumerical):
                        """
                        Specifies the minimum number of mesh layers to be created within the thin volume mesh.
                        """
                        pass

                    class objects(PyTextual):
                        """
                        Parameter objects of value type list[str].
                        """
                        pass

                    class parallel_source(PyParameter):
                        """
                        Enable this option if you have multiple source zones in parallel that you want to select for thin meshing.
                        """
                        pass

                    class parallel_target(PyParameter):
                        """
                        Enable this option if you have multiple target zones in parallel that you want to select for thin meshing,
                        """
                        pass

                    class region_scope(PyTextual):
                        """
                        Specify the Region(s) where the thin volume meshing controls will be applied.
                        """
                        pass

                    class remesh_overlapping(PyParameter):
                        """
                        Parameter remesh_overlapping of value type bool.
                        """
                        pass

                    class select_source_by(PyTextual):
                        """
                        Choose whether to select the source surfaces by label or by zone.
                        """
                        pass

                    class select_target_by(PyTextual):
                        """
                        Choose whether to select the source surfaces by label or by zone.
                        """
                        pass

                    class side_imprints(PyParameter):
                        """
                        Specifies the mesher to project the outer nodes of the thin volume mesh onto adjacent boundary face zones and is enabled by default. This ensures that geometric details of the thin volume are accurately captured at the boundary.
                        """
                        pass

                    class size(PyNumerical):
                        """
                        enter the Size of each thin mesh layer or use the default.
                        """
                        pass

                    class stacked_plates(PyParameter):
                        """
                        For models consisting of stacked planar plates, you can enable the Stacked Plates option to select all source-target zones that are aligned with the global x-y-z plane.
                        """
                        pass

                    class thin_meshing_name(PyTextual):
                        """
                        Enter a name for the thin volume mesh control, or use the default.
                        """
                        pass

                    class thin_vol_regs(PyTextual):
                        """
                        Parameter thin_vol_regs of value type list[str].
                        """
                        pass

                    class topo_source_list(PyTextual):
                        """
                        Parameter topo_source_list of value type list[str].
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                    class zone_location_2(PyTextual):
                        """
                        Parameter zone_location_2 of value type list[str].
                        """
                        pass

                    class zone_source_list(PyTextual):
                        """
                        Select the zone(s) to use as the source.
                        """
                        pass

                    class zone_target_list(PyTextual):
                        """
                        Select the zone(s) to use as the target.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _add_thin_volume_meshing_controls:
                return super().__getitem__(key)

        class add_virtual_topology(PyNamedObjectContainer):
            """
            .
            """
            class _add_virtual_topology(PyMenu):
                """
                Singleton _add_virtual_topology.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.add_child = self.__class__.add_child(service, rules, path + [("add_child", "")])
                        self.control_name = self.__class__.control_name(service, rules, path + [("control_name", "")])
                        self.face_label_list = self.__class__.face_label_list(service, rules, path + [("face_label_list", "")])
                        self.face_zone_list = self.__class__.face_zone_list(service, rules, path + [("face_zone_list", "")])
                        self.new_faces = self.__class__.new_faces(service, rules, path + [("new_faces", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        super().__init__(service, rules, path)

                    class add_child(PyParameter):
                        """
                        Parameter add_child of value type bool.
                        """
                        pass

                    class control_name(PyTextual):
                        """
                        Parameter control_name of value type str.
                        """
                        pass

                    class face_label_list(PyTextual):
                        """
                        Parameter face_label_list of value type list[str].
                        """
                        pass

                    class face_zone_list(PyTextual):
                        """
                        Parameter face_zone_list of value type list[str].
                        """
                        pass

                    class new_faces(PyParameter):
                        """
                        Parameter new_faces of value type list[int].
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Parameter selection_type of value type str.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _add_virtual_topology:
                return super().__getitem__(key)

        class apply_share_topology(PyNamedObjectContainer):
            """
            .
            """
            class _apply_share_topology(PyMenu):
                """
                Singleton _apply_share_topology.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.improve_surface_mesh_preferences = self.__class__.improve_surface_mesh_preferences(service, rules, path + [("improve_surface_mesh_preferences", "")])
                        self.share_topology_preferences = self.__class__.share_topology_preferences(service, rules, path + [("share_topology_preferences", "")])
                        self.surface_mesh_preferences = self.__class__.surface_mesh_preferences(service, rules, path + [("surface_mesh_preferences", "")])
                        self.edge_labels = self.__class__.edge_labels(service, rules, path + [("edge_labels", "")])
                        self.gap_distance = self.__class__.gap_distance(service, rules, path + [("gap_distance", "")])
                        self.gap_distance_connect = self.__class__.gap_distance_connect(service, rules, path + [("gap_distance_connect", "")])
                        self.interface_select = self.__class__.interface_select(service, rules, path + [("interface_select", "")])
                        self.min_size = self.__class__.min_size(service, rules, path + [("min_size", "")])
                        super().__init__(service, rules, path)

                    class improve_surface_mesh_preferences(PyMenu):
                        """
                        Singleton improve_surface_mesh_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.advanced_improve = self.__class__.advanced_improve(service, rules, path + [("advanced_improve", "")])
                            self.allow_defeaturing = self.__class__.allow_defeaturing(service, rules, path + [("allow_defeaturing", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            self.si_dihedral_angle = self.__class__.si_dihedral_angle(service, rules, path + [("si_dihedral_angle", "")])
                            self.si_improve_dihedral_angle = self.__class__.si_improve_dihedral_angle(service, rules, path + [("si_improve_dihedral_angle", "")])
                            self.si_quality_collapse_limit = self.__class__.si_quality_collapse_limit(service, rules, path + [("si_quality_collapse_limit", "")])
                            self.si_quality_iterations = self.__class__.si_quality_iterations(service, rules, path + [("si_quality_iterations", "")])
                            self.si_quality_max_angle = self.__class__.si_quality_max_angle(service, rules, path + [("si_quality_max_angle", "")])
                            self.si_remove_step = self.__class__.si_remove_step(service, rules, path + [("si_remove_step", "")])
                            self.si_step_quality_limit = self.__class__.si_step_quality_limit(service, rules, path + [("si_step_quality_limit", "")])
                            self.si_step_width = self.__class__.si_step_width(service, rules, path + [("si_step_width", "")])
                            super().__init__(service, rules, path)

                        class advanced_improve(PyParameter):
                            """
                            Parameter advanced_improve of value type bool.
                            """
                            pass

                        class allow_defeaturing(PyParameter):
                            """
                            Parameter allow_defeaturing of value type bool.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Parameter show_in_gui of value type bool.
                            """
                            pass

                        class si_dihedral_angle(PyNumerical):
                            """
                            Parameter si_dihedral_angle of value type float.
                            """
                            pass

                        class si_improve_dihedral_angle(PyParameter):
                            """
                            Parameter si_improve_dihedral_angle of value type bool.
                            """
                            pass

                        class si_quality_collapse_limit(PyNumerical):
                            """
                            Parameter si_quality_collapse_limit of value type float.
                            """
                            pass

                        class si_quality_iterations(PyNumerical):
                            """
                            Parameter si_quality_iterations of value type int.
                            """
                            pass

                        class si_quality_max_angle(PyNumerical):
                            """
                            Parameter si_quality_max_angle of value type float.
                            """
                            pass

                        class si_remove_step(PyParameter):
                            """
                            Parameter si_remove_step of value type bool.
                            """
                            pass

                        class si_step_quality_limit(PyNumerical):
                            """
                            Parameter si_step_quality_limit of value type float.
                            """
                            pass

                        class si_step_width(PyNumerical):
                            """
                            Parameter si_step_width of value type float.
                            """
                            pass

                    class share_topology_preferences(PyMenu):
                        """
                        Singleton share_topology_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.advanced_improve = self.__class__.advanced_improve(service, rules, path + [("advanced_improve", "")])
                            self.allow_defeaturing = self.__class__.allow_defeaturing(service, rules, path + [("allow_defeaturing", "")])
                            self.connect_label_wildcard = self.__class__.connect_label_wildcard(service, rules, path + [("connect_label_wildcard", "")])
                            self.execute_join_intersect = self.__class__.execute_join_intersect(service, rules, path + [("execute_join_intersect", "")])
                            self.fluid_label_wildcard = self.__class__.fluid_label_wildcard(service, rules, path + [("fluid_label_wildcard", "")])
                            self.intf_label_list = self.__class__.intf_label_list(service, rules, path + [("intf_label_list", "")])
                            self.join_tolerance_increment = self.__class__.join_tolerance_increment(service, rules, path + [("join_tolerance_increment", "")])
                            self.model_is_periodic = self.__class__.model_is_periodic(service, rules, path + [("model_is_periodic", "")])
                            self.number_of_join_tries = self.__class__.number_of_join_tries(service, rules, path + [("number_of_join_tries", "")])
                            self.operation = self.__class__.operation(service, rules, path + [("operation", "")])
                            self.per_label_list = self.__class__.per_label_list(service, rules, path + [("per_label_list", "")])
                            self.relative_share_topology_tolerance = self.__class__.relative_share_topology_tolerance(service, rules, path + [("relative_share_topology_tolerance", "")])
                            self.rename_internals_by_body_names = self.__class__.rename_internals_by_body_names(service, rules, path + [("rename_internals_by_body_names", "")])
                            self.share_topology_angle = self.__class__.share_topology_angle(service, rules, path + [("share_topology_angle", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            super().__init__(service, rules, path)

                        class advanced_improve(PyParameter):
                            """
                            Parameter advanced_improve of value type bool.
                            """
                            pass

                        class allow_defeaturing(PyParameter):
                            """
                            Parameter allow_defeaturing of value type bool.
                            """
                            pass

                        class connect_label_wildcard(PyTextual):
                            """
                            Enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                            """
                            pass

                        class execute_join_intersect(PyTextual):
                            """
                            Choose whether the system will only join faces, only intersect faces, or do both.
                            """
                            pass

                        class fluid_label_wildcard(PyTextual):
                            """
                            Parameter fluid_label_wildcard of value type str.
                            """
                            pass

                        class intf_label_list(PyTextual):
                            """
                            Enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                            """
                            pass

                        class join_tolerance_increment(PyNumerical):
                            """
                            Specify the increment by which the tolerance changes for each attempt to join face pairs.
                            """
                            pass

                        class model_is_periodic(PyParameter):
                            """
                            Choose whether or not you need to set up periodic boundaries. If you select yes, then choose your periodic boundaries from the list of available boundaries.
                            """
                            pass

                        class number_of_join_tries(PyNumerical):
                            """
                            Specify the number of attempts that will be made to join face pairs under the given criteria.
                            """
                            pass

                        class operation(PyTextual):
                            """
                            Choose whether to apply share topology using the Join-Intersect method where you join and/or intersect the problematic faces, or using the Interface Connect method where you connect edges of overlapping face pairs. Note that imprinting of overlapping faces in SCDM/Discovery is highly recommended for the Interface Connect method.
                            """
                            pass

                        class per_label_list(PyTextual):
                            """
                            Parameter per_label_list of value type list[str].
                            """
                            pass

                        class relative_share_topology_tolerance(PyNumerical):
                            """
                            Specify the relative tolerance for joining or intersecting face pairs, or the relative tolerance for connecting edge and face pairs.
                            """
                            pass

                        class rename_internals_by_body_names(PyParameter):
                            """
                            Choose whether or not to apply body names from the imported geometry and use them in naming internal boundaries.  For instance, the internal face between two regions solid and body would be renamed to solid-body.
                            """
                            pass

                        class share_topology_angle(PyNumerical):
                            """
                            Specify the threshold angle for joining face pairs.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Display advanced options that you may want to apply to the task.
                            """
                            pass

                    class surface_mesh_preferences(PyMenu):
                        """
                        Singleton surface_mesh_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.auto_assign_zone_types = self.__class__.auto_assign_zone_types(service, rules, path + [("auto_assign_zone_types", "")])
                            self.auto_merge = self.__class__.auto_merge(service, rules, path + [("auto_merge", "")])
                            self.auto_surface_remesh = self.__class__.auto_surface_remesh(service, rules, path + [("auto_surface_remesh", "")])
                            self.fold_face_limit = self.__class__.fold_face_limit(service, rules, path + [("fold_face_limit", "")])
                            self.improve_quality = self.__class__.improve_quality(service, rules, path + [("improve_quality", "")])
                            self.max_step_width = self.__class__.max_step_width(service, rules, path + [("max_step_width", "")])
                            self.parallel_region_compute = self.__class__.parallel_region_compute(service, rules, path + [("parallel_region_compute", "")])
                            self.quality_improve_collapase_skewness_limit = self.__class__.quality_improve_collapase_skewness_limit(service, rules, path + [("quality_improve_collapase_skewness_limit", "")])
                            self.quality_improve_max_angle = self.__class__.quality_improve_max_angle(service, rules, path + [("quality_improve_max_angle", "")])
                            self.quality_improve_skewness_limit = self.__class__.quality_improve_skewness_limit(service, rules, path + [("quality_improve_skewness_limit", "")])
                            self.remove_steps = self.__class__.remove_steps(service, rules, path + [("remove_steps", "")])
                            self.self_intersect_check = self.__class__.self_intersect_check(service, rules, path + [("self_intersect_check", "")])
                            self.separate_by_angle = self.__class__.separate_by_angle(service, rules, path + [("separate_by_angle", "")])
                            self.separation_angle = self.__class__.separation_angle(service, rules, path + [("separation_angle", "")])
                            self.set_volume_mesh_max_size = self.__class__.set_volume_mesh_max_size(service, rules, path + [("set_volume_mesh_max_size", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            self.thin_volume_meshing_auto_control_creation = self.__class__.thin_volume_meshing_auto_control_creation(service, rules, path + [("thin_volume_meshing_auto_control_creation", "")])
                            self.volume_mesh_max_size = self.__class__.volume_mesh_max_size(service, rules, path + [("volume_mesh_max_size", "")])
                            super().__init__(service, rules, path)

                        class auto_assign_zone_types(PyParameter):
                            """
                            Parameter auto_assign_zone_types of value type bool.
                            """
                            pass

                        class auto_merge(PyParameter):
                            """
                            Parameter auto_merge of value type bool.
                            """
                            pass

                        class auto_surface_remesh(PyTextual):
                            """
                            Parameter auto_surface_remesh of value type str.
                            """
                            pass

                        class fold_face_limit(PyNumerical):
                            """
                            Parameter fold_face_limit of value type float.
                            """
                            pass

                        class improve_quality(PyParameter):
                            """
                            Parameter improve_quality of value type bool.
                            """
                            pass

                        class max_step_width(PyNumerical):
                            """
                            Parameter max_step_width of value type float.
                            """
                            pass

                        class parallel_region_compute(PyTextual):
                            """
                            Parameter parallel_region_compute of value type str.
                            """
                            pass

                        class quality_improve_collapase_skewness_limit(PyNumerical):
                            """
                            Parameter quality_improve_collapase_skewness_limit of value type float.
                            """
                            pass

                        class quality_improve_max_angle(PyNumerical):
                            """
                            Parameter quality_improve_max_angle of value type float.
                            """
                            pass

                        class quality_improve_skewness_limit(PyNumerical):
                            """
                            Parameter quality_improve_skewness_limit of value type float.
                            """
                            pass

                        class remove_steps(PyParameter):
                            """
                            Parameter remove_steps of value type bool.
                            """
                            pass

                        class self_intersect_check(PyParameter):
                            """
                            Parameter self_intersect_check of value type bool.
                            """
                            pass

                        class separate_by_angle(PyTextual):
                            """
                            Parameter separate_by_angle of value type str.
                            """
                            pass

                        class separation_angle(PyNumerical):
                            """
                            Parameter separation_angle of value type float.
                            """
                            pass

                        class set_volume_mesh_max_size(PyParameter):
                            """
                            Parameter set_volume_mesh_max_size of value type bool.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Parameter show_in_gui of value type bool.
                            """
                            pass

                        class thin_volume_meshing_auto_control_creation(PyParameter):
                            """
                            Parameter thin_volume_meshing_auto_control_creation of value type bool.
                            """
                            pass

                        class volume_mesh_max_size(PyNumerical):
                            """
                            Parameter volume_mesh_max_size of value type float.
                            """
                            pass

                    class edge_labels(PyTextual):
                        """
                        Parameter edge_labels of value type list[str].
                        """
                        pass

                    class gap_distance(PyNumerical):
                        """
                        Specify the maximum distance under which gaps will be removed. Use the Show Marked Gaps button to display such gaps.
                        """
                        pass

                    class gap_distance_connect(PyNumerical):
                        """
                        Specify the maximum distance under which gaps will be removed (the default value of 0 is recommended). Use the Show Marked Gaps button to display such gaps.
                        """
                        pass

                    class interface_select(PyTextual):
                        """
                        Choose whether to have the interface labels selected manually (Manual), automatically (Automatic), or when force share connect topology is utilized in the  geometry (Automatic - Using Connect Topology).
                        """
                        pass

                    class min_size(PyNumerical):
                        """
                        Parameter min_size of value type float.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _apply_share_topology:
                return super().__getitem__(key)

        class axisymmetric_sweep(PyNamedObjectContainer):
            """
            .
            """
            class _axisymmetric_sweep(PyMenu):
                """
                Singleton _axisymmetric_sweep.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.axis_direction = self.__class__.axis_direction(service, rules, path + [("axis_direction", "")])
                        self.axis_origin = self.__class__.axis_origin(service, rules, path + [("axis_origin", "")])
                        self.axis_sweep_control_name = self.__class__.axis_sweep_control_name(service, rules, path + [("axis_sweep_control_name", "")])
                        self.number_of_layers = self.__class__.number_of_layers(service, rules, path + [("number_of_layers", "")])
                        self.revolution_angle_deg = self.__class__.revolution_angle_deg(service, rules, path + [("revolution_angle_deg", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.sweep_boundary_zone_list = self.__class__.sweep_boundary_zone_list(service, rules, path + [("sweep_boundary_zone_list", "")])
                        self.topology_list = self.__class__.topology_list(service, rules, path + [("topology_list", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        super().__init__(service, rules, path)

                    class axis_direction(PyMenu):
                        """
                        Singleton axis_direction.
                        """
                        def __init__(self, service, rules, path):
                            self.x = self.__class__.x(service, rules, path + [("x", "")])
                            self.y = self.__class__.y(service, rules, path + [("y", "")])
                            self.z = self.__class__.z(service, rules, path + [("z", "")])
                            super().__init__(service, rules, path)

                        class x(PyNumerical):
                            """
                            Specify the X component for the currently active axis definition (axis origin or axis direction).
                            """
                            pass

                        class y(PyNumerical):
                            """
                            Specify the Y component for the currently active axis definition (axis origin or axis direction).
                            """
                            pass

                        class z(PyNumerical):
                            """
                            Specify the Z component for the currently active axis definition (axis origin or axis direction).
                            """
                            pass

                    class axis_origin(PyMenu):
                        """
                        Singleton axis_origin.
                        """
                        def __init__(self, service, rules, path):
                            self.x = self.__class__.x(service, rules, path + [("x", "")])
                            self.y = self.__class__.y(service, rules, path + [("y", "")])
                            self.z = self.__class__.z(service, rules, path + [("z", "")])
                            super().__init__(service, rules, path)

                        class x(PyNumerical):
                            """
                            Specify the X component for the currently active axis definition (axis origin or axis direction).
                            """
                            pass

                        class y(PyNumerical):
                            """
                            Specify the Y component for the currently active axis definition (axis origin or axis direction).
                            """
                            pass

                        class z(PyNumerical):
                            """
                            Specify the Z component for the currently active axis definition (axis origin or axis direction).
                            """
                            pass

                    class axis_sweep_control_name(PyTextual):
                        """
                        Specify a name for this axisymmetric sweep control.
                        """
                        pass

                    class number_of_layers(PyNumerical):
                        """
                        Specify the number of layers (divisions) used in the swept direction.
                        """
                        pass

                    class revolution_angle_deg(PyNumerical):
                        """
                        Specify the revolution angle for the sweep in degrees (typically 360 for a full rotation).
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Parameter selection_type of value type str.
                        """
                        pass

                    class sweep_boundary_zone_list(PyTextual):
                        """
                        Select one or more boundary zones from the list to which you will apply the sweep. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class topology_list(PyTextual):
                        """
                        Parameter topology_list of value type list[str].
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _axisymmetric_sweep:
                return super().__getitem__(key)

        class capping(PyNamedObjectContainer):
            """
            .
            """
            class _capping(PyMenu):
                """
                Singleton _capping.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.create_patch_preferences = self.__class__.create_patch_preferences(service, rules, path + [("create_patch_preferences", "")])
                        self.cap_labels = self.__class__.cap_labels(service, rules, path + [("cap_labels", "")])
                        self.complete_label_selection_list = self.__class__.complete_label_selection_list(service, rules, path + [("complete_label_selection_list", "")])
                        self.complete_topology_list = self.__class__.complete_topology_list(service, rules, path + [("complete_topology_list", "")])
                        self.complete_zone_selection_list = self.__class__.complete_zone_selection_list(service, rules, path + [("complete_zone_selection_list", "")])
                        self.label_selection_list = self.__class__.label_selection_list(service, rules, path + [("label_selection_list", "")])
                        self.new_object_name = self.__class__.new_object_name(service, rules, path + [("new_object_name", "")])
                        self.object_association = self.__class__.object_association(service, rules, path + [("object_association", "")])
                        self.patch_name = self.__class__.patch_name(service, rules, path + [("patch_name", "")])
                        self.patch_object_name = self.__class__.patch_object_name(service, rules, path + [("patch_object_name", "")])
                        self.patch_type = self.__class__.patch_type(service, rules, path + [("patch_type", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.topology_list = self.__class__.topology_list(service, rules, path + [("topology_list", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        self.zone_selection_list = self.__class__.zone_selection_list(service, rules, path + [("zone_selection_list", "")])
                        self.zone_type = self.__class__.zone_type(service, rules, path + [("zone_type", "")])
                        super().__init__(service, rules, path)

                    class create_patch_preferences(PyMenu):
                        """
                        Singleton create_patch_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.check_cap_self_intersection = self.__class__.check_cap_self_intersection(service, rules, path + [("check_cap_self_intersection", "")])
                            self.max_cap_limit = self.__class__.max_cap_limit(service, rules, path + [("max_cap_limit", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            super().__init__(service, rules, path)

                        class check_cap_self_intersection(PyParameter):
                            """
                            Choose whether or not the system will detect if the capping surface intersects with any other face in the model. If an intersected face is found, it is automatically deleted. To increase the efficiency of the capping task, this option should be set to "no".
                            """
                            pass

                        class max_cap_limit(PyNumerical):
                            """
                            Specify the upper limit for the number of edges that can be present on the capping surface.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Display advanced options that you may want to apply to the task.
                            """
                            pass

                    class cap_labels(PyTextual):
                        """
                        Parameter cap_labels of value type list[str].
                        """
                        pass

                    class complete_label_selection_list(PyTextual):
                        """
                        Choose one or more face zone labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class complete_topology_list(PyTextual):
                        """
                        Parameter complete_topology_list of value type list[str].
                        """
                        pass

                    class complete_zone_selection_list(PyTextual):
                        """
                        Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class label_selection_list(PyTextual):
                        """
                        Choose one or more face zone labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class new_object_name(PyTextual):
                        """
                        Parameter new_object_name of value type str.
                        """
                        pass

                    class object_association(PyTextual):
                        """
                        Parameter object_association of value type str.
                        """
                        pass

                    class patch_name(PyTextual):
                        """
                        Enter a name for the capping surface.
                        """
                        pass

                    class patch_object_name(PyTextual):
                        """
                        Parameter patch_object_name of value type str.
                        """
                        pass

                    class patch_type(PyTextual):
                        """
                        Choose the type of capping surface: a regular, simple opening with one or more faces:  or an annular opening where the fluid is within two concentric cylinders:
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Choose how you want to select your surface (by label or by zone).
                        """
                        pass

                    class topology_list(PyTextual):
                        """
                        Parameter topology_list of value type list[str].
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                    class zone_selection_list(PyTextual):
                        """
                        Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class zone_type(PyTextual):
                        """
                        Choose the type of zone to assign to the capping surface (velocity inlet, pressure outlet, etc.).
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _capping:
                return super().__getitem__(key)

        class check_mesh(PyNamedObjectContainer):
            """
            .
            """
            class _check_mesh(PyMenu):
                """
                Singleton _check_mesh.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        super().__init__(service, rules, path)

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _check_mesh:
                return super().__getitem__(key)

        class check_surface_quality(PyNamedObjectContainer):
            """
            .
            """
            class _check_surface_quality(PyMenu):
                """
                Singleton _check_surface_quality.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        super().__init__(service, rules, path)

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _check_surface_quality:
                return super().__getitem__(key)

        class check_volume_quality(PyNamedObjectContainer):
            """
            .
            """
            class _check_volume_quality(PyMenu):
                """
                Singleton _check_volume_quality.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        super().__init__(service, rules, path)

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _check_volume_quality:
                return super().__getitem__(key)

        class choose_mesh_control_options(PyNamedObjectContainer):
            """
            .
            """
            class _choose_mesh_control_options(PyMenu):
                """
                Singleton _choose_mesh_control_options.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.mesh_control_options = self.__class__.mesh_control_options(service, rules, path + [("mesh_control_options", "")])
                        self.creation_method = self.__class__.creation_method(service, rules, path + [("creation_method", "")])
                        self.global_growth_rate = self.__class__.global_growth_rate(service, rules, path + [("global_growth_rate", "")])
                        self.global_max = self.__class__.global_max(service, rules, path + [("global_max", "")])
                        self.global_min = self.__class__.global_min(service, rules, path + [("global_min", "")])
                        self.read_or_create = self.__class__.read_or_create(service, rules, path + [("read_or_create", "")])
                        self.size_control_file_name = self.__class__.size_control_file_name(service, rules, path + [("size_control_file_name", "")])
                        self.view_option = self.__class__.view_option(service, rules, path + [("view_option", "")])
                        self.wrap_size_control_file_name = self.__class__.wrap_size_control_file_name(service, rules, path + [("wrap_size_control_file_name", "")])
                        super().__init__(service, rules, path)

                    class mesh_control_options(PyMenu):
                        """
                        Singleton mesh_control_options.
                        """
                        def __init__(self, service, rules, path):
                            self.advanced_options = self.__class__.advanced_options(service, rules, path + [("advanced_options", "")])
                            self.boundary_layers = self.__class__.boundary_layers(service, rules, path + [("boundary_layers", "")])
                            self.edge_proximity_computation = self.__class__.edge_proximity_computation(service, rules, path + [("edge_proximity_computation", "")])
                            self.existing_size_field = self.__class__.existing_size_field(service, rules, path + [("existing_size_field", "")])
                            self.solid_fluid_raio = self.__class__.solid_fluid_raio(service, rules, path + [("solid_fluid_raio", "")])
                            self.solid_fluid_ratio = self.__class__.solid_fluid_ratio(service, rules, path + [("solid_fluid_ratio", "")])
                            self.targe_size_field_file_name = self.__class__.targe_size_field_file_name(service, rules, path + [("targe_size_field_file_name", "")])
                            self.target_size_field_file_name = self.__class__.target_size_field_file_name(service, rules, path + [("target_size_field_file_name", "")])
                            self.wrap_size_field_file_name = self.__class__.wrap_size_field_file_name(service, rules, path + [("wrap_size_field_file_name", "")])
                            self.wrap_target_both_options = self.__class__.wrap_target_both_options(service, rules, path + [("wrap_target_both_options", "")])
                            self.wrap_target_raio = self.__class__.wrap_target_raio(service, rules, path + [("wrap_target_raio", "")])
                            self.wrap_target_ratio = self.__class__.wrap_target_ratio(service, rules, path + [("wrap_target_ratio", "")])
                            self.wrap_target_size_field_ratio = self.__class__.wrap_target_size_field_ratio(service, rules, path + [("wrap_target_size_field_ratio", "")])
                            super().__init__(service, rules, path)

                        class advanced_options(PyParameter):
                            """
                            Display advanced options that you may want to apply to the task.
                            """
                            pass

                        class boundary_layers(PyParameter):
                            """
                            Parameter boundary_layers of value type bool.
                            """
                            pass

                        class edge_proximity_computation(PyParameter):
                            """
                            For geometries having a very large number of small feature edges, select Yes to speed up the calculation and reduce memory requirements when using a proximity size function.
                            """
                            pass

                        class existing_size_field(PyTextual):
                            """
                            Determine which existing size field files will be used: Both Wrap and Target (the default), Target Only, or Wrap Only. For complex models, computational expense can be lowered by choosing one of the other options. If either Wrap Only or Target Only is selected, then the other values are determined using the Wrap/Target Size Ratio value.
                            """
                            pass

                        class solid_fluid_raio(PyNumerical):
                            """
                            The ratio of the actual size of the solid and the actual size of the fluid.
                            """
                            pass

                        class solid_fluid_ratio(PyNumerical):
                            """
                            Parameter solid_fluid_ratio of value type float.
                            """
                            pass

                        class targe_size_field_file_name(PyTextual):
                            """
                            Indicate the name and location of the target size field file (\\*.sf).
                            """
                            pass

                        class target_size_field_file_name(PyTextual):
                            """
                            Parameter target_size_field_file_name of value type str.
                            """
                            pass

                        class wrap_size_field_file_name(PyTextual):
                            """
                            Indicate the name and location of the wrap size field file (\\*.sf).
                            """
                            pass

                        class wrap_target_both_options(PyTextual):
                            """
                            Determine how the size controls are calculated in the Add Local Sizing task: using Both Wrap and Target values, by Target Only (the default), or by Wrap Only. For complex models, computational expense can be lowered by choosing one of the other options. If either Wrap Only or Target Only is selected, then the other values are determined using the Wrap/Target Size Ratio value.
                            """
                            pass

                        class wrap_target_raio(PyNumerical):
                            """
                            This is the ratio of the wrap size and the target size controls. For example, if this ratio is 0.67 and the initial minimum target size is 1 and initial maximum target size is 16, then the initial minimum wrap size will be 0.67 and the initial maximum wrap size will be 10.72 . This value does not affect BOI or soft size controls, since, in such cases, the Wrap/Target Size Control Ratio is set to 1.
                            """
                            pass

                        class wrap_target_ratio(PyNumerical):
                            """
                            Parameter wrap_target_ratio of value type float.
                            """
                            pass

                        class wrap_target_size_field_ratio(PyNumerical):
                            """
                            The ratio of the initial wrap size field and the local target size field.
                            """
                            pass

                    class creation_method(PyTextual):
                        """
                        Determine whether you want to use default size controls or not. Default will populate your size controls with default settings, based on the number of objects in your model. The Custom option can be used to populate as many size controls as you need using your own customized settings.
                        """
                        pass

                    class global_growth_rate(PyNumerical):
                        """
                        Parameter global_growth_rate of value type float.
                        """
                        pass

                    class global_max(PyNumerical):
                        """
                        Parameter global_max of value type float.
                        """
                        pass

                    class global_min(PyNumerical):
                        """
                        Parameter global_min of value type float.
                        """
                        pass

                    class read_or_create(PyTextual):
                        """
                        Determine whether you want to create new, or use existing mesh size controls or size fields.
                        """
                        pass

                    class size_control_file_name(PyTextual):
                        """
                        Browse to specify the location and the name of the size control file (.szcontrol) where your mesh controls are defined.
                        """
                        pass

                    class view_option(PyTextual):
                        """
                        Determine if you would like to use separate tasks or a table to view and work with your mesh controls.
                        """
                        pass

                    class wrap_size_control_file_name(PyTextual):
                        """
                        Browse to specify the location and the name of the size control file (.szcontrol) where your mesh controls are defined.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _choose_mesh_control_options:
                return super().__getitem__(key)

        class close_leakage(PyNamedObjectContainer):
            """
            .
            """
            class _close_leakage(PyMenu):
                """
                Singleton _close_leakage.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.close_leakage_option = self.__class__.close_leakage_option(service, rules, path + [("close_leakage_option", "")])
                        super().__init__(service, rules, path)

                    class close_leakage_option(PyParameter):
                        """
                        Parameter close_leakage_option of value type bool.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _close_leakage:
                return super().__getitem__(key)

        class compute_regions(PyNamedObjectContainer):
            """
            .
            """
            class _compute_regions(PyMenu):
                """
                Singleton _compute_regions.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.complex_meshing_regions_option = self.__class__.complex_meshing_regions_option(service, rules, path + [("complex_meshing_regions_option", "")])
                        super().__init__(service, rules, path)

                    class complex_meshing_regions_option(PyParameter):
                        """
                        Parameter complex_meshing_regions_option of value type bool.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _compute_regions:
                return super().__getitem__(key)

        class compute_size_fields(PyNamedObjectContainer):
            """
            .
            """
            class _compute_size_fields(PyMenu):
                """
                Singleton _compute_size_fields.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.compute_size_field_control = self.__class__.compute_size_field_control(service, rules, path + [("compute_size_field_control", "")])
                        super().__init__(service, rules, path)

                    class compute_size_field_control(PyParameter):
                        """
                        Parameter compute_size_field_control of value type bool.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _compute_size_fields:
                return super().__getitem__(key)

        class create_collar_mesh(PyNamedObjectContainer):
            """
            .
            """
            class _create_collar_mesh(PyMenu):
                """
                Singleton _create_collar_mesh.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.axis = self.__class__.axis(service, rules, path + [("axis", "")])
                        self.bounding_box_object = self.__class__.bounding_box_object(service, rules, path + [("bounding_box_object", "")])
                        self.cylinder_object = self.__class__.cylinder_object(service, rules, path + [("cylinder_object", "")])
                        self.geometry_tools_properties = self.__class__.geometry_tools_properties(service, rules, path + [("geometry_tools_properties", "")])
                        self.offset_object = self.__class__.offset_object(service, rules, path + [("offset_object", "")])
                        self.boi_max_size = self.__class__.boi_max_size(service, rules, path + [("boi_max_size", "")])
                        self.boi_size_name = self.__class__.boi_size_name(service, rules, path + [("boi_size_name", "")])
                        self.creation_method = self.__class__.creation_method(service, rules, path + [("creation_method", "")])
                        self.cylinder_length = self.__class__.cylinder_length(service, rules, path + [("cylinder_length", "")])
                        self.cylinder_method = self.__class__.cylinder_method(service, rules, path + [("cylinder_method", "")])
                        self.label_selection_list = self.__class__.label_selection_list(service, rules, path + [("label_selection_list", "")])
                        self.object_selection_list = self.__class__.object_selection_list(service, rules, path + [("object_selection_list", "")])
                        self.object_selection_single = self.__class__.object_selection_single(service, rules, path + [("object_selection_single", "")])
                        self.refinement_regions_name = self.__class__.refinement_regions_name(service, rules, path + [("refinement_regions_name", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.topology_list = self.__class__.topology_list(service, rules, path + [("topology_list", "")])
                        self.volume_fill = self.__class__.volume_fill(service, rules, path + [("volume_fill", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        self.zone_selection_list = self.__class__.zone_selection_list(service, rules, path + [("zone_selection_list", "")])
                        self.zone_selection_single = self.__class__.zone_selection_single(service, rules, path + [("zone_selection_single", "")])
                        super().__init__(service, rules, path)

                    class axis(PyMenu):
                        """
                        Singleton axis.
                        """
                        def __init__(self, service, rules, path):
                            self.x_component = self.__class__.x_component(service, rules, path + [("x_component", "")])
                            self.y_component = self.__class__.y_component(service, rules, path + [("y_component", "")])
                            self.z_component = self.__class__.z_component(service, rules, path + [("z_component", "")])
                            super().__init__(service, rules, path)

                        class x_component(PyNumerical):
                            """
                            Parameter x_component of value type float.
                            """
                            pass

                        class y_component(PyNumerical):
                            """
                            Parameter y_component of value type float.
                            """
                            pass

                        class z_component(PyNumerical):
                            """
                            Parameter z_component of value type float.
                            """
                            pass

                    class bounding_box_object(PyMenu):
                        """
                        Singleton bounding_box_object.
                        """
                        def __init__(self, service, rules, path):
                            self.size_relative_length = self.__class__.size_relative_length(service, rules, path + [("size_relative_length", "")])
                            self.xmax = self.__class__.xmax(service, rules, path + [("xmax", "")])
                            self.xmax_ratio = self.__class__.xmax_ratio(service, rules, path + [("xmax_ratio", "")])
                            self.xmin = self.__class__.xmin(service, rules, path + [("xmin", "")])
                            self.xmin_ratio = self.__class__.xmin_ratio(service, rules, path + [("xmin_ratio", "")])
                            self.ymax = self.__class__.ymax(service, rules, path + [("ymax", "")])
                            self.ymax_ratio = self.__class__.ymax_ratio(service, rules, path + [("ymax_ratio", "")])
                            self.ymin = self.__class__.ymin(service, rules, path + [("ymin", "")])
                            self.ymin_ratio = self.__class__.ymin_ratio(service, rules, path + [("ymin_ratio", "")])
                            self.zmax = self.__class__.zmax(service, rules, path + [("zmax", "")])
                            self.zmax_ratio = self.__class__.zmax_ratio(service, rules, path + [("zmax_ratio", "")])
                            self.zmin = self.__class__.zmin(service, rules, path + [("zmin", "")])
                            self.zmin_ratio = self.__class__.zmin_ratio(service, rules, path + [("zmin_ratio", "")])
                            super().__init__(service, rules, path)

                        class size_relative_length(PyTextual):
                            """
                            Parameter size_relative_length of value type str.
                            """
                            pass

                        class xmax(PyNumerical):
                            """
                            Specify the x-coordinate of the offset collar mesh.
                            """
                            pass

                        class xmax_ratio(PyNumerical):
                            """
                            Parameter xmax_ratio of value type float.
                            """
                            pass

                        class xmin(PyNumerical):
                            """
                            Parameter xmin of value type float.
                            """
                            pass

                        class xmin_ratio(PyNumerical):
                            """
                            Parameter xmin_ratio of value type float.
                            """
                            pass

                        class ymax(PyNumerical):
                            """
                            Specify the x-coordinate of the offset collar mesh.
                            """
                            pass

                        class ymax_ratio(PyNumerical):
                            """
                            Parameter ymax_ratio of value type float.
                            """
                            pass

                        class ymin(PyNumerical):
                            """
                            Parameter ymin of value type float.
                            """
                            pass

                        class ymin_ratio(PyNumerical):
                            """
                            Parameter ymin_ratio of value type float.
                            """
                            pass

                        class zmax(PyNumerical):
                            """
                            Specify the x-coordinate of the offset collar mesh.
                            """
                            pass

                        class zmax_ratio(PyNumerical):
                            """
                            Parameter zmax_ratio of value type float.
                            """
                            pass

                        class zmin(PyNumerical):
                            """
                            Parameter zmin of value type float.
                            """
                            pass

                        class zmin_ratio(PyNumerical):
                            """
                            Parameter zmin_ratio of value type float.
                            """
                            pass

                    class cylinder_object(PyMenu):
                        """
                        Singleton cylinder_object.
                        """
                        def __init__(self, service, rules, path):
                            self.height_back_inc = self.__class__.height_back_inc(service, rules, path + [("height_back_inc", "")])
                            self.height_front_inc = self.__class__.height_front_inc(service, rules, path + [("height_front_inc", "")])
                            self.height_node = self.__class__.height_node(service, rules, path + [("height_node", "")])
                            self.node_1 = self.__class__.node_1(service, rules, path + [("node_1", "")])
                            self.node_2 = self.__class__.node_2(service, rules, path + [("node_2", "")])
                            self.node_3 = self.__class__.node_3(service, rules, path + [("node_3", "")])
                            self.radius_1 = self.__class__.radius_1(service, rules, path + [("radius_1", "")])
                            self.radius_2 = self.__class__.radius_2(service, rules, path + [("radius_2", "")])
                            self.x1 = self.__class__.x1(service, rules, path + [("x1", "")])
                            self.x2 = self.__class__.x2(service, rules, path + [("x2", "")])
                            self.x_offset = self.__class__.x_offset(service, rules, path + [("x_offset", "")])
                            self.y1 = self.__class__.y1(service, rules, path + [("y1", "")])
                            self.y2 = self.__class__.y2(service, rules, path + [("y2", "")])
                            self.y_offset = self.__class__.y_offset(service, rules, path + [("y_offset", "")])
                            self.z1 = self.__class__.z1(service, rules, path + [("z1", "")])
                            self.z2 = self.__class__.z2(service, rules, path + [("z2", "")])
                            self.z_offset = self.__class__.z_offset(service, rules, path + [("z_offset", "")])
                            super().__init__(service, rules, path)

                        class height_back_inc(PyNumerical):
                            """
                            Parameter height_back_inc of value type float.
                            """
                            pass

                        class height_front_inc(PyNumerical):
                            """
                            Parameter height_front_inc of value type float.
                            """
                            pass

                        class height_node(PyTextual):
                            """
                            Parameter height_node of value type str.
                            """
                            pass

                        class node_1(PyTextual):
                            """
                            Parameter node_1 of value type str.
                            """
                            pass

                        class node_2(PyTextual):
                            """
                            Parameter node_2 of value type str.
                            """
                            pass

                        class node_3(PyTextual):
                            """
                            Parameter node_3 of value type str.
                            """
                            pass

                        class radius_1(PyNumerical):
                            """
                            Parameter radius_1 of value type float.
                            """
                            pass

                        class radius_2(PyNumerical):
                            """
                            Parameter radius_2 of value type float.
                            """
                            pass

                        class x1(PyNumerical):
                            """
                            Parameter x1 of value type float.
                            """
                            pass

                        class x2(PyNumerical):
                            """
                            Parameter x2 of value type float.
                            """
                            pass

                        class x_offset(PyNumerical):
                            """
                            Parameter x_offset of value type float.
                            """
                            pass

                        class y1(PyNumerical):
                            """
                            Parameter y1 of value type float.
                            """
                            pass

                        class y2(PyNumerical):
                            """
                            Parameter y2 of value type float.
                            """
                            pass

                        class y_offset(PyNumerical):
                            """
                            Parameter y_offset of value type float.
                            """
                            pass

                        class z1(PyNumerical):
                            """
                            Parameter z1 of value type float.
                            """
                            pass

                        class z2(PyNumerical):
                            """
                            Parameter z2 of value type float.
                            """
                            pass

                        class z_offset(PyNumerical):
                            """
                            Parameter z_offset of value type float.
                            """
                            pass

                    class geometry_tools_properties(PyMenu):
                        """
                        Singleton geometry_tools_properties.
                        """
                        def __init__(self, service, rules, path):
                            self.box_center_x = self.__class__.box_center_x(service, rules, path + [("box_center_x", "")])
                            self.box_center_y = self.__class__.box_center_y(service, rules, path + [("box_center_y", "")])
                            self.box_center_z = self.__class__.box_center_z(service, rules, path + [("box_center_z", "")])
                            self.box_x_length = self.__class__.box_x_length(service, rules, path + [("box_x_length", "")])
                            self.box_y_length = self.__class__.box_y_length(service, rules, path + [("box_y_length", "")])
                            self.box_z_length = self.__class__.box_z_length(service, rules, path + [("box_z_length", "")])
                            self.cylinder_radius_1 = self.__class__.cylinder_radius_1(service, rules, path + [("cylinder_radius_1", "")])
                            self.cylinder_radius_2 = self.__class__.cylinder_radius_2(service, rules, path + [("cylinder_radius_2", "")])
                            self.cylinder_x1 = self.__class__.cylinder_x1(service, rules, path + [("cylinder_x1", "")])
                            self.cylinder_x2 = self.__class__.cylinder_x2(service, rules, path + [("cylinder_x2", "")])
                            self.cylinder_y1 = self.__class__.cylinder_y1(service, rules, path + [("cylinder_y1", "")])
                            self.cylinder_y2 = self.__class__.cylinder_y2(service, rules, path + [("cylinder_y2", "")])
                            self.cylinder_z1 = self.__class__.cylinder_z1(service, rules, path + [("cylinder_z1", "")])
                            self.cylinder_z2 = self.__class__.cylinder_z2(service, rules, path + [("cylinder_z2", "")])
                            super().__init__(service, rules, path)

                        class box_center_x(PyNumerical):
                            """
                            Specify the x-coordinate of the offset collar mesh.
                            """
                            pass

                        class box_center_y(PyNumerical):
                            """
                            Specify the y-coordinate of the offset collar mesh.
                            """
                            pass

                        class box_center_z(PyNumerical):
                            """
                            Specify the z-coordinate of the offset collar mesh.
                            """
                            pass

                        class box_x_length(PyNumerical):
                            """
                            Parameter box_x_length of value type float.
                            """
                            pass

                        class box_y_length(PyNumerical):
                            """
                            Parameter box_y_length of value type float.
                            """
                            pass

                        class box_z_length(PyNumerical):
                            """
                            Parameter box_z_length of value type float.
                            """
                            pass

                        class cylinder_radius_1(PyNumerical):
                            """
                            Parameter cylinder_radius_1 of value type float.
                            """
                            pass

                        class cylinder_radius_2(PyNumerical):
                            """
                            Parameter cylinder_radius_2 of value type float.
                            """
                            pass

                        class cylinder_x1(PyNumerical):
                            """
                            Parameter cylinder_x1 of value type float.
                            """
                            pass

                        class cylinder_x2(PyNumerical):
                            """
                            Parameter cylinder_x2 of value type float.
                            """
                            pass

                        class cylinder_y1(PyNumerical):
                            """
                            Parameter cylinder_y1 of value type float.
                            """
                            pass

                        class cylinder_y2(PyNumerical):
                            """
                            Parameter cylinder_y2 of value type float.
                            """
                            pass

                        class cylinder_z1(PyNumerical):
                            """
                            Parameter cylinder_z1 of value type float.
                            """
                            pass

                        class cylinder_z2(PyNumerical):
                            """
                            Parameter cylinder_z2 of value type float.
                            """
                            pass

                    class offset_object(PyMenu):
                        """
                        Singleton offset_object.
                        """
                        def __init__(self, service, rules, path):
                            self.aspect_ratio = self.__class__.aspect_ratio(service, rules, path + [("aspect_ratio", "")])
                            self.boundary_layer_height = self.__class__.boundary_layer_height(service, rules, path + [("boundary_layer_height", "")])
                            self.boundary_layer_levels = self.__class__.boundary_layer_levels(service, rules, path + [("boundary_layer_levels", "")])
                            self.cross_wake_growth_factor = self.__class__.cross_wake_growth_factor(service, rules, path + [("cross_wake_growth_factor", "")])
                            self.defeaturing_size = self.__class__.defeaturing_size(service, rules, path + [("defeaturing_size", "")])
                            self.edge_selection_list = self.__class__.edge_selection_list(service, rules, path + [("edge_selection_list", "")])
                            self.first_height = self.__class__.first_height(service, rules, path + [("first_height", "")])
                            self.flip_direction = self.__class__.flip_direction(service, rules, path + [("flip_direction", "")])
                            self.flow_direction = self.__class__.flow_direction(service, rules, path + [("flow_direction", "")])
                            self.last_ratio_percentage = self.__class__.last_ratio_percentage(service, rules, path + [("last_ratio_percentage", "")])
                            self.mpt_method_type = self.__class__.mpt_method_type(service, rules, path + [("mpt_method_type", "")])
                            self.number_of_layers = self.__class__.number_of_layers(service, rules, path + [("number_of_layers", "")])
                            self.offset_method_type = self.__class__.offset_method_type(service, rules, path + [("offset_method_type", "")])
                            self.rate = self.__class__.rate(service, rules, path + [("rate", "")])
                            self.show_coordinates = self.__class__.show_coordinates(service, rules, path + [("show_coordinates", "")])
                            self.wake_growth_factor = self.__class__.wake_growth_factor(service, rules, path + [("wake_growth_factor", "")])
                            self.wake_levels = self.__class__.wake_levels(service, rules, path + [("wake_levels", "")])
                            self.x = self.__class__.x(service, rules, path + [("x", "")])
                            self.y = self.__class__.y(service, rules, path + [("y", "")])
                            self.z = self.__class__.z(service, rules, path + [("z", "")])
                            super().__init__(service, rules, path)

                        class aspect_ratio(PyNumerical):
                            """
                            Parameter aspect_ratio of value type float.
                            """
                            pass

                        class boundary_layer_height(PyNumerical):
                            """
                            Specify the total height of the boundary layer for this refinement region (this is flow in the vicinity).
                            """
                            pass

                        class boundary_layer_levels(PyNumerical):
                            """
                            Parameter boundary_layer_levels of value type int.
                            """
                            pass

                        class cross_wake_growth_factor(PyNumerical):
                            """
                            Parameter cross_wake_growth_factor of value type float.
                            """
                            pass

                        class defeaturing_size(PyNumerical):
                            """
                            Parameter defeaturing_size of value type float.
                            """
                            pass

                        class edge_selection_list(PyTextual):
                            """
                            Choose a single edge zone from the list below for your edge-based collar mesh. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                            """
                            pass

                        class first_height(PyNumerical):
                            """
                            Parameter first_height of value type float.
                            """
                            pass

                        class flip_direction(PyParameter):
                            """
                            Parameter flip_direction of value type bool.
                            """
                            pass

                        class flow_direction(PyTextual):
                            """
                            Parameter flow_direction of value type str.
                            """
                            pass

                        class last_ratio_percentage(PyNumerical):
                            """
                            Parameter last_ratio_percentage of value type float.
                            """
                            pass

                        class mpt_method_type(PyTextual):
                            """
                            Choose how you want to assign the location of the offset collar mesh. You can choose Automatic to have the system determine the best place for the collar mesh based on the intersected bodies or zones, or you can choose to use distinct Numerical Inputs.
                            """
                            pass

                        class number_of_layers(PyNumerical):
                            """
                            Parameter number_of_layers of value type int.
                            """
                            pass

                        class offset_method_type(PyTextual):
                            """
                            Parameter offset_method_type of value type str.
                            """
                            pass

                        class rate(PyNumerical):
                            """
                            Parameter rate of value type float.
                            """
                            pass

                        class show_coordinates(PyParameter):
                            """
                            Display the X, Y, and Z coordinate fields
                            """
                            pass

                        class wake_growth_factor(PyNumerical):
                            """
                            Parameter wake_growth_factor of value type float.
                            """
                            pass

                        class wake_levels(PyNumerical):
                            """
                            Parameter wake_levels of value type int.
                            """
                            pass

                        class x(PyNumerical):
                            """
                            Specify the x-coordinate of the offset collar mesh.
                            """
                            pass

                        class y(PyNumerical):
                            """
                            Specify the y-coordinate of the offset collar mesh.
                            """
                            pass

                        class z(PyNumerical):
                            """
                            Specify the z-coordinate of the offset collar mesh.
                            """
                            pass

                    class boi_max_size(PyNumerical):
                        """
                        Specify the maximum size of the elements for the collar mesh.
                        """
                        pass

                    class boi_size_name(PyTextual):
                        """
                        Parameter boi_size_name of value type str.
                        """
                        pass

                    class creation_method(PyTextual):
                        """
                        Choose how you want to create the collar mesh: either by using intersecting objects, an edge-based collar, or an existing object.
                        """
                        pass

                    class cylinder_length(PyNumerical):
                        """
                        Parameter cylinder_length of value type float.
                        """
                        pass

                    class cylinder_method(PyTextual):
                        """
                        Parameter cylinder_method of value type str.
                        """
                        pass

                    class label_selection_list(PyTextual):
                        """
                        Select one or more labels that will make up the collar mesh. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class object_selection_list(PyTextual):
                        """
                        Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class object_selection_single(PyTextual):
                        """
                        Choose a single object from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class refinement_regions_name(PyTextual):
                        """
                        Specify a name for the collar mesh or use the default name.
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Choose how you want to make your selection (by object, label, or zone name).
                        """
                        pass

                    class topology_list(PyTextual):
                        """
                        Parameter topology_list of value type list[str].
                        """
                        pass

                    class volume_fill(PyTextual):
                        """
                        Specify the type of mesh cell to use to fill the collar mesh. Available options are tetrahedral, hexcore, poly, or poly-hexcore. .
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                    class zone_selection_list(PyTextual):
                        """
                        Choose one or more zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class zone_selection_single(PyTextual):
                        """
                        Choose a single zone from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _create_collar_mesh:
                return super().__getitem__(key)

        class create_component_mesh(PyNamedObjectContainer):
            """
            .
            """
            class _create_component_mesh(PyMenu):
                """
                Singleton _create_component_mesh.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.axis = self.__class__.axis(service, rules, path + [("axis", "")])
                        self.bounding_box_object = self.__class__.bounding_box_object(service, rules, path + [("bounding_box_object", "")])
                        self.cylinder_object = self.__class__.cylinder_object(service, rules, path + [("cylinder_object", "")])
                        self.geometry_tools_properties = self.__class__.geometry_tools_properties(service, rules, path + [("geometry_tools_properties", "")])
                        self.offset_object = self.__class__.offset_object(service, rules, path + [("offset_object", "")])
                        self.boi_max_size = self.__class__.boi_max_size(service, rules, path + [("boi_max_size", "")])
                        self.boi_size_name = self.__class__.boi_size_name(service, rules, path + [("boi_size_name", "")])
                        self.creation_method = self.__class__.creation_method(service, rules, path + [("creation_method", "")])
                        self.cylinder_length = self.__class__.cylinder_length(service, rules, path + [("cylinder_length", "")])
                        self.cylinder_method = self.__class__.cylinder_method(service, rules, path + [("cylinder_method", "")])
                        self.label_selection_list = self.__class__.label_selection_list(service, rules, path + [("label_selection_list", "")])
                        self.object_selection_list = self.__class__.object_selection_list(service, rules, path + [("object_selection_list", "")])
                        self.object_selection_single = self.__class__.object_selection_single(service, rules, path + [("object_selection_single", "")])
                        self.refinement_regions_name = self.__class__.refinement_regions_name(service, rules, path + [("refinement_regions_name", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.topology_list = self.__class__.topology_list(service, rules, path + [("topology_list", "")])
                        self.volume_fill = self.__class__.volume_fill(service, rules, path + [("volume_fill", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        self.zone_selection_list = self.__class__.zone_selection_list(service, rules, path + [("zone_selection_list", "")])
                        self.zone_selection_single = self.__class__.zone_selection_single(service, rules, path + [("zone_selection_single", "")])
                        super().__init__(service, rules, path)

                    class axis(PyMenu):
                        """
                        Singleton axis.
                        """
                        def __init__(self, service, rules, path):
                            self.x_component = self.__class__.x_component(service, rules, path + [("x_component", "")])
                            self.y_component = self.__class__.y_component(service, rules, path + [("y_component", "")])
                            self.z_component = self.__class__.z_component(service, rules, path + [("z_component", "")])
                            super().__init__(service, rules, path)

                        class x_component(PyNumerical):
                            """
                            Parameter x_component of value type float.
                            """
                            pass

                        class y_component(PyNumerical):
                            """
                            Parameter y_component of value type float.
                            """
                            pass

                        class z_component(PyNumerical):
                            """
                            Parameter z_component of value type float.
                            """
                            pass

                    class bounding_box_object(PyMenu):
                        """
                        View the extents of the bounding box.
                        """
                        def __init__(self, service, rules, path):
                            self.size_relative_length = self.__class__.size_relative_length(service, rules, path + [("size_relative_length", "")])
                            self.xmax = self.__class__.xmax(service, rules, path + [("xmax", "")])
                            self.xmax_ratio = self.__class__.xmax_ratio(service, rules, path + [("xmax_ratio", "")])
                            self.xmin = self.__class__.xmin(service, rules, path + [("xmin", "")])
                            self.xmin_ratio = self.__class__.xmin_ratio(service, rules, path + [("xmin_ratio", "")])
                            self.ymax = self.__class__.ymax(service, rules, path + [("ymax", "")])
                            self.ymax_ratio = self.__class__.ymax_ratio(service, rules, path + [("ymax_ratio", "")])
                            self.ymin = self.__class__.ymin(service, rules, path + [("ymin", "")])
                            self.ymin_ratio = self.__class__.ymin_ratio(service, rules, path + [("ymin_ratio", "")])
                            self.zmax = self.__class__.zmax(service, rules, path + [("zmax", "")])
                            self.zmax_ratio = self.__class__.zmax_ratio(service, rules, path + [("zmax_ratio", "")])
                            self.zmin = self.__class__.zmin(service, rules, path + [("zmin", "")])
                            self.zmin_ratio = self.__class__.zmin_ratio(service, rules, path + [("zmin_ratio", "")])
                            super().__init__(service, rules, path)

                        class size_relative_length(PyTextual):
                            """
                            Determine if you would like to specify the bounding box for the component mesh as a ratio of the geometry length, or by specifying a specific location for the minimum and maximum coordinates.
                            """
                            pass

                        class xmax(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the X direction by the specified value.
                            """
                            pass

                        class xmax_ratio(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the X direction by the specified value. The value is the ratio relative to the geometry size in the X direction.
                            """
                            pass

                        class xmin(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the X direction by the specified value.
                            """
                            pass

                        class xmin_ratio(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the X direction by the specified value. The value is the ratio relative to the geometry size in the X direction.
                            """
                            pass

                        class ymax(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the Y direction by the specified value.
                            """
                            pass

                        class ymax_ratio(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the Y direction by the specified value. The value is the ratio relative to the geometry size in the Y direction.
                            """
                            pass

                        class ymin(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the Y direction by the specified value.
                            """
                            pass

                        class ymin_ratio(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the Y direction by the specified value. The value is the ratio relative to the geometry size in the Y direction.
                            """
                            pass

                        class zmax(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the Z direction by the specified value.
                            """
                            pass

                        class zmax_ratio(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the Z direction by the specified value. The value is the ratio relative to the geometry size in the Z direction.
                            """
                            pass

                        class zmin(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the Z direction by the specified value.
                            """
                            pass

                        class zmin_ratio(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the Z direction by the specified value. The value is the ratio relative to the geometry size in the Z direction.
                            """
                            pass

                    class cylinder_object(PyMenu):
                        """
                        Singleton cylinder_object.
                        """
                        def __init__(self, service, rules, path):
                            self.height_back_inc = self.__class__.height_back_inc(service, rules, path + [("height_back_inc", "")])
                            self.height_front_inc = self.__class__.height_front_inc(service, rules, path + [("height_front_inc", "")])
                            self.height_node = self.__class__.height_node(service, rules, path + [("height_node", "")])
                            self.node_1 = self.__class__.node_1(service, rules, path + [("node_1", "")])
                            self.node_2 = self.__class__.node_2(service, rules, path + [("node_2", "")])
                            self.node_3 = self.__class__.node_3(service, rules, path + [("node_3", "")])
                            self.radius_1 = self.__class__.radius_1(service, rules, path + [("radius_1", "")])
                            self.radius_2 = self.__class__.radius_2(service, rules, path + [("radius_2", "")])
                            self.x1 = self.__class__.x1(service, rules, path + [("x1", "")])
                            self.x2 = self.__class__.x2(service, rules, path + [("x2", "")])
                            self.x_offset = self.__class__.x_offset(service, rules, path + [("x_offset", "")])
                            self.y1 = self.__class__.y1(service, rules, path + [("y1", "")])
                            self.y2 = self.__class__.y2(service, rules, path + [("y2", "")])
                            self.y_offset = self.__class__.y_offset(service, rules, path + [("y_offset", "")])
                            self.z1 = self.__class__.z1(service, rules, path + [("z1", "")])
                            self.z2 = self.__class__.z2(service, rules, path + [("z2", "")])
                            self.z_offset = self.__class__.z_offset(service, rules, path + [("z_offset", "")])
                            super().__init__(service, rules, path)

                        class height_back_inc(PyNumerical):
                            """
                            Parameter height_back_inc of value type float.
                            """
                            pass

                        class height_front_inc(PyNumerical):
                            """
                            Parameter height_front_inc of value type float.
                            """
                            pass

                        class height_node(PyTextual):
                            """
                            Parameter height_node of value type str.
                            """
                            pass

                        class node_1(PyTextual):
                            """
                            Parameter node_1 of value type str.
                            """
                            pass

                        class node_2(PyTextual):
                            """
                            Parameter node_2 of value type str.
                            """
                            pass

                        class node_3(PyTextual):
                            """
                            Parameter node_3 of value type str.
                            """
                            pass

                        class radius_1(PyNumerical):
                            """
                            Parameter radius_1 of value type float.
                            """
                            pass

                        class radius_2(PyNumerical):
                            """
                            Parameter radius_2 of value type float.
                            """
                            pass

                        class x1(PyNumerical):
                            """
                            Parameter x1 of value type float.
                            """
                            pass

                        class x2(PyNumerical):
                            """
                            Parameter x2 of value type float.
                            """
                            pass

                        class x_offset(PyNumerical):
                            """
                            Parameter x_offset of value type float.
                            """
                            pass

                        class y1(PyNumerical):
                            """
                            Parameter y1 of value type float.
                            """
                            pass

                        class y2(PyNumerical):
                            """
                            Parameter y2 of value type float.
                            """
                            pass

                        class y_offset(PyNumerical):
                            """
                            Parameter y_offset of value type float.
                            """
                            pass

                        class z1(PyNumerical):
                            """
                            Parameter z1 of value type float.
                            """
                            pass

                        class z2(PyNumerical):
                            """
                            Parameter z2 of value type float.
                            """
                            pass

                        class z_offset(PyNumerical):
                            """
                            Parameter z_offset of value type float.
                            """
                            pass

                    class geometry_tools_properties(PyMenu):
                        """
                        Singleton geometry_tools_properties.
                        """
                        def __init__(self, service, rules, path):
                            self.box_center_x = self.__class__.box_center_x(service, rules, path + [("box_center_x", "")])
                            self.box_center_y = self.__class__.box_center_y(service, rules, path + [("box_center_y", "")])
                            self.box_center_z = self.__class__.box_center_z(service, rules, path + [("box_center_z", "")])
                            self.box_x_length = self.__class__.box_x_length(service, rules, path + [("box_x_length", "")])
                            self.box_y_length = self.__class__.box_y_length(service, rules, path + [("box_y_length", "")])
                            self.box_z_length = self.__class__.box_z_length(service, rules, path + [("box_z_length", "")])
                            self.cylinder_radius_1 = self.__class__.cylinder_radius_1(service, rules, path + [("cylinder_radius_1", "")])
                            self.cylinder_radius_2 = self.__class__.cylinder_radius_2(service, rules, path + [("cylinder_radius_2", "")])
                            self.cylinder_x1 = self.__class__.cylinder_x1(service, rules, path + [("cylinder_x1", "")])
                            self.cylinder_x2 = self.__class__.cylinder_x2(service, rules, path + [("cylinder_x2", "")])
                            self.cylinder_y1 = self.__class__.cylinder_y1(service, rules, path + [("cylinder_y1", "")])
                            self.cylinder_y2 = self.__class__.cylinder_y2(service, rules, path + [("cylinder_y2", "")])
                            self.cylinder_z1 = self.__class__.cylinder_z1(service, rules, path + [("cylinder_z1", "")])
                            self.cylinder_z2 = self.__class__.cylinder_z2(service, rules, path + [("cylinder_z2", "")])
                            super().__init__(service, rules, path)

                        class box_center_x(PyNumerical):
                            """
                            Parameter box_center_x of value type float.
                            """
                            pass

                        class box_center_y(PyNumerical):
                            """
                            Parameter box_center_y of value type float.
                            """
                            pass

                        class box_center_z(PyNumerical):
                            """
                            Parameter box_center_z of value type float.
                            """
                            pass

                        class box_x_length(PyNumerical):
                            """
                            Parameter box_x_length of value type float.
                            """
                            pass

                        class box_y_length(PyNumerical):
                            """
                            Parameter box_y_length of value type float.
                            """
                            pass

                        class box_z_length(PyNumerical):
                            """
                            Parameter box_z_length of value type float.
                            """
                            pass

                        class cylinder_radius_1(PyNumerical):
                            """
                            Parameter cylinder_radius_1 of value type float.
                            """
                            pass

                        class cylinder_radius_2(PyNumerical):
                            """
                            Parameter cylinder_radius_2 of value type float.
                            """
                            pass

                        class cylinder_x1(PyNumerical):
                            """
                            Parameter cylinder_x1 of value type float.
                            """
                            pass

                        class cylinder_x2(PyNumerical):
                            """
                            Parameter cylinder_x2 of value type float.
                            """
                            pass

                        class cylinder_y1(PyNumerical):
                            """
                            Parameter cylinder_y1 of value type float.
                            """
                            pass

                        class cylinder_y2(PyNumerical):
                            """
                            Parameter cylinder_y2 of value type float.
                            """
                            pass

                        class cylinder_z1(PyNumerical):
                            """
                            Parameter cylinder_z1 of value type float.
                            """
                            pass

                        class cylinder_z2(PyNumerical):
                            """
                            Parameter cylinder_z2 of value type float.
                            """
                            pass

                    class offset_object(PyMenu):
                        """
                        Singleton offset_object.
                        """
                        def __init__(self, service, rules, path):
                            self.aspect_ratio = self.__class__.aspect_ratio(service, rules, path + [("aspect_ratio", "")])
                            self.boundary_layer_height = self.__class__.boundary_layer_height(service, rules, path + [("boundary_layer_height", "")])
                            self.boundary_layer_levels = self.__class__.boundary_layer_levels(service, rules, path + [("boundary_layer_levels", "")])
                            self.cross_wake_growth_factor = self.__class__.cross_wake_growth_factor(service, rules, path + [("cross_wake_growth_factor", "")])
                            self.defeaturing_size = self.__class__.defeaturing_size(service, rules, path + [("defeaturing_size", "")])
                            self.edge_selection_list = self.__class__.edge_selection_list(service, rules, path + [("edge_selection_list", "")])
                            self.first_height = self.__class__.first_height(service, rules, path + [("first_height", "")])
                            self.flip_direction = self.__class__.flip_direction(service, rules, path + [("flip_direction", "")])
                            self.flow_direction = self.__class__.flow_direction(service, rules, path + [("flow_direction", "")])
                            self.last_ratio_percentage = self.__class__.last_ratio_percentage(service, rules, path + [("last_ratio_percentage", "")])
                            self.mpt_method_type = self.__class__.mpt_method_type(service, rules, path + [("mpt_method_type", "")])
                            self.number_of_layers = self.__class__.number_of_layers(service, rules, path + [("number_of_layers", "")])
                            self.offset_method_type = self.__class__.offset_method_type(service, rules, path + [("offset_method_type", "")])
                            self.rate = self.__class__.rate(service, rules, path + [("rate", "")])
                            self.show_coordinates = self.__class__.show_coordinates(service, rules, path + [("show_coordinates", "")])
                            self.wake_growth_factor = self.__class__.wake_growth_factor(service, rules, path + [("wake_growth_factor", "")])
                            self.wake_levels = self.__class__.wake_levels(service, rules, path + [("wake_levels", "")])
                            self.x = self.__class__.x(service, rules, path + [("x", "")])
                            self.y = self.__class__.y(service, rules, path + [("y", "")])
                            self.z = self.__class__.z(service, rules, path + [("z", "")])
                            super().__init__(service, rules, path)

                        class aspect_ratio(PyNumerical):
                            """
                            Specify the ratio of the prism base length to the prism layer height.
                            """
                            pass

                        class boundary_layer_height(PyNumerical):
                            """
                            Specify the total height of the boundary layer for this refinement region (this is flow in the vicinity).
                            """
                            pass

                        class boundary_layer_levels(PyNumerical):
                            """
                            Parameter boundary_layer_levels of value type int.
                            """
                            pass

                        class cross_wake_growth_factor(PyNumerical):
                            """
                            Parameter cross_wake_growth_factor of value type float.
                            """
                            pass

                        class defeaturing_size(PyNumerical):
                            """
                            Parameter defeaturing_size of value type float.
                            """
                            pass

                        class edge_selection_list(PyTextual):
                            """
                            Parameter edge_selection_list of value type list[str].
                            """
                            pass

                        class first_height(PyNumerical):
                            """
                            Specify the height of the first layer of cells in the boundary layer.
                            """
                            pass

                        class flip_direction(PyParameter):
                            """
                            Parameter flip_direction of value type bool.
                            """
                            pass

                        class flow_direction(PyTextual):
                            """
                            Parameter flow_direction of value type str.
                            """
                            pass

                        class last_ratio_percentage(PyNumerical):
                            """
                            Specify the offset height of the last layer as a percentage of the local base mesh size.
                            """
                            pass

                        class mpt_method_type(PyTextual):
                            """
                            Parameter mpt_method_type of value type str.
                            """
                            pass

                        class number_of_layers(PyNumerical):
                            """
                            Select the number of boundary layers to be generated.
                            """
                            pass

                        class offset_method_type(PyTextual):
                            """
                            Choose the method that will be used to create the boundary layer, or prism, controls.
                            """
                            pass

                        class rate(PyNumerical):
                            """
                            Specify the rate of growth of the boundary layer.
                            """
                            pass

                        class show_coordinates(PyParameter):
                            """
                            Parameter show_coordinates of value type bool.
                            """
                            pass

                        class wake_growth_factor(PyNumerical):
                            """
                            Parameter wake_growth_factor of value type float.
                            """
                            pass

                        class wake_levels(PyNumerical):
                            """
                            Parameter wake_levels of value type int.
                            """
                            pass

                        class x(PyNumerical):
                            """
                            Parameter x of value type float.
                            """
                            pass

                        class y(PyNumerical):
                            """
                            Parameter y of value type float.
                            """
                            pass

                        class z(PyNumerical):
                            """
                            Parameter z of value type float.
                            """
                            pass

                    class boi_max_size(PyNumerical):
                        """
                        Specify the maximum size of the elements for the component mesh.
                        """
                        pass

                    class boi_size_name(PyTextual):
                        """
                        Parameter boi_size_name of value type str.
                        """
                        pass

                    class creation_method(PyTextual):
                        """
                        Choose how you want to create the component mesh: either by using an offset surface, creating a bounding box, using an existing portion of the geometry, or by growing a boundary layer.
                        """
                        pass

                    class cylinder_length(PyNumerical):
                        """
                        Parameter cylinder_length of value type float.
                        """
                        pass

                    class cylinder_method(PyTextual):
                        """
                        Parameter cylinder_method of value type str.
                        """
                        pass

                    class label_selection_list(PyTextual):
                        """
                        Select one or more labels that will make up the component mesh. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class object_selection_list(PyTextual):
                        """
                        Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class object_selection_single(PyTextual):
                        """
                        Choose a single object from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class refinement_regions_name(PyTextual):
                        """
                        Specify a name for the component mesh or use the default value.
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Choose how you want to make your selection (by object, label, or zone name).
                        """
                        pass

                    class topology_list(PyTextual):
                        """
                        Parameter topology_list of value type list[str].
                        """
                        pass

                    class volume_fill(PyTextual):
                        """
                        Specify the type of mesh cell to use to fill the component mesh. Available options are tetrahedral, hexcore, poly, or poly-hexcore. .
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                    class zone_selection_list(PyTextual):
                        """
                        Choose one or more zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class zone_selection_single(PyTextual):
                        """
                        Choose a single zone from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _create_component_mesh:
                return super().__getitem__(key)

        class create_contact_patch(PyNamedObjectContainer):
            """
            .
            """
            class _create_contact_patch(PyMenu):
                """
                Singleton _create_contact_patch.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.contact_patch_defeaturing_size = self.__class__.contact_patch_defeaturing_size(service, rules, path + [("contact_patch_defeaturing_size", "")])
                        self.contact_patch_name = self.__class__.contact_patch_name(service, rules, path + [("contact_patch_name", "")])
                        self.distance = self.__class__.distance(service, rules, path + [("distance", "")])
                        self.feature_angle = self.__class__.feature_angle(service, rules, path + [("feature_angle", "")])
                        self.flip_direction = self.__class__.flip_direction(service, rules, path + [("flip_direction", "")])
                        self.ground_zone_selection_list = self.__class__.ground_zone_selection_list(service, rules, path + [("ground_zone_selection_list", "")])
                        self.label_selection_list = self.__class__.label_selection_list(service, rules, path + [("label_selection_list", "")])
                        self.object_selection_list = self.__class__.object_selection_list(service, rules, path + [("object_selection_list", "")])
                        self.patch_hole = self.__class__.patch_hole(service, rules, path + [("patch_hole", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        self.zone_selection_list = self.__class__.zone_selection_list(service, rules, path + [("zone_selection_list", "")])
                        super().__init__(service, rules, path)

                    class contact_patch_defeaturing_size(PyNumerical):
                        """
                        Allows you to control the smoothness of the contact patch. With the default value of 0, no smoothing takes place. With a value greater than 0, the patch is defeatured to create a smooth patch. This will lead to better quality volume mesh at the contact, for instance, between the tire and the ground.
                        """
                        pass

                    class contact_patch_name(PyTextual):
                        """
                        Specify a name for the contact patch object, or retain the default name.
                        """
                        pass

                    class distance(PyNumerical):
                        """
                        Specify the distance of the contact patch geometry from the ground zone, or the thickness of the contact patch.
                        """
                        pass

                    class feature_angle(PyNumerical):
                        """
                        Specify a value for the angle used to extract feature edges on the contact patch object.
                        """
                        pass

                    class flip_direction(PyParameter):
                        """
                        Use this option to switch the direction/orientation of the contact patch.
                        """
                        pass

                    class ground_zone_selection_list(PyTextual):
                        """
                        Choose one or more face zones from the list below that represent the contact target (for instance, the ground face zone in an enclosing bounding box for a tire-ground contact scenario).
                        """
                        pass

                    class label_selection_list(PyTextual):
                        """
                        Select one or more labels that represent the contact source. Use the Filter Text field to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class object_selection_list(PyTextual):
                        """
                        Choose an object from the list below that represent the contact source. Use the Filter Text field to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class patch_hole(PyParameter):
                        """
                        Indicate whether you want the contact patch object to be filled or not.
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Choose how you want to make your selection (for instance, by object, zone, or label).
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                    class zone_selection_list(PyTextual):
                        """
                        Choose one or more face zones from the list below that represent the contact source. Use the Filter Text field to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _create_contact_patch:
                return super().__getitem__(key)

        class create_external_flow_boundaries(PyNamedObjectContainer):
            """
            .
            """
            class _create_external_flow_boundaries(PyMenu):
                """
                Singleton _create_external_flow_boundaries.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.bounding_box_object = self.__class__.bounding_box_object(service, rules, path + [("bounding_box_object", "")])
                        self.creation_method = self.__class__.creation_method(service, rules, path + [("creation_method", "")])
                        self.external_boundaries_name = self.__class__.external_boundaries_name(service, rules, path + [("external_boundaries_name", "")])
                        self.extraction_method = self.__class__.extraction_method(service, rules, path + [("extraction_method", "")])
                        self.label_selection_list = self.__class__.label_selection_list(service, rules, path + [("label_selection_list", "")])
                        self.label_selection_single = self.__class__.label_selection_single(service, rules, path + [("label_selection_single", "")])
                        self.object_selection_list = self.__class__.object_selection_list(service, rules, path + [("object_selection_list", "")])
                        self.object_selection_single = self.__class__.object_selection_single(service, rules, path + [("object_selection_single", "")])
                        self.original_object_name = self.__class__.original_object_name(service, rules, path + [("original_object_name", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        self.zone_selection_list = self.__class__.zone_selection_list(service, rules, path + [("zone_selection_list", "")])
                        self.zone_selection_single = self.__class__.zone_selection_single(service, rules, path + [("zone_selection_single", "")])
                        super().__init__(service, rules, path)

                    class bounding_box_object(PyMenu):
                        """
                        View the extents of the bounding box.
                        """
                        def __init__(self, service, rules, path):
                            self.size_relative_length = self.__class__.size_relative_length(service, rules, path + [("size_relative_length", "")])
                            self.xmax = self.__class__.xmax(service, rules, path + [("xmax", "")])
                            self.xmax_ratio = self.__class__.xmax_ratio(service, rules, path + [("xmax_ratio", "")])
                            self.xmin = self.__class__.xmin(service, rules, path + [("xmin", "")])
                            self.xmin_ratio = self.__class__.xmin_ratio(service, rules, path + [("xmin_ratio", "")])
                            self.ymax = self.__class__.ymax(service, rules, path + [("ymax", "")])
                            self.ymax_ratio = self.__class__.ymax_ratio(service, rules, path + [("ymax_ratio", "")])
                            self.ymin = self.__class__.ymin(service, rules, path + [("ymin", "")])
                            self.ymin_ratio = self.__class__.ymin_ratio(service, rules, path + [("ymin_ratio", "")])
                            self.zmax = self.__class__.zmax(service, rules, path + [("zmax", "")])
                            self.zmax_ratio = self.__class__.zmax_ratio(service, rules, path + [("zmax_ratio", "")])
                            self.zmin = self.__class__.zmin(service, rules, path + [("zmin", "")])
                            self.zmin_ratio = self.__class__.zmin_ratio(service, rules, path + [("zmin_ratio", "")])
                            super().__init__(service, rules, path)

                        class size_relative_length(PyTextual):
                            """
                            Determine if you would like to specify the bounding box as a ratio of the geometry length, or by specifying a specific location for the minimum and maximum coordinates.
                            """
                            pass

                        class xmax(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the X direction by the specified value.
                            """
                            pass

                        class xmax_ratio(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the X direction by the specified value. The value is the ratio relative to the geometry size in the X direction.
                            """
                            pass

                        class xmin(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the X direction by the specified value.
                            """
                            pass

                        class xmin_ratio(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the X direction by the specified value. The value is the ratio relative to the geometry size in the X direction.
                            """
                            pass

                        class ymax(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the Y direction by the specified value.
                            """
                            pass

                        class ymax_ratio(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the Y direction by the specified value. The value is the ratio relative to the geometry size in the Y direction.
                            """
                            pass

                        class ymin(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the Y direction by the specified value.
                            """
                            pass

                        class ymin_ratio(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the Y direction by the specified value. The value is the ratio relative to the geometry size in the Y direction.
                            """
                            pass

                        class zmax(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the Z direction by the specified value.
                            """
                            pass

                        class zmax_ratio(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the Z direction by the specified value. The value is the ratio relative to the geometry size in the Z direction.
                            """
                            pass

                        class zmin(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the Z direction by the specified value.
                            """
                            pass

                        class zmin_ratio(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the Z direction by the specified value. The value is the ratio relative to the geometry size in the Z direction.
                            """
                            pass

                    class creation_method(PyTextual):
                        """
                        Choose how you want to create the external flow boundary: either by creating a new boundary using a bounding box, or use an existing portion of the geometry.
                        """
                        pass

                    class external_boundaries_name(PyTextual):
                        """
                        Enter a name for the external flow boundary or use the default value.
                        """
                        pass

                    class extraction_method(PyTextual):
                        """
                        Choose whether you would like to extract the external flow region either as a surface mesh object (a direct surface remesh of the object) a wrap, or an existing mesh (for overset components). The object setting is applied later when generating the surface mesh.
                        """
                        pass

                    class label_selection_list(PyTextual):
                        """
                        Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class label_selection_single(PyTextual):
                        """
                        Choose a single label from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class object_selection_list(PyTextual):
                        """
                        Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class object_selection_single(PyTextual):
                        """
                        Choose a single object from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class original_object_name(PyTextual):
                        """
                        Parameter original_object_name of value type str.
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Choose how you want to make your selection (by object, label, or zone name).
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                    class zone_selection_list(PyTextual):
                        """
                        Choose one or more zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class zone_selection_single(PyTextual):
                        """
                        Choose a single zone from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _create_external_flow_boundaries:
                return super().__getitem__(key)

        class create_gap_cover(PyNamedObjectContainer):
            """
            .
            """
            class _create_gap_cover(PyMenu):
                """
                Singleton _create_gap_cover.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.advanced_options = self.__class__.advanced_options(service, rules, path + [("advanced_options", "")])
                        self.gap_cover_between_zones = self.__class__.gap_cover_between_zones(service, rules, path + [("gap_cover_between_zones", "")])
                        self.gap_cover_feature_imprint = self.__class__.gap_cover_feature_imprint(service, rules, path + [("gap_cover_feature_imprint", "")])
                        self.gap_cover_name = self.__class__.gap_cover_name(service, rules, path + [("gap_cover_name", "")])
                        self.gap_cover_refine_factor = self.__class__.gap_cover_refine_factor(service, rules, path + [("gap_cover_refine_factor", "")])
                        self.gap_cover_refine_factor_at_gap = self.__class__.gap_cover_refine_factor_at_gap(service, rules, path + [("gap_cover_refine_factor_at_gap", "")])
                        self.gap_size = self.__class__.gap_size(service, rules, path + [("gap_size", "")])
                        self.gap_size_ratio = self.__class__.gap_size_ratio(service, rules, path + [("gap_size_ratio", "")])
                        self.label_selection_list = self.__class__.label_selection_list(service, rules, path + [("label_selection_list", "")])
                        self.max_island_face_for_gap_cover = self.__class__.max_island_face_for_gap_cover(service, rules, path + [("max_island_face_for_gap_cover", "")])
                        self.object_selection_list = self.__class__.object_selection_list(service, rules, path + [("object_selection_list", "")])
                        self.refine_wrapper_before_projection = self.__class__.refine_wrapper_before_projection(service, rules, path + [("refine_wrapper_before_projection", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.sizing_method = self.__class__.sizing_method(service, rules, path + [("sizing_method", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        self.zone_selection_list = self.__class__.zone_selection_list(service, rules, path + [("zone_selection_list", "")])
                        super().__init__(service, rules, path)

                    class advanced_options(PyParameter):
                        """
                        Display advanced options that you may want to apply to the task.
                        """
                        pass

                    class gap_cover_between_zones(PyParameter):
                        """
                        Determine if you only want to cover gaps between boundary zones (Yes), or if you want to cover all gaps within and between boundary zones (No)
                        """
                        pass

                    class gap_cover_feature_imprint(PyParameter):
                        """
                        Use this option to better define gap coverings. When this option is set to Yes, the gap covers are more accurate. Once the coarse wrap closes any gaps, this option also snaps the nodes of the wrapper onto all previously defined edge features to more closely cover the gaps. Setting this option to Yes, however, can be computationally expensive when modeling large vehicles (such as in aerospace), thus, the default is No.  Here, when set to No, wrapper faces at the corners are not on the geometry and are incorrectly marked as a gap. When set to Yes, only wrap faces at the gap are marked.
                        """
                        pass

                    class gap_cover_name(PyTextual):
                        """
                        Specify a name for the gap cover object, or retain the default name.
                        """
                        pass

                    class gap_cover_refine_factor(PyNumerical):
                        """
                        Allows you to control the resolution of the gap cover size based on a scaling of the Max Gap Size (or Max Gap Size Factor). It ranges from 0.0625 to 1 with a default value of 1.0). The higher the Resolution Factor, the more likely that some gaps may not be fully covered. Depending on the gap in question, lowering the Resolution Factor reduces the wrapper to sufficiently cover the gap in most cases.
                        """
                        pass

                    class gap_cover_refine_factor_at_gap(PyNumerical):
                        """
                        Allows you to specify the level of refinement for the gap-cover (patch). Decreasing the value increases the refinement of the patch.
                        """
                        pass

                    class gap_size(PyNumerical):
                        """
                        A specified maximum width for the gap.
                        """
                        pass

                    class gap_size_ratio(PyNumerical):
                        """
                        Specify a value for the gap size factor that, when multiplied by the local initial size field, corresponds to the size of the gap that needs to be covered.
                        """
                        pass

                    class label_selection_list(PyTextual):
                        """
                        Select one or more labels that represent the contact source. Use the Filter Text field to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class max_island_face_for_gap_cover(PyNumerical):
                        """
                        Specify the maximum face count required for isolated areas (islands) to be created during surface mesh generation. Any islands that have a face count smaller than this value will be removed, and only larger islands will remain.
                        """
                        pass

                    class object_selection_list(PyTextual):
                        """
                        Choose an object from the list below that represent the contact source. Use the Filter Text field to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class refine_wrapper_before_projection(PyParameter):
                        """
                        Parameter refine_wrapper_before_projection of value type bool.
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Choose how you want to make your selection (for instance, by object name, zone name, or label name).
                        """
                        pass

                    class sizing_method(PyTextual):
                        """
                        Determine the method for specifying the gap cover sizing controls. The Wrapper Based on Size Field option uses the size field control settings defined in the Choose Mesh Controls task. Using the Uniform Wrapper option requires you to provide a value for the Max Gap Size. If this task is located at a point in the workflow prior to the Choose Mesh Control Options task, then only the Uniform Wrapper option is available.
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                    class zone_selection_list(PyTextual):
                        """
                        Choose one or more face zones from the list below that represent the contact source. Use the Filter Text field to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _create_gap_cover:
                return super().__getitem__(key)

        class create_group(PyNamedObjectContainer):
            """
            .
            """
            class _create_group(PyMenu):
                """
                Singleton _create_group.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.new_group_name = self.__class__.new_group_name(service, rules, path + [("new_group_name", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.topology_list = self.__class__.topology_list(service, rules, path + [("topology_list", "")])
                        super().__init__(service, rules, path)

                    class new_group_name(PyTextual):
                        """
                        Parameter new_group_name of value type str.
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Parameter selection_type of value type str.
                        """
                        pass

                    class topology_list(PyTextual):
                        """
                        Parameter topology_list of value type list[str].
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _create_group:
                return super().__getitem__(key)

        class create_leak_shield(PyNamedObjectContainer):
            """
            .
            """
            class _create_leak_shield(PyMenu):
                """
                Singleton _create_leak_shield.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.dead_regions_list = self.__class__.dead_regions_list(service, rules, path + [("dead_regions_list", "")])
                        self.leak_shield_name = self.__class__.leak_shield_name(service, rules, path + [("leak_shield_name", "")])
                        self.live_mpt_selection_list = self.__class__.live_mpt_selection_list(service, rules, path + [("live_mpt_selection_list", "")])
                        self.max_hole_size = self.__class__.max_hole_size(service, rules, path + [("max_hole_size", "")])
                        self.merge_patches = self.__class__.merge_patches(service, rules, path + [("merge_patches", "")])
                        self.min_hole_size = self.__class__.min_hole_size(service, rules, path + [("min_hole_size", "")])
                        self.object_selection_list = self.__class__.object_selection_list(service, rules, path + [("object_selection_list", "")])
                        self.patch_at_live = self.__class__.patch_at_live(service, rules, path + [("patch_at_live", "")])
                        self.prompt_for_cleanup = self.__class__.prompt_for_cleanup(service, rules, path + [("prompt_for_cleanup", "")])
                        self.size_field_file_name = self.__class__.size_field_file_name(service, rules, path + [("size_field_file_name", "")])
                        self.specify_dead = self.__class__.specify_dead(service, rules, path + [("specify_dead", "")])
                        self.specify_live = self.__class__.specify_live(service, rules, path + [("specify_live", "")])
                        self.specify_obj = self.__class__.specify_obj(service, rules, path + [("specify_obj", "")])
                        self.use_size_field = self.__class__.use_size_field(service, rules, path + [("use_size_field", "")])
                        super().__init__(service, rules, path)

                    class dead_regions_list(PyTextual):
                        """
                        Parameter dead_regions_list of value type list[str].
                        """
                        pass

                    class leak_shield_name(PyTextual):
                        """
                        Parameter leak_shield_name of value type str.
                        """
                        pass

                    class live_mpt_selection_list(PyTextual):
                        """
                        Parameter live_mpt_selection_list of value type list[str].
                        """
                        pass

                    class max_hole_size(PyNumerical):
                        """
                        Parameter max_hole_size of value type float.
                        """
                        pass

                    class merge_patches(PyParameter):
                        """
                        Parameter merge_patches of value type bool.
                        """
                        pass

                    class min_hole_size(PyNumerical):
                        """
                        Parameter min_hole_size of value type float.
                        """
                        pass

                    class object_selection_list(PyTextual):
                        """
                        Parameter object_selection_list of value type list[str].
                        """
                        pass

                    class patch_at_live(PyParameter):
                        """
                        Parameter patch_at_live of value type bool.
                        """
                        pass

                    class prompt_for_cleanup(PyParameter):
                        """
                        Parameter prompt_for_cleanup of value type bool.
                        """
                        pass

                    class size_field_file_name(PyTextual):
                        """
                        Parameter size_field_file_name of value type str.
                        """
                        pass

                    class specify_dead(PyParameter):
                        """
                        Parameter specify_dead of value type bool.
                        """
                        pass

                    class specify_live(PyParameter):
                        """
                        Parameter specify_live of value type bool.
                        """
                        pass

                    class specify_obj(PyParameter):
                        """
                        Parameter specify_obj of value type bool.
                        """
                        pass

                    class use_size_field(PyTextual):
                        """
                        Parameter use_size_field of value type str.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _create_leak_shield:
                return super().__getitem__(key)

        class create_local_refinement_regions(PyNamedObjectContainer):
            """
            .
            """
            class _create_local_refinement_regions(PyMenu):
                """
                Singleton _create_local_refinement_regions.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.axis = self.__class__.axis(service, rules, path + [("axis", "")])
                        self.bounding_box_object = self.__class__.bounding_box_object(service, rules, path + [("bounding_box_object", "")])
                        self.cylinder_object = self.__class__.cylinder_object(service, rules, path + [("cylinder_object", "")])
                        self.geometry_tools_properties = self.__class__.geometry_tools_properties(service, rules, path + [("geometry_tools_properties", "")])
                        self.offset_object = self.__class__.offset_object(service, rules, path + [("offset_object", "")])
                        self.boi_max_size = self.__class__.boi_max_size(service, rules, path + [("boi_max_size", "")])
                        self.boi_size_name = self.__class__.boi_size_name(service, rules, path + [("boi_size_name", "")])
                        self.creation_method = self.__class__.creation_method(service, rules, path + [("creation_method", "")])
                        self.cylinder_length = self.__class__.cylinder_length(service, rules, path + [("cylinder_length", "")])
                        self.cylinder_method = self.__class__.cylinder_method(service, rules, path + [("cylinder_method", "")])
                        self.label_selection_list = self.__class__.label_selection_list(service, rules, path + [("label_selection_list", "")])
                        self.object_selection_list = self.__class__.object_selection_list(service, rules, path + [("object_selection_list", "")])
                        self.object_selection_single = self.__class__.object_selection_single(service, rules, path + [("object_selection_single", "")])
                        self.refinement_regions_name = self.__class__.refinement_regions_name(service, rules, path + [("refinement_regions_name", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.topology_list = self.__class__.topology_list(service, rules, path + [("topology_list", "")])
                        self.volume_fill = self.__class__.volume_fill(service, rules, path + [("volume_fill", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        self.zone_selection_list = self.__class__.zone_selection_list(service, rules, path + [("zone_selection_list", "")])
                        self.zone_selection_single = self.__class__.zone_selection_single(service, rules, path + [("zone_selection_single", "")])
                        super().__init__(service, rules, path)

                    class axis(PyMenu):
                        """
                        Singleton axis.
                        """
                        def __init__(self, service, rules, path):
                            self.x_component = self.__class__.x_component(service, rules, path + [("x_component", "")])
                            self.y_component = self.__class__.y_component(service, rules, path + [("y_component", "")])
                            self.z_component = self.__class__.z_component(service, rules, path + [("z_component", "")])
                            super().__init__(service, rules, path)

                        class x_component(PyNumerical):
                            """
                            Specify the X-component of the cylindrical vector.
                            """
                            pass

                        class y_component(PyNumerical):
                            """
                            Specify the Y-component of the cylindrical vector.
                            """
                            pass

                        class z_component(PyNumerical):
                            """
                            Specify the Z-component of the cylindrical vector.
                            """
                            pass

                    class bounding_box_object(PyMenu):
                        """
                        View the extents of the bounding box.
                        """
                        def __init__(self, service, rules, path):
                            self.size_relative_length = self.__class__.size_relative_length(service, rules, path + [("size_relative_length", "")])
                            self.xmax = self.__class__.xmax(service, rules, path + [("xmax", "")])
                            self.xmax_ratio = self.__class__.xmax_ratio(service, rules, path + [("xmax_ratio", "")])
                            self.xmin = self.__class__.xmin(service, rules, path + [("xmin", "")])
                            self.xmin_ratio = self.__class__.xmin_ratio(service, rules, path + [("xmin_ratio", "")])
                            self.ymax = self.__class__.ymax(service, rules, path + [("ymax", "")])
                            self.ymax_ratio = self.__class__.ymax_ratio(service, rules, path + [("ymax_ratio", "")])
                            self.ymin = self.__class__.ymin(service, rules, path + [("ymin", "")])
                            self.ymin_ratio = self.__class__.ymin_ratio(service, rules, path + [("ymin_ratio", "")])
                            self.zmax = self.__class__.zmax(service, rules, path + [("zmax", "")])
                            self.zmax_ratio = self.__class__.zmax_ratio(service, rules, path + [("zmax_ratio", "")])
                            self.zmin = self.__class__.zmin(service, rules, path + [("zmin", "")])
                            self.zmin_ratio = self.__class__.zmin_ratio(service, rules, path + [("zmin_ratio", "")])
                            super().__init__(service, rules, path)

                        class size_relative_length(PyTextual):
                            """
                            Determine if you would like to specify the bounding box for the refinement region as a ratio of the geometry length, or by specifying a specific location for the minimum and maximum coordinates.
                            """
                            pass

                        class xmax(PyNumerical):
                            """
                            Specify the X-coordinate for the initial position of the cylindrical refinement region.
                            """
                            pass

                        class xmax_ratio(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the X direction by the specified value. The value is the ratio relative to the geometry size in the X direction.
                            """
                            pass

                        class xmin(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the X direction by the specified value.
                            """
                            pass

                        class xmin_ratio(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the X direction by the specified value. The value is the ratio relative to the geometry size in the X direction.
                            """
                            pass

                        class ymax(PyNumerical):
                            """
                            Specify the X-coordinate for the initial position of the cylindrical refinement region.
                            """
                            pass

                        class ymax_ratio(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the Y direction by the specified value. The value is the ratio relative to the geometry size in the Y direction.
                            """
                            pass

                        class ymin(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the Y direction by the specified value.
                            """
                            pass

                        class ymin_ratio(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the Y direction by the specified value. The value is the ratio relative to the geometry size in the Y direction.
                            """
                            pass

                        class zmax(PyNumerical):
                            """
                            Specify the X-coordinate for the initial position of the cylindrical refinement region.
                            """
                            pass

                        class zmax_ratio(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the Z direction by the specified value. The value is the ratio relative to the geometry size in the Z direction.
                            """
                            pass

                        class zmin(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the Z direction by the specified value.
                            """
                            pass

                        class zmin_ratio(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the Z direction by the specified value. The value is the ratio relative to the geometry size in the Z direction.
                            """
                            pass

                    class cylinder_object(PyMenu):
                        """
                        Singleton cylinder_object.
                        """
                        def __init__(self, service, rules, path):
                            self.height_back_inc = self.__class__.height_back_inc(service, rules, path + [("height_back_inc", "")])
                            self.height_front_inc = self.__class__.height_front_inc(service, rules, path + [("height_front_inc", "")])
                            self.height_node = self.__class__.height_node(service, rules, path + [("height_node", "")])
                            self.node_1 = self.__class__.node_1(service, rules, path + [("node_1", "")])
                            self.node_2 = self.__class__.node_2(service, rules, path + [("node_2", "")])
                            self.node_3 = self.__class__.node_3(service, rules, path + [("node_3", "")])
                            self.radius_1 = self.__class__.radius_1(service, rules, path + [("radius_1", "")])
                            self.radius_2 = self.__class__.radius_2(service, rules, path + [("radius_2", "")])
                            self.x1 = self.__class__.x1(service, rules, path + [("x1", "")])
                            self.x2 = self.__class__.x2(service, rules, path + [("x2", "")])
                            self.x_offset = self.__class__.x_offset(service, rules, path + [("x_offset", "")])
                            self.y1 = self.__class__.y1(service, rules, path + [("y1", "")])
                            self.y2 = self.__class__.y2(service, rules, path + [("y2", "")])
                            self.y_offset = self.__class__.y_offset(service, rules, path + [("y_offset", "")])
                            self.z1 = self.__class__.z1(service, rules, path + [("z1", "")])
                            self.z2 = self.__class__.z2(service, rules, path + [("z2", "")])
                            self.z_offset = self.__class__.z_offset(service, rules, path + [("z_offset", "")])
                            super().__init__(service, rules, path)

                        class height_back_inc(PyNumerical):
                            """
                            Parameter height_back_inc of value type float.
                            """
                            pass

                        class height_front_inc(PyNumerical):
                            """
                            Parameter height_front_inc of value type float.
                            """
                            pass

                        class height_node(PyTextual):
                            """
                            Parameter height_node of value type str.
                            """
                            pass

                        class node_1(PyTextual):
                            """
                            Parameter node_1 of value type str.
                            """
                            pass

                        class node_2(PyTextual):
                            """
                            Parameter node_2 of value type str.
                            """
                            pass

                        class node_3(PyTextual):
                            """
                            Parameter node_3 of value type str.
                            """
                            pass

                        class radius_1(PyNumerical):
                            """
                            Specify the radius of the cylinder at the initial position.
                            """
                            pass

                        class radius_2(PyNumerical):
                            """
                            Specify the radius of the cylinder at the second position.
                            """
                            pass

                        class x1(PyNumerical):
                            """
                            Specify the X-coordinate of the first position of the cylinder.
                            """
                            pass

                        class x2(PyNumerical):
                            """
                            Specify the X-coordinate of the second position of the cylinder.
                            """
                            pass

                        class x_offset(PyNumerical):
                            """
                            Specify the X-coordinate for the offset of the initial position of the cylinder.
                            """
                            pass

                        class y1(PyNumerical):
                            """
                            Specify the Y-coordinate of the first position of the cylinder.
                            """
                            pass

                        class y2(PyNumerical):
                            """
                            Specify the Y-coordinate of the second position of the cylinder.
                            """
                            pass

                        class y_offset(PyNumerical):
                            """
                            Specify the Y-coordinate for the offset of the initial position of the cylinder.
                            """
                            pass

                        class z1(PyNumerical):
                            """
                            Specify the Z-coordinate of the first position of the cylinder.
                            """
                            pass

                        class z2(PyNumerical):
                            """
                            Specify the Z-coordinate of the second position of the cylinder.
                            """
                            pass

                        class z_offset(PyNumerical):
                            """
                            Specify the Z-coordinate for the offset of the initial position of the cylinder.
                            """
                            pass

                    class geometry_tools_properties(PyMenu):
                        """
                        Singleton geometry_tools_properties.
                        """
                        def __init__(self, service, rules, path):
                            self.box_center_x = self.__class__.box_center_x(service, rules, path + [("box_center_x", "")])
                            self.box_center_y = self.__class__.box_center_y(service, rules, path + [("box_center_y", "")])
                            self.box_center_z = self.__class__.box_center_z(service, rules, path + [("box_center_z", "")])
                            self.box_x_length = self.__class__.box_x_length(service, rules, path + [("box_x_length", "")])
                            self.box_y_length = self.__class__.box_y_length(service, rules, path + [("box_y_length", "")])
                            self.box_z_length = self.__class__.box_z_length(service, rules, path + [("box_z_length", "")])
                            self.cylinder_radius_1 = self.__class__.cylinder_radius_1(service, rules, path + [("cylinder_radius_1", "")])
                            self.cylinder_radius_2 = self.__class__.cylinder_radius_2(service, rules, path + [("cylinder_radius_2", "")])
                            self.cylinder_x1 = self.__class__.cylinder_x1(service, rules, path + [("cylinder_x1", "")])
                            self.cylinder_x2 = self.__class__.cylinder_x2(service, rules, path + [("cylinder_x2", "")])
                            self.cylinder_y1 = self.__class__.cylinder_y1(service, rules, path + [("cylinder_y1", "")])
                            self.cylinder_y2 = self.__class__.cylinder_y2(service, rules, path + [("cylinder_y2", "")])
                            self.cylinder_z1 = self.__class__.cylinder_z1(service, rules, path + [("cylinder_z1", "")])
                            self.cylinder_z2 = self.__class__.cylinder_z2(service, rules, path + [("cylinder_z2", "")])
                            super().__init__(service, rules, path)

                        class box_center_x(PyNumerical):
                            """
                            Specify the X-coordinate for the initial position of the cylindrical refinement region.
                            """
                            pass

                        class box_center_y(PyNumerical):
                            """
                            Specify the Y-coordinate for the initial position of the cylindrical refinement region.
                            """
                            pass

                        class box_center_z(PyNumerical):
                            """
                            Specify the Z-coordinate for the initial position of the cylindrical refinement region.
                            """
                            pass

                        class box_x_length(PyNumerical):
                            """
                            Parameter box_x_length of value type float.
                            """
                            pass

                        class box_y_length(PyNumerical):
                            """
                            Parameter box_y_length of value type float.
                            """
                            pass

                        class box_z_length(PyNumerical):
                            """
                            Parameter box_z_length of value type float.
                            """
                            pass

                        class cylinder_radius_1(PyNumerical):
                            """
                            Specify the radius of the cylinder at the initial position.
                            """
                            pass

                        class cylinder_radius_2(PyNumerical):
                            """
                            Specify the radius of the cylinder at the second position.
                            """
                            pass

                        class cylinder_x1(PyNumerical):
                            """
                            Specify the X-coordinate of the first position of the cylinder.
                            """
                            pass

                        class cylinder_x2(PyNumerical):
                            """
                            Specify the X-coordinate of the second position of the cylinder.
                            """
                            pass

                        class cylinder_y1(PyNumerical):
                            """
                            Specify the Y-coordinate of the first position of the cylinder.
                            """
                            pass

                        class cylinder_y2(PyNumerical):
                            """
                            Specify the Y-coordinate of the second position of the cylinder.
                            """
                            pass

                        class cylinder_z1(PyNumerical):
                            """
                            Specify the Z-coordinate of the first position of the cylinder.
                            """
                            pass

                        class cylinder_z2(PyNumerical):
                            """
                            Specify the Z-coordinate of the second position of the cylinder.
                            """
                            pass

                    class offset_object(PyMenu):
                        """
                        These fields contain parameters that define the characteristics of the refinements region (direction, thickness, levels, etc.)
                        """
                        def __init__(self, service, rules, path):
                            self.aspect_ratio = self.__class__.aspect_ratio(service, rules, path + [("aspect_ratio", "")])
                            self.boundary_layer_height = self.__class__.boundary_layer_height(service, rules, path + [("boundary_layer_height", "")])
                            self.boundary_layer_levels = self.__class__.boundary_layer_levels(service, rules, path + [("boundary_layer_levels", "")])
                            self.cross_wake_growth_factor = self.__class__.cross_wake_growth_factor(service, rules, path + [("cross_wake_growth_factor", "")])
                            self.defeaturing_size = self.__class__.defeaturing_size(service, rules, path + [("defeaturing_size", "")])
                            self.edge_selection_list = self.__class__.edge_selection_list(service, rules, path + [("edge_selection_list", "")])
                            self.first_height = self.__class__.first_height(service, rules, path + [("first_height", "")])
                            self.flip_direction = self.__class__.flip_direction(service, rules, path + [("flip_direction", "")])
                            self.flow_direction = self.__class__.flow_direction(service, rules, path + [("flow_direction", "")])
                            self.last_ratio_percentage = self.__class__.last_ratio_percentage(service, rules, path + [("last_ratio_percentage", "")])
                            self.mpt_method_type = self.__class__.mpt_method_type(service, rules, path + [("mpt_method_type", "")])
                            self.number_of_layers = self.__class__.number_of_layers(service, rules, path + [("number_of_layers", "")])
                            self.offset_method_type = self.__class__.offset_method_type(service, rules, path + [("offset_method_type", "")])
                            self.rate = self.__class__.rate(service, rules, path + [("rate", "")])
                            self.show_coordinates = self.__class__.show_coordinates(service, rules, path + [("show_coordinates", "")])
                            self.wake_growth_factor = self.__class__.wake_growth_factor(service, rules, path + [("wake_growth_factor", "")])
                            self.wake_levels = self.__class__.wake_levels(service, rules, path + [("wake_levels", "")])
                            self.x = self.__class__.x(service, rules, path + [("x", "")])
                            self.y = self.__class__.y(service, rules, path + [("y", "")])
                            self.z = self.__class__.z(service, rules, path + [("z", "")])
                            super().__init__(service, rules, path)

                        class aspect_ratio(PyNumerical):
                            """
                            Parameter aspect_ratio of value type float.
                            """
                            pass

                        class boundary_layer_height(PyNumerical):
                            """
                            Specify the total height of the boundary layer for this refinement region (this is flow in the vicinity).
                            """
                            pass

                        class boundary_layer_levels(PyNumerical):
                            """
                            Specify the number of boundary layers that are to be captured in the refinement region.
                            """
                            pass

                        class cross_wake_growth_factor(PyNumerical):
                            """
                            Specify the factor by which the refinement region expands in the rest of the directions.
                            """
                            pass

                        class defeaturing_size(PyNumerical):
                            """
                            Specify a value that is used to obtain a rough shape of the selected object(s). The larger the value, the more approximate the shape.
                            """
                            pass

                        class edge_selection_list(PyTextual):
                            """
                            Parameter edge_selection_list of value type list[str].
                            """
                            pass

                        class first_height(PyNumerical):
                            """
                            Parameter first_height of value type float.
                            """
                            pass

                        class flip_direction(PyParameter):
                            """
                            Reverses the orientation of the refinement region.
                            """
                            pass

                        class flow_direction(PyTextual):
                            """
                            Specify the direction that the flow through this refinement region.
                            """
                            pass

                        class last_ratio_percentage(PyNumerical):
                            """
                            Parameter last_ratio_percentage of value type float.
                            """
                            pass

                        class mpt_method_type(PyTextual):
                            """
                            Parameter mpt_method_type of value type str.
                            """
                            pass

                        class number_of_layers(PyNumerical):
                            """
                            Parameter number_of_layers of value type int.
                            """
                            pass

                        class offset_method_type(PyTextual):
                            """
                            Parameter offset_method_type of value type str.
                            """
                            pass

                        class rate(PyNumerical):
                            """
                            Parameter rate of value type float.
                            """
                            pass

                        class show_coordinates(PyParameter):
                            """
                            Parameter show_coordinates of value type bool.
                            """
                            pass

                        class wake_growth_factor(PyNumerical):
                            """
                            Specify the factor by which the refinement region expands in the wake of the flow direction.
                            """
                            pass

                        class wake_levels(PyNumerical):
                            """
                            Specify the number of refinement layers that will appear in the wake.
                            """
                            pass

                        class x(PyNumerical):
                            """
                            Specify the X-coordinate for the initial position of the cylindrical refinement region.
                            """
                            pass

                        class y(PyNumerical):
                            """
                            Specify the Y-coordinate for the initial position of the cylindrical refinement region.
                            """
                            pass

                        class z(PyNumerical):
                            """
                            Specify the Z-coordinate for the initial position of the cylindrical refinement region.
                            """
                            pass

                    class boi_max_size(PyNumerical):
                        """
                        Specify the cell size for the refinement region mesh.
                        """
                        pass

                    class boi_size_name(PyTextual):
                        """
                        Parameter boi_size_name of value type str.
                        """
                        pass

                    class creation_method(PyTextual):
                        """
                        Choose how you want to create the refinement region: by creating a bounding box, a cylindrical bounding region, or using an offset surface. You should select a closed body for the offset surface.
                        """
                        pass

                    class cylinder_length(PyNumerical):
                        """
                        Specify the Length of the cylinder.
                        """
                        pass

                    class cylinder_method(PyTextual):
                        """
                        Choose how the cylindrical refinement region will be defined. The Vector and Length option allows you to define the cylindrical refinement region based either on the location of selected object(s) or zone(s), or by coordinates. If you choose to select by object(s) or zone(s), the location of the cylindrical refinement region will be at the center point of the selected surface. The Two Positions option allows you to explicitly define the location and dimension of the cylindrical refinement region without having to select object(s) or zone(s).
                        """
                        pass

                    class label_selection_list(PyTextual):
                        """
                        Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class object_selection_list(PyTextual):
                        """
                        Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class object_selection_single(PyTextual):
                        """
                        Choose a single object from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class refinement_regions_name(PyTextual):
                        """
                        Enter a name for the body of influence.
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Choose how you want to make your selection (by object, label, or zone name).
                        """
                        pass

                    class topology_list(PyTextual):
                        """
                        Parameter topology_list of value type list[str].
                        """
                        pass

                    class volume_fill(PyTextual):
                        """
                        Parameter volume_fill of value type str.
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                    class zone_selection_list(PyTextual):
                        """
                        Choose one or more zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class zone_selection_single(PyTextual):
                        """
                        Parameter zone_selection_single of value type list[str].
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _create_local_refinement_regions:
                return super().__getitem__(key)

        class create_mesh_objects(PyNamedObjectContainer):
            """
            .
            """
            class _create_mesh_objects(PyMenu):
                """
                Singleton _create_mesh_objects.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.create_a_face_zone_per_body = self.__class__.create_a_face_zone_per_body(service, rules, path + [("create_a_face_zone_per_body", "")])
                        self.merge_zones_based_on_labels = self.__class__.merge_zones_based_on_labels(service, rules, path + [("merge_zones_based_on_labels", "")])
                        super().__init__(service, rules, path)

                    class create_a_face_zone_per_body(PyParameter):
                        """
                        Parameter create_a_face_zone_per_body of value type bool.
                        """
                        pass

                    class merge_zones_based_on_labels(PyParameter):
                        """
                        Parameter merge_zones_based_on_labels of value type bool.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _create_mesh_objects:
                return super().__getitem__(key)

        class create_multizone_mesh(PyNamedObjectContainer):
            """
            .
            """
            class _create_multizone_mesh(PyMenu):
                """
                Singleton _create_multizone_mesh.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.cfd_surface_mesh_controls = self.__class__.cfd_surface_mesh_controls(service, rules, path + [("cfd_surface_mesh_controls", "")])
                        self.body_label_body_list = self.__class__.body_label_body_list(service, rules, path + [("body_label_body_list", "")])
                        self.body_label_list = self.__class__.body_label_list(service, rules, path + [("body_label_list", "")])
                        self.cell_zone_list = self.__class__.cell_zone_list(service, rules, path + [("cell_zone_list", "")])
                        self.complete_region_scope = self.__class__.complete_region_scope(service, rules, path + [("complete_region_scope", "")])
                        self.merge_body_labels = self.__class__.merge_body_labels(service, rules, path + [("merge_body_labels", "")])
                        self.meshing_strategy = self.__class__.meshing_strategy(service, rules, path + [("meshing_strategy", "")])
                        self.non_conformal = self.__class__.non_conformal(service, rules, path + [("non_conformal", "")])
                        self.orthogonal_quality_limit = self.__class__.orthogonal_quality_limit(service, rules, path + [("orthogonal_quality_limit", "")])
                        self.re_merge_zones = self.__class__.re_merge_zones(service, rules, path + [("re_merge_zones", "")])
                        self.region_scope = self.__class__.region_scope(service, rules, path + [("region_scope", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.size_function_scale_factor = self.__class__.size_function_scale_factor(service, rules, path + [("size_function_scale_factor", "")])
                        super().__init__(service, rules, path)

                    class cfd_surface_mesh_controls(PyMenu):
                        """
                        Singleton cfd_surface_mesh_controls.
                        """
                        def __init__(self, service, rules, path):
                            self.auto_create_scoped_sizing = self.__class__.auto_create_scoped_sizing(service, rules, path + [("auto_create_scoped_sizing", "")])
                            self.cells_per_gap = self.__class__.cells_per_gap(service, rules, path + [("cells_per_gap", "")])
                            self.curvature_normal_angle = self.__class__.curvature_normal_angle(service, rules, path + [("curvature_normal_angle", "")])
                            self.draw_size_control = self.__class__.draw_size_control(service, rules, path + [("draw_size_control", "")])
                            self.growth_rate = self.__class__.growth_rate(service, rules, path + [("growth_rate", "")])
                            self.max_size = self.__class__.max_size(service, rules, path + [("max_size", "")])
                            self.min_size = self.__class__.min_size(service, rules, path + [("min_size", "")])
                            self.object_based_controls = self.__class__.object_based_controls(service, rules, path + [("object_based_controls", "")])
                            self.preview_sizefield = self.__class__.preview_sizefield(service, rules, path + [("preview_sizefield", "")])
                            self.refacet = self.__class__.refacet(service, rules, path + [("refacet", "")])
                            self.remesh_imported_mesh = self.__class__.remesh_imported_mesh(service, rules, path + [("remesh_imported_mesh", "")])
                            self.save_size_field = self.__class__.save_size_field(service, rules, path + [("save_size_field", "")])
                            self.save_size_field_file = self.__class__.save_size_field_file(service, rules, path + [("save_size_field_file", "")])
                            self.scope_proximity_to = self.__class__.scope_proximity_to(service, rules, path + [("scope_proximity_to", "")])
                            self.size_control_file = self.__class__.size_control_file(service, rules, path + [("size_control_file", "")])
                            self.size_field_file = self.__class__.size_field_file(service, rules, path + [("size_field_file", "")])
                            self.size_functions = self.__class__.size_functions(service, rules, path + [("size_functions", "")])
                            self.surface_mesh_method = self.__class__.surface_mesh_method(service, rules, path + [("surface_mesh_method", "")])
                            self.use_size_files = self.__class__.use_size_files(service, rules, path + [("use_size_files", "")])
                            super().__init__(service, rules, path)

                        class auto_create_scoped_sizing(PyParameter):
                            """
                            Parameter auto_create_scoped_sizing of value type bool.
                            """
                            pass

                        class cells_per_gap(PyNumerical):
                            """
                            Parameter cells_per_gap of value type float.
                            """
                            pass

                        class curvature_normal_angle(PyNumerical):
                            """
                            Parameter curvature_normal_angle of value type float.
                            """
                            pass

                        class draw_size_control(PyParameter):
                            """
                            Parameter draw_size_control of value type bool.
                            """
                            pass

                        class growth_rate(PyNumerical):
                            """
                            Parameter growth_rate of value type float.
                            """
                            pass

                        class max_size(PyNumerical):
                            """
                            Parameter max_size of value type float.
                            """
                            pass

                        class min_size(PyNumerical):
                            """
                            Parameter min_size of value type float.
                            """
                            pass

                        class object_based_controls(PyParameter):
                            """
                            Parameter object_based_controls of value type bool.
                            """
                            pass

                        class preview_sizefield(PyParameter):
                            """
                            Parameter preview_sizefield of value type bool.
                            """
                            pass

                        class refacet(PyParameter):
                            """
                            Parameter refacet of value type bool.
                            """
                            pass

                        class remesh_imported_mesh(PyTextual):
                            """
                            Parameter remesh_imported_mesh of value type str.
                            """
                            pass

                        class save_size_field(PyParameter):
                            """
                            Parameter save_size_field of value type bool.
                            """
                            pass

                        class save_size_field_file(PyTextual):
                            """
                            Parameter save_size_field_file of value type str.
                            """
                            pass

                        class scope_proximity_to(PyTextual):
                            """
                            Parameter scope_proximity_to of value type str.
                            """
                            pass

                        class size_control_file(PyTextual):
                            """
                            Parameter size_control_file of value type str.
                            """
                            pass

                        class size_field_file(PyTextual):
                            """
                            Parameter size_field_file of value type str.
                            """
                            pass

                        class size_functions(PyTextual):
                            """
                            Parameter size_functions of value type str.
                            """
                            pass

                        class surface_mesh_method(PyTextual):
                            """
                            Parameter surface_mesh_method of value type str.
                            """
                            pass

                        class use_size_files(PyTextual):
                            """
                            Parameter use_size_files of value type str.
                            """
                            pass

                    class body_label_body_list(PyTextual):
                        """
                        Parameter body_label_body_list of value type list[str].
                        """
                        pass

                    class body_label_list(PyTextual):
                        """
                        Parameter body_label_list of value type list[str].
                        """
                        pass

                    class cell_zone_list(PyTextual):
                        """
                        Parameter cell_zone_list of value type list[str].
                        """
                        pass

                    class complete_region_scope(PyTextual):
                        """
                        Select the named region(s) from the list to which you would like to generate the multi-zone mesh. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class merge_body_labels(PyParameter):
                        """
                        Parameter merge_body_labels of value type bool.
                        """
                        pass

                    class meshing_strategy(PyTextual):
                        """
                        Parameter meshing_strategy of value type str.
                        """
                        pass

                    class non_conformal(PyTextual):
                        """
                        Optionally specify that multizone regions are non-conformally connected to other volumetric regions.  If you want to have a conformal mesh but, because of meshing constraints, that is not possible, then you can switch to non-conformal here and avoid doing so in the CAD model.
                        """
                        pass

                    class orthogonal_quality_limit(PyNumerical):
                        """
                        This value sets the threshold for when mesh quality improvements are automatically invoked that employ the orthogonal quality limit, and is recommended to be around 0.04.
                        """
                        pass

                    class re_merge_zones(PyParameter):
                        """
                        Parameter re_merge_zones of value type bool.
                        """
                        pass

                    class region_scope(PyTextual):
                        """
                        Select the named region(s) from the list to which you would like to generate the multi-zone mesh. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Parameter selection_type of value type str.
                        """
                        pass

                    class size_function_scale_factor(PyNumerical):
                        """
                        Enable the scaling of the multizone mesh. In some cases when the multizone region is too coarse when compared to the adjacent surface mesh, a connection is not possible. You can specify a size function scaling factor here to improve the sizing match between the multizone and the non-multizone regions and avoid any free faces. Typically, a value between 0.7 and 0.8 is recommended.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _create_multizone_mesh:
                return super().__getitem__(key)

        class create_overset_mesh(PyNamedObjectContainer):
            """
            .
            """
            class _create_overset_mesh(PyMenu):
                """
                Singleton _create_overset_mesh.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.object_selection_list = self.__class__.object_selection_list(service, rules, path + [("object_selection_list", "")])
                        self.overset_interfaces_name = self.__class__.overset_interfaces_name(service, rules, path + [("overset_interfaces_name", "")])
                        super().__init__(service, rules, path)

                    class object_selection_list(PyTextual):
                        """
                        Select one or more overset mesh objects that will make up the mesh interface. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class overset_interfaces_name(PyTextual):
                        """
                        Specify a name for the overset mesh interface or use the default value.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _create_overset_mesh:
                return super().__getitem__(key)

        class create_porous_regions(PyNamedObjectContainer):
            """
            .
            """
            class _create_porous_regions(PyMenu):
                """
                Singleton _create_porous_regions.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.non_rectangular_parameters = self.__class__.non_rectangular_parameters(service, rules, path + [("non_rectangular_parameters", "")])
                        self.buffer_size_ratio = self.__class__.buffer_size_ratio(service, rules, path + [("buffer_size_ratio", "")])
                        self.cell_size_p1_p2 = self.__class__.cell_size_p1_p2(service, rules, path + [("cell_size_p1_p2", "")])
                        self.cell_size_p1_p3 = self.__class__.cell_size_p1_p3(service, rules, path + [("cell_size_p1_p3", "")])
                        self.cell_size_p1_p4 = self.__class__.cell_size_p1_p4(service, rules, path + [("cell_size_p1_p4", "")])
                        self.file_name = self.__class__.file_name(service, rules, path + [("file_name", "")])
                        self.input_method = self.__class__.input_method(service, rules, path + [("input_method", "")])
                        self.location = self.__class__.location(service, rules, path + [("location", "")])
                        self.p1 = self.__class__.p1(service, rules, path + [("p1", "")])
                        self.p2 = self.__class__.p2(service, rules, path + [("p2", "")])
                        self.p3 = self.__class__.p3(service, rules, path + [("p3", "")])
                        self.p4 = self.__class__.p4(service, rules, path + [("p4", "")])
                        self.porous_region_name = self.__class__.porous_region_name(service, rules, path + [("porous_region_name", "")])
                        self.wrapper_size_factor = self.__class__.wrapper_size_factor(service, rules, path + [("wrapper_size_factor", "")])
                        super().__init__(service, rules, path)

                    class non_rectangular_parameters(PyMenu):
                        """
                        Singleton non_rectangular_parameters.
                        """
                        def __init__(self, service, rules, path):
                            self.buffer_size = self.__class__.buffer_size(service, rules, path + [("buffer_size", "")])
                            self.feature_angle = self.__class__.feature_angle(service, rules, path + [("feature_angle", "")])
                            self.flip_direction = self.__class__.flip_direction(service, rules, path + [("flip_direction", "")])
                            self.label_selection_list = self.__class__.label_selection_list(service, rules, path + [("label_selection_list", "")])
                            self.mesh_size = self.__class__.mesh_size(service, rules, path + [("mesh_size", "")])
                            self.non_rectangular_buffer_size = self.__class__.non_rectangular_buffer_size(service, rules, path + [("non_rectangular_buffer_size", "")])
                            self.number_of_layers = self.__class__.number_of_layers(service, rules, path + [("number_of_layers", "")])
                            self.object_selection_list = self.__class__.object_selection_list(service, rules, path + [("object_selection_list", "")])
                            self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                            self.thickness = self.__class__.thickness(service, rules, path + [("thickness", "")])
                            self.zone_selection_list = self.__class__.zone_selection_list(service, rules, path + [("zone_selection_list", "")])
                            super().__init__(service, rules, path)

                        class buffer_size(PyNumerical):
                            """
                            Specify a value for the buffer size. The buffer is created as an extra layer. The thickness is equivalent to the product of the buffer size ratio and the core thickness. The core thickness is the distance between P1 and P4.
                            """
                            pass

                        class feature_angle(PyNumerical):
                            """
                            Specify the angle at which features will be extracted for the porous region.
                            """
                            pass

                        class flip_direction(PyParameter):
                            """
                            Reverses the orientation of the porous region.
                            """
                            pass

                        class label_selection_list(PyTextual):
                            """
                            Select a single label that will correspond to the porous region. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                            """
                            pass

                        class mesh_size(PyNumerical):
                            """
                            Specify the cell size for the porous region mesh.
                            """
                            pass

                        class non_rectangular_buffer_size(PyNumerical):
                            """
                            Specify a value for the buffer size. The buffer is created as an extra layer. The thickness is equivalent to the product of the buffer size ratio and the core thickness. The core thickness is the distance between P1 and P4.
                            """
                            pass

                        class number_of_layers(PyNumerical):
                            """
                            Specify the number of layers, or divisions, along the thickness of the porous region.
                            """
                            pass

                        class object_selection_list(PyTextual):
                            """
                            Choose a single object (or void) from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                            """
                            pass

                        class selection_type(PyTextual):
                            """
                            Choose how you want to make your selection (by object, zone, or label).
                            """
                            pass

                        class thickness(PyNumerical):
                            """
                            Specify the thickness (or the total height) of the porous region.
                            """
                            pass

                        class zone_selection_list(PyTextual):
                            """
                            Choose a single face zone from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                            """
                            pass

                    class buffer_size_ratio(PyNumerical):
                        """
                        Specify a value for the buffer size ratio. The buffer is created as an extra layer. The thickness is equivalent to the product of the buffer size ratio and the core thickness. The core thickness is the distance between P1 and P4.
                        """
                        pass

                    class cell_size_p1_p2(PyNumerical):
                        """
                        Specify the size of the cells that lie between P1 and P2 of the porous region. P1 is the first point designated for the porous region; P2 is the second point of the porous region - created to the left of P1 in the same plane.
                        """
                        pass

                    class cell_size_p1_p3(PyNumerical):
                        """
                        Specify the size of the cells that lie between P1 and P3 of the porous region. P1 is the first point designated for the porous region; P3 is the third point of the porous region - created above P1 in the same plane.
                        """
                        pass

                    class cell_size_p1_p4(PyNumerical):
                        """
                        Specify the size of the cells that lie between P1 and P4 of the porous region. P1 is the first point designated for the porous region; P4 is the fourth point of the porous region - created in relation to P1 to essentially define a thickness for the porous region.
                        """
                        pass

                    class file_name(PyTextual):
                        """
                        Specify the name and location of the text file containing the porous region definition.  More...
                        """
                        pass

                    class input_method(PyTextual):
                        """
                        Indicate whether you are creating the porous region using Direct coordinates, by using a Text file, or by specifying a Nonrectangular region.
                        """
                        pass

                    class location(PyTextual):
                        """
                        Specify how you would like to determine the location of the porous region.
                        """
                        pass

                    class p1(PyParameter):
                        """
                        Parameter p1 of value type list[float].
                        """
                        pass

                    class p2(PyParameter):
                        """
                        Parameter p2 of value type list[float].
                        """
                        pass

                    class p3(PyParameter):
                        """
                        Parameter p3 of value type list[float].
                        """
                        pass

                    class p4(PyParameter):
                        """
                        Parameter p4 of value type list[float].
                        """
                        pass

                    class porous_region_name(PyTextual):
                        """
                        Specify a name for the porous region or use the default value.
                        """
                        pass

                    class wrapper_size_factor(PyNumerical):
                        """
                        Parameter wrapper_size_factor of value type float.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _create_porous_regions:
                return super().__getitem__(key)

        class create_regions(PyNamedObjectContainer):
            """
            .
            """
            class _create_regions(PyMenu):
                """
                Singleton _create_regions.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.mesh_object = self.__class__.mesh_object(service, rules, path + [("mesh_object", "")])
                        self.number_of_flow_volumes = self.__class__.number_of_flow_volumes(service, rules, path + [("number_of_flow_volumes", "")])
                        self.retain_dead_region_name = self.__class__.retain_dead_region_name(service, rules, path + [("retain_dead_region_name", "")])
                        super().__init__(service, rules, path)

                    class mesh_object(PyTextual):
                        """
                        Parameter mesh_object of value type str.
                        """
                        pass

                    class number_of_flow_volumes(PyNumerical):
                        """
                        Confirm the number of flow volumes required for the analysis. The system will detect additional regions if they exist, however, it will detect fluid regions only where they are connected to capping surfaces.
                        """
                        pass

                    class retain_dead_region_name(PyParameter):
                        """
                        If any dead regions are present, you can choose to determine how such regions are named. Voids or dead regions are usually named dead0, dead1, dead2, and so on, and can remain so when this prompt is set to no. When this prompt is set to yes, however, the dead region names will also be prefixed with the original dead region name (usually derived from an adjacent region), such as dead0-fluid:1, dead1-fluid:2, and so on.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _create_regions:
                return super().__getitem__(key)

        class create_surface_mesh(PyNamedObjectContainer):
            """
            .
            """
            class _create_surface_mesh(PyMenu):
                """
                Singleton _create_surface_mesh.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.cad_faceting_controls = self.__class__.cad_faceting_controls(service, rules, path + [("cad_faceting_controls", "")])
                        self.cad_import_options = self.__class__.cad_import_options(service, rules, path + [("cad_import_options", "")])
                        self.cfd_surface_mesh_controls = self.__class__.cfd_surface_mesh_controls(service, rules, path + [("cfd_surface_mesh_controls", "")])
                        self.share_topology_preferences = self.__class__.share_topology_preferences(service, rules, path + [("share_topology_preferences", "")])
                        self.surface_mesh_preferences = self.__class__.surface_mesh_preferences(service, rules, path + [("surface_mesh_preferences", "")])
                        self.append_mesh = self.__class__.append_mesh(service, rules, path + [("append_mesh", "")])
                        self.cad_faceting_file_name = self.__class__.cad_faceting_file_name(service, rules, path + [("cad_faceting_file_name", "")])
                        self.directory = self.__class__.directory(service, rules, path + [("directory", "")])
                        self.execute_share_topology = self.__class__.execute_share_topology(service, rules, path + [("execute_share_topology", "")])
                        self.import_type = self.__class__.import_type(service, rules, path + [("import_type", "")])
                        self.length_unit = self.__class__.length_unit(service, rules, path + [("length_unit", "")])
                        self.original_zones = self.__class__.original_zones(service, rules, path + [("original_zones", "")])
                        self.pattern = self.__class__.pattern(service, rules, path + [("pattern", "")])
                        self.preview_size_toggle = self.__class__.preview_size_toggle(service, rules, path + [("preview_size_toggle", "")])
                        self.remesh_label_list = self.__class__.remesh_label_list(service, rules, path + [("remesh_label_list", "")])
                        self.remesh_selection_type = self.__class__.remesh_selection_type(service, rules, path + [("remesh_selection_type", "")])
                        self.remesh_zone_list = self.__class__.remesh_zone_list(service, rules, path + [("remesh_zone_list", "")])
                        self.separation_angle = self.__class__.separation_angle(service, rules, path + [("separation_angle", "")])
                        self.separation_required = self.__class__.separation_required(service, rules, path + [("separation_required", "")])
                        self.tesselation_method = self.__class__.tesselation_method(service, rules, path + [("tesselation_method", "")])
                        super().__init__(service, rules, path)

                    class cad_faceting_controls(PyMenu):
                        """
                        Singleton cad_faceting_controls.
                        """
                        def __init__(self, service, rules, path):
                            self.max_size = self.__class__.max_size(service, rules, path + [("max_size", "")])
                            self.refine_faceting = self.__class__.refine_faceting(service, rules, path + [("refine_faceting", "")])
                            self.tolerance = self.__class__.tolerance(service, rules, path + [("tolerance", "")])
                            super().__init__(service, rules, path)

                        class max_size(PyNumerical):
                            """
                            Specify the maximum size of the elements for the surface mesh.
                            """
                            pass

                        class refine_faceting(PyParameter):
                            """
                            Parameter refine_faceting of value type bool.
                            """
                            pass

                        class tolerance(PyNumerical):
                            """
                            Parameter tolerance of value type float.
                            """
                            pass

                    class cad_import_options(PyMenu):
                        """
                        Singleton cad_import_options.
                        """
                        def __init__(self, service, rules, path):
                            self.create_cad_assemblies = self.__class__.create_cad_assemblies(service, rules, path + [("create_cad_assemblies", "")])
                            self.extract_features = self.__class__.extract_features(service, rules, path + [("extract_features", "")])
                            self.feature_angle = self.__class__.feature_angle(service, rules, path + [("feature_angle", "")])
                            self.import_curvature_data_from_cad = self.__class__.import_curvature_data_from_cad(service, rules, path + [("import_curvature_data_from_cad", "")])
                            self.import_named_selections = self.__class__.import_named_selections(service, rules, path + [("import_named_selections", "")])
                            self.import_part_names = self.__class__.import_part_names(service, rules, path + [("import_part_names", "")])
                            self.one_object_per = self.__class__.one_object_per(service, rules, path + [("one_object_per", "")])
                            self.one_zone_per = self.__class__.one_zone_per(service, rules, path + [("one_zone_per", "")])
                            self.open_all_cad_in_subdirectories = self.__class__.open_all_cad_in_subdirectories(service, rules, path + [("open_all_cad_in_subdirectories", "")])
                            self.save_pmdb_intermediate_file = self.__class__.save_pmdb_intermediate_file(service, rules, path + [("save_pmdb_intermediate_file", "")])
                            self.use_part_or_body_as_suffix = self.__class__.use_part_or_body_as_suffix(service, rules, path + [("use_part_or_body_as_suffix", "")])
                            super().__init__(service, rules, path)

                        class create_cad_assemblies(PyParameter):
                            """
                            Parameter create_cad_assemblies of value type bool.
                            """
                            pass

                        class extract_features(PyParameter):
                            """
                            Parameter extract_features of value type bool.
                            """
                            pass

                        class feature_angle(PyNumerical):
                            """
                            Parameter feature_angle of value type float.
                            """
                            pass

                        class import_curvature_data_from_cad(PyParameter):
                            """
                            Parameter import_curvature_data_from_cad of value type bool.
                            """
                            pass

                        class import_named_selections(PyParameter):
                            """
                            Parameter import_named_selections of value type bool.
                            """
                            pass

                        class import_part_names(PyParameter):
                            """
                            Parameter import_part_names of value type bool.
                            """
                            pass

                        class one_object_per(PyTextual):
                            """
                            Parameter one_object_per of value type str.
                            """
                            pass

                        class one_zone_per(PyTextual):
                            """
                            Parameter one_zone_per of value type str.
                            """
                            pass

                        class open_all_cad_in_subdirectories(PyParameter):
                            """
                            Parameter open_all_cad_in_subdirectories of value type bool.
                            """
                            pass

                        class save_pmdb_intermediate_file(PyParameter):
                            """
                            Parameter save_pmdb_intermediate_file of value type bool.
                            """
                            pass

                        class use_part_or_body_as_suffix(PyParameter):
                            """
                            Parameter use_part_or_body_as_suffix of value type bool.
                            """
                            pass

                    class cfd_surface_mesh_controls(PyMenu):
                        """
                        Singleton cfd_surface_mesh_controls.
                        """
                        def __init__(self, service, rules, path):
                            self.auto_create_scoped_sizing = self.__class__.auto_create_scoped_sizing(service, rules, path + [("auto_create_scoped_sizing", "")])
                            self.cells_per_gap = self.__class__.cells_per_gap(service, rules, path + [("cells_per_gap", "")])
                            self.curvature_normal_angle = self.__class__.curvature_normal_angle(service, rules, path + [("curvature_normal_angle", "")])
                            self.draw_size_control = self.__class__.draw_size_control(service, rules, path + [("draw_size_control", "")])
                            self.growth_rate = self.__class__.growth_rate(service, rules, path + [("growth_rate", "")])
                            self.max_size = self.__class__.max_size(service, rules, path + [("max_size", "")])
                            self.min_size = self.__class__.min_size(service, rules, path + [("min_size", "")])
                            self.object_based_controls = self.__class__.object_based_controls(service, rules, path + [("object_based_controls", "")])
                            self.preview_sizefield = self.__class__.preview_sizefield(service, rules, path + [("preview_sizefield", "")])
                            self.refacet = self.__class__.refacet(service, rules, path + [("refacet", "")])
                            self.remesh_imported_mesh = self.__class__.remesh_imported_mesh(service, rules, path + [("remesh_imported_mesh", "")])
                            self.save_size_field = self.__class__.save_size_field(service, rules, path + [("save_size_field", "")])
                            self.save_size_field_file = self.__class__.save_size_field_file(service, rules, path + [("save_size_field_file", "")])
                            self.scope_proximity_to = self.__class__.scope_proximity_to(service, rules, path + [("scope_proximity_to", "")])
                            self.size_control_file = self.__class__.size_control_file(service, rules, path + [("size_control_file", "")])
                            self.size_field_file = self.__class__.size_field_file(service, rules, path + [("size_field_file", "")])
                            self.size_functions = self.__class__.size_functions(service, rules, path + [("size_functions", "")])
                            self.surface_mesh_method = self.__class__.surface_mesh_method(service, rules, path + [("surface_mesh_method", "")])
                            self.use_size_files = self.__class__.use_size_files(service, rules, path + [("use_size_files", "")])
                            super().__init__(service, rules, path)

                        class auto_create_scoped_sizing(PyParameter):
                            """
                            Parameter auto_create_scoped_sizing of value type bool.
                            """
                            pass

                        class cells_per_gap(PyNumerical):
                            """
                            Specify the minimum number of layers of elements to be generated in the gaps. The number of cells per gap can be a real value, with a minimum value of 0.01.
                            """
                            pass

                        class curvature_normal_angle(PyNumerical):
                            """
                            Specify the maximum allowable angle (from 0 to 180 degrees) that one element edge is allowed to span given a particular geometry curvature. You can use this field to limit the number of elements that are generated along a curve or surface if the minimum size is too small for that particular curve.  More...
                            """
                            pass

                        class draw_size_control(PyParameter):
                            """
                            Enable this field to display the size boxes in the graphics window.
                            """
                            pass

                        class growth_rate(PyNumerical):
                            """
                            Specify the increase in element edge length with each succeeding layer of elements.
                            """
                            pass

                        class max_size(PyNumerical):
                            """
                            Specify the maximum size of the elements for the surface mesh.
                            """
                            pass

                        class min_size(PyNumerical):
                            """
                            Specify the minimum size of the elements for the surface mesh. A minimum size between approximately 0.1 - 10 is recommended.
                            """
                            pass

                        class object_based_controls(PyParameter):
                            """
                            Choose if you would like to ignore any small artificial gaps that may exist between two objects/bodies; especially applicable to assemblies that typically have duplicate faces and edges in between each body.
                            """
                            pass

                        class preview_sizefield(PyParameter):
                            """
                            Enable this option to visualize the size field in the graphics window.
                            """
                            pass

                        class refacet(PyParameter):
                            """
                            Parameter refacet of value type bool.
                            """
                            pass

                        class remesh_imported_mesh(PyTextual):
                            """
                            For an imported surface mesh, determine which surfaces you wish to remesh in this task. Choices depend upon if any local sizing has been added or not.  More...
                            """
                            pass

                        class save_size_field(PyParameter):
                            """
                            Parameter save_size_field of value type bool.
                            """
                            pass

                        class save_size_field_file(PyTextual):
                            """
                            Specify a size field file that contains the size function definitions based on specified parameters.
                            """
                            pass

                        class scope_proximity_to(PyTextual):
                            """
                            Set proximity based refinement. Edges considers edge-to-edge proximity, while Faces considers face-to-face proximity, and Faces and Edges considers both.  More...
                            """
                            pass

                        class size_control_file(PyTextual):
                            """
                            Specify a size controls file (\\*.szcontrol) that contains the scoped sizing control definitions. The control name and type, and the scope of the control will be included in the size control file along with global size parameters.
                            """
                            pass

                        class size_field_file(PyTextual):
                            """
                            Specify a size field file that contains the size function definitions based on specified parameters.
                            """
                            pass

                        class size_functions(PyTextual):
                            """
                            Choose the type of size function that you want to apply to the surface mesh: based on curvature, proximity, or both.
                            """
                            pass

                        class surface_mesh_method(PyTextual):
                            """
                            Parameter surface_mesh_method of value type str.
                            """
                            pass

                        class use_size_files(PyTextual):
                            """
                            Specify whether or not you want to use your own size field file and/or your own size control file when generating the surface mesh.
                            """
                            pass

                    class share_topology_preferences(PyMenu):
                        """
                        Singleton share_topology_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.advanced_improve = self.__class__.advanced_improve(service, rules, path + [("advanced_improve", "")])
                            self.allow_defeaturing = self.__class__.allow_defeaturing(service, rules, path + [("allow_defeaturing", "")])
                            self.connect_label_wildcard = self.__class__.connect_label_wildcard(service, rules, path + [("connect_label_wildcard", "")])
                            self.execute_join_intersect = self.__class__.execute_join_intersect(service, rules, path + [("execute_join_intersect", "")])
                            self.fluid_label_wildcard = self.__class__.fluid_label_wildcard(service, rules, path + [("fluid_label_wildcard", "")])
                            self.intf_label_list = self.__class__.intf_label_list(service, rules, path + [("intf_label_list", "")])
                            self.join_tolerance_increment = self.__class__.join_tolerance_increment(service, rules, path + [("join_tolerance_increment", "")])
                            self.model_is_periodic = self.__class__.model_is_periodic(service, rules, path + [("model_is_periodic", "")])
                            self.number_of_join_tries = self.__class__.number_of_join_tries(service, rules, path + [("number_of_join_tries", "")])
                            self.operation = self.__class__.operation(service, rules, path + [("operation", "")])
                            self.per_label_list = self.__class__.per_label_list(service, rules, path + [("per_label_list", "")])
                            self.relative_share_topology_tolerance = self.__class__.relative_share_topology_tolerance(service, rules, path + [("relative_share_topology_tolerance", "")])
                            self.rename_internals_by_body_names = self.__class__.rename_internals_by_body_names(service, rules, path + [("rename_internals_by_body_names", "")])
                            self.share_topology_angle = self.__class__.share_topology_angle(service, rules, path + [("share_topology_angle", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            super().__init__(service, rules, path)

                        class advanced_improve(PyParameter):
                            """
                            Parameter advanced_improve of value type bool.
                            """
                            pass

                        class allow_defeaturing(PyParameter):
                            """
                            Parameter allow_defeaturing of value type bool.
                            """
                            pass

                        class connect_label_wildcard(PyTextual):
                            """
                            Enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                            """
                            pass

                        class execute_join_intersect(PyTextual):
                            """
                            Choose whether the system will only join faces, only intersect faces, or do both.
                            """
                            pass

                        class fluid_label_wildcard(PyTextual):
                            """
                            Parameter fluid_label_wildcard of value type str.
                            """
                            pass

                        class intf_label_list(PyTextual):
                            """
                            Enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                            """
                            pass

                        class join_tolerance_increment(PyNumerical):
                            """
                            Specify the increment by which the tolerance changes for each attempt to join face pairs.
                            """
                            pass

                        class model_is_periodic(PyParameter):
                            """
                            Choose whether or not you need to set up periodic boundaries. If you select yes, then choose your periodic boundaries from the list of available boundaries.
                            """
                            pass

                        class number_of_join_tries(PyNumerical):
                            """
                            Specify the number of attempts that will be made to join face pairs under the given criteria.
                            """
                            pass

                        class operation(PyTextual):
                            """
                            Choose whether to apply share topology using the Join-Intersect method where you join and/or intersect the problematic faces, or using the Interface Connect method where you connect edges of overlapping face pairs. Note that imprinting of overlapping faces in SCDM/Discovery is highly recommended for the Interface Connect method.
                            """
                            pass

                        class per_label_list(PyTextual):
                            """
                            Parameter per_label_list of value type list[str].
                            """
                            pass

                        class relative_share_topology_tolerance(PyNumerical):
                            """
                            Specify the relative tolerance for joining or intersecting face pairs, or the relative tolerance for connecting edge and face pairs.
                            """
                            pass

                        class rename_internals_by_body_names(PyParameter):
                            """
                            Choose whether or not to apply body names from the imported geometry and use them in naming internal boundaries.  For instance, the internal face between two regions solid and body would be renamed to solid-body.
                            """
                            pass

                        class share_topology_angle(PyNumerical):
                            """
                            Specify the threshold angle for joining face pairs.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Display advanced options that you may want to apply to the task.
                            """
                            pass

                    class surface_mesh_preferences(PyMenu):
                        """
                        Singleton surface_mesh_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.auto_assign_zone_types = self.__class__.auto_assign_zone_types(service, rules, path + [("auto_assign_zone_types", "")])
                            self.auto_merge = self.__class__.auto_merge(service, rules, path + [("auto_merge", "")])
                            self.auto_surface_remesh = self.__class__.auto_surface_remesh(service, rules, path + [("auto_surface_remesh", "")])
                            self.fold_face_limit = self.__class__.fold_face_limit(service, rules, path + [("fold_face_limit", "")])
                            self.improve_quality = self.__class__.improve_quality(service, rules, path + [("improve_quality", "")])
                            self.max_step_width = self.__class__.max_step_width(service, rules, path + [("max_step_width", "")])
                            self.parallel_region_compute = self.__class__.parallel_region_compute(service, rules, path + [("parallel_region_compute", "")])
                            self.quality_improve_collapase_skewness_limit = self.__class__.quality_improve_collapase_skewness_limit(service, rules, path + [("quality_improve_collapase_skewness_limit", "")])
                            self.quality_improve_max_angle = self.__class__.quality_improve_max_angle(service, rules, path + [("quality_improve_max_angle", "")])
                            self.quality_improve_skewness_limit = self.__class__.quality_improve_skewness_limit(service, rules, path + [("quality_improve_skewness_limit", "")])
                            self.remove_steps = self.__class__.remove_steps(service, rules, path + [("remove_steps", "")])
                            self.self_intersect_check = self.__class__.self_intersect_check(service, rules, path + [("self_intersect_check", "")])
                            self.separate_by_angle = self.__class__.separate_by_angle(service, rules, path + [("separate_by_angle", "")])
                            self.separation_angle = self.__class__.separation_angle(service, rules, path + [("separation_angle", "")])
                            self.set_volume_mesh_max_size = self.__class__.set_volume_mesh_max_size(service, rules, path + [("set_volume_mesh_max_size", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            self.thin_volume_meshing_auto_control_creation = self.__class__.thin_volume_meshing_auto_control_creation(service, rules, path + [("thin_volume_meshing_auto_control_creation", "")])
                            self.volume_mesh_max_size = self.__class__.volume_mesh_max_size(service, rules, path + [("volume_mesh_max_size", "")])
                            super().__init__(service, rules, path)

                        class auto_assign_zone_types(PyParameter):
                            """
                            Choose whether or not to automatically assign boundary types to zones.
                            """
                            pass

                        class auto_merge(PyParameter):
                            """
                            Parameter auto_merge of value type bool.
                            """
                            pass

                        class auto_surface_remesh(PyTextual):
                            """
                            Choose whether or not to automatically remesh in order to remove excessive clustering of nodes. By default (auto), this is done if local sizing has been assigned or Share Topology is invoked, but skipped if not. Performance may be improved if this is disabled. In addition, you can choose to use the much faster refaceting technique as an alternative to automatic remeshing. When importing the mesh, remeshing is only performed if this option is set to yes and then all faces are remeshed; and the refaceting option is not available because the initial mesh cannot be refaceted.
                            """
                            pass

                        class fold_face_limit(PyNumerical):
                            """
                            Specify the value limiting when folded faces are smoothed or resolved. Folded faces are resolved while under this limit. Set this value to 0 if the number of free nodes (due to a zero-thickness wall such as a baffle for instance) falls below 10.
                            """
                            pass

                        class improve_quality(PyParameter):
                            """
                            Choose whether or not to apply quality measures during surface mesh generation. You should disable this option when using Multizone meshing of very thin structures, relative to the minimum size.
                            """
                            pass

                        class max_step_width(PyNumerical):
                            """
                            Specify the width of the step that you wish to remove.
                            """
                            pass

                        class parallel_region_compute(PyTextual):
                            """
                            If your geometry contains conformal regions, you can choose whether or not to compute regions in parallel. Selecting yes for this option may speed up the computation if your geometry has a large number of regions. Note that when computing regions in parallel, nodal curvature data will be lost which may affect surface remeshing.
                            """
                            pass

                        class quality_improve_collapase_skewness_limit(PyNumerical):
                            """
                            Specify the limiting skewness value for cell collapse to improve the mesh. If any remaining triangles are above this limit, these triangles will be aggressively removed using a fixed maximum angle of 120 degrees.
                            """
                            pass

                        class quality_improve_max_angle(PyNumerical):
                            """
                            Specify the maximum angle between the normals of adjacent faces. This quality measure is useful in locating sharp corners in complicated geometries. The angle value ranges from 0 to 180 degrees. Four consecutive attempts are made to improve the quality, each using a larger adjacent angle, until this maximum value.
                            """
                            pass

                        class quality_improve_skewness_limit(PyNumerical):
                            """
                            Specify a limiting value for skewness to improve the quality of the surface mesh. Quality improvement is attempted on those triangles where the skewness is above this limit.
                            """
                            pass

                        class remove_steps(PyParameter):
                            """
                            Indicate if there are any small imperfections (ledge or step artifacts from the original CAD geometry) that can be removed as part of this task. If you select yes, then you must specify a Max Step Width.
                            """
                            pass

                        class self_intersect_check(PyParameter):
                            """
                            Choose whether or not to check for self-intersecting faces. Performance may be improved if this is disabled.
                            """
                            pass

                        class separate_by_angle(PyTextual):
                            """
                            Choose whether or not to separate zones. This is required to select faces for capping. If Named Selections have already been defined at these locations, then separation is not needed. Performance may be improved if this is disabled.
                            """
                            pass

                        class separation_angle(PyNumerical):
                            """
                            Specify a desired angle for determining separation. Assigning a smaller separation angle will produce more zones.
                            """
                            pass

                        class set_volume_mesh_max_size(PyParameter):
                            """
                            Specify the maximum size of the elements for the surface mesh.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Display advanced options that you may want to apply to the task.
                            """
                            pass

                        class thin_volume_meshing_auto_control_creation(PyParameter):
                            """
                            If your geometry contains small edges, you can choose to extract these edge features when generating the surface mesh by selecting yes. Note that selecting yes , will always extract small edge features regardless of your selection for the Auto Remesh to Remove Clustering? option.
                            """
                            pass

                        class volume_mesh_max_size(PyNumerical):
                            """
                            Specify the maximum size of the elements for the surface mesh.
                            """
                            pass

                    class append_mesh(PyParameter):
                        """
                        Parameter append_mesh of value type bool.
                        """
                        pass

                    class cad_faceting_file_name(PyTextual):
                        """
                        Parameter cad_faceting_file_name of value type str.
                        """
                        pass

                    class directory(PyTextual):
                        """
                        Parameter directory of value type str.
                        """
                        pass

                    class execute_share_topology(PyParameter):
                        """
                        For imported CAD assemblies with multiple parts, use this task to identify and close any problematic gaps and choose whether to join and/or intersect the problematic faces.   More...
                        """
                        pass

                    class import_type(PyTextual):
                        """
                        Parameter import_type of value type str.
                        """
                        pass

                    class length_unit(PyTextual):
                        """
                        Parameter length_unit of value type str.
                        """
                        pass

                    class original_zones(PyTextual):
                        """
                        Parameter original_zones of value type list[str].
                        """
                        pass

                    class pattern(PyTextual):
                        """
                        Parameter pattern of value type str.
                        """
                        pass

                    class preview_size_toggle(PyParameter):
                        """
                        For an imported surface mesh, use this field to visualize those boundaries that already have assigned local sizing controls (and any selected boundaries if applicable).
                        """
                        pass

                    class remesh_label_list(PyTextual):
                        """
                        Parameter remesh_label_list of value type list[str].
                        """
                        pass

                    class remesh_selection_type(PyTextual):
                        """
                        Choose how you want to select your surface(s) to remesh (by label or by zone).
                        """
                        pass

                    class remesh_zone_list(PyTextual):
                        """
                        Parameter remesh_zone_list of value type list[str].
                        """
                        pass

                    class separation_angle(PyNumerical):
                        """
                        Specify a desired angle for determining separation. Assigning a smaller separation angle will produce more zones.
                        """
                        pass

                    class separation_required(PyParameter):
                        """
                        Choose whether or not to separate face zones. By default, this is set to No. If you choose to separate zones, specify a Separation Angle. You should separate zones when using Multizone meshing. Separation is needed in case named selections for inlets, outlets, capping, local boundary layers, etc. have not been defined within the CAD model in advance. You should only select Yes if you need to separate faces for capping, boundary conditions, or inflation on specific faces.
                        """
                        pass

                    class tesselation_method(PyTextual):
                        """
                        Parameter tesselation_method of value type str.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _create_surface_mesh:
                return super().__getitem__(key)

        class create_volume_mesh_ftm(PyNamedObjectContainer):
            """
            .
            """
            class _create_volume_mesh_ftm(PyMenu):
                """
                Singleton _create_volume_mesh_ftm.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.advanced_options = self.__class__.advanced_options(service, rules, path + [("advanced_options", "")])
                        self.all_region_name_list = self.__class__.all_region_name_list(service, rules, path + [("all_region_name_list", "")])
                        self.all_region_size_list = self.__class__.all_region_size_list(service, rules, path + [("all_region_size_list", "")])
                        self.all_region_volume_fill_list = self.__class__.all_region_volume_fill_list(service, rules, path + [("all_region_volume_fill_list", "")])
                        self.avoid_hanging_nodes = self.__class__.avoid_hanging_nodes(service, rules, path + [("avoid_hanging_nodes", "")])
                        self.conformal_prism_split = self.__class__.conformal_prism_split(service, rules, path + [("conformal_prism_split", "")])
                        self.dihedral_min_angle = self.__class__.dihedral_min_angle(service, rules, path + [("dihedral_min_angle", "")])
                        self.edit_volume_settings = self.__class__.edit_volume_settings(service, rules, path + [("edit_volume_settings", "")])
                        self.enable_parallel = self.__class__.enable_parallel(service, rules, path + [("enable_parallel", "")])
                        self.fast_ro = self.__class__.fast_ro(service, rules, path + [("fast_ro", "")])
                        self.fill_with_size_field = self.__class__.fill_with_size_field(service, rules, path + [("fill_with_size_field", "")])
                        self.global_buffer_layers = self.__class__.global_buffer_layers(service, rules, path + [("global_buffer_layers", "")])
                        self.max_boundary_cell_level = self.__class__.max_boundary_cell_level(service, rules, path + [("max_boundary_cell_level", "")])
                        self.max_boundary_cell_size = self.__class__.max_boundary_cell_size(service, rules, path + [("max_boundary_cell_size", "")])
                        self.max_cell_level = self.__class__.max_cell_level(service, rules, path + [("max_cell_level", "")])
                        self.max_cell_size = self.__class__.max_cell_size(service, rules, path + [("max_cell_size", "")])
                        self.mesh_quality = self.__class__.mesh_quality(service, rules, path + [("mesh_quality", "")])
                        self.octree_boundary_face_size_ratio = self.__class__.octree_boundary_face_size_ratio(service, rules, path + [("octree_boundary_face_size_ratio", "")])
                        self.octree_peel_layers = self.__class__.octree_peel_layers(service, rules, path + [("octree_peel_layers", "")])
                        self.old_region_name_list = self.__class__.old_region_name_list(service, rules, path + [("old_region_name_list", "")])
                        self.old_region_size_list = self.__class__.old_region_size_list(service, rules, path + [("old_region_size_list", "")])
                        self.old_region_volume_fill_list = self.__class__.old_region_volume_fill_list(service, rules, path + [("old_region_volume_fill_list", "")])
                        self.orthogonal_quality = self.__class__.orthogonal_quality(service, rules, path + [("orthogonal_quality", "")])
                        self.prism_normal_smooth_relaxation_factor = self.__class__.prism_normal_smooth_relaxation_factor(service, rules, path + [("prism_normal_smooth_relaxation_factor", "")])
                        self.quality_method = self.__class__.quality_method(service, rules, path + [("quality_method", "")])
                        self.region_name_list = self.__class__.region_name_list(service, rules, path + [("region_name_list", "")])
                        self.region_size_list = self.__class__.region_size_list(service, rules, path + [("region_size_list", "")])
                        self.region_volume_fill_list = self.__class__.region_volume_fill_list(service, rules, path + [("region_volume_fill_list", "")])
                        self.ro_curv_max_angle = self.__class__.ro_curv_max_angle(service, rules, path + [("ro_curv_max_angle", "")])
                        self.ro_curv_min_angle = self.__class__.ro_curv_min_angle(service, rules, path + [("ro_curv_min_angle", "")])
                        self.ro_curv_switch_angle_criterion = self.__class__.ro_curv_switch_angle_criterion(service, rules, path + [("ro_curv_switch_angle_criterion", "")])
                        self.ro_ref_size = self.__class__.ro_ref_size(service, rules, path + [("ro_ref_size", "")])
                        self.save_volume_mesh = self.__class__.save_volume_mesh(service, rules, path + [("save_volume_mesh", "")])
                        self.show_sub_tasks = self.__class__.show_sub_tasks(service, rules, path + [("show_sub_tasks", "")])
                        self.spike_removal_angle = self.__class__.spike_removal_angle(service, rules, path + [("spike_removal_angle", "")])
                        self.tet_poly_growth_rate = self.__class__.tet_poly_growth_rate(service, rules, path + [("tet_poly_growth_rate", "")])
                        self.tet_prism_stairstep_exposed_quads = self.__class__.tet_prism_stairstep_exposed_quads(service, rules, path + [("tet_prism_stairstep_exposed_quads", "")])
                        self.thin_volume_meshing_max_aspect_ratio = self.__class__.thin_volume_meshing_max_aspect_ratio(service, rules, path + [("thin_volume_meshing_max_aspect_ratio", "")])
                        super().__init__(service, rules, path)

                    class advanced_options(PyParameter):
                        """
                        Display advanced options that you may want to apply to the task.
                        """
                        pass

                    class all_region_name_list(PyTextual):
                        """
                        Parameter all_region_name_list of value type list[str].
                        """
                        pass

                    class all_region_size_list(PyTextual):
                        """
                        Parameter all_region_size_list of value type list[str].
                        """
                        pass

                    class all_region_volume_fill_list(PyTextual):
                        """
                        Parameter all_region_volume_fill_list of value type list[str].
                        """
                        pass

                    class avoid_hanging_nodes(PyParameter):
                        """
                        Specify whether or not you want to avoid any potential 1:8 cell transition in the hexcore or polyhexcore region of the volume mesh, replacing any abrupt change in the cell size with tetrahedral or polyhedral cells.
                        """
                        pass

                    class conformal_prism_split(PyParameter):
                        """
                        Since neighboring zones with different numbers of layers will lead to conformal prism layers between them, use this field to determine whether you want to split the boundary layer cells conformally or not. When this option is set to Yes, the prism sides of the two zones will share nodes. This option is only available when stair-stepping is invoked. Note that adjacent regions should have an even ratio of prism layers when using this option.
                        """
                        pass

                    class dihedral_min_angle(PyNumerical):
                        """
                        Parameter dihedral_min_angle of value type float.
                        """
                        pass

                    class edit_volume_settings(PyParameter):
                        """
                        Enable this option to review and/or edit the fill settings for your volume region(s).
                        """
                        pass

                    class enable_parallel(PyParameter):
                        """
                        Enable this option to perform parallel volume and continuous boundary layer (prism) meshing for fluid region(s). Applicable for poly, hexcore and poly-hexcore volume fill types.
                        """
                        pass

                    class fast_ro(PyParameter):
                        """
                        Parameter fast_ro of value type bool.
                        """
                        pass

                    class fill_with_size_field(PyParameter):
                        """
                        Determine whether or not you want to use size fields when generating the volume mesh. Generating the volume mesh using size fields can require additional memory as you increase the number of processing cores. This is because the size field is replicated for each core as the size field is not properly distributed. When using size fields, you are limited by the size of the machine. When not using size fields, however, you require less memory and you can use a higher number of cores with limited RAM, leading to a faster mesh generation.
                        """
                        pass

                    class global_buffer_layers(PyNumerical):
                        """
                        Specify the number of buffer layers for the octree volume mesh. If size controls have not been defined previously, then the default is 2, otherwise the default is calculated based on the maximum growth size.
                        """
                        pass

                    class max_boundary_cell_level(PyNumerical):
                        """
                        Parameter max_boundary_cell_level of value type int.
                        """
                        pass

                    class max_boundary_cell_size(PyNumerical):
                        """
                        Parameter max_boundary_cell_size of value type float.
                        """
                        pass

                    class max_cell_level(PyNumerical):
                        """
                        Parameter max_cell_level of value type int.
                        """
                        pass

                    class max_cell_size(PyNumerical):
                        """
                        Parameter max_cell_size of value type float.
                        """
                        pass

                    class mesh_quality(PyNumerical):
                        """
                        Parameter mesh_quality of value type float.
                        """
                        pass

                    class octree_boundary_face_size_ratio(PyNumerical):
                        """
                        Specify the ratio between the octree face size and the boundary face size. The default is 2.5 such that the octree mesh near the boundary is 2.5 times larger than the boundary mesh.
                        """
                        pass

                    class octree_peel_layers(PyNumerical):
                        """
                        Specify the number of octree layers to be removed between the boundary and the core. The resulting cavity will be filled with tet cells for hexcore meshes and with poly cells for polyhexcore meshes.
                        """
                        pass

                    class old_region_name_list(PyTextual):
                        """
                        Parameter old_region_name_list of value type list[str].
                        """
                        pass

                    class old_region_size_list(PyTextual):
                        """
                        Parameter old_region_size_list of value type list[str].
                        """
                        pass

                    class old_region_volume_fill_list(PyTextual):
                        """
                        Parameter old_region_volume_fill_list of value type list[str].
                        """
                        pass

                    class orthogonal_quality(PyNumerical):
                        """
                        This value sets the threshold for when mesh quality improvements are automatically invoked that employ the orthogonal quality limit, and is recommended to be around 0.04.
                        """
                        pass

                    class prism_normal_smooth_relaxation_factor(PyNumerical):
                        """
                        Specify the smoothness factor for normal prism layers. Increasing this value will generate more prism layers especially near sharp corners. Note that this option is only available when Enable Parallel Meshing for Fluids is turned on and when Stairstep is selected for the Post Improvement Method in the Add Boundary Layers task.
                        """
                        pass

                    class quality_method(PyTextual):
                        """
                        Choose from different types of mesh quality controls (aspect ratio, change in size, and so on). Choices include Orthogonal (the default for the workflows) and Enhanced Orthogonal. For more information, see  More... .
                        """
                        pass

                    class region_name_list(PyTextual):
                        """
                        Parameter region_name_list of value type list[str].
                        """
                        pass

                    class region_size_list(PyTextual):
                        """
                        Parameter region_size_list of value type list[str].
                        """
                        pass

                    class region_volume_fill_list(PyTextual):
                        """
                        Parameter region_volume_fill_list of value type list[str].
                        """
                        pass

                    class ro_curv_max_angle(PyNumerical):
                        """
                        Parameter ro_curv_max_angle of value type float.
                        """
                        pass

                    class ro_curv_min_angle(PyNumerical):
                        """
                        Parameter ro_curv_min_angle of value type float.
                        """
                        pass

                    class ro_curv_switch_angle_criterion(PyNumerical):
                        """
                        Parameter ro_curv_switch_angle_criterion of value type float.
                        """
                        pass

                    class ro_ref_size(PyNumerical):
                        """
                        Parameter ro_ref_size of value type float.
                        """
                        pass

                    class save_volume_mesh(PyParameter):
                        """
                        Select this option to save the volume mesh.
                        """
                        pass

                    class show_sub_tasks(PyParameter):
                        """
                        Parameter show_sub_tasks of value type bool.
                        """
                        pass

                    class spike_removal_angle(PyNumerical):
                        """
                        Parameter spike_removal_angle of value type float.
                        """
                        pass

                    class tet_poly_growth_rate(PyNumerical):
                        """
                        Specify the maximum growth rate for tet and poly cells. By default, this corresponds to a growth rate of 1.2.
                        """
                        pass

                    class tet_prism_stairstep_exposed_quads(PyParameter):
                        """
                        This option can be used when generating a tetrahedral mesh with prism cells and is set to No by default. Selecting Yes for this option will enable stair-stepping for exposed quadrilateral faces (exposed quads) on prism cells. Stair-stepping will prevent pyramids from being created on these exposed quads, which generally would lead to poor quality in the exposed quad location.
                        """
                        pass

                    class thin_volume_meshing_max_aspect_ratio(PyNumerical):
                        """
                        Parameter thin_volume_meshing_max_aspect_ratio of value type float.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _create_volume_mesh_ftm:
                return super().__getitem__(key)

        class create_volume_mesh_wtm(PyNamedObjectContainer):
            """
            .
            """
            class _create_volume_mesh_wtm(PyMenu):
                """
                Singleton _create_volume_mesh_wtm.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.cfd_surface_mesh_controls = self.__class__.cfd_surface_mesh_controls(service, rules, path + [("cfd_surface_mesh_controls", "")])
                        self.face_scope = self.__class__.face_scope(service, rules, path + [("face_scope", "")])
                        self.global_thin_volume_preferences = self.__class__.global_thin_volume_preferences(service, rules, path + [("global_thin_volume_preferences", "")])
                        self.prism_preferences = self.__class__.prism_preferences(service, rules, path + [("prism_preferences", "")])
                        self.volume_fill_controls = self.__class__.volume_fill_controls(service, rules, path + [("volume_fill_controls", "")])
                        self.volume_mesh_preferences = self.__class__.volume_mesh_preferences(service, rules, path + [("volume_mesh_preferences", "")])
                        self.body_label_body_list = self.__class__.body_label_body_list(service, rules, path + [("body_label_body_list", "")])
                        self.body_label_list = self.__class__.body_label_list(service, rules, path + [("body_label_list", "")])
                        self.decoupled_parallel_meshing = self.__class__.decoupled_parallel_meshing(service, rules, path + [("decoupled_parallel_meshing", "")])
                        self.first_aspect_ratio = self.__class__.first_aspect_ratio(service, rules, path + [("first_aspect_ratio", "")])
                        self.first_height = self.__class__.first_height(service, rules, path + [("first_height", "")])
                        self.invoke_prims_control = self.__class__.invoke_prims_control(service, rules, path + [("invoke_prims_control", "")])
                        self.merge_cell_zones = self.__class__.merge_cell_zones(service, rules, path + [("merge_cell_zones", "")])
                        self.mesh_dead_regions = self.__class__.mesh_dead_regions(service, rules, path + [("mesh_dead_regions", "")])
                        self.mesh_fluid_regions = self.__class__.mesh_fluid_regions(service, rules, path + [("mesh_fluid_regions", "")])
                        self.mesh_object = self.__class__.mesh_object(service, rules, path + [("mesh_object", "")])
                        self.mesh_solid_regions = self.__class__.mesh_solid_regions(service, rules, path + [("mesh_solid_regions", "")])
                        self.number_of_layers = self.__class__.number_of_layers(service, rules, path + [("number_of_layers", "")])
                        self.offset_method_type = self.__class__.offset_method_type(service, rules, path + [("offset_method_type", "")])
                        self.old_region_hex_max_cell_length_list = self.__class__.old_region_hex_max_cell_length_list(service, rules, path + [("old_region_hex_max_cell_length_list", "")])
                        self.old_region_tet_growth_rate_list = self.__class__.old_region_tet_growth_rate_list(service, rules, path + [("old_region_tet_growth_rate_list", "")])
                        self.old_region_tet_max_cell_length_list = self.__class__.old_region_tet_max_cell_length_list(service, rules, path + [("old_region_tet_max_cell_length_list", "")])
                        self.parallel_meshing = self.__class__.parallel_meshing(service, rules, path + [("parallel_meshing", "")])
                        self.prime_meshing = self.__class__.prime_meshing(service, rules, path + [("prime_meshing", "")])
                        self.prism_layers = self.__class__.prism_layers(service, rules, path + [("prism_layers", "")])
                        self.quad_tet_transition = self.__class__.quad_tet_transition(service, rules, path + [("quad_tet_transition", "")])
                        self.rate = self.__class__.rate(service, rules, path + [("rate", "")])
                        self.re_merge_zones = self.__class__.re_merge_zones(service, rules, path + [("re_merge_zones", "")])
                        self.region_based_preferences = self.__class__.region_based_preferences(service, rules, path + [("region_based_preferences", "")])
                        self.region_hex_max_cell_length_list = self.__class__.region_hex_max_cell_length_list(service, rules, path + [("region_hex_max_cell_length_list", "")])
                        self.region_hex_name_list = self.__class__.region_hex_name_list(service, rules, path + [("region_hex_name_list", "")])
                        self.region_tet_growth_rate_list = self.__class__.region_tet_growth_rate_list(service, rules, path + [("region_tet_growth_rate_list", "")])
                        self.region_tet_max_cell_length_list = self.__class__.region_tet_max_cell_length_list(service, rules, path + [("region_tet_max_cell_length_list", "")])
                        self.region_tet_name_list = self.__class__.region_tet_name_list(service, rules, path + [("region_tet_name_list", "")])
                        self.show_solid_fluid_meshed = self.__class__.show_solid_fluid_meshed(service, rules, path + [("show_solid_fluid_meshed", "")])
                        self.sizing_method = self.__class__.sizing_method(service, rules, path + [("sizing_method", "")])
                        self.solver = self.__class__.solver(service, rules, path + [("solver", "")])
                        self.transition_ratio = self.__class__.transition_ratio(service, rules, path + [("transition_ratio", "")])
                        self.volume_fill = self.__class__.volume_fill(service, rules, path + [("volume_fill", "")])
                        super().__init__(service, rules, path)

                    class cfd_surface_mesh_controls(PyMenu):
                        """
                        Singleton cfd_surface_mesh_controls.
                        """
                        def __init__(self, service, rules, path):
                            self.auto_create_scoped_sizing = self.__class__.auto_create_scoped_sizing(service, rules, path + [("auto_create_scoped_sizing", "")])
                            self.cells_per_gap = self.__class__.cells_per_gap(service, rules, path + [("cells_per_gap", "")])
                            self.curvature_normal_angle = self.__class__.curvature_normal_angle(service, rules, path + [("curvature_normal_angle", "")])
                            self.draw_size_control = self.__class__.draw_size_control(service, rules, path + [("draw_size_control", "")])
                            self.growth_rate = self.__class__.growth_rate(service, rules, path + [("growth_rate", "")])
                            self.max_size = self.__class__.max_size(service, rules, path + [("max_size", "")])
                            self.min_size = self.__class__.min_size(service, rules, path + [("min_size", "")])
                            self.object_based_controls = self.__class__.object_based_controls(service, rules, path + [("object_based_controls", "")])
                            self.preview_sizefield = self.__class__.preview_sizefield(service, rules, path + [("preview_sizefield", "")])
                            self.refacet = self.__class__.refacet(service, rules, path + [("refacet", "")])
                            self.remesh_imported_mesh = self.__class__.remesh_imported_mesh(service, rules, path + [("remesh_imported_mesh", "")])
                            self.save_size_field = self.__class__.save_size_field(service, rules, path + [("save_size_field", "")])
                            self.save_size_field_file = self.__class__.save_size_field_file(service, rules, path + [("save_size_field_file", "")])
                            self.scope_proximity_to = self.__class__.scope_proximity_to(service, rules, path + [("scope_proximity_to", "")])
                            self.size_control_file = self.__class__.size_control_file(service, rules, path + [("size_control_file", "")])
                            self.size_field_file = self.__class__.size_field_file(service, rules, path + [("size_field_file", "")])
                            self.size_functions = self.__class__.size_functions(service, rules, path + [("size_functions", "")])
                            self.surface_mesh_method = self.__class__.surface_mesh_method(service, rules, path + [("surface_mesh_method", "")])
                            self.use_size_files = self.__class__.use_size_files(service, rules, path + [("use_size_files", "")])
                            super().__init__(service, rules, path)

                        class auto_create_scoped_sizing(PyParameter):
                            """
                            Parameter auto_create_scoped_sizing of value type bool.
                            """
                            pass

                        class cells_per_gap(PyNumerical):
                            """
                            Parameter cells_per_gap of value type float.
                            """
                            pass

                        class curvature_normal_angle(PyNumerical):
                            """
                            Parameter curvature_normal_angle of value type float.
                            """
                            pass

                        class draw_size_control(PyParameter):
                            """
                            Parameter draw_size_control of value type bool.
                            """
                            pass

                        class growth_rate(PyNumerical):
                            """
                            Specify the rate of growth for a tetrahedron or polyhedron mesh.
                            """
                            pass

                        class max_size(PyNumerical):
                            """
                            Parameter max_size of value type float.
                            """
                            pass

                        class min_size(PyNumerical):
                            """
                            Parameter min_size of value type float.
                            """
                            pass

                        class object_based_controls(PyParameter):
                            """
                            Parameter object_based_controls of value type bool.
                            """
                            pass

                        class preview_sizefield(PyParameter):
                            """
                            Parameter preview_sizefield of value type bool.
                            """
                            pass

                        class refacet(PyParameter):
                            """
                            Parameter refacet of value type bool.
                            """
                            pass

                        class remesh_imported_mesh(PyTextual):
                            """
                            Parameter remesh_imported_mesh of value type str.
                            """
                            pass

                        class save_size_field(PyParameter):
                            """
                            Parameter save_size_field of value type bool.
                            """
                            pass

                        class save_size_field_file(PyTextual):
                            """
                            Parameter save_size_field_file of value type str.
                            """
                            pass

                        class scope_proximity_to(PyTextual):
                            """
                            Parameter scope_proximity_to of value type str.
                            """
                            pass

                        class size_control_file(PyTextual):
                            """
                            Parameter size_control_file of value type str.
                            """
                            pass

                        class size_field_file(PyTextual):
                            """
                            Parameter size_field_file of value type str.
                            """
                            pass

                        class size_functions(PyTextual):
                            """
                            Parameter size_functions of value type str.
                            """
                            pass

                        class surface_mesh_method(PyTextual):
                            """
                            Parameter surface_mesh_method of value type str.
                            """
                            pass

                        class use_size_files(PyTextual):
                            """
                            Parameter use_size_files of value type str.
                            """
                            pass

                    class face_scope(PyMenu):
                        """
                        Singleton face_scope.
                        """
                        def __init__(self, service, rules, path):
                            self.face_scope_mesh_object = self.__class__.face_scope_mesh_object(service, rules, path + [("face_scope_mesh_object", "")])
                            self.grow_on = self.__class__.grow_on(service, rules, path + [("grow_on", "")])
                            self.regions_type = self.__class__.regions_type(service, rules, path + [("regions_type", "")])
                            self.topology_list = self.__class__.topology_list(service, rules, path + [("topology_list", "")])
                            super().__init__(service, rules, path)

                        class face_scope_mesh_object(PyTextual):
                            """
                            Parameter face_scope_mesh_object of value type str.
                            """
                            pass

                        class grow_on(PyTextual):
                            """
                            Parameter grow_on of value type str.
                            """
                            pass

                        class regions_type(PyTextual):
                            """
                            Parameter regions_type of value type str.
                            """
                            pass

                        class topology_list(PyTextual):
                            """
                            Parameter topology_list of value type list[str].
                            """
                            pass

                    class global_thin_volume_preferences(PyMenu):
                        """
                        Singleton global_thin_volume_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.auto_order_controls = self.__class__.auto_order_controls(service, rules, path + [("auto_order_controls", "")])
                            self.min_aspect_ratio = self.__class__.min_aspect_ratio(service, rules, path + [("min_aspect_ratio", "")])
                            self.show_global_thin_volume_preferences = self.__class__.show_global_thin_volume_preferences(service, rules, path + [("show_global_thin_volume_preferences", "")])
                            self.stair_step = self.__class__.stair_step(service, rules, path + [("stair_step", "")])
                            super().__init__(service, rules, path)

                        class auto_order_controls(PyTextual):
                            """
                            When set to yes, will automatically swap source and target faces in order to increase the success rate of the thin volume mesh generation. This option is set to yes by default for conventional thin volume meshing and is set to no when Stacked Plates is enabled.
                            """
                            pass

                        class min_aspect_ratio(PyNumerical):
                            """
                            Controls the minimum aspect ratio for cells at the boundary of the thin volume mesh regions. By default, this option is set to 0.3, other than for Stacked Plates, where it is set to 0.1. For flat parallel plates (not including stacked plates), it is recommended to use a value of 0.1 to produce a high quality thin volume mesh.
                            """
                            pass

                        class show_global_thin_volume_preferences(PyParameter):
                            """
                            Display global settings for thin volume meshing.
                            """
                            pass

                        class stair_step(PyTextual):
                            """
                            Use this option to invoke stair-stepping at thin volume mesh regions.
                            """
                            pass

                    class prism_preferences(PyMenu):
                        """
                        Display global settings for your boundary layers. Note that these settings are not applied for Multizone boundary layers
                        """
                        def __init__(self, service, rules, path):
                            self.ignore_inflation = self.__class__.ignore_inflation(service, rules, path + [("ignore_inflation", "")])
                            self.merge_boundary_layers = self.__class__.merge_boundary_layers(service, rules, path + [("merge_boundary_layers", "")])
                            self.normal_smooth_relaxation_factor = self.__class__.normal_smooth_relaxation_factor(service, rules, path + [("normal_smooth_relaxation_factor", "")])
                            self.prism_adjacent_angle = self.__class__.prism_adjacent_angle(service, rules, path + [("prism_adjacent_angle", "")])
                            self.prism_gap_factor = self.__class__.prism_gap_factor(service, rules, path + [("prism_gap_factor", "")])
                            self.prism_keep_first_layer = self.__class__.prism_keep_first_layer(service, rules, path + [("prism_keep_first_layer", "")])
                            self.prism_max_aspect_ratio = self.__class__.prism_max_aspect_ratio(service, rules, path + [("prism_max_aspect_ratio", "")])
                            self.prism_min_aspect_ratio = self.__class__.prism_min_aspect_ratio(service, rules, path + [("prism_min_aspect_ratio", "")])
                            self.prism_stair_step_options = self.__class__.prism_stair_step_options(service, rules, path + [("prism_stair_step_options", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            self.stair_step_icem_quality_limit = self.__class__.stair_step_icem_quality_limit(service, rules, path + [("stair_step_icem_quality_limit", "")])
                            self.stairstep_exposed_quads = self.__class__.stairstep_exposed_quads(service, rules, path + [("stairstep_exposed_quads", "")])
                            super().__init__(service, rules, path)

                        class ignore_inflation(PyTextual):
                            """
                            Specify whether to automatically ignore boundary layers where there is an acute angle.
                            """
                            pass

                        class merge_boundary_layers(PyParameter):
                            """
                            Choose whether or not you want to have the boundary layer mesh merged into the bulk mesh.
                            """
                            pass

                        class normal_smooth_relaxation_factor(PyNumerical):
                            """
                            Specify the smoothness factor for normal prism layers. Increasing this value will generate more prism layers especially near sharp corners.
                            """
                            pass

                        class prism_adjacent_angle(PyNumerical):
                            """
                            Specify the angle for which the boundary layer would imprint on an adjacent boundary.
                            """
                            pass

                        class prism_gap_factor(PyNumerical):
                            """
                            Specify the relative gap-size (based on local mesh size) between two boundary layer caps. If this limit is exceeded, the boundary layer will automatically be compressed.
                            """
                            pass

                        class prism_keep_first_layer(PyParameter):
                            """
                            Specify whether to retain the initial boundary layer height.
                            """
                            pass

                        class prism_max_aspect_ratio(PyNumerical):
                            """
                            Specify the maximum aspect ratio for the boundary layer when proximity compression is applied.
                            """
                            pass

                        class prism_min_aspect_ratio(PyNumerical):
                            """
                            Controls the minimum aspect ratio for cells at the boundary of the thin volume mesh regions. By default, this option is set to 0.3, other than for Stacked Plates, where it is set to 0.1. For flat parallel plates (not including stacked plates), it is recommended to use a value of 0.1 to produce a high quality thin volume mesh.
                            """
                            pass

                        class prism_stair_step_options(PyTextual):
                            """
                            Use this option to reduce the stair-stepping at certain locations based on quality or proximity criteria. By default, Yes allows you to retain the default stair-step handling, otherwise you can also choose No, Exclude proximity check, No, Exclude quality check, or No, Exclude both checks.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Display global settings for your boundary layers. Note that these settings are not applied for Multizone boundary layers
                            """
                            pass

                        class stair_step_icem_quality_limit(PyNumerical):
                            """
                            Parameter stair_step_icem_quality_limit of value type float.
                            """
                            pass

                        class stairstep_exposed_quads(PyParameter):
                            """
                            This option can be used when generating a tetrahedral mesh with prism cells and is set to No by default. Selecting Yes for this option will enable stair-stepping for exposed quadrilateral faces (exposed quads) on prism cells. Stair-stepping will prevent pyramids from being created on these exposed quads, which generally would lead to poor quality in the exposed quad location.
                            """
                            pass

                    class volume_fill_controls(PyMenu):
                        """
                        Singleton volume_fill_controls.
                        """
                        def __init__(self, service, rules, path):
                            self.buffer_layers = self.__class__.buffer_layers(service, rules, path + [("buffer_layers", "")])
                            self.cell_sizing = self.__class__.cell_sizing(service, rules, path + [("cell_sizing", "")])
                            self.growth_rate = self.__class__.growth_rate(service, rules, path + [("growth_rate", "")])
                            self.hex_max_cell_length = self.__class__.hex_max_cell_length(service, rules, path + [("hex_max_cell_length", "")])
                            self.hex_max_size = self.__class__.hex_max_size(service, rules, path + [("hex_max_size", "")])
                            self.hex_min_cell_length = self.__class__.hex_min_cell_length(service, rules, path + [("hex_min_cell_length", "")])
                            self.max_size = self.__class__.max_size(service, rules, path + [("max_size", "")])
                            self.peel_layers = self.__class__.peel_layers(service, rules, path + [("peel_layers", "")])
                            self.tet_poly_max_cell_length = self.__class__.tet_poly_max_cell_length(service, rules, path + [("tet_poly_max_cell_length", "")])
                            self.type = self.__class__.type(service, rules, path + [("type", "")])
                            super().__init__(service, rules, path)

                        class buffer_layers(PyNumerical):
                            """
                            Specify the number of additional layers required to cover the rapid transition between finer cells in the boundary mesh and the coarser cells in the initial Cartesian mesh.
                            """
                            pass

                        class cell_sizing(PyTextual):
                            """
                            Parameter cell_sizing of value type str.
                            """
                            pass

                        class growth_rate(PyNumerical):
                            """
                            Specify the rate of growth for a tetrahedron or polyhedron mesh.
                            """
                            pass

                        class hex_max_cell_length(PyNumerical):
                            """
                            The maximum cell length for the hexahedron volume fill type.
                            """
                            pass

                        class hex_max_size(PyNumerical):
                            """
                            Parameter hex_max_size of value type float.
                            """
                            pass

                        class hex_min_cell_length(PyNumerical):
                            """
                            The minimum cell length for the hexcore or  poly-hexcore volume fill types.
                            """
                            pass

                        class max_size(PyNumerical):
                            """
                            Parameter max_size of value type float.
                            """
                            pass

                        class peel_layers(PyNumerical):
                            """
                            Specify the number of layers that control the gap between the hexahedra core and the geometry.  This distance is assumed to be the height of an ideal tetrahedral cell on the boundary face.
                            """
                            pass

                        class tet_poly_max_cell_length(PyNumerical):
                            """
                            The maximum cell length for either the tetrahedron, polyhedron, or poly-hexcore volume fill types.
                            """
                            pass

                        class type(PyTextual):
                            """
                            Parameter type of value type str.
                            """
                            pass

                    class volume_mesh_preferences(PyMenu):
                        """
                        Singleton volume_mesh_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.add_multiple_quality_methods = self.__class__.add_multiple_quality_methods(service, rules, path + [("add_multiple_quality_methods", "")])
                            self.avoid_1_8_transition = self.__class__.avoid_1_8_transition(service, rules, path + [("avoid_1_8_transition", "")])
                            self.check_self_proximity = self.__class__.check_self_proximity(service, rules, path + [("check_self_proximity", "")])
                            self.max_cell_size_change = self.__class__.max_cell_size_change(service, rules, path + [("max_cell_size_change", "")])
                            self.merge_body_labels = self.__class__.merge_body_labels(service, rules, path + [("merge_body_labels", "")])
                            self.min_edge_length = self.__class__.min_edge_length(service, rules, path + [("min_edge_length", "")])
                            self.min_face_area = self.__class__.min_face_area(service, rules, path + [("min_face_area", "")])
                            self.min_poly_size = self.__class__.min_poly_size(service, rules, path + [("min_poly_size", "")])
                            self.poly_feature_angle = self.__class__.poly_feature_angle(service, rules, path + [("poly_feature_angle", "")])
                            self.poly_in_solids = self.__class__.poly_in_solids(service, rules, path + [("poly_in_solids", "")])
                            self.prepare_zone_names = self.__class__.prepare_zone_names(service, rules, path + [("prepare_zone_names", "")])
                            self.quality_method = self.__class__.quality_method(service, rules, path + [("quality_method", "")])
                            self.quality_warning_limit = self.__class__.quality_warning_limit(service, rules, path + [("quality_warning_limit", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            self.size_field_periodicity = self.__class__.size_field_periodicity(service, rules, path + [("size_field_periodicity", "")])
                            self.solid_growth_rate = self.__class__.solid_growth_rate(service, rules, path + [("solid_growth_rate", "")])
                            self.tet_in_solids = self.__class__.tet_in_solids(service, rules, path + [("tet_in_solids", "")])
                            self.use_size_field = self.__class__.use_size_field(service, rules, path + [("use_size_field", "")])
                            self.use_size_field_in_solids = self.__class__.use_size_field_in_solids(service, rules, path + [("use_size_field_in_solids", "")])
                            self.write_prism_control_file = self.__class__.write_prism_control_file(service, rules, path + [("write_prism_control_file", "")])
                            super().__init__(service, rules, path)

                        class add_multiple_quality_methods(PyTextual):
                            """
                            Parameter add_multiple_quality_methods of value type str.
                            """
                            pass

                        class avoid_1_8_transition(PyParameter):
                            """
                            Indicate whether or not you want to avoid any potential 1:8 cell transition in the hexcore region of the volume mesh, replacing any abrupt change in the cell size with polyhedral cells to improve solver performance in such transitional areas.
                            """
                            pass

                        class check_self_proximity(PyParameter):
                            """
                            Choose whether or not you would like to check for proximity issues (such as overlapping surfaces, very small gaps between surfaces, very sharp angles, etc.). Problematic areas will be highlighted in the graphics window if this option is set to yes.
                            """
                            pass

                        class max_cell_size_change(PyNumerical):
                            """
                            Parameter max_cell_size_change of value type float.
                            """
                            pass

                        class merge_body_labels(PyParameter):
                            """
                            Determine whether or not you would like to merge bodies that contain multiple body labels when generating the volume mesh (the default is yes)
                            """
                            pass

                        class min_edge_length(PyNumerical):
                            """
                            Parameter min_edge_length of value type float.
                            """
                            pass

                        class min_face_area(PyNumerical):
                            """
                            Parameter min_face_area of value type float.
                            """
                            pass

                        class min_poly_size(PyNumerical):
                            """
                            Parameter min_poly_size of value type float.
                            """
                            pass

                        class poly_feature_angle(PyNumerical):
                            """
                            Specify the angle to preserve features when using a polyhedral-based mesh.
                            """
                            pass

                        class poly_in_solids(PyParameter):
                            """
                            Indicate whether or not to fill only polyhedra cells in all solid regions during volume meshing using the poly-hexcore volume fill method.  The default value is no. Setting this to yes may improve meshing efficiency.
                            """
                            pass

                        class prepare_zone_names(PyParameter):
                            """
                            Indicate whether or not you want to persistently rename volume mesh components. This will make zone names equivalent to region names, and will make cell and face zone names unique.  Using this field is highly recommended for any parametric study. Persistent renaming only works if all body names are unique.
                            """
                            pass

                        class quality_method(PyTextual):
                            """
                            Choose from several different types of mesh quality controls (skewness, aspect ratio, change in size, and so on). Choices include Orthogonal (the default for the workflows), Enhanced Orthogonal, and Skewness. For more information, see  More... .
                            """
                            pass

                        class quality_warning_limit(PyNumerical):
                            """
                            Specify the threshold for when mesh quality improvements are automatically invoked that employ the orthogonal quality limit.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Display advanced options that you may want to apply to the task.
                            """
                            pass

                        class size_field_periodicity(PyParameter):
                            """
                            You can use the Size Field Periodicity option (set to no by default) to specify how the size field is generated when periodic boundaries are present. Selecting yes for this option will enforce a consistent size field across periodic boundaries. This option should only be enabled if periodic boundaries are well defined prior to generating the surface mesh.
                            """
                            pass

                        class solid_growth_rate(PyNumerical):
                            """
                            Specify the rate of growth for a tetrahedron or polyhedron mesh.
                            """
                            pass

                        class tet_in_solids(PyParameter):
                            """
                            Parameter tet_in_solids of value type bool.
                            """
                            pass

                        class use_size_field(PyParameter):
                            """
                            Specify whether or not to use size fields as part of generating the volume mesh. By default, this is set to yes when a BOI or body sizing has been defined in the Add Local Sizing task, however, for large cases, it can be turned off for the hexcore and poly-hexcore volume fill methods.
                            """
                            pass

                        class use_size_field_in_solids(PyParameter):
                            """
                            This option is available when both the Use Size Field? and Fill Polyhedra in Solids? options are enabled for the poly-hexcore fill method. By default this option is set to no, which specifies growth-rate-based sizing for polyhedra regions during poly-hexcore generation. Selecting yes for this option specifies the sizing for polyhedra regions to be size-field based and is recommended when BOI(s) or body sizing have been defined that include the polyhedra region.
                            """
                            pass

                        class write_prism_control_file(PyParameter):
                            """
                            Indicate whether or not you want to save a .pzmcontrol file to your working folder that will contain the boundary (prism) layer specifications.
                            """
                            pass

                    class body_label_body_list(PyTextual):
                        """
                        Parameter body_label_body_list of value type list[str].
                        """
                        pass

                    class body_label_list(PyTextual):
                        """
                        Parameter body_label_list of value type list[str].
                        """
                        pass

                    class decoupled_parallel_meshing(PyParameter):
                        """
                        Allows you to employ parallel settings for quicker and more efficient volume meshing. Disable this option if you are interested in only generating the volume mesh in serial mode.
                        """
                        pass

                    class first_aspect_ratio(PyNumerical):
                        """
                        Specify the aspect ratio of the first layer of prism cells that are extruded from the base boundary zone.
                        """
                        pass

                    class first_height(PyNumerical):
                        """
                        Specify the height of the first layer of cells in the boundary layer.
                        """
                        pass

                    class invoke_prims_control(PyTextual):
                        """
                        Parameter invoke_prims_control of value type str.
                        """
                        pass

                    class merge_cell_zones(PyParameter):
                        """
                        Parameter merge_cell_zones of value type bool.
                        """
                        pass

                    class mesh_dead_regions(PyParameter):
                        """
                        Parameter mesh_dead_regions of value type bool.
                        """
                        pass

                    class mesh_fluid_regions(PyParameter):
                        """
                        Choose whether to mesh the fluid regions in addition to the solid regions. This is enabled by default, and can be enabled along with the Mesh Solid Regions option, however, both options cannot be turned off at the same time.
                        """
                        pass

                    class mesh_object(PyTextual):
                        """
                        Parameter mesh_object of value type str.
                        """
                        pass

                    class mesh_solid_regions(PyParameter):
                        """
                        Choose whether to mesh the solid regions in addition to the fluid regions. This is enabled by default, and can be enabled along with the Mesh Fluid Regions option, however, both options cannot be turned off at the same time.
                        """
                        pass

                    class number_of_layers(PyNumerical):
                        """
                        Select the number of boundary layers to be generated.
                        """
                        pass

                    class offset_method_type(PyTextual):
                        """
                        Choose the type of offset to determine how the mesh cells closest to the boundary are generated.  More...
                        """
                        pass

                    class old_region_hex_max_cell_length_list(PyTextual):
                        """
                        Parameter old_region_hex_max_cell_length_list of value type list[str].
                        """
                        pass

                    class old_region_tet_growth_rate_list(PyTextual):
                        """
                        Parameter old_region_tet_growth_rate_list of value type list[str].
                        """
                        pass

                    class old_region_tet_max_cell_length_list(PyTextual):
                        """
                        Parameter old_region_tet_max_cell_length_list of value type list[str].
                        """
                        pass

                    class parallel_meshing(PyParameter):
                        """
                        Allows you to employ parallel settings for quicker and more efficient volume meshing. Disable this option if you are interested in only generating the volume mesh in serial mode.
                        """
                        pass

                    class prime_meshing(PyParameter):
                        """
                        Parameter prime_meshing of value type bool.
                        """
                        pass

                    class prism_layers(PyParameter):
                        """
                        Parameter prism_layers of value type bool.
                        """
                        pass

                    class quad_tet_transition(PyTextual):
                        """
                        Parameter quad_tet_transition of value type str.
                        """
                        pass

                    class rate(PyNumerical):
                        """
                        Specify the rate of growth for the boundary layer.
                        """
                        pass

                    class re_merge_zones(PyParameter):
                        """
                        After separating zones during surface meshing, here, choose to re-merge the zones prior to creating the volume mesh.
                        """
                        pass

                    class region_based_preferences(PyParameter):
                        """
                        Parameter region_based_preferences of value type bool.
                        """
                        pass

                    class region_hex_max_cell_length_list(PyTextual):
                        """
                        Parameter region_hex_max_cell_length_list of value type list[str].
                        """
                        pass

                    class region_hex_name_list(PyTextual):
                        """
                        Parameter region_hex_name_list of value type list[str].
                        """
                        pass

                    class region_tet_growth_rate_list(PyTextual):
                        """
                        Parameter region_tet_growth_rate_list of value type list[str].
                        """
                        pass

                    class region_tet_max_cell_length_list(PyTextual):
                        """
                        Parameter region_tet_max_cell_length_list of value type list[str].
                        """
                        pass

                    class region_tet_name_list(PyTextual):
                        """
                        Parameter region_tet_name_list of value type list[str].
                        """
                        pass

                    class show_solid_fluid_meshed(PyParameter):
                        """
                        Parameter show_solid_fluid_meshed of value type bool.
                        """
                        pass

                    class sizing_method(PyTextual):
                        """
                        Choose how the cell sizing controls (such as growth rate and the maximum cell length) will be evaluated: either globally or on a region-by-region basis.
                        """
                        pass

                    class solver(PyTextual):
                        """
                        Specify the target solver for which you want to generate the volume mesh (Fluent or CFX).
                        """
                        pass

                    class transition_ratio(PyNumerical):
                        """
                        Specify the rate at which adjacent elements grow, for the smooth transition offset method.
                        """
                        pass

                    class volume_fill(PyTextual):
                        """
                        Specify the type of cell to be used in the volumetric mesh: polyhedra (default), poly-hexcore, hexcore, or tetrahedral.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _create_volume_mesh_wtm:
                return super().__getitem__(key)

        class create_zero_thickness_geometry(PyNamedObjectContainer):
            """
            .
            """
            class _create_zero_thickness_geometry(PyMenu):
                """
                Singleton _create_zero_thickness_geometry.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.distance = self.__class__.distance(service, rules, path + [("distance", "")])
                        self.label_selection_list = self.__class__.label_selection_list(service, rules, path + [("label_selection_list", "")])
                        self.object_selection_list = self.__class__.object_selection_list(service, rules, path + [("object_selection_list", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.zero_thickness_name = self.__class__.zero_thickness_name(service, rules, path + [("zero_thickness_name", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        self.zone_selection_list = self.__class__.zone_selection_list(service, rules, path + [("zone_selection_list", "")])
                        super().__init__(service, rules, path)

                    class distance(PyNumerical):
                        """
                        Specify a value that adds thickness to the selected object. Thickness is applied in the normal direction. Negative values are allowed to preview the opposite/flipped direction. The original face normal will be kept, but you can add thickness in either direction based on a positive or negative value.
                        """
                        pass

                    class label_selection_list(PyTextual):
                        """
                        Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class object_selection_list(PyTextual):
                        """
                        Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Choose how you want to make your selection (by object, label, or zone name).
                        """
                        pass

                    class zero_thickness_name(PyTextual):
                        """
                        Specify a name for the thickness control or use the default value.
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                    class zone_selection_list(PyTextual):
                        """
                        Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _create_zero_thickness_geometry:
                return super().__getitem__(key)

        class custom_journal_task(PyNamedObjectContainer):
            """
            .
            """
            class _custom_journal_task(PyMenu):
                """
                Singleton _custom_journal_task.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.journal_string = self.__class__.journal_string(service, rules, path + [("journal_string", "")])
                        self.prime_journal = self.__class__.prime_journal(service, rules, path + [("prime_journal", "")])
                        self.python_journal = self.__class__.python_journal(service, rules, path + [("python_journal", "")])
                        super().__init__(service, rules, path)

                    class journal_string(PyTextual):
                        """
                        Enter one or more journal commands.
                        """
                        pass

                    class prime_journal(PyParameter):
                        """
                        Parameter prime_journal of value type bool.
                        """
                        pass

                    class python_journal(PyParameter):
                        """
                        Parameter python_journal of value type bool.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _custom_journal_task:
                return super().__getitem__(key)

        class define_boundary_layer_controls(PyNamedObjectContainer):
            """
            .
            """
            class _define_boundary_layer_controls(PyMenu):
                """
                Singleton _define_boundary_layer_controls.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.add_child = self.__class__.add_child(service, rules, path + [("add_child", "")])
                        self.aspect_ratio = self.__class__.aspect_ratio(service, rules, path + [("aspect_ratio", "")])
                        self.first_height = self.__class__.first_height(service, rules, path + [("first_height", "")])
                        self.growth_rate = self.__class__.growth_rate(service, rules, path + [("growth_rate", "")])
                        self.last_ratio_percentage = self.__class__.last_ratio_percentage(service, rules, path + [("last_ratio_percentage", "")])
                        self.offset_method_type = self.__class__.offset_method_type(service, rules, path + [("offset_method_type", "")])
                        self.prism_layers = self.__class__.prism_layers(service, rules, path + [("prism_layers", "")])
                        self.prisms_settings_name = self.__class__.prisms_settings_name(service, rules, path + [("prisms_settings_name", "")])
                        self.region_selection_list = self.__class__.region_selection_list(service, rules, path + [("region_selection_list", "")])
                        super().__init__(service, rules, path)

                    class add_child(PyParameter):
                        """
                        Determine whether or not you want to better capture flow in and around the boundary layer of your fluid regions.
                        """
                        pass

                    class aspect_ratio(PyNumerical):
                        """
                        Specify the ratio of the prism base length to the prism layer height.
                        """
                        pass

                    class first_height(PyNumerical):
                        """
                        Specify the height of the first layer of cells in the boundary layer.
                        """
                        pass

                    class growth_rate(PyNumerical):
                        """
                        Specify the rate of growth of the boundary layer.
                        """
                        pass

                    class last_ratio_percentage(PyNumerical):
                        """
                        Specify the offset height of the last layer as a percentage of the local base mesh size.
                        """
                        pass

                    class offset_method_type(PyTextual):
                        """
                        Choose the method that will be used to create the boundary layer, or prism, controls.
                        """
                        pass

                    class prism_layers(PyNumerical):
                        """
                        Specify the number of cell layers you require along the boundary.
                        """
                        pass

                    class prisms_settings_name(PyTextual):
                        """
                        Specify a name for the boundary layer control or use the default value.
                        """
                        pass

                    class region_selection_list(PyTextual):
                        """
                        Choose one or more regions from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _define_boundary_layer_controls:
                return super().__getitem__(key)

        class define_global_sizing(PyNamedObjectContainer):
            """
            .
            """
            class _define_global_sizing(PyMenu):
                """
                Singleton _define_global_sizing.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.cells_per_gap = self.__class__.cells_per_gap(service, rules, path + [("cells_per_gap", "")])
                        self.curvature_normal_angle = self.__class__.curvature_normal_angle(service, rules, path + [("curvature_normal_angle", "")])
                        self.enable_multi_threading = self.__class__.enable_multi_threading(service, rules, path + [("enable_multi_threading", "")])
                        self.growth_rate = self.__class__.growth_rate(service, rules, path + [("growth_rate", "")])
                        self.max_size = self.__class__.max_size(service, rules, path + [("max_size", "")])
                        self.mesher = self.__class__.mesher(service, rules, path + [("mesher", "")])
                        self.min_size = self.__class__.min_size(service, rules, path + [("min_size", "")])
                        self.number_of_multi_threads = self.__class__.number_of_multi_threads(service, rules, path + [("number_of_multi_threads", "")])
                        self.prime_size_control_ids = self.__class__.prime_size_control_ids(service, rules, path + [("prime_size_control_ids", "")])
                        self.reverse_edge_zone_orientationfor_persistent = self.__class__.reverse_edge_zone_orientationfor_persistent(service, rules, path + [("reverse_edge_zone_orientationfor_persistent", "")])
                        self.scope_proximity_to = self.__class__.scope_proximity_to(service, rules, path + [("scope_proximity_to", "")])
                        self.size_functions = self.__class__.size_functions(service, rules, path + [("size_functions", "")])
                        super().__init__(service, rules, path)

                    class cells_per_gap(PyNumerical):
                        """
                        Parameter cells_per_gap of value type float.
                        """
                        pass

                    class curvature_normal_angle(PyNumerical):
                        """
                        Parameter curvature_normal_angle of value type float.
                        """
                        pass

                    class enable_multi_threading(PyParameter):
                        """
                        Parameter enable_multi_threading of value type bool.
                        """
                        pass

                    class growth_rate(PyNumerical):
                        """
                        Parameter growth_rate of value type float.
                        """
                        pass

                    class max_size(PyNumerical):
                        """
                        Parameter max_size of value type float.
                        """
                        pass

                    class mesher(PyTextual):
                        """
                        Parameter mesher of value type str.
                        """
                        pass

                    class min_size(PyNumerical):
                        """
                        Parameter min_size of value type float.
                        """
                        pass

                    class number_of_multi_threads(PyNumerical):
                        """
                        Parameter number_of_multi_threads of value type int.
                        """
                        pass

                    class prime_size_control_ids(PyParameter):
                        """
                        Parameter prime_size_control_ids of value type list[int].
                        """
                        pass

                    class reverse_edge_zone_orientationfor_persistent(PyParameter):
                        """
                        Parameter reverse_edge_zone_orientationfor_persistent of value type list[int].
                        """
                        pass

                    class scope_proximity_to(PyTextual):
                        """
                        Parameter scope_proximity_to of value type str.
                        """
                        pass

                    class size_functions(PyTextual):
                        """
                        Parameter size_functions of value type str.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _define_global_sizing:
                return super().__getitem__(key)

        class define_leakage_threshold(PyNamedObjectContainer):
            """
            .
            """
            class _define_leakage_threshold(PyMenu):
                """
                Singleton _define_leakage_threshold.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.add_child = self.__class__.add_child(service, rules, path + [("add_child", "")])
                        self.dead_regions_list = self.__class__.dead_regions_list(service, rules, path + [("dead_regions_list", "")])
                        self.dead_regions_size = self.__class__.dead_regions_size(service, rules, path + [("dead_regions_size", "")])
                        self.flip_direction = self.__class__.flip_direction(service, rules, path + [("flip_direction", "")])
                        self.leakage_name = self.__class__.leakage_name(service, rules, path + [("leakage_name", "")])
                        self.plane_clipping_value = self.__class__.plane_clipping_value(service, rules, path + [("plane_clipping_value", "")])
                        self.plane_direction = self.__class__.plane_direction(service, rules, path + [("plane_direction", "")])
                        self.region_selection_single = self.__class__.region_selection_single(service, rules, path + [("region_selection_single", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        super().__init__(service, rules, path)

                    class add_child(PyParameter):
                        """
                        Indicate whether or not you need to define a leakage threshold for one or more regions.
                        """
                        pass

                    class dead_regions_list(PyTextual):
                        """
                        Choose one or more regions from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class dead_regions_size(PyNumerical):
                        """
                        The leakage threshold size is based on multiples of two. For example, if leaks are detected at 8 but not at 16 (for example, 2\\*8), then the threshold size is 16, and any leakage smaller than 16 will be closed.
                        """
                        pass

                    class flip_direction(PyParameter):
                        """
                        Change the orientation of the clipping plane, exposing the mesh on the opposite side.
                        """
                        pass

                    class leakage_name(PyTextual):
                        """
                        Specify a name for the leakage threshold or use the default value.
                        """
                        pass

                    class plane_clipping_value(PyNumerical):
                        """
                        Use the slider to move the clipping plane along the axis of the selected X, Y, or Z direction.
                        """
                        pass

                    class plane_direction(PyTextual):
                        """
                        Indicates the direction in which the clipping plane faces.
                        """
                        pass

                    class region_selection_single(PyTextual):
                        """
                        Choose a single region from the list of identified regions below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Choose how you want to make your selection (by object or by a previously identified region).
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _define_leakage_threshold:
                return super().__getitem__(key)

        class describe_geometry(PyNamedObjectContainer):
            """
            .
            """
            class _describe_geometry(PyMenu):
                """
                Singleton _describe_geometry.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.improve_surface_mesh_preferences = self.__class__.improve_surface_mesh_preferences(service, rules, path + [("improve_surface_mesh_preferences", "")])
                        self.capping_required = self.__class__.capping_required(service, rules, path + [("capping_required", "")])
                        self.duplicates = self.__class__.duplicates(service, rules, path + [("duplicates", "")])
                        self.edge_labels = self.__class__.edge_labels(service, rules, path + [("edge_labels", "")])
                        self.edge_zone_list = self.__class__.edge_zone_list(service, rules, path + [("edge_zone_list", "")])
                        self.fluid_regions = self.__class__.fluid_regions(service, rules, path + [("fluid_regions", "")])
                        self.invoke_share_topology = self.__class__.invoke_share_topology(service, rules, path + [("invoke_share_topology", "")])
                        self.multizone = self.__class__.multizone(service, rules, path + [("multizone", "")])
                        self.non_conformal = self.__class__.non_conformal(service, rules, path + [("non_conformal", "")])
                        self.old_zone_list = self.__class__.old_zone_list(service, rules, path + [("old_zone_list", "")])
                        self.old_zone_type_list = self.__class__.old_zone_type_list(service, rules, path + [("old_zone_type_list", "")])
                        self.region_list = self.__class__.region_list(service, rules, path + [("region_list", "")])
                        self.setup_internal_types = self.__class__.setup_internal_types(service, rules, path + [("setup_internal_types", "")])
                        self.setup_internals = self.__class__.setup_internals(service, rules, path + [("setup_internals", "")])
                        self.setup_type = self.__class__.setup_type(service, rules, path + [("setup_type", "")])
                        self.wall_to_internal = self.__class__.wall_to_internal(service, rules, path + [("wall_to_internal", "")])
                        super().__init__(service, rules, path)

                    class improve_surface_mesh_preferences(PyMenu):
                        """
                        Singleton improve_surface_mesh_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.advanced_improve = self.__class__.advanced_improve(service, rules, path + [("advanced_improve", "")])
                            self.allow_defeaturing = self.__class__.allow_defeaturing(service, rules, path + [("allow_defeaturing", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            self.si_dihedral_angle = self.__class__.si_dihedral_angle(service, rules, path + [("si_dihedral_angle", "")])
                            self.si_improve_dihedral_angle = self.__class__.si_improve_dihedral_angle(service, rules, path + [("si_improve_dihedral_angle", "")])
                            self.si_quality_collapse_limit = self.__class__.si_quality_collapse_limit(service, rules, path + [("si_quality_collapse_limit", "")])
                            self.si_quality_iterations = self.__class__.si_quality_iterations(service, rules, path + [("si_quality_iterations", "")])
                            self.si_quality_max_angle = self.__class__.si_quality_max_angle(service, rules, path + [("si_quality_max_angle", "")])
                            self.si_remove_step = self.__class__.si_remove_step(service, rules, path + [("si_remove_step", "")])
                            self.si_step_quality_limit = self.__class__.si_step_quality_limit(service, rules, path + [("si_step_quality_limit", "")])
                            self.si_step_width = self.__class__.si_step_width(service, rules, path + [("si_step_width", "")])
                            super().__init__(service, rules, path)

                        class advanced_improve(PyParameter):
                            """
                            Parameter advanced_improve of value type bool.
                            """
                            pass

                        class allow_defeaturing(PyParameter):
                            """
                            Parameter allow_defeaturing of value type bool.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Parameter show_in_gui of value type bool.
                            """
                            pass

                        class si_dihedral_angle(PyNumerical):
                            """
                            Parameter si_dihedral_angle of value type float.
                            """
                            pass

                        class si_improve_dihedral_angle(PyParameter):
                            """
                            Parameter si_improve_dihedral_angle of value type bool.
                            """
                            pass

                        class si_quality_collapse_limit(PyNumerical):
                            """
                            Parameter si_quality_collapse_limit of value type float.
                            """
                            pass

                        class si_quality_iterations(PyNumerical):
                            """
                            Parameter si_quality_iterations of value type int.
                            """
                            pass

                        class si_quality_max_angle(PyNumerical):
                            """
                            Parameter si_quality_max_angle of value type float.
                            """
                            pass

                        class si_remove_step(PyParameter):
                            """
                            Parameter si_remove_step of value type bool.
                            """
                            pass

                        class si_step_quality_limit(PyNumerical):
                            """
                            Parameter si_step_quality_limit of value type float.
                            """
                            pass

                        class si_step_width(PyNumerical):
                            """
                            Parameter si_step_width of value type float.
                            """
                            pass

                    class capping_required(PyParameter):
                        """
                        Choose whether or not you are going to perform any capping operations, thereby enclosing a fluid region.
                        """
                        pass

                    class duplicates(PyParameter):
                        """
                        Parameter duplicates of value type bool.
                        """
                        pass

                    class edge_labels(PyTextual):
                        """
                        Parameter edge_labels of value type list[str].
                        """
                        pass

                    class edge_zone_list(PyTextual):
                        """
                        Parameter edge_zone_list of value type list[str].
                        """
                        pass

                    class fluid_regions(PyTextual):
                        """
                        Parameter fluid_regions of value type list[str].
                        """
                        pass

                    class invoke_share_topology(PyTextual):
                        """
                        For CAD assemblies with multiple parts, choose whether or not to identify and close any problematic gaps and whether to join and/or intersect problematic faces. This will add an Apply Share Topology task to your workflow. Note that in situations where you want to use overlapping non-conformal interfaces, you must use the non-conformal option. In all other situations, such as when you have totally disconnected bodies (that is, with no overlap), you should instead elect to choose the Share Topology option even if there is nothing to share.
                        """
                        pass

                    class multizone(PyParameter):
                        """
                        Determine whether or not you want to perform multi-zone meshing on your geometry. Selecting Yes will add an Add Multizone Controls task and a Generate Multizone Mesh task to your workflow.
                        """
                        pass

                    class non_conformal(PyParameter):
                        """
                        Determine whether or not you want to create non-conformal meshes between the objects in your geometry. Note that in situations where you want to use overlapping non-conformal interfaces, you must use the non-conformal option. In all other situations, such as when you have totally disconnected bodies (that is, with no overlap), you should instead elect to choose the Share Topology option even if there is nothing to share.
                        """
                        pass

                    class old_zone_list(PyTextual):
                        """
                        Parameter old_zone_list of value type list[str].
                        """
                        pass

                    class old_zone_type_list(PyTextual):
                        """
                        Parameter old_zone_type_list of value type list[str].
                        """
                        pass

                    class region_list(PyTextual):
                        """
                        Parameter region_list of value type list[str].
                        """
                        pass

                    class setup_internal_types(PyTextual):
                        """
                        Parameter setup_internal_types of value type list[str].
                        """
                        pass

                    class setup_internals(PyTextual):
                        """
                        Parameter setup_internals of value type list[str].
                        """
                        pass

                    class setup_type(PyTextual):
                        """
                        Choose whether your geometry represents only a solid body, only a fluid body, or both a solid and fluid body.
                        """
                        pass

                    class wall_to_internal(PyParameter):
                        """
                        Choose whether or not to change interior fluid-fluid boundaries from type "wall" to "internal". Only internal boundaries bounded by two fluid regions are converted into internal zone types. If new fluid regions are assigned, this task is executed after the Update Regions task. Internal boundaries that are designated as "baffles" are retained as walls.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _describe_geometry:
                return super().__getitem__(key)

        class describe_geometry_and_flow(PyNamedObjectContainer):
            """
            .
            """
            class _describe_geometry_and_flow(PyMenu):
                """
                Singleton _describe_geometry_and_flow.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.describe_geometry_and_flow_options = self.__class__.describe_geometry_and_flow_options(service, rules, path + [("describe_geometry_and_flow_options", "")])
                        self.add_enclosure = self.__class__.add_enclosure(service, rules, path + [("add_enclosure", "")])
                        self.all_task_list = self.__class__.all_task_list(service, rules, path + [("all_task_list", "")])
                        self.close_caps = self.__class__.close_caps(service, rules, path + [("close_caps", "")])
                        self.flow_type = self.__class__.flow_type(service, rules, path + [("flow_type", "")])
                        self.geometry_options = self.__class__.geometry_options(service, rules, path + [("geometry_options", "")])
                        self.local_refinement_regions = self.__class__.local_refinement_regions(service, rules, path + [("local_refinement_regions", "")])
                        super().__init__(service, rules, path)

                    class describe_geometry_and_flow_options(PyMenu):
                        """
                        Singleton describe_geometry_and_flow_options.
                        """
                        def __init__(self, service, rules, path):
                            self.advanced_options = self.__class__.advanced_options(service, rules, path + [("advanced_options", "")])
                            self.close_leakages = self.__class__.close_leakages(service, rules, path + [("close_leakages", "")])
                            self.close_leakges = self.__class__.close_leakges(service, rules, path + [("close_leakges", "")])
                            self.enable_overset = self.__class__.enable_overset(service, rules, path + [("enable_overset", "")])
                            self.enable_prime_wrapper = self.__class__.enable_prime_wrapper(service, rules, path + [("enable_prime_wrapper", "")])
                            self.extract_edge_features = self.__class__.extract_edge_features(service, rules, path + [("extract_edge_features", "")])
                            self.identify_regions = self.__class__.identify_regions(service, rules, path + [("identify_regions", "")])
                            self.moving_objects = self.__class__.moving_objects(service, rules, path + [("moving_objects", "")])
                            self.porous_regions = self.__class__.porous_regions(service, rules, path + [("porous_regions", "")])
                            self.zero_thickness = self.__class__.zero_thickness(service, rules, path + [("zero_thickness", "")])
                            super().__init__(service, rules, path)

                        class advanced_options(PyParameter):
                            """
                            Display advanced options that you may want to apply to the workflow.
                            """
                            pass

                        class close_leakages(PyParameter):
                            """
                            Parameter close_leakages of value type bool.
                            """
                            pass

                        class close_leakges(PyParameter):
                            """
                            Specify whether or not your geometry contains any problems (such as gaps or overlapping/intersecting surfaces) that may create leakages that need to be closed. If so, then a Define Leakage Threshold task is added to the workflow.
                            """
                            pass

                        class enable_overset(PyParameter):
                            """
                            Specify whether or not you will need to create any overlapping or overset meshes. Such types of meshes can provide better mesh resolution in and around complicated, intersected portions of your geometry.
                            """
                            pass

                        class enable_prime_wrapper(PyParameter):
                            """
                            Parameter enable_prime_wrapper of value type bool.
                            """
                            pass

                        class extract_edge_features(PyParameter):
                            """
                            Specify whether or not you will need to extract additional edge features from your imported geometry. These edge features will be captured. If so, then an Extract Edge Features task will be added to the workflow.
                            """
                            pass

                        class identify_regions(PyParameter):
                            """
                            Specify whether or not you need to specifically identify and analyze particular regions. If so, then an Identify Regions task is added to the workflow.
                            """
                            pass

                        class moving_objects(PyParameter):
                            """
                            Specify whether or not you will need to create or identify any specialized construction surfaces within your geometry or flow that need to be identified (such as capping surfaces or cylindrical surfaces to be used for moving reference frames, etc.). If so, then an Identify Construction Surfaces task will be added to the workflow. More...
                            """
                            pass

                        class porous_regions(PyParameter):
                            """
                            Specify whether or not you will have any porous regions in your geometry. If so, then a Create Porous Regions task will be added to the workflow. A simple primitive rectangle will be placed over complex and detailed geometry of a porous region (for example, fins and tubes of a heat exchanger).  With buffer layer:
                            """
                            pass

                        class zero_thickness(PyTextual):
                            """
                            Specify whether or not you will need to account for any portions of your geometry with zero-thickness, and apply thickness to them for a more refined surface mesh. If so, then an Add Thickness task will be added to the workflow.
                            """
                            pass

                    class add_enclosure(PyParameter):
                        """
                        Specify whether you are going to need to add an external flow boundary around your imported geometry. If so, this will add a Create External Flow Boundaries task to the workflow.
                        """
                        pass

                    class all_task_list(PyTextual):
                        """
                        Parameter all_task_list of value type list[str].
                        """
                        pass

                    class close_caps(PyParameter):
                        """
                        Specify whether or not you will need to cover, or cap, and large holes in order to create an internal fluid flow region. If so, this will add an Enclose Fluid Regions (Capping) task to the workflow.
                        """
                        pass

                    class flow_type(PyTextual):
                        """
                        Specify the type of flow you want to simulate: external flow, internal flow, or both. The appropriate Standard Options (for example adding an enclosure, adding caps, etc.) will be selected for you, depending on your choice.
                        """
                        pass

                    class geometry_options(PyParameter):
                        """
                        Display standard geometry-based options that you may want to apply to the workflow.
                        """
                        pass

                    class local_refinement_regions(PyParameter):
                        """
                        Specify whether or not you will need to add local refinement in and around the imported geometry. If so, this will add a Create Local Refinement Regions task to the workflow.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _describe_geometry_and_flow:
                return super().__getitem__(key)

        class describe_overset_features(PyNamedObjectContainer):
            """
            .
            """
            class _describe_overset_features(PyMenu):
                """
                Singleton _describe_overset_features.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.advanced_options = self.__class__.advanced_options(service, rules, path + [("advanced_options", "")])
                        self.background_mesh = self.__class__.background_mesh(service, rules, path + [("background_mesh", "")])
                        self.collar_grid = self.__class__.collar_grid(service, rules, path + [("collar_grid", "")])
                        self.component_grid = self.__class__.component_grid(service, rules, path + [("component_grid", "")])
                        self.overset_interfaces = self.__class__.overset_interfaces(service, rules, path + [("overset_interfaces", "")])
                        super().__init__(service, rules, path)

                    class advanced_options(PyParameter):
                        """
                        Parameter advanced_options of value type bool.
                        """
                        pass

                    class background_mesh(PyParameter):
                        """
                        Parameter background_mesh of value type bool.
                        """
                        pass

                    class collar_grid(PyParameter):
                        """
                        Indicate whether you need to add an overset collar mesh task to the workflow
                        """
                        pass

                    class component_grid(PyParameter):
                        """
                        Indicate whether you need to add an overset component mesh task to the workflow.
                        """
                        pass

                    class overset_interfaces(PyParameter):
                        """
                        Parameter overset_interfaces of value type bool.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _describe_overset_features:
                return super().__getitem__(key)

        class extract_edge_features(PyNamedObjectContainer):
            """
            .
            """
            class _extract_edge_features(PyMenu):
                """
                Singleton _extract_edge_features.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.complete_geom_object_selection_list = self.__class__.complete_geom_object_selection_list(service, rules, path + [("complete_geom_object_selection_list", "")])
                        self.complete_object_selection_list = self.__class__.complete_object_selection_list(service, rules, path + [("complete_object_selection_list", "")])
                        self.extract_edges_name = self.__class__.extract_edges_name(service, rules, path + [("extract_edges_name", "")])
                        self.extract_method_type = self.__class__.extract_method_type(service, rules, path + [("extract_method_type", "")])
                        self.feature_angle_local = self.__class__.feature_angle_local(service, rules, path + [("feature_angle_local", "")])
                        self.geom_object_selection_list = self.__class__.geom_object_selection_list(service, rules, path + [("geom_object_selection_list", "")])
                        self.individual_collective = self.__class__.individual_collective(service, rules, path + [("individual_collective", "")])
                        self.label_selection_list = self.__class__.label_selection_list(service, rules, path + [("label_selection_list", "")])
                        self.non_extracted_objects = self.__class__.non_extracted_objects(service, rules, path + [("non_extracted_objects", "")])
                        self.object_selection_list = self.__class__.object_selection_list(service, rules, path + [("object_selection_list", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.sharp_angle = self.__class__.sharp_angle(service, rules, path + [("sharp_angle", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        self.zone_selection_list = self.__class__.zone_selection_list(service, rules, path + [("zone_selection_list", "")])
                        super().__init__(service, rules, path)

                    class complete_geom_object_selection_list(PyTextual):
                        """
                        Select one or more geometry objects from the list below to apply the edge feature extraction to. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class complete_object_selection_list(PyTextual):
                        """
                        Select one or more geometry objects from the list below to apply the edge feature extraction to. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class extract_edges_name(PyTextual):
                        """
                        Specify a name for the edge feature extraction or use the default value.
                        """
                        pass

                    class extract_method_type(PyTextual):
                        """
                        Choose how the edge features are to be extracted: either by feature angle, intersection loops, or by sharp angle.
                        """
                        pass

                    class feature_angle_local(PyNumerical):
                        """
                        Specify the minimum angle between the feature edges that should be preserved.
                        """
                        pass

                    class geom_object_selection_list(PyTextual):
                        """
                        Select one or more geometry objects from the list below to apply the edge feature extraction to. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class individual_collective(PyTextual):
                        """
                        Choose face zone interactivity -  individual: considers intersection of face zones within the object(s) selected; collectively: consider intersection of faces only across selected objects.
                        """
                        pass

                    class label_selection_list(PyTextual):
                        """
                        Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class non_extracted_objects(PyTextual):
                        """
                        Parameter non_extracted_objects of value type list[str].
                        """
                        pass

                    class object_selection_list(PyTextual):
                        """
                        Select one or more geometry objects from the list below to apply the edge feature extraction to. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Choose how you want to make your selection (by object, label, or zone name).
                        """
                        pass

                    class sharp_angle(PyNumerical):
                        """
                        Use the slider to specify the sharp angle (in degrees) that will be used in the feature extraction.
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                    class zone_selection_list(PyTextual):
                        """
                        Select one or more zones from the list below to apply the edge feature extraction to. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _extract_edge_features:
                return super().__getitem__(key)

        class extrude_volume_mesh(PyNamedObjectContainer):
            """
            .
            """
            class _extrude_volume_mesh(PyMenu):
                """
                Singleton _extrude_volume_mesh.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.volume_mesh_extrusion_preferences = self.__class__.volume_mesh_extrusion_preferences(service, rules, path + [("volume_mesh_extrusion_preferences", "")])
                        self.extend_to_periodic_pair = self.__class__.extend_to_periodic_pair(service, rules, path + [("extend_to_periodic_pair", "")])
                        self.external_boundary_zone_list = self.__class__.external_boundary_zone_list(service, rules, path + [("external_boundary_zone_list", "")])
                        self.extrude_normal_based = self.__class__.extrude_normal_based(service, rules, path + [("extrude_normal_based", "")])
                        self.first_height = self.__class__.first_height(service, rules, path + [("first_height", "")])
                        self.growth_rate = self.__class__.growth_rate(service, rules, path + [("growth_rate", "")])
                        self.m_ex_control_name = self.__class__.m_ex_control_name(service, rules, path + [("m_ex_control_name", "")])
                        self.method = self.__class__.method(service, rules, path + [("method", "")])
                        self.numberof_layers = self.__class__.numberof_layers(service, rules, path + [("numberof_layers", "")])
                        self.preserve_periodic_info = self.__class__.preserve_periodic_info(service, rules, path + [("preserve_periodic_info", "")])
                        self.reverse_direction = self.__class__.reverse_direction(service, rules, path + [("reverse_direction", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.topology_list = self.__class__.topology_list(service, rules, path + [("topology_list", "")])
                        self.total_height = self.__class__.total_height(service, rules, path + [("total_height", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        super().__init__(service, rules, path)

                    class volume_mesh_extrusion_preferences(PyMenu):
                        """
                        Singleton volume_mesh_extrusion_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.bias_method = self.__class__.bias_method(service, rules, path + [("bias_method", "")])
                            self.max_layer_height = self.__class__.max_layer_height(service, rules, path + [("max_layer_height", "")])
                            self.merge_cell_zones = self.__class__.merge_cell_zones(service, rules, path + [("merge_cell_zones", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            super().__init__(service, rules, path)

                        class bias_method(PyTextual):
                            """
                            Select from a choice of patterns that you want to apply to your volume mesh extrusion.
                            """
                            pass

                        class max_layer_height(PyNumerical):
                            """
                            Specify the maximum allowed height/thickness for prism layers in this operation.
                            """
                            pass

                        class merge_cell_zones(PyParameter):
                            """
                            Indicate whether or not you want to merge the extruded layers with any adjacent regions.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Display advanced options that you may want to apply to the task.
                            """
                            pass

                    class extend_to_periodic_pair(PyParameter):
                        """
                        Parameter extend_to_periodic_pair of value type bool.
                        """
                        pass

                    class external_boundary_zone_list(PyTextual):
                        """
                        Select one or more boundaries. All selected boundaries must share the same plane. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class extrude_normal_based(PyParameter):
                        """
                        Specify whether the volume extrusion is derived from normal-based faceting or direction-based faceting. When enabled (the default), the volume extrusion is derived on normal-based faceting, such that for each layer, the normal is calculated and smoothing occurs, and is suitable for non-planar surfaces. For planar surfaces, disable this option to use a direction-based approach where the direction is chosen based on the average normal of the entire surface, and is used to extrude all layers.
                        """
                        pass

                    class first_height(PyNumerical):
                        """
                        Specify a value for the height of the first layer of the extrusion or use the default value.
                        """
                        pass

                    class growth_rate(PyNumerical):
                        """
                        Specify how the extrusion layers will grow. For example, a value of 1.2 indicates that each successive layer will grow by 20 percent of the previous layer. 
                                        More...
                        """
                        pass

                    class m_ex_control_name(PyTextual):
                        """
                        Specify a name for the extrusion or use the default value.
                        """
                        pass

                    class method(PyTextual):
                        """
                        Choose whether you want the extrusion to be based on a specified Total Height value, or one based on a specified First Height value. The relationship between the two is illustrated by:
                        """
                        pass

                    class numberof_layers(PyNumerical):
                        """
                        Specify the number of extrusion layers.
                        """
                        pass

                    class preserve_periodic_info(PyParameter):
                        """
                        Parameter preserve_periodic_info of value type bool.
                        """
                        pass

                    class reverse_direction(PyParameter):
                        """
                        Parameter reverse_direction of value type bool.
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Parameter selection_type of value type str.
                        """
                        pass

                    class topology_list(PyTextual):
                        """
                        Parameter topology_list of value type list[str].
                        """
                        pass

                    class total_height(PyNumerical):
                        """
                        Specify a value for the total height of the extrusion or use the default value.
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _extrude_volume_mesh:
                return super().__getitem__(key)

        class generate_initial_surface_mesh(PyNamedObjectContainer):
            """
            .
            """
            class _generate_initial_surface_mesh(PyMenu):
                """
                Singleton _generate_initial_surface_mesh.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.prism_2d_preferences = self.__class__.prism_2d_preferences(service, rules, path + [("prism_2d_preferences", "")])
                        self.surface_2d_preferences = self.__class__.surface_2d_preferences(service, rules, path + [("surface_2d_preferences", "")])
                        self.enable_multi_threading = self.__class__.enable_multi_threading(service, rules, path + [("enable_multi_threading", "")])
                        self.generate_quads = self.__class__.generate_quads(service, rules, path + [("generate_quads", "")])
                        self.number_of_multi_threads = self.__class__.number_of_multi_threads(service, rules, path + [("number_of_multi_threads", "")])
                        self.project_on_geometry = self.__class__.project_on_geometry(service, rules, path + [("project_on_geometry", "")])
                        super().__init__(service, rules, path)

                    class prism_2d_preferences(PyMenu):
                        """
                        Singleton prism_2d_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.gap_factor = self.__class__.gap_factor(service, rules, path + [("gap_factor", "")])
                            self.local_remesh = self.__class__.local_remesh(service, rules, path + [("local_remesh", "")])
                            self.max_aspect_ratio = self.__class__.max_aspect_ratio(service, rules, path + [("max_aspect_ratio", "")])
                            self.max_face_skew = self.__class__.max_face_skew(service, rules, path + [("max_face_skew", "")])
                            self.min_aspect_ratio = self.__class__.min_aspect_ratio(service, rules, path + [("min_aspect_ratio", "")])
                            self.n_orthogonal_layers = self.__class__.n_orthogonal_layers(service, rules, path + [("n_orthogonal_layers", "")])
                            self.refine_stretched_quads = self.__class__.refine_stretched_quads(service, rules, path + [("refine_stretched_quads", "")])
                            self.remesh_growth_rate = self.__class__.remesh_growth_rate(service, rules, path + [("remesh_growth_rate", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            self.split_quads = self.__class__.split_quads(service, rules, path + [("split_quads", "")])
                            super().__init__(service, rules, path)

                        class gap_factor(PyNumerical):
                            """
                            Parameter gap_factor of value type float.
                            """
                            pass

                        class local_remesh(PyParameter):
                            """
                            Parameter local_remesh of value type bool.
                            """
                            pass

                        class max_aspect_ratio(PyNumerical):
                            """
                            Parameter max_aspect_ratio of value type float.
                            """
                            pass

                        class max_face_skew(PyNumerical):
                            """
                            Parameter max_face_skew of value type float.
                            """
                            pass

                        class min_aspect_ratio(PyNumerical):
                            """
                            Parameter min_aspect_ratio of value type float.
                            """
                            pass

                        class n_orthogonal_layers(PyNumerical):
                            """
                            Parameter n_orthogonal_layers of value type int.
                            """
                            pass

                        class refine_stretched_quads(PyParameter):
                            """
                            Parameter refine_stretched_quads of value type bool.
                            """
                            pass

                        class remesh_growth_rate(PyNumerical):
                            """
                            Parameter remesh_growth_rate of value type float.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Parameter show_in_gui of value type bool.
                            """
                            pass

                        class split_quads(PyParameter):
                            """
                            Parameter split_quads of value type bool.
                            """
                            pass

                    class surface_2d_preferences(PyMenu):
                        """
                        Singleton surface_2d_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.merge_edge_zones_based_on_labels = self.__class__.merge_edge_zones_based_on_labels(service, rules, path + [("merge_edge_zones_based_on_labels", "")])
                            self.merge_face_zones_based_on_labels = self.__class__.merge_face_zones_based_on_labels(service, rules, path + [("merge_face_zones_based_on_labels", "")])
                            self.show_advanced_options = self.__class__.show_advanced_options(service, rules, path + [("show_advanced_options", "")])
                            super().__init__(service, rules, path)

                        class merge_edge_zones_based_on_labels(PyParameter):
                            """
                            Parameter merge_edge_zones_based_on_labels of value type bool.
                            """
                            pass

                        class merge_face_zones_based_on_labels(PyParameter):
                            """
                            Parameter merge_face_zones_based_on_labels of value type bool.
                            """
                            pass

                        class show_advanced_options(PyParameter):
                            """
                            Parameter show_advanced_options of value type bool.
                            """
                            pass

                    class enable_multi_threading(PyParameter):
                        """
                        Parameter enable_multi_threading of value type bool.
                        """
                        pass

                    class generate_quads(PyParameter):
                        """
                        Parameter generate_quads of value type bool.
                        """
                        pass

                    class number_of_multi_threads(PyNumerical):
                        """
                        Parameter number_of_multi_threads of value type int.
                        """
                        pass

                    class project_on_geometry(PyParameter):
                        """
                        Parameter project_on_geometry of value type bool.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _generate_initial_surface_mesh:
                return super().__getitem__(key)

        class generate_map_mesh(PyNamedObjectContainer):
            """
            .
            """
            class _generate_map_mesh(PyMenu):
                """
                Singleton _generate_map_mesh.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.add_child = self.__class__.add_child(service, rules, path + [("add_child", "")])
                        self.constant_size = self.__class__.constant_size(service, rules, path + [("constant_size", "")])
                        self.control_name = self.__class__.control_name(service, rules, path + [("control_name", "")])
                        self.face_label_list = self.__class__.face_label_list(service, rules, path + [("face_label_list", "")])
                        self.face_zone_list = self.__class__.face_zone_list(service, rules, path + [("face_zone_list", "")])
                        self.growth_rate = self.__class__.growth_rate(service, rules, path + [("growth_rate", "")])
                        self.project_on_geometry = self.__class__.project_on_geometry(service, rules, path + [("project_on_geometry", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.short_side_divisions = self.__class__.short_side_divisions(service, rules, path + [("short_side_divisions", "")])
                        self.sizing_option = self.__class__.sizing_option(service, rules, path + [("sizing_option", "")])
                        self.split_quads = self.__class__.split_quads(service, rules, path + [("split_quads", "")])
                        super().__init__(service, rules, path)

                    class add_child(PyTextual):
                        """
                        Parameter add_child of value type str.
                        """
                        pass

                    class constant_size(PyNumerical):
                        """
                        Parameter constant_size of value type float.
                        """
                        pass

                    class control_name(PyTextual):
                        """
                        Parameter control_name of value type str.
                        """
                        pass

                    class face_label_list(PyTextual):
                        """
                        Parameter face_label_list of value type list[str].
                        """
                        pass

                    class face_zone_list(PyTextual):
                        """
                        Parameter face_zone_list of value type list[str].
                        """
                        pass

                    class growth_rate(PyNumerical):
                        """
                        Parameter growth_rate of value type float.
                        """
                        pass

                    class project_on_geometry(PyParameter):
                        """
                        Parameter project_on_geometry of value type bool.
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Parameter selection_type of value type str.
                        """
                        pass

                    class short_side_divisions(PyNumerical):
                        """
                        Parameter short_side_divisions of value type int.
                        """
                        pass

                    class sizing_option(PyTextual):
                        """
                        Parameter sizing_option of value type str.
                        """
                        pass

                    class split_quads(PyParameter):
                        """
                        Parameter split_quads of value type bool.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _generate_map_mesh:
                return super().__getitem__(key)

        class generate_prism_layers(PyNamedObjectContainer):
            """
            .
            """
            class _generate_prism_layers(PyMenu):
                """
                Singleton _generate_prism_layers.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.generate_prisms_option = self.__class__.generate_prisms_option(service, rules, path + [("generate_prisms_option", "")])
                        super().__init__(service, rules, path)

                    class generate_prisms_option(PyParameter):
                        """
                        Parameter generate_prisms_option of value type bool.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _generate_prism_layers:
                return super().__getitem__(key)

        class generate_surface_mesh(PyNamedObjectContainer):
            """
            .
            """
            class _generate_surface_mesh(PyMenu):
                """
                Singleton _generate_surface_mesh.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.advanced_inner_wrap = self.__class__.advanced_inner_wrap(service, rules, path + [("advanced_inner_wrap", "")])
                        self.advanced_options = self.__class__.advanced_options(service, rules, path + [("advanced_options", "")])
                        self.auto_assign_zone_types = self.__class__.auto_assign_zone_types(service, rules, path + [("auto_assign_zone_types", "")])
                        self.auto_pairing = self.__class__.auto_pairing(service, rules, path + [("auto_pairing", "")])
                        self.auto_region_between_porous = self.__class__.auto_region_between_porous(service, rules, path + [("auto_region_between_porous", "")])
                        self.dihedral_min_angle = self.__class__.dihedral_min_angle(service, rules, path + [("dihedral_min_angle", "")])
                        self.gap_cover_zone_recovery = self.__class__.gap_cover_zone_recovery(service, rules, path + [("gap_cover_zone_recovery", "")])
                        self.global_min = self.__class__.global_min(service, rules, path + [("global_min", "")])
                        self.intermediate_file_name = self.__class__.intermediate_file_name(service, rules, path + [("intermediate_file_name", "")])
                        self.leak_shield = self.__class__.leak_shield(service, rules, path + [("leak_shield", "")])
                        self.max_island_face = self.__class__.max_island_face(service, rules, path + [("max_island_face", "")])
                        self.merge_wrapper_at_solid_conacts = self.__class__.merge_wrapper_at_solid_conacts(service, rules, path + [("merge_wrapper_at_solid_conacts", "")])
                        self.number_of_sessions = self.__class__.number_of_sessions(service, rules, path + [("number_of_sessions", "")])
                        self.parallel_serial_option = self.__class__.parallel_serial_option(service, rules, path + [("parallel_serial_option", "")])
                        self.project_on_geometry = self.__class__.project_on_geometry(service, rules, path + [("project_on_geometry", "")])
                        self.save_intermediate_files = self.__class__.save_intermediate_files(service, rules, path + [("save_intermediate_files", "")])
                        self.save_surface_mesh = self.__class__.save_surface_mesh(service, rules, path + [("save_surface_mesh", "")])
                        self.separate_surface = self.__class__.separate_surface(service, rules, path + [("separate_surface", "")])
                        self.show_sub_tasks = self.__class__.show_sub_tasks(service, rules, path + [("show_sub_tasks", "")])
                        self.spike_removal_angle = self.__class__.spike_removal_angle(service, rules, path + [("spike_removal_angle", "")])
                        self.surface_quality = self.__class__.surface_quality(service, rules, path + [("surface_quality", "")])
                        self.use_size_field_for_prime_wrap = self.__class__.use_size_field_for_prime_wrap(service, rules, path + [("use_size_field_for_prime_wrap", "")])
                        super().__init__(service, rules, path)

                    class advanced_inner_wrap(PyParameter):
                        """
                        Choose whether or not to extend or expand the surface mesh into any interior pockets or cavities.
                        """
                        pass

                    class advanced_options(PyParameter):
                        """
                        Display advanced options that you may want to apply to the task.
                        """
                        pass

                    class auto_assign_zone_types(PyParameter):
                        """
                        Choose whether or not to automatically assign boundary types to zones.
                        """
                        pass

                    class auto_pairing(PyParameter):
                        """
                        Specify whether or not you want to separate contact pairs between fluids and solids.
                        """
                        pass

                    class auto_region_between_porous(PyParameter):
                        """
                        Parameter auto_region_between_porous of value type bool.
                        """
                        pass

                    class dihedral_min_angle(PyNumerical):
                        """
                        Specify a value for the minimum dihedral angle for the specified region. A dihedral angle of 30 degrees are recommended or use the default value. You should not exceed 30 degrees.
                        """
                        pass

                    class gap_cover_zone_recovery(PyParameter):
                        """
                        Determine whether or not to keep or remove the zones representing the cap covers. When set to Yes, the zones representing the gap covers are retained, whereas when set to No (the default), the zones for the gap covers are removed.
                        """
                        pass

                    class global_min(PyNumerical):
                        """
                        Specify a global minimum value for the surface mesh. The default minimum value is calculated based on available target and wrap size controls and bodies of influence. 
                                        More...
                        """
                        pass

                    class intermediate_file_name(PyTextual):
                        """
                        By default, files are saved in a temporary folder and later deleted once the session is ended. You can also save files in a specified folder. The prefix for the name of the files are taken from the FMD or STL file name.
                        """
                        pass

                    class leak_shield(PyParameter):
                        """
                        Parameter leak_shield of value type bool.
                        """
                        pass

                    class max_island_face(PyNumerical):
                        """
                        Specify the maximum face count required for isolated areas (islands) to be created during surface mesh generation. Any islands that have a face count smaller than this value will be removed, and only larger islands will remain.
                        """
                        pass

                    class merge_wrapper_at_solid_conacts(PyParameter):
                        """
                        Specify whether or not you want to allow contacts between solid and fluid regions to be merged into the surface mesh wrapper. When enabled, all bounding faces of a fluid region wrap that come into contact with solid regions will be merged into a single zone (using the prefix _contact). Each respective wrapped fluid region will have one _contact zone associated with it.
                        """
                        pass

                    class number_of_sessions(PyNumerical):
                        """
                        Indicate the number of parallel sessions that are to be used, depending upon the number of solid objects that need to be meshed.
                        """
                        pass

                    class parallel_serial_option(PyParameter):
                        """
                        Specify whether or not you want to perform solid meshing using parallel sessions. Select Yes and indicate the Maximum Number of Sessions. The number of parallel sessions that are used will depend upon the number of solid objects that need to be meshed.
                        """
                        pass

                    class project_on_geometry(PyParameter):
                        """
                        Determine whether, after surface meshing, Fluent will project the mesh nodes back onto to the original CAD model.
                        """
                        pass

                    class save_intermediate_files(PyParameter):
                        """
                        Determine whether or not you want to save any intermediate files that are generated during volume meshing. Disabling this option may increase speed and efficiency.
                        """
                        pass

                    class save_surface_mesh(PyParameter):
                        """
                        Select this option to save the surface mesh. Use advanced options to determine whether to save intermediate files or not, and to choose a specific directory to save the mesh.
                        """
                        pass

                    class separate_surface(PyParameter):
                        """
                        Select Yes if you want to have the final surface mesh to be viewed as separated zones.
                        """
                        pass

                    class show_sub_tasks(PyParameter):
                        """
                        Parameter show_sub_tasks of value type bool.
                        """
                        pass

                    class spike_removal_angle(PyNumerical):
                        """
                        Specify a value for the minimum spike angle for the specified region. A spike angle of 250 degrees is recommended or use the default value. You should not exceed 260 degrees.
                        """
                        pass

                    class surface_quality(PyNumerical):
                        """
                        This is the target maximum surface mesh quality. The recommended value is between 0.7 and 0.85.
                        """
                        pass

                    class use_size_field_for_prime_wrap(PyParameter):
                        """
                        Parameter use_size_field_for_prime_wrap of value type bool.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _generate_surface_mesh:
                return super().__getitem__(key)

        class generate_volume_mesh(PyNamedObjectContainer):
            """
            .
            """
            class _generate_volume_mesh(PyMenu):
                """
                Singleton _generate_volume_mesh.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.mesh_fluid_domain_option = self.__class__.mesh_fluid_domain_option(service, rules, path + [("mesh_fluid_domain_option", "")])
                        super().__init__(service, rules, path)

                    class mesh_fluid_domain_option(PyParameter):
                        """
                        Parameter mesh_fluid_domain_option of value type bool.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _generate_volume_mesh:
                return super().__getitem__(key)

        class identify_construction_surfaces(PyNamedObjectContainer):
            """
            .
            """
            class _identify_construction_surfaces(PyMenu):
                """
                Singleton _identify_construction_surfaces.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.axis = self.__class__.axis(service, rules, path + [("axis", "")])
                        self.bounding_box_object = self.__class__.bounding_box_object(service, rules, path + [("bounding_box_object", "")])
                        self.cylinder_object = self.__class__.cylinder_object(service, rules, path + [("cylinder_object", "")])
                        self.pivot = self.__class__.pivot(service, rules, path + [("pivot", "")])
                        self.rotation = self.__class__.rotation(service, rules, path + [("rotation", "")])
                        self.creation_method = self.__class__.creation_method(service, rules, path + [("creation_method", "")])
                        self.cylinder_method = self.__class__.cylinder_method(service, rules, path + [("cylinder_method", "")])
                        self.defeaturing_size = self.__class__.defeaturing_size(service, rules, path + [("defeaturing_size", "")])
                        self.label_selection_list = self.__class__.label_selection_list(service, rules, path + [("label_selection_list", "")])
                        self.label_selection_single = self.__class__.label_selection_single(service, rules, path + [("label_selection_single", "")])
                        self.name = self.__class__.name(service, rules, path + [("name", "")])
                        self.object_selection_list = self.__class__.object_selection_list(service, rules, path + [("object_selection_list", "")])
                        self.object_selection_single = self.__class__.object_selection_single(service, rules, path + [("object_selection_single", "")])
                        self.offset_height = self.__class__.offset_height(service, rules, path + [("offset_height", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        self.zone_selection_list = self.__class__.zone_selection_list(service, rules, path + [("zone_selection_list", "")])
                        self.zone_selection_single = self.__class__.zone_selection_single(service, rules, path + [("zone_selection_single", "")])
                        super().__init__(service, rules, path)

                    class axis(PyMenu):
                        """
                        Singleton axis.
                        """
                        def __init__(self, service, rules, path):
                            self.x_component = self.__class__.x_component(service, rules, path + [("x_component", "")])
                            self.y_component = self.__class__.y_component(service, rules, path + [("y_component", "")])
                            self.z_component = self.__class__.z_component(service, rules, path + [("z_component", "")])
                            super().__init__(service, rules, path)

                        class x_component(PyNumerical):
                            """
                            Parameter x_component of value type float.
                            """
                            pass

                        class y_component(PyNumerical):
                            """
                            Parameter y_component of value type float.
                            """
                            pass

                        class z_component(PyNumerical):
                            """
                            Parameter z_component of value type float.
                            """
                            pass

                    class bounding_box_object(PyMenu):
                        """
                        View the extents of the bounding box.
                        """
                        def __init__(self, service, rules, path):
                            self.size_relative_length = self.__class__.size_relative_length(service, rules, path + [("size_relative_length", "")])
                            self.xmax = self.__class__.xmax(service, rules, path + [("xmax", "")])
                            self.xmax_ratio = self.__class__.xmax_ratio(service, rules, path + [("xmax_ratio", "")])
                            self.xmin = self.__class__.xmin(service, rules, path + [("xmin", "")])
                            self.xmin_ratio = self.__class__.xmin_ratio(service, rules, path + [("xmin_ratio", "")])
                            self.ymax = self.__class__.ymax(service, rules, path + [("ymax", "")])
                            self.ymax_ratio = self.__class__.ymax_ratio(service, rules, path + [("ymax_ratio", "")])
                            self.ymin = self.__class__.ymin(service, rules, path + [("ymin", "")])
                            self.ymin_ratio = self.__class__.ymin_ratio(service, rules, path + [("ymin_ratio", "")])
                            self.zmax = self.__class__.zmax(service, rules, path + [("zmax", "")])
                            self.zmax_ratio = self.__class__.zmax_ratio(service, rules, path + [("zmax_ratio", "")])
                            self.zmin = self.__class__.zmin(service, rules, path + [("zmin", "")])
                            self.zmin_ratio = self.__class__.zmin_ratio(service, rules, path + [("zmin_ratio", "")])
                            super().__init__(service, rules, path)

                        class size_relative_length(PyTextual):
                            """
                            Determine if you would like to specify the bounding box for the construction surface as a ratio of the geometry length, or by specifying a specific location for the minimum and maximum coordinates.
                            """
                            pass

                        class xmax(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the X direction by the specified value.
                            """
                            pass

                        class xmax_ratio(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the X direction by the specified value. The value is the ratio relative to the geometry size in the X direction.
                            """
                            pass

                        class xmin(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the X direction by the specified value.
                            """
                            pass

                        class xmin_ratio(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the X direction by the specified value. The value is the ratio relative to the geometry size in the X direction.
                            """
                            pass

                        class ymax(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the Y direction by the specified value.
                            """
                            pass

                        class ymax_ratio(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the Y direction by the specified value. The value is the ratio relative to the geometry size in the Y direction.
                            """
                            pass

                        class ymin(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the Y direction by the specified value.
                            """
                            pass

                        class ymin_ratio(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the Y direction by the specified value. The value is the ratio relative to the geometry size in the Y direction.
                            """
                            pass

                        class zmax(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the Z direction by the specified value.
                            """
                            pass

                        class zmax_ratio(PyNumerical):
                            """
                            Extends the maximum size of the bounding box in the Z direction by the specified value. The value is the ratio relative to the geometry size in the Z direction.
                            """
                            pass

                        class zmin(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the Z direction by the specified value.
                            """
                            pass

                        class zmin_ratio(PyNumerical):
                            """
                            Extends the minimum size of the bounding box in the Z direction by the specified value. The value is the ratio relative to the geometry size in the Z direction.
                            """
                            pass

                    class cylinder_object(PyMenu):
                        """
                        Singleton cylinder_object.
                        """
                        def __init__(self, service, rules, path):
                            self.height_back_inc = self.__class__.height_back_inc(service, rules, path + [("height_back_inc", "")])
                            self.height_front_inc = self.__class__.height_front_inc(service, rules, path + [("height_front_inc", "")])
                            self.height_node = self.__class__.height_node(service, rules, path + [("height_node", "")])
                            self.node_1 = self.__class__.node_1(service, rules, path + [("node_1", "")])
                            self.node_2 = self.__class__.node_2(service, rules, path + [("node_2", "")])
                            self.node_3 = self.__class__.node_3(service, rules, path + [("node_3", "")])
                            self.radius_1 = self.__class__.radius_1(service, rules, path + [("radius_1", "")])
                            self.radius_2 = self.__class__.radius_2(service, rules, path + [("radius_2", "")])
                            self.x1 = self.__class__.x1(service, rules, path + [("x1", "")])
                            self.x2 = self.__class__.x2(service, rules, path + [("x2", "")])
                            self.x_offset = self.__class__.x_offset(service, rules, path + [("x_offset", "")])
                            self.y1 = self.__class__.y1(service, rules, path + [("y1", "")])
                            self.y2 = self.__class__.y2(service, rules, path + [("y2", "")])
                            self.y_offset = self.__class__.y_offset(service, rules, path + [("y_offset", "")])
                            self.z1 = self.__class__.z1(service, rules, path + [("z1", "")])
                            self.z2 = self.__class__.z2(service, rules, path + [("z2", "")])
                            self.z_offset = self.__class__.z_offset(service, rules, path + [("z_offset", "")])
                            super().__init__(service, rules, path)

                        class height_back_inc(PyNumerical):
                            """
                            Parameter height_back_inc of value type float.
                            """
                            pass

                        class height_front_inc(PyNumerical):
                            """
                            Parameter height_front_inc of value type float.
                            """
                            pass

                        class height_node(PyTextual):
                            """
                            Parameter height_node of value type str.
                            """
                            pass

                        class node_1(PyTextual):
                            """
                            Parameter node_1 of value type str.
                            """
                            pass

                        class node_2(PyTextual):
                            """
                            Parameter node_2 of value type str.
                            """
                            pass

                        class node_3(PyTextual):
                            """
                            Parameter node_3 of value type str.
                            """
                            pass

                        class radius_1(PyNumerical):
                            """
                            Parameter radius_1 of value type float.
                            """
                            pass

                        class radius_2(PyNumerical):
                            """
                            Parameter radius_2 of value type float.
                            """
                            pass

                        class x1(PyNumerical):
                            """
                            Parameter x1 of value type float.
                            """
                            pass

                        class x2(PyNumerical):
                            """
                            Parameter x2 of value type float.
                            """
                            pass

                        class x_offset(PyNumerical):
                            """
                            Parameter x_offset of value type float.
                            """
                            pass

                        class y1(PyNumerical):
                            """
                            Parameter y1 of value type float.
                            """
                            pass

                        class y2(PyNumerical):
                            """
                            Parameter y2 of value type float.
                            """
                            pass

                        class y_offset(PyNumerical):
                            """
                            Parameter y_offset of value type float.
                            """
                            pass

                        class z1(PyNumerical):
                            """
                            Parameter z1 of value type float.
                            """
                            pass

                        class z2(PyNumerical):
                            """
                            Parameter z2 of value type float.
                            """
                            pass

                        class z_offset(PyNumerical):
                            """
                            Parameter z_offset of value type float.
                            """
                            pass

                    class pivot(PyMenu):
                        """
                        Singleton pivot.
                        """
                        def __init__(self, service, rules, path):
                            self.x = self.__class__.x(service, rules, path + [("x", "")])
                            self.y = self.__class__.y(service, rules, path + [("y", "")])
                            self.z = self.__class__.z(service, rules, path + [("z", "")])
                            super().__init__(service, rules, path)

                        class x(PyNumerical):
                            """
                            Parameter x of value type float.
                            """
                            pass

                        class y(PyNumerical):
                            """
                            Parameter y of value type float.
                            """
                            pass

                        class z(PyNumerical):
                            """
                            Parameter z of value type float.
                            """
                            pass

                    class rotation(PyMenu):
                        """
                        Singleton rotation.
                        """
                        def __init__(self, service, rules, path):
                            self.x_component = self.__class__.x_component(service, rules, path + [("x_component", "")])
                            self.y_component = self.__class__.y_component(service, rules, path + [("y_component", "")])
                            super().__init__(service, rules, path)

                        class x_component(PyNumerical):
                            """
                            Parameter x_component of value type float.
                            """
                            pass

                        class y_component(PyNumerical):
                            """
                            Parameter y_component of value type float.
                            """
                            pass

                    class creation_method(PyTextual):
                        """
                        Choose whether to create the construction surface using an Existing object or zone, a bounding Box, or by using an Offset Surface.
                        """
                        pass

                    class cylinder_method(PyTextual):
                        """
                        Parameter cylinder_method of value type str.
                        """
                        pass

                    class defeaturing_size(PyNumerical):
                        """
                        Specify a value that is used to obtain a rough shape of the selected object(s). The larger the value, the more approximate the shape.
                        """
                        pass

                    class label_selection_list(PyTextual):
                        """
                        Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class label_selection_single(PyTextual):
                        """
                        Choose a single label from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class name(PyTextual):
                        """
                        Specify a name for the construction surface or use the default value.
                        """
                        pass

                    class object_selection_list(PyTextual):
                        """
                        Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class object_selection_single(PyTextual):
                        """
                        Choose a single object from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class offset_height(PyNumerical):
                        """
                        Specify the height of the offset construction surface. This is how far from the selected object(s) the rough shape is offset.
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Choose how you want to make your selection (by object, label, or zone name).
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                    class zone_selection_list(PyTextual):
                        """
                        Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class zone_selection_single(PyTextual):
                        """
                        Choose a single zone from the list below. Use the Filter Text field to provide text and/or regular expressions in filtering the list. The matching list item(s) are automatically displayed in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _identify_construction_surfaces:
                return super().__getitem__(key)

        class identify_deviated_faces(PyNamedObjectContainer):
            """
            .
            """
            class _identify_deviated_faces(PyMenu):
                """
                Singleton _identify_deviated_faces.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.advanced_options = self.__class__.advanced_options(service, rules, path + [("advanced_options", "")])
                        self.deviation_max_value = self.__class__.deviation_max_value(service, rules, path + [("deviation_max_value", "")])
                        self.deviation_min_value = self.__class__.deviation_min_value(service, rules, path + [("deviation_min_value", "")])
                        self.display_grid_name = self.__class__.display_grid_name(service, rules, path + [("display_grid_name", "")])
                        self.include_gap_cover_geometry = self.__class__.include_gap_cover_geometry(service, rules, path + [("include_gap_cover_geometry", "")])
                        self.object_selection_list = self.__class__.object_selection_list(service, rules, path + [("object_selection_list", "")])
                        self.overlay = self.__class__.overlay(service, rules, path + [("overlay", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        self.zone_selection_list = self.__class__.zone_selection_list(service, rules, path + [("zone_selection_list", "")])
                        super().__init__(service, rules, path)

                    class advanced_options(PyParameter):
                        """
                        Enable this option to automatically calculate the minimum and maximum deviation for the selected object(s) or zone(s).
                        """
                        pass

                    class deviation_max_value(PyNumerical):
                        """
                        When Auto Compute is disabled, specify a maximum value for the deviation.
                        """
                        pass

                    class deviation_min_value(PyNumerical):
                        """
                        When Auto Compute is disabled, specify a minimum value for the deviation.
                        """
                        pass

                    class display_grid_name(PyTextual):
                        """
                        Enter a name for the identified deviated faces.
                        """
                        pass

                    class include_gap_cover_geometry(PyParameter):
                        """
                        Determine if you want to include any gap covers in the check for deviated faces. If so, the default minimum and maximum deviation range is automatically calculated.
                        """
                        pass

                    class object_selection_list(PyTextual):
                        """
                        Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class overlay(PyTextual):
                        """
                        Determine how you want the deviated faces to be displayed (either with the mesh or with the geometry).
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Specify whether the identification of deviated faces is to be applied to an indicated object or zone.
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                    class zone_selection_list(PyTextual):
                        """
                        Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _identify_deviated_faces:
                return super().__getitem__(key)

        class identify_orphans(PyNamedObjectContainer):
            """
            .
            """
            class _identify_orphans(PyMenu):
                """
                Singleton _identify_orphans.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.check_overset_interface_intersection = self.__class__.check_overset_interface_intersection(service, rules, path + [("check_overset_interface_intersection", "")])
                        self.donor_priority_method = self.__class__.donor_priority_method(service, rules, path + [("donor_priority_method", "")])
                        self.enable_grid_priority = self.__class__.enable_grid_priority(service, rules, path + [("enable_grid_priority", "")])
                        self.number_of_orphans = self.__class__.number_of_orphans(service, rules, path + [("number_of_orphans", "")])
                        self.object_selection_list = self.__class__.object_selection_list(service, rules, path + [("object_selection_list", "")])
                        self.old_region_name_list = self.__class__.old_region_name_list(service, rules, path + [("old_region_name_list", "")])
                        self.old_region_size_list = self.__class__.old_region_size_list(service, rules, path + [("old_region_size_list", "")])
                        self.overlap_boundaries = self.__class__.overlap_boundaries(service, rules, path + [("overlap_boundaries", "")])
                        self.region_name_list = self.__class__.region_name_list(service, rules, path + [("region_name_list", "")])
                        self.region_size_list = self.__class__.region_size_list(service, rules, path + [("region_size_list", "")])
                        super().__init__(service, rules, path)

                    class check_overset_interface_intersection(PyParameter):
                        """
                        Enabled by default, Fluent checks for any overset interface intersections while identifying orphans. Disable this option to skip the intersection check and increase the speed of identifying orphans.
                        """
                        pass

                    class donor_priority_method(PyTextual):
                        """
                        Determines the location of the overset mesh. Choose how the mesh donor cells are prioritized - either based on the cell size (proportional to the inverse of the cell volume) or based on the boundary distance (proportional to the inverse of the distance to the closest boundary).
                        """
                        pass

                    class enable_grid_priority(PyParameter):
                        """
                        Controls the ability to prioritize your overset grids (meshes). The priorities of the overset mesh are then carried over into the solver.
                        """
                        pass

                    class number_of_orphans(PyTextual):
                        """
                        Specify the allowable number of orphans to accept in your mesh.
                        """
                        pass

                    class object_selection_list(PyTextual):
                        """
                        Select one or more mesh objects that you would like to identify any potential orphan faces. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class old_region_name_list(PyTextual):
                        """
                        Parameter old_region_name_list of value type list[str].
                        """
                        pass

                    class old_region_size_list(PyTextual):
                        """
                        Parameter old_region_size_list of value type list[str].
                        """
                        pass

                    class overlap_boundaries(PyParameter):
                        """
                        Determine if you need to account for any overlapping boundaries that may be present in your overset mesh (due to overlapping geometry and boundaries or those sometimes generated by collar meshes). You can improve the overset performance by setting this option to no.
                        """
                        pass

                    class region_name_list(PyTextual):
                        """
                        Parameter region_name_list of value type list[str].
                        """
                        pass

                    class region_size_list(PyTextual):
                        """
                        Parameter region_size_list of value type list[str].
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _identify_orphans:
                return super().__getitem__(key)

        class identify_regions(PyNamedObjectContainer):
            """
            .
            """
            class _identify_regions(PyMenu):
                """
                Singleton _identify_regions.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.add_child = self.__class__.add_child(service, rules, path + [("add_child", "")])
                        self.graphical_selection = self.__class__.graphical_selection(service, rules, path + [("graphical_selection", "")])
                        self.label_selection_list = self.__class__.label_selection_list(service, rules, path + [("label_selection_list", "")])
                        self.link_construction = self.__class__.link_construction(service, rules, path + [("link_construction", "")])
                        self.material_points_name = self.__class__.material_points_name(service, rules, path + [("material_points_name", "")])
                        self.mpt_method_type = self.__class__.mpt_method_type(service, rules, path + [("mpt_method_type", "")])
                        self.new_region_type = self.__class__.new_region_type(service, rules, path + [("new_region_type", "")])
                        self.object_selection_list = self.__class__.object_selection_list(service, rules, path + [("object_selection_list", "")])
                        self.offset_x = self.__class__.offset_x(service, rules, path + [("offset_x", "")])
                        self.offset_y = self.__class__.offset_y(service, rules, path + [("offset_y", "")])
                        self.offset_z = self.__class__.offset_z(service, rules, path + [("offset_z", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.show_coordinates = self.__class__.show_coordinates(service, rules, path + [("show_coordinates", "")])
                        self.x = self.__class__.x(service, rules, path + [("x", "")])
                        self.y = self.__class__.y(service, rules, path + [("y", "")])
                        self.z = self.__class__.z(service, rules, path + [("z", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        self.zone_selection_list = self.__class__.zone_selection_list(service, rules, path + [("zone_selection_list", "")])
                        super().__init__(service, rules, path)

                    class add_child(PyParameter):
                        """
                        Determine whether or not you want to specify any fluid or void regions using this task.
                        """
                        pass

                    class graphical_selection(PyParameter):
                        """
                        Enable this option and select a point in the graphics window to be the center of the region.
                        """
                        pass

                    class label_selection_list(PyTextual):
                        """
                        Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class link_construction(PyParameter):
                        """
                        Keep the default value of no for most cases involving a singular fluid region. If you mean to identify an additional fluid region, choose yes to indicate that the current fluid region is either inside or adjacent to a construction surface(s), in order to properly mesh this fluid region accordingly (that is, using a surface mesh).
                        """
                        pass

                    class material_points_name(PyTextual):
                        """
                        Specify a name for the region that you want to identify or use the default value.
                        """
                        pass

                    class mpt_method_type(PyTextual):
                        """
                        Choose how you want to identify the region: using a distinct numerical input of X, Y, and Z coordinates, using the centroid of the selected object, or by using an offset distance relative to the centroid of selected object/zone.
                        """
                        pass

                    class new_region_type(PyTextual):
                        """
                        Specify the type of region as being fluid, solid, or a void.
                        """
                        pass

                    class object_selection_list(PyTextual):
                        """
                        Choose one or more objects (or voids) from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class offset_x(PyNumerical):
                        """
                        The x-coordinate of the offset distance relative to the centroid of the selected object/zone.
                        """
                        pass

                    class offset_y(PyNumerical):
                        """
                        The y-coordinate of the offset distance relative to the centroid of the selected object/zone.
                        """
                        pass

                    class offset_z(PyNumerical):
                        """
                        The z-coordinate of the offset distance relative to the centroid of the selected object/zone.
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Choose how you want to make your selection (by object, label, or zone name).
                        """
                        pass

                    class show_coordinates(PyParameter):
                        """
                        Enable this option when providing numerical inputs for the region location, and you want to view the exact coordinates.
                        """
                        pass

                    class x(PyNumerical):
                        """
                        The x-coordinate of the center of the region.
                        """
                        pass

                    class y(PyNumerical):
                        """
                        The y-coordinate of the center of the region.
                        """
                        pass

                    class z(PyNumerical):
                        """
                        The z-coordinate of the center of the region.
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                    class zone_selection_list(PyTextual):
                        """
                        Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _identify_regions:
                return super().__getitem__(key)

        class import_boi_geometry(PyNamedObjectContainer):
            """
            .
            """
            class _import_boi_geometry(PyMenu):
                """
                Singleton _import_boi_geometry.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.cad_import_options = self.__class__.cad_import_options(service, rules, path + [("cad_import_options", "")])
                        self.geometry_file_name = self.__class__.geometry_file_name(service, rules, path + [("geometry_file_name", "")])
                        self.imported_objects = self.__class__.imported_objects(service, rules, path + [("imported_objects", "")])
                        self.length_unit = self.__class__.length_unit(service, rules, path + [("length_unit", "")])
                        self.mesh_file_name = self.__class__.mesh_file_name(service, rules, path + [("mesh_file_name", "")])
                        self.type = self.__class__.type(service, rules, path + [("type", "")])
                        super().__init__(service, rules, path)

                    class cad_import_options(PyMenu):
                        """
                        Singleton cad_import_options.
                        """
                        def __init__(self, service, rules, path):
                            self.create_cad_assemblies = self.__class__.create_cad_assemblies(service, rules, path + [("create_cad_assemblies", "")])
                            self.extract_features = self.__class__.extract_features(service, rules, path + [("extract_features", "")])
                            self.feature_angle = self.__class__.feature_angle(service, rules, path + [("feature_angle", "")])
                            self.import_curvature_data_from_cad = self.__class__.import_curvature_data_from_cad(service, rules, path + [("import_curvature_data_from_cad", "")])
                            self.import_named_selections = self.__class__.import_named_selections(service, rules, path + [("import_named_selections", "")])
                            self.import_part_names = self.__class__.import_part_names(service, rules, path + [("import_part_names", "")])
                            self.one_object_per = self.__class__.one_object_per(service, rules, path + [("one_object_per", "")])
                            self.one_zone_per = self.__class__.one_zone_per(service, rules, path + [("one_zone_per", "")])
                            self.open_all_cad_in_subdirectories = self.__class__.open_all_cad_in_subdirectories(service, rules, path + [("open_all_cad_in_subdirectories", "")])
                            self.save_pmdb_intermediate_file = self.__class__.save_pmdb_intermediate_file(service, rules, path + [("save_pmdb_intermediate_file", "")])
                            self.use_part_or_body_as_suffix = self.__class__.use_part_or_body_as_suffix(service, rules, path + [("use_part_or_body_as_suffix", "")])
                            super().__init__(service, rules, path)

                        class create_cad_assemblies(PyParameter):
                            """
                            Parameter create_cad_assemblies of value type bool.
                            """
                            pass

                        class extract_features(PyParameter):
                            """
                            Parameter extract_features of value type bool.
                            """
                            pass

                        class feature_angle(PyNumerical):
                            """
                            Parameter feature_angle of value type float.
                            """
                            pass

                        class import_curvature_data_from_cad(PyParameter):
                            """
                            Parameter import_curvature_data_from_cad of value type bool.
                            """
                            pass

                        class import_named_selections(PyParameter):
                            """
                            Parameter import_named_selections of value type bool.
                            """
                            pass

                        class import_part_names(PyParameter):
                            """
                            Parameter import_part_names of value type bool.
                            """
                            pass

                        class one_object_per(PyTextual):
                            """
                            Parameter one_object_per of value type str.
                            """
                            pass

                        class one_zone_per(PyTextual):
                            """
                            Parameter one_zone_per of value type str.
                            """
                            pass

                        class open_all_cad_in_subdirectories(PyParameter):
                            """
                            Parameter open_all_cad_in_subdirectories of value type bool.
                            """
                            pass

                        class save_pmdb_intermediate_file(PyParameter):
                            """
                            Parameter save_pmdb_intermediate_file of value type bool.
                            """
                            pass

                        class use_part_or_body_as_suffix(PyParameter):
                            """
                            Parameter use_part_or_body_as_suffix of value type bool.
                            """
                            pass

                    class geometry_file_name(PyTextual):
                        """
                        Select CAD file(s) to import into your simulation as a body of influence. Supported file types are SpaceClaim (.scdoc) and Workbench (.agdb) files and also .pmdb files. Other supported formats include: \\*.CATpart, \\*.prt, \\*.x_t, \\*.sat, \\*.step, and \\*.iges files)
                        """
                        pass

                    class imported_objects(PyTextual):
                        """
                        Parameter imported_objects of value type list[str].
                        """
                        pass

                    class length_unit(PyTextual):
                        """
                        Parameter length_unit of value type str.
                        """
                        pass

                    class mesh_file_name(PyTextual):
                        """
                        Select surface or volume mesh file(s) to import into your simulation as a body of influence. Supported file types are: \\*.msh, \\*.msh.gz, and \\*.msh.h5 files).
                        """
                        pass

                    class type(PyTextual):
                        """
                        Specify whether you are importing CAD geometry file(s) or whether you are specifying surface or volume mesh file(s) to represent bodies of influence for your simulation. The units for length will be the same as those specified in the Import Geometry task.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _import_boi_geometry:
                return super().__getitem__(key)

        class import_cad_and_part_management(PyNamedObjectContainer):
            """
            .
            """
            class _import_cad_and_part_management(PyMenu):
                """
                Singleton _import_cad_and_part_management.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.options = self.__class__.options(service, rules, path + [("options", "")])
                        self.refacet_options = self.__class__.refacet_options(service, rules, path + [("refacet_options", "")])
                        self.refaceting = self.__class__.refaceting(service, rules, path + [("refaceting", "")])
                        self.append = self.__class__.append(service, rules, path + [("append", "")])
                        self.append_file_name = self.__class__.append_file_name(service, rules, path + [("append_file_name", "")])
                        self.context = self.__class__.context(service, rules, path + [("context", "")])
                        self.create_object_per = self.__class__.create_object_per(service, rules, path + [("create_object_per", "")])
                        self.edge_extraction = self.__class__.edge_extraction(service, rules, path + [("edge_extraction", "")])
                        self.feature_angle = self.__class__.feature_angle(service, rules, path + [("feature_angle", "")])
                        self.file_length_unit = self.__class__.file_length_unit(service, rules, path + [("file_length_unit", "")])
                        self.file_length_unit_append = self.__class__.file_length_unit_append(service, rules, path + [("file_length_unit_append", "")])
                        self.file_loaded = self.__class__.file_loaded(service, rules, path + [("file_loaded", "")])
                        self.fmd_file_name = self.__class__.fmd_file_name(service, rules, path + [("fmd_file_name", "")])
                        self.ignore_solid_names = self.__class__.ignore_solid_names(service, rules, path + [("ignore_solid_names", "")])
                        self.ignore_solid_names_append = self.__class__.ignore_solid_names_append(service, rules, path + [("ignore_solid_names_append", "")])
                        self.jt_lod = self.__class__.jt_lod(service, rules, path + [("jt_lod", "")])
                        self.jt_lod_append = self.__class__.jt_lod_append(service, rules, path + [("jt_lod_append", "")])
                        self.length_unit = self.__class__.length_unit(service, rules, path + [("length_unit", "")])
                        self.object_setting = self.__class__.object_setting(service, rules, path + [("object_setting", "")])
                        self.one_zone_per = self.__class__.one_zone_per(service, rules, path + [("one_zone_per", "")])
                        self.part_per_body = self.__class__.part_per_body(service, rules, path + [("part_per_body", "")])
                        self.prefix_parent_name = self.__class__.prefix_parent_name(service, rules, path + [("prefix_parent_name", "")])
                        self.remove_empty_parts = self.__class__.remove_empty_parts(service, rules, path + [("remove_empty_parts", "")])
                        self.route = self.__class__.route(service, rules, path + [("route", "")])
                        self.route_append = self.__class__.route_append(service, rules, path + [("route_append", "")])
                        super().__init__(service, rules, path)

                    class options(PyMenu):
                        """
                        Singleton options.
                        """
                        def __init__(self, service, rules, path):
                            self.line = self.__class__.line(service, rules, path + [("line", "")])
                            self.solid = self.__class__.solid(service, rules, path + [("solid", "")])
                            self.surface = self.__class__.surface(service, rules, path + [("surface", "")])
                            super().__init__(service, rules, path)

                        class line(PyParameter):
                            """
                            Enable this option to import line bodies along with your CAD geometry.
                            """
                            pass

                        class solid(PyParameter):
                            """
                            Enable this option to import solid bodies along with your CAD geometry.
                            """
                            pass

                        class surface(PyParameter):
                            """
                            Enable this option to import surface bodies along with your CAD geometry.
                            """
                            pass

                    class refacet_options(PyMenu):
                        """
                        Singleton refacet_options.
                        """
                        def __init__(self, service, rules, path):
                            self.deviation = self.__class__.deviation(service, rules, path + [("deviation", "")])
                            self.max_size = self.__class__.max_size(service, rules, path + [("max_size", "")])
                            self.normal_angle = self.__class__.normal_angle(service, rules, path + [("normal_angle", "")])
                            self.refacet_during_load = self.__class__.refacet_during_load(service, rules, path + [("refacet_during_load", "")])
                            super().__init__(service, rules, path)

                        class deviation(PyNumerical):
                            """
                            Specify the distance between facet edges and the geometry edges. Decreasing this value will result in more facets along curved edges.
                            """
                            pass

                        class max_size(PyNumerical):
                            """
                            Specify a maximum element size for the imported model to avoid very large facets during the file import.
                            """
                            pass

                        class normal_angle(PyNumerical):
                            """
                            Specify a rotational angle (in degrees) of transformation.
                            """
                            pass

                        class refacet_during_load(PyParameter):
                            """
                            This option is available when DSCO is selected for the Import Route. When enabled, this option will refacet the geometry as it is converted to a .fmd file. This option eliminates the need for any refaceting operation after the geometry is loaded, which can be expensive.
                            """
                            pass

                    class refaceting(PyMenu):
                        """
                        Singleton refaceting.
                        """
                        def __init__(self, service, rules, path):
                            self.deviation = self.__class__.deviation(service, rules, path + [("deviation", "")])
                            self.facet_max_edge_length = self.__class__.facet_max_edge_length(service, rules, path + [("facet_max_edge_length", "")])
                            self.max_edge_length_factor = self.__class__.max_edge_length_factor(service, rules, path + [("max_edge_length_factor", "")])
                            self.max_size = self.__class__.max_size(service, rules, path + [("max_size", "")])
                            self.normal_angle = self.__class__.normal_angle(service, rules, path + [("normal_angle", "")])
                            self.refacet = self.__class__.refacet(service, rules, path + [("refacet", "")])
                            super().__init__(service, rules, path)

                        class deviation(PyNumerical):
                            """
                            Specify the distance between facet edges and the geometry edges. Decreasing this value will result in more facets along curved edges.
                            """
                            pass

                        class facet_max_edge_length(PyTextual):
                            """
                            Controls the edge size of facets, ensuring that no facet edge exceeds the specified length. The max edge length size (Max Size) can either be specified directly by selecting Absolute or specified as a factor (Max Edge Length Factor) relative to the bounding box of the geometry by selecting Relative (Bounding Box).
                            """
                            pass

                        class max_edge_length_factor(PyNumerical):
                            """
                            Specifies the maximum size of the facets relative to the bounding box of the geometry.
                            """
                            pass

                        class max_size(PyNumerical):
                            """
                            Specify a maximum element size for the imported model to avoid very large facets during the file import.
                            """
                            pass

                        class normal_angle(PyNumerical):
                            """
                            Specify a rotational angle (in degrees) of transformation.
                            """
                            pass

                        class refacet(PyParameter):
                            """
                            Select this option when you want to change faceting of the selected object. Refaceting will refacet the original CAD geometry. Only the faceted CAD geometry is used during the meshing process. The refaceting settings control how far the facet edges are from the model and the size of the facets.  More...
                            """
                            pass

                    class append(PyParameter):
                        """
                        Enable this field and browse and select additional CAD files. Use the Append button to add the additional CAD components to the bottom of the CAD Model tree upon loading.
                        """
                        pass

                    class append_file_name(PyTextual):
                        """
                        Enable this option and browse/select another CAD file to append to your original geometry. Specify additional CAD files in the Append File field, and use the Append button to load additional CAD files into the tree, after the original CAD objects. To quickly append multiple CAD files, you can use basic wildcard expression patterns such as the \\* or ? wildcards.
                        """
                        pass

                    class context(PyNumerical):
                        """
                        Parameter context of value type int.
                        """
                        pass

                    class create_object_per(PyTextual):
                        """
                        Choose whether to create meshing objects by part, or by selectively customizing the portions of the imported CAD geometry to mesh. If you select by part, then meshing objects are automatically created for you once you import the geometry. Refaceting options are available as well for all meshing objects.
                        """
                        pass

                    class edge_extraction(PyTextual):
                        """
                        Choose how edges will be extracted from the CAD geometry. Setting this option to auto will extract edges from the CAD geometry when the number of meshing objects is less than 10,000. If this limit is exceeded, then no edges are extracted. When this option is set to yes, then edges are extracted regardless of the number of meshing objects. No edges are extracted when this option is set to no.
                        """
                        pass

                    class feature_angle(PyNumerical):
                        """
                        Specify a rotational angle (in degrees) of transformation.
                        """
                        pass

                    class file_length_unit(PyTextual):
                        """
                        Specify the units of length used by this .stl file before loading the CAD file.
                        """
                        pass

                    class file_length_unit_append(PyTextual):
                        """
                        Enable this field and browse and select additional CAD files. Use the Append button to add the additional CAD components to the bottom of the CAD Model tree upon loading.
                        """
                        pass

                    class file_loaded(PyParameter):
                        """
                        Parameter file_loaded of value type bool.
                        """
                        pass

                    class fmd_file_name(PyTextual):
                        """
                        Select a CAD file to import into your simulation. Standard Ansys file types, among others, are supported, including .scdoc, .dsco, .agdb, .fmd, .fmdb, .fmd, .pmdb, .tgf, and .msh. To quickly import multiple CAD files, you can use basic wildcard expression patterns such as the \\* or ? wildcards. More...
                        """
                        pass

                    class ignore_solid_names(PyParameter):
                        """
                        Enable this option to import your CAD geometry while ignoring the names assigned to solids. Note that binary STL files contain a single solid and may have an associated solid name, whereas ASCII STL files contain one or more solids and each can have a  solid name. This option allows to control whether or not to use the name contained in the STL file for naming mesh objects and components.
                        """
                        pass

                    class ignore_solid_names_append(PyParameter):
                        """
                        Enable this field and browse and select additional CAD files. Use the Append button to add the additional CAD components to the bottom of the CAD Model tree upon loading.
                        """
                        pass

                    class jt_lod(PyNumerical):
                        """
                        Specify the level of detail that you want to include for this .jt file before loading the CAD file.
                        """
                        pass

                    class jt_lod_append(PyNumerical):
                        """
                        Enable this field and browse and select additional CAD files. Use the Append button to add the additional CAD components to the bottom of the CAD Model tree upon loading.
                        """
                        pass

                    class length_unit(PyTextual):
                        """
                        Select a suitable unit for display in the graphics window.
                        """
                        pass

                    class object_setting(PyTextual):
                        """
                        Parameter object_setting of value type str.
                        """
                        pass

                    class one_zone_per(PyTextual):
                        """
                        Specify whether to create your meshing zones based on an object, part, body or face. For instance, choosing the face option would create a separate zone for every topological face.
                        """
                        pass

                    class part_per_body(PyParameter):
                        """
                        Enable this option to make all bodies available as individual parts in the CAD Model tree once the CAD file is loaded into the task.
                        """
                        pass

                    class prefix_parent_name(PyParameter):
                        """
                        This applies the name of the component (or assembly) as a prefix to the individual part names when the geometry is loaded into the task.
                        """
                        pass

                    class remove_empty_parts(PyParameter):
                        """
                        Enabled by default, this option lets you import your CAD geometry while removing any empty components.
                        """
                        pass

                    class route(PyTextual):
                        """
                        Provides the recommended route in order to import and load the specified CAD file into this task. The default settings are recommended in most cases.  More...
                        """
                        pass

                    class route_append(PyTextual):
                        """
                        Enable this field and browse and select additional CAD files. Use the Append button to add the additional CAD components to the bottom of the CAD Model tree upon loading.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _import_cad_and_part_management:
                return super().__getitem__(key)

        class import_geometry(PyNamedObjectContainer):
            """
            .
            """
            class _import_geometry(PyMenu):
                """
                Singleton _import_geometry.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.cad_import_options = self.__class__.cad_import_options(service, rules, path + [("cad_import_options", "")])
                        self.import_cad_preferences = self.__class__.import_cad_preferences(service, rules, path + [("import_cad_preferences", "")])
                        self.append_mesh = self.__class__.append_mesh(service, rules, path + [("append_mesh", "")])
                        self.directory = self.__class__.directory(service, rules, path + [("directory", "")])
                        self.file_format = self.__class__.file_format(service, rules, path + [("file_format", "")])
                        self.file_name = self.__class__.file_name(service, rules, path + [("file_name", "")])
                        self.file_names = self.__class__.file_names(service, rules, path + [("file_names", "")])
                        self.import_type = self.__class__.import_type(service, rules, path + [("import_type", "")])
                        self.length_unit = self.__class__.length_unit(service, rules, path + [("length_unit", "")])
                        self.mesh_file_name = self.__class__.mesh_file_name(service, rules, path + [("mesh_file_name", "")])
                        self.mesh_unit = self.__class__.mesh_unit(service, rules, path + [("mesh_unit", "")])
                        self.num_parts = self.__class__.num_parts(service, rules, path + [("num_parts", "")])
                        self.pattern = self.__class__.pattern(service, rules, path + [("pattern", "")])
                        self.use_body_labels = self.__class__.use_body_labels(service, rules, path + [("use_body_labels", "")])
                        super().__init__(service, rules, path)

                    class cad_import_options(PyMenu):
                        """
                        Singleton cad_import_options.
                        """
                        def __init__(self, service, rules, path):
                            self.create_cad_assemblies = self.__class__.create_cad_assemblies(service, rules, path + [("create_cad_assemblies", "")])
                            self.extract_features = self.__class__.extract_features(service, rules, path + [("extract_features", "")])
                            self.feature_angle = self.__class__.feature_angle(service, rules, path + [("feature_angle", "")])
                            self.import_curvature_data_from_cad = self.__class__.import_curvature_data_from_cad(service, rules, path + [("import_curvature_data_from_cad", "")])
                            self.import_named_selections = self.__class__.import_named_selections(service, rules, path + [("import_named_selections", "")])
                            self.import_part_names = self.__class__.import_part_names(service, rules, path + [("import_part_names", "")])
                            self.one_object_per = self.__class__.one_object_per(service, rules, path + [("one_object_per", "")])
                            self.one_zone_per = self.__class__.one_zone_per(service, rules, path + [("one_zone_per", "")])
                            self.open_all_cad_in_subdirectories = self.__class__.open_all_cad_in_subdirectories(service, rules, path + [("open_all_cad_in_subdirectories", "")])
                            self.save_pmdb_intermediate_file = self.__class__.save_pmdb_intermediate_file(service, rules, path + [("save_pmdb_intermediate_file", "")])
                            self.use_part_or_body_as_suffix = self.__class__.use_part_or_body_as_suffix(service, rules, path + [("use_part_or_body_as_suffix", "")])
                            super().__init__(service, rules, path)

                        class create_cad_assemblies(PyParameter):
                            """
                            Parameter create_cad_assemblies of value type bool.
                            """
                            pass

                        class extract_features(PyParameter):
                            """
                            Parameter extract_features of value type bool.
                            """
                            pass

                        class feature_angle(PyNumerical):
                            """
                            Parameter feature_angle of value type float.
                            """
                            pass

                        class import_curvature_data_from_cad(PyParameter):
                            """
                            Parameter import_curvature_data_from_cad of value type bool.
                            """
                            pass

                        class import_named_selections(PyParameter):
                            """
                            Parameter import_named_selections of value type bool.
                            """
                            pass

                        class import_part_names(PyParameter):
                            """
                            Parameter import_part_names of value type bool.
                            """
                            pass

                        class one_object_per(PyTextual):
                            """
                            Parameter one_object_per of value type str.
                            """
                            pass

                        class one_zone_per(PyTextual):
                            """
                            Parameter one_zone_per of value type str.
                            """
                            pass

                        class open_all_cad_in_subdirectories(PyParameter):
                            """
                            Parameter open_all_cad_in_subdirectories of value type bool.
                            """
                            pass

                        class save_pmdb_intermediate_file(PyParameter):
                            """
                            Parameter save_pmdb_intermediate_file of value type bool.
                            """
                            pass

                        class use_part_or_body_as_suffix(PyParameter):
                            """
                            Parameter use_part_or_body_as_suffix of value type bool.
                            """
                            pass

                    class import_cad_preferences(PyMenu):
                        """
                        Singleton import_cad_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.automatic_object_creation = self.__class__.automatic_object_creation(service, rules, path + [("automatic_object_creation", "")])
                            self.edge_label = self.__class__.edge_label(service, rules, path + [("edge_label", "")])
                            self.extract_angle = self.__class__.extract_angle(service, rules, path + [("extract_angle", "")])
                            self.faceted_bodies = self.__class__.faceted_bodies(service, rules, path + [("faceted_bodies", "")])
                            self.max_facet_length = self.__class__.max_facet_length(service, rules, path + [("max_facet_length", "")])
                            self.max_facet_length_option = self.__class__.max_facet_length_option(service, rules, path + [("max_facet_length_option", "")])
                            self.max_facet_length_ratio = self.__class__.max_facet_length_ratio(service, rules, path + [("max_facet_length_ratio", "")])
                            self.merge_nodes = self.__class__.merge_nodes(service, rules, path + [("merge_nodes", "")])
                            self.refaceting = self.__class__.refaceting(service, rules, path + [("refaceting", "")])
                            self.separate_zone_by = self.__class__.separate_zone_by(service, rules, path + [("separate_zone_by", "")])
                            self.separation_angle = self.__class__.separation_angle(service, rules, path + [("separation_angle", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            self.tolerance = self.__class__.tolerance(service, rules, path + [("tolerance", "")])
                            super().__init__(service, rules, path)

                        class automatic_object_creation(PyParameter):
                            """
                            Determine whether or not mesh objects and labels are automatically created upon import, potentially and dramatically increasing the mesh import speed for very large cases. By default, this is set to yes however, if it is set to no, then no labels are created and a single mesh object is created employing all zones.
                            """
                            pass

                        class edge_label(PyParameter):
                            """
                            Specify whether or not the imported CAD geometry already includes specific edges with assigned names (named selections). These named edges can be available later in the workflow when you are adding local size controls.
                            """
                            pass

                        class extract_angle(PyNumerical):
                            """
                            Parameter extract_angle of value type float.
                            """
                            pass

                        class faceted_bodies(PyParameter):
                            """
                            When performing faceting and wrapping operations in your CAD tool lead to non-CAD geometries, set this option to yes to be able to use such geometries in the workflow. To ensure a relatively good quality surface mesh, you should shrink wrap any faceted bodies. In addition, each shrink-wrapped faceted body should be defined in its own unique component within the CAD environment.
                            """
                            pass

                        class max_facet_length(PyNumerical):
                            """
                            Enables you to specify a maximum facet size for the imported model to avoid very large facets during the file import. Depending on the CAD geometry, this may yield more accuracy.
                            """
                            pass

                        class max_facet_length_option(PyTextual):
                            """
                            Set a maximum allowed edge length for faceted CAD import. Enabling this option helps limit overly long triangles during tessellation.
                            """
                            pass

                        class max_facet_length_ratio(PyNumerical):
                            """
                            Specify a factor that scales the target size to compute the maximum facet edge length during tessellation. Larger factors allow longer facet edges.
                            """
                            pass

                        class merge_nodes(PyParameter):
                            """
                            Parameter merge_nodes of value type bool.
                            """
                            pass

                        class refaceting(PyParameter):
                            """
                            Enable this option to be able to set the Tolerance and the Max Facet Length custom faceting options for the imported geometry.
                            """
                            pass

                        class separate_zone_by(PyTextual):
                            """
                            Choose whether or not you are going to separate zones upon import based on a region, a region and a specified separation angle, a face, or neither. This is required to select faces for local sizing. If Named Selections have already been defined at these locations, then separation is not needed.
                            """
                            pass

                        class separation_angle(PyNumerical):
                            """
                            Specify the angle at which features will be extracted from the CAD model on import. Assigning a smaller separation angle will produce more zones.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Display advanced options that you may want to apply to the task.
                            """
                            pass

                        class tolerance(PyNumerical):
                            """
                            Specify the level of facet refinement during import. A value approximately 1/10 of the intended minimum size is recommended. Using a value of 0 results in the coarsest possible faceting.
                            """
                            pass

                    class append_mesh(PyParameter):
                        """
                        Parameter append_mesh of value type bool.
                        """
                        pass

                    class directory(PyTextual):
                        """
                        Parameter directory of value type str.
                        """
                        pass

                    class file_format(PyTextual):
                        """
                        Indicate whether the imported geometry is a CAD File or a Mesh (either a surface or volume mesh).
                        """
                        pass

                    class file_name(PyTextual):
                        """
                        Select a CAD file to import into your simulation. Supported file types are SpaceClaim (.scdoc) and Workbench (.agdb) files and also .pmdb files. Other supported formats include: \\*.CATpart, \\*.prt, \\*.x_t, \\*.sat, \\*.step, and \\*.iges files).
                        """
                        pass

                    class file_names(PyTextual):
                        """
                        Select multiple CAD files to import into your simulation. When importing multiple files, use the browse button (...) to open the Select File dialog that allows you to make multiple selections, as long as the files are in the same directory and are of the same CAD format. Supported file types are SpaceClaim (.scdoc) and Workbench (.agdb) files and also .pmdb files. Other supported formats include: \\*.CATpart, \\*.prt, \\*.x_t, \\*.sat, \\*.step, and \\*.iges files).
                        """
                        pass

                    class import_type(PyTextual):
                        """
                        When the File Format is set to CAD, use the Import Type field to import a Single File (the default), or Multiple Files. When importing multiple files, the Select File dialog allows you to make multiple selections, as long as the files are in the same directory and are of the same CAD format.
                        """
                        pass

                    class length_unit(PyTextual):
                        """
                        Select a suitable working unit for the meshing operation, with a min size of the order of 1. The model will be automatically scaled to meters when switching to the solver. It is recommended to select units so that the minimum size is between approximately 0.1 - 10. If the minimum size falls outside of this range, then you should change the units.
                        """
                        pass

                    class mesh_file_name(PyTextual):
                        """
                        Select a CAD file to import into your simulation. Supported file types are SpaceClaim (.scdoc) and Workbench (.agdb) files and also .pmdb files. Other supported formats include: \\*.CATpart, \\*.prt, \\*.x_t, \\*.sat, \\*.step, and \\*.iges files).
                        """
                        pass

                    class mesh_unit(PyTextual):
                        """
                        Specify the units in which the surface or volume mesh was created in.
                        """
                        pass

                    class num_parts(PyNumerical):
                        """
                        Parameter num_parts of value type float.
                        """
                        pass

                    class pattern(PyTextual):
                        """
                        Parameter pattern of value type str.
                        """
                        pass

                    class use_body_labels(PyParameter):
                        """
                        Specify that you want to use any composite body labels that are defined in your imported CAD geometry by choosing Yes. If the imported CAD file does not contain any body labels, then this will automatically be set to No.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _import_geometry:
                return super().__getitem__(key)

        class improve_surface_mesh(PyNamedObjectContainer):
            """
            .
            """
            class _improve_surface_mesh(PyMenu):
                """
                Singleton _improve_surface_mesh.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.improve_surface_mesh_preferences = self.__class__.improve_surface_mesh_preferences(service, rules, path + [("improve_surface_mesh_preferences", "")])
                        self.face_quality_limit = self.__class__.face_quality_limit(service, rules, path + [("face_quality_limit", "")])
                        self.mesh_object = self.__class__.mesh_object(service, rules, path + [("mesh_object", "")])
                        self.min_size = self.__class__.min_size(service, rules, path + [("min_size", "")])
                        self.scope_improve_to = self.__class__.scope_improve_to(service, rules, path + [("scope_improve_to", "")])
                        super().__init__(service, rules, path)

                    class improve_surface_mesh_preferences(PyMenu):
                        """
                        Singleton improve_surface_mesh_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.advanced_improve = self.__class__.advanced_improve(service, rules, path + [("advanced_improve", "")])
                            self.allow_defeaturing = self.__class__.allow_defeaturing(service, rules, path + [("allow_defeaturing", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            self.si_dihedral_angle = self.__class__.si_dihedral_angle(service, rules, path + [("si_dihedral_angle", "")])
                            self.si_improve_dihedral_angle = self.__class__.si_improve_dihedral_angle(service, rules, path + [("si_improve_dihedral_angle", "")])
                            self.si_quality_collapse_limit = self.__class__.si_quality_collapse_limit(service, rules, path + [("si_quality_collapse_limit", "")])
                            self.si_quality_iterations = self.__class__.si_quality_iterations(service, rules, path + [("si_quality_iterations", "")])
                            self.si_quality_max_angle = self.__class__.si_quality_max_angle(service, rules, path + [("si_quality_max_angle", "")])
                            self.si_remove_step = self.__class__.si_remove_step(service, rules, path + [("si_remove_step", "")])
                            self.si_step_quality_limit = self.__class__.si_step_quality_limit(service, rules, path + [("si_step_quality_limit", "")])
                            self.si_step_width = self.__class__.si_step_width(service, rules, path + [("si_step_width", "")])
                            super().__init__(service, rules, path)

                        class advanced_improve(PyParameter):
                            """
                            Parameter advanced_improve of value type bool.
                            """
                            pass

                        class allow_defeaturing(PyParameter):
                            """
                            Parameter allow_defeaturing of value type bool.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Display advanced options that you may want to apply to the task.
                            """
                            pass

                        class si_dihedral_angle(PyNumerical):
                            """
                            Parameter si_dihedral_angle of value type float.
                            """
                            pass

                        class si_improve_dihedral_angle(PyParameter):
                            """
                            Parameter si_improve_dihedral_angle of value type bool.
                            """
                            pass

                        class si_quality_collapse_limit(PyNumerical):
                            """
                            Specify the limiting skewness value for cell collapse to improve the mesh. The default value changes automatically when you change the Face Quality Limit.
                            """
                            pass

                        class si_quality_iterations(PyNumerical):
                            """
                            Specify the number of iterations that will be performed to improve the mesh.
                            """
                            pass

                        class si_quality_max_angle(PyNumerical):
                            """
                            Specify the maximum angle between the normals of adjacent faces during mesh improvement. This quality measure is useful in locating sharp corners in complicated geometries. The angle value ranges from 0-180 degrees.
                            """
                            pass

                        class si_remove_step(PyParameter):
                            """
                            Indicate if there are any small imperfections (ledge or step artifacts from the original CAD geometry) that can be removed as part of this task. If you select yes, then you must specify a Max Step Width and the Step Skewness Quality Limit.
                            """
                            pass

                        class si_step_quality_limit(PyNumerical):
                            """
                            Specify the limiting skewness quality for the step(s) to be removed.
                            """
                            pass

                        class si_step_width(PyNumerical):
                            """
                            Specify the width of the step that you wish to remove.
                            """
                            pass

                    class face_quality_limit(PyNumerical):
                        """
                        Use the specified value to improve the surface mesh. Note that this control can aggressively change your surface mesh when applied.
                        """
                        pass

                    class mesh_object(PyTextual):
                        """
                        Parameter mesh_object of value type str.
                        """
                        pass

                    class min_size(PyNumerical):
                        """
                        Parameter min_size of value type float.
                        """
                        pass

                    class scope_improve_to(PyTextual):
                        """
                        Parameter scope_improve_to of value type str.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _improve_surface_mesh:
                return super().__getitem__(key)

        class improve_volume_mesh(PyNamedObjectContainer):
            """
            .
            """
            class _improve_volume_mesh(PyMenu):
                """
                Singleton _improve_volume_mesh.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.improve_volume_mesh_preferences = self.__class__.improve_volume_mesh_preferences(service, rules, path + [("improve_volume_mesh_preferences", "")])
                        self.add_multiple_quality_methods = self.__class__.add_multiple_quality_methods(service, rules, path + [("add_multiple_quality_methods", "")])
                        self.cell_quality_limit = self.__class__.cell_quality_limit(service, rules, path + [("cell_quality_limit", "")])
                        self.old_quality_criteria_list = self.__class__.old_quality_criteria_list(service, rules, path + [("old_quality_criteria_list", "")])
                        self.old_quality_method_list = self.__class__.old_quality_method_list(service, rules, path + [("old_quality_method_list", "")])
                        self.quality_criteria_list = self.__class__.quality_criteria_list(service, rules, path + [("quality_criteria_list", "")])
                        self.quality_method = self.__class__.quality_method(service, rules, path + [("quality_method", "")])
                        self.quality_method_list = self.__class__.quality_method_list(service, rules, path + [("quality_method_list", "")])
                        super().__init__(service, rules, path)

                    class improve_volume_mesh_preferences(PyMenu):
                        """
                        Singleton improve_volume_mesh_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.iterations = self.__class__.iterations(service, rules, path + [("iterations", "")])
                            self.min_angle = self.__class__.min_angle(service, rules, path + [("min_angle", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            self.smooth_remaining_bad_cells = self.__class__.smooth_remaining_bad_cells(service, rules, path + [("smooth_remaining_bad_cells", "")])
                            super().__init__(service, rules, path)

                        class iterations(PyNumerical):
                            """
                            Specify the number of iterations that will be performed to improve the mesh.
                            """
                            pass

                        class min_angle(PyNumerical):
                            """
                            Specify the minimum angle between the normals of adjacent faces during mesh improvement. This quality measure is useful in locating sharp corners in complicated geometries. The angle value ranges from 0 to 180 degrees.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Display advanced options that you may want to apply to the task.
                            """
                            pass

                        class smooth_remaining_bad_cells(PyParameter):
                            """
                            Choose whether or not to ignore geometric features that are related to any remaining problematic cells in the volume mesh.
                            """
                            pass

                    class add_multiple_quality_methods(PyParameter):
                        """
                        Use this option to specify quality criteria for multiple quality methods.
                        """
                        pass

                    class cell_quality_limit(PyNumerical):
                        """
                        Use the specified value to improve the volume mesh. Note that this control can aggressively change your volume mesh when applied.
                        """
                        pass

                    class old_quality_criteria_list(PyTextual):
                        """
                        Parameter old_quality_criteria_list of value type list[str].
                        """
                        pass

                    class old_quality_method_list(PyTextual):
                        """
                        Parameter old_quality_method_list of value type list[str].
                        """
                        pass

                    class quality_criteria_list(PyTextual):
                        """
                        Parameter quality_criteria_list of value type list[str].
                        """
                        pass

                    class quality_method(PyTextual):
                        """
                        Choose from several different types of mesh quality controls (skewness, aspect ratio, change in size, and so on). Choices include Orthogonal (the default for the workflows), Enhanced Orthogonal, and Skewness. For more information, see  More... .
                        """
                        pass

                    class quality_method_list(PyTextual):
                        """
                        Parameter quality_method_list of value type list[str].
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _improve_volume_mesh:
                return super().__getitem__(key)

        class load_cad_geometry(PyNamedObjectContainer):
            """
            .
            """
            class _load_cad_geometry(PyMenu):
                """
                Singleton _load_cad_geometry.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.refaceting = self.__class__.refaceting(service, rules, path + [("refaceting", "")])
                        self.create_object_per = self.__class__.create_object_per(service, rules, path + [("create_object_per", "")])
                        self.faceting_tolerance = self.__class__.faceting_tolerance(service, rules, path + [("faceting_tolerance", "")])
                        self.file_name = self.__class__.file_name(service, rules, path + [("file_name", "")])
                        self.length_unit = self.__class__.length_unit(service, rules, path + [("length_unit", "")])
                        self.num_parts = self.__class__.num_parts(service, rules, path + [("num_parts", "")])
                        self.route = self.__class__.route(service, rules, path + [("route", "")])
                        self.use_prime_geometry_kernel = self.__class__.use_prime_geometry_kernel(service, rules, path + [("use_prime_geometry_kernel", "")])
                        super().__init__(service, rules, path)

                    class refaceting(PyMenu):
                        """
                        Singleton refaceting.
                        """
                        def __init__(self, service, rules, path):
                            self.custom_deviation = self.__class__.custom_deviation(service, rules, path + [("custom_deviation", "")])
                            self.custom_normal_angle = self.__class__.custom_normal_angle(service, rules, path + [("custom_normal_angle", "")])
                            self.deviation = self.__class__.deviation(service, rules, path + [("deviation", "")])
                            self.facet_max_edge_length = self.__class__.facet_max_edge_length(service, rules, path + [("facet_max_edge_length", "")])
                            self.facet_resolution = self.__class__.facet_resolution(service, rules, path + [("facet_resolution", "")])
                            self.max_edge_length = self.__class__.max_edge_length(service, rules, path + [("max_edge_length", "")])
                            self.max_edge_length_factor = self.__class__.max_edge_length_factor(service, rules, path + [("max_edge_length_factor", "")])
                            self.normal_angle = self.__class__.normal_angle(service, rules, path + [("normal_angle", "")])
                            self.refacet = self.__class__.refacet(service, rules, path + [("refacet", "")])
                            super().__init__(service, rules, path)

                        class custom_deviation(PyNumerical):
                            """
                            Parameter custom_deviation of value type float.
                            """
                            pass

                        class custom_normal_angle(PyNumerical):
                            """
                            Parameter custom_normal_angle of value type float.
                            """
                            pass

                        class deviation(PyNumerical):
                            """
                            Parameter deviation of value type float.
                            """
                            pass

                        class facet_max_edge_length(PyTextual):
                            """
                            Parameter facet_max_edge_length of value type str.
                            """
                            pass

                        class facet_resolution(PyTextual):
                            """
                            Parameter facet_resolution of value type str.
                            """
                            pass

                        class max_edge_length(PyNumerical):
                            """
                            Parameter max_edge_length of value type float.
                            """
                            pass

                        class max_edge_length_factor(PyNumerical):
                            """
                            Parameter max_edge_length_factor of value type float.
                            """
                            pass

                        class normal_angle(PyNumerical):
                            """
                            Parameter normal_angle of value type float.
                            """
                            pass

                        class refacet(PyParameter):
                            """
                            Parameter refacet of value type bool.
                            """
                            pass

                    class create_object_per(PyTextual):
                        """
                        Parameter create_object_per of value type str.
                        """
                        pass

                    class faceting_tolerance(PyNumerical):
                        """
                        Parameter faceting_tolerance of value type float.
                        """
                        pass

                    class file_name(PyTextual):
                        """
                        Parameter file_name of value type str.
                        """
                        pass

                    class length_unit(PyTextual):
                        """
                        Parameter length_unit of value type str.
                        """
                        pass

                    class num_parts(PyNumerical):
                        """
                        Parameter num_parts of value type float.
                        """
                        pass

                    class route(PyTextual):
                        """
                        Parameter route of value type str.
                        """
                        pass

                    class use_prime_geometry_kernel(PyParameter):
                        """
                        Parameter use_prime_geometry_kernel of value type bool.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _load_cad_geometry:
                return super().__getitem__(key)

        class manage_zones_ftm(PyNamedObjectContainer):
            """
            .
            """
            class _manage_zones_ftm(PyMenu):
                """
                Singleton _manage_zones_ftm.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.add_prefix_name = self.__class__.add_prefix_name(service, rules, path + [("add_prefix_name", "")])
                        self.angle = self.__class__.angle(service, rules, path + [("angle", "")])
                        self.area = self.__class__.area(service, rules, path + [("area", "")])
                        self.body_label_list = self.__class__.body_label_list(service, rules, path + [("body_label_list", "")])
                        self.complete_label_list = self.__class__.complete_label_list(service, rules, path + [("complete_label_list", "")])
                        self.complete_zone_list = self.__class__.complete_zone_list(service, rules, path + [("complete_zone_list", "")])
                        self.control_name = self.__class__.control_name(service, rules, path + [("control_name", "")])
                        self.equal_range = self.__class__.equal_range(service, rules, path + [("equal_range", "")])
                        self.face_merge = self.__class__.face_merge(service, rules, path + [("face_merge", "")])
                        self.label_list = self.__class__.label_list(service, rules, path + [("label_list", "")])
                        self.manage_cell_zone_list = self.__class__.manage_cell_zone_list(service, rules, path + [("manage_cell_zone_list", "")])
                        self.manage_face_zone_list = self.__class__.manage_face_zone_list(service, rules, path + [("manage_face_zone_list", "")])
                        self.operation = self.__class__.operation(service, rules, path + [("operation", "")])
                        self.operation_name = self.__class__.operation_name(service, rules, path + [("operation_name", "")])
                        self.size_filter = self.__class__.size_filter(service, rules, path + [("size_filter", "")])
                        self.topology_list = self.__class__.topology_list(service, rules, path + [("topology_list", "")])
                        self.type = self.__class__.type(service, rules, path + [("type", "")])
                        self.volume = self.__class__.volume(service, rules, path + [("volume", "")])
                        self.zone_filter = self.__class__.zone_filter(service, rules, path + [("zone_filter", "")])
                        self.zone_list = self.__class__.zone_list(service, rules, path + [("zone_list", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        self.zone_or_label = self.__class__.zone_or_label(service, rules, path + [("zone_or_label", "")])
                        super().__init__(service, rules, path)

                    class add_prefix_name(PyTextual):
                        """
                        The text string to be applied to this zone operation.
                        """
                        pass

                    class angle(PyNumerical):
                        """
                        Specify a value for the separation angle for determining separation. Assigning a smaller separation angle will produce more zones.
                        """
                        pass

                    class area(PyNumerical):
                        """
                        Parameter area of value type float.
                        """
                        pass

                    class body_label_list(PyTextual):
                        """
                        Choose from the list of labels, or enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class complete_label_list(PyTextual):
                        """
                        Choose from the list of labels, or enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class complete_zone_list(PyTextual):
                        """
                        Parameter complete_zone_list of value type list[str].
                        """
                        pass

                    class control_name(PyTextual):
                        """
                        Specify a name for the managed zone control or use the default value.
                        """
                        pass

                    class equal_range(PyNumerical):
                        """
                        Specify a percentage range to maintain equivalency for the cell zone volume value or the face zone area value.
                        """
                        pass

                    class face_merge(PyParameter):
                        """
                        Indicate whether or not you want to merge faces as part of the zone operation.
                        """
                        pass

                    class label_list(PyTextual):
                        """
                        Choose from the list of labels, or enter a text string to filter out the list of labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class manage_cell_zone_list(PyTextual):
                        """
                        Choose from the list of cell zones, or enter a text string to filter out the list of cell zones. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class manage_face_zone_list(PyTextual):
                        """
                        Choose from the list of face zones, or enter a text string to filter out the list of face zones. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class operation(PyTextual):
                        """
                        Indicate the operation you wish to perform on the zones. When the task is located prior volume meshing: Separate Zones, Split Cylinders, Split normal to X, Split normal to Y, Split normal to Z, or Extract Edges. When the task is located after volume meshing: Change prefix, Rename, Merge, or Separate Zones. If your imported CAD geometry contains bodies with multiple body labels, you can also choose Merge cells within each body label
                        """
                        pass

                    class operation_name(PyTextual):
                        """
                        The text string to be applied to this zone operation.
                        """
                        pass

                    class size_filter(PyTextual):
                        """
                        Indicate how you would like to filter the list of zones: All, Less than, More than, or Equal to the indicated value for the Volume (cell zone) or Area (face zone).
                        """
                        pass

                    class topology_list(PyTextual):
                        """
                        Parameter topology_list of value type list[str].
                        """
                        pass

                    class type(PyTextual):
                        """
                        Indicate whether you are going to operate on Cell Zones or Face Zones. If your imported CAD geometry contains bodies with multiple body labels, you can also choose Body Labels.
                        """
                        pass

                    class volume(PyNumerical):
                        """
                        Parameter volume of value type float.
                        """
                        pass

                    class zone_filter(PyTextual):
                        """
                        Choose the type of zone. For cell zones, choose from Fluid, Solid, or All. For face zones, choose from Internal, Fluid-Fluid, Solid-Fluid, Fluid-Solid, External-Solid, External-Fluid, or External.
                        """
                        pass

                    class zone_list(PyTextual):
                        """
                        Parameter zone_list of value type list[str].
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                    class zone_or_label(PyTextual):
                        """
                        Choose how you want to make your selection (by label or zone name).
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _manage_zones_ftm:
                return super().__getitem__(key)

        class mesh_controls_table(PyNamedObjectContainer):
            """
            .
            """
            class _mesh_controls_table(PyMenu):
                """
                Singleton _mesh_controls_table.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.size_control_parameters = self.__class__.size_control_parameters(service, rules, path + [("size_control_parameters", "")])
                        self.draw_size_control = self.__class__.draw_size_control(service, rules, path + [("draw_size_control", "")])
                        self.global_max = self.__class__.global_max(service, rules, path + [("global_max", "")])
                        self.global_min = self.__class__.global_min(service, rules, path + [("global_min", "")])
                        self.initial_size_control = self.__class__.initial_size_control(service, rules, path + [("initial_size_control", "")])
                        self.size_control_interval = self.__class__.size_control_interval(service, rules, path + [("size_control_interval", "")])
                        self.target_growth_rate = self.__class__.target_growth_rate(service, rules, path + [("target_growth_rate", "")])
                        self.target_size_control = self.__class__.target_size_control(service, rules, path + [("target_size_control", "")])
                        super().__init__(service, rules, path)

                    class size_control_parameters(PyMenu):
                        """
                        Singleton size_control_parameters.
                        """
                        def __init__(self, service, rules, path):
                            self.new_label_cells = self.__class__.new_label_cells(service, rules, path + [("new_label_cells", "")])
                            self.new_label_curvature = self.__class__.new_label_curvature(service, rules, path + [("new_label_curvature", "")])
                            self.new_label_max = self.__class__.new_label_max(service, rules, path + [("new_label_max", "")])
                            self.new_label_min = self.__class__.new_label_min(service, rules, path + [("new_label_min", "")])
                            self.new_label_objects = self.__class__.new_label_objects(service, rules, path + [("new_label_objects", "")])
                            self.new_label_resolution = self.__class__.new_label_resolution(service, rules, path + [("new_label_resolution", "")])
                            self.new_label_type = self.__class__.new_label_type(service, rules, path + [("new_label_type", "")])
                            self.new_labels = self.__class__.new_labels(service, rules, path + [("new_labels", "")])
                            self.new_zone_type = self.__class__.new_zone_type(service, rules, path + [("new_zone_type", "")])
                            super().__init__(service, rules, path)

                        class new_label_cells(PyTextual):
                            """
                            Parameter new_label_cells of value type list[str].
                            """
                            pass

                        class new_label_curvature(PyTextual):
                            """
                            Parameter new_label_curvature of value type list[str].
                            """
                            pass

                        class new_label_max(PyTextual):
                            """
                            Parameter new_label_max of value type list[str].
                            """
                            pass

                        class new_label_min(PyTextual):
                            """
                            Parameter new_label_min of value type list[str].
                            """
                            pass

                        class new_label_objects(PyTextual):
                            """
                            Parameter new_label_objects of value type list[str].
                            """
                            pass

                        class new_label_resolution(PyTextual):
                            """
                            Parameter new_label_resolution of value type list[str].
                            """
                            pass

                        class new_label_type(PyTextual):
                            """
                            Parameter new_label_type of value type list[str].
                            """
                            pass

                        class new_labels(PyTextual):
                            """
                            Parameter new_labels of value type list[str].
                            """
                            pass

                        class new_zone_type(PyTextual):
                            """
                            Parameter new_zone_type of value type list[str].
                            """
                            pass

                    class draw_size_control(PyParameter):
                        """
                        Enable this field to display the size boxes in the graphics window.
                        """
                        pass

                    class global_max(PyNumerical):
                        """
                        Parameter global_max of value type float.
                        """
                        pass

                    class global_min(PyNumerical):
                        """
                        Parameter global_min of value type float.
                        """
                        pass

                    class initial_size_control(PyParameter):
                        """
                        Enable this field to display the initial size control in the graphics window.
                        """
                        pass

                    class size_control_interval(PyNumerical):
                        """
                        Specify the amount of size control boxes to display.
                        """
                        pass

                    class target_growth_rate(PyNumerical):
                        """
                        Parameter target_growth_rate of value type float.
                        """
                        pass

                    class target_size_control(PyParameter):
                        """
                        Enable this field to display the target size control in the graphics window.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _mesh_controls_table:
                return super().__getitem__(key)

        class modify_mesh_refinement(PyNamedObjectContainer):
            """
            .
            """
            class _modify_mesh_refinement(PyMenu):
                """
                Singleton _modify_mesh_refinement.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.cfd_surface_mesh_controls = self.__class__.cfd_surface_mesh_controls(service, rules, path + [("cfd_surface_mesh_controls", "")])
                        self.remesh_preferences = self.__class__.remesh_preferences(service, rules, path + [("remesh_preferences", "")])
                        self.face_zone_or_label = self.__class__.face_zone_or_label(service, rules, path + [("face_zone_or_label", "")])
                        self.local_max_size = self.__class__.local_max_size(service, rules, path + [("local_max_size", "")])
                        self.local_min_size = self.__class__.local_min_size(service, rules, path + [("local_min_size", "")])
                        self.local_size = self.__class__.local_size(service, rules, path + [("local_size", "")])
                        self.mesh_object = self.__class__.mesh_object(service, rules, path + [("mesh_object", "")])
                        self.remesh_cells_per_gap = self.__class__.remesh_cells_per_gap(service, rules, path + [("remesh_cells_per_gap", "")])
                        self.remesh_control_name = self.__class__.remesh_control_name(service, rules, path + [("remesh_control_name", "")])
                        self.remesh_curvature_normal_angle = self.__class__.remesh_curvature_normal_angle(service, rules, path + [("remesh_curvature_normal_angle", "")])
                        self.remesh_execution = self.__class__.remesh_execution(service, rules, path + [("remesh_execution", "")])
                        self.remesh_face_label_list = self.__class__.remesh_face_label_list(service, rules, path + [("remesh_face_label_list", "")])
                        self.remesh_face_zone_list = self.__class__.remesh_face_zone_list(service, rules, path + [("remesh_face_zone_list", "")])
                        self.remesh_growth_rate = self.__class__.remesh_growth_rate(service, rules, path + [("remesh_growth_rate", "")])
                        self.sizing_type = self.__class__.sizing_type(service, rules, path + [("sizing_type", "")])
                        super().__init__(service, rules, path)

                    class cfd_surface_mesh_controls(PyMenu):
                        """
                        Singleton cfd_surface_mesh_controls.
                        """
                        def __init__(self, service, rules, path):
                            self.auto_create_scoped_sizing = self.__class__.auto_create_scoped_sizing(service, rules, path + [("auto_create_scoped_sizing", "")])
                            self.cells_per_gap = self.__class__.cells_per_gap(service, rules, path + [("cells_per_gap", "")])
                            self.curvature_normal_angle = self.__class__.curvature_normal_angle(service, rules, path + [("curvature_normal_angle", "")])
                            self.draw_size_control = self.__class__.draw_size_control(service, rules, path + [("draw_size_control", "")])
                            self.growth_rate = self.__class__.growth_rate(service, rules, path + [("growth_rate", "")])
                            self.max_size = self.__class__.max_size(service, rules, path + [("max_size", "")])
                            self.min_size = self.__class__.min_size(service, rules, path + [("min_size", "")])
                            self.object_based_controls = self.__class__.object_based_controls(service, rules, path + [("object_based_controls", "")])
                            self.preview_sizefield = self.__class__.preview_sizefield(service, rules, path + [("preview_sizefield", "")])
                            self.refacet = self.__class__.refacet(service, rules, path + [("refacet", "")])
                            self.remesh_imported_mesh = self.__class__.remesh_imported_mesh(service, rules, path + [("remesh_imported_mesh", "")])
                            self.save_size_field = self.__class__.save_size_field(service, rules, path + [("save_size_field", "")])
                            self.save_size_field_file = self.__class__.save_size_field_file(service, rules, path + [("save_size_field_file", "")])
                            self.scope_proximity_to = self.__class__.scope_proximity_to(service, rules, path + [("scope_proximity_to", "")])
                            self.size_control_file = self.__class__.size_control_file(service, rules, path + [("size_control_file", "")])
                            self.size_field_file = self.__class__.size_field_file(service, rules, path + [("size_field_file", "")])
                            self.size_functions = self.__class__.size_functions(service, rules, path + [("size_functions", "")])
                            self.surface_mesh_method = self.__class__.surface_mesh_method(service, rules, path + [("surface_mesh_method", "")])
                            self.use_size_files = self.__class__.use_size_files(service, rules, path + [("use_size_files", "")])
                            super().__init__(service, rules, path)

                        class auto_create_scoped_sizing(PyParameter):
                            """
                            Parameter auto_create_scoped_sizing of value type bool.
                            """
                            pass

                        class cells_per_gap(PyNumerical):
                            """
                            Parameter cells_per_gap of value type float.
                            """
                            pass

                        class curvature_normal_angle(PyNumerical):
                            """
                            Parameter curvature_normal_angle of value type float.
                            """
                            pass

                        class draw_size_control(PyParameter):
                            """
                            Enable this field to display the size boxes in the graphics window.
                            """
                            pass

                        class growth_rate(PyNumerical):
                            """
                            Parameter growth_rate of value type float.
                            """
                            pass

                        class max_size(PyNumerical):
                            """
                            Parameter max_size of value type float.
                            """
                            pass

                        class min_size(PyNumerical):
                            """
                            Parameter min_size of value type float.
                            """
                            pass

                        class object_based_controls(PyParameter):
                            """
                            Parameter object_based_controls of value type bool.
                            """
                            pass

                        class preview_sizefield(PyParameter):
                            """
                            Parameter preview_sizefield of value type bool.
                            """
                            pass

                        class refacet(PyParameter):
                            """
                            Parameter refacet of value type bool.
                            """
                            pass

                        class remesh_imported_mesh(PyTextual):
                            """
                            Parameter remesh_imported_mesh of value type str.
                            """
                            pass

                        class save_size_field(PyParameter):
                            """
                            Parameter save_size_field of value type bool.
                            """
                            pass

                        class save_size_field_file(PyTextual):
                            """
                            Parameter save_size_field_file of value type str.
                            """
                            pass

                        class scope_proximity_to(PyTextual):
                            """
                            Parameter scope_proximity_to of value type str.
                            """
                            pass

                        class size_control_file(PyTextual):
                            """
                            Parameter size_control_file of value type str.
                            """
                            pass

                        class size_field_file(PyTextual):
                            """
                            Parameter size_field_file of value type str.
                            """
                            pass

                        class size_functions(PyTextual):
                            """
                            Parameter size_functions of value type str.
                            """
                            pass

                        class surface_mesh_method(PyTextual):
                            """
                            Parameter surface_mesh_method of value type str.
                            """
                            pass

                        class use_size_files(PyTextual):
                            """
                            Parameter use_size_files of value type str.
                            """
                            pass

                    class remesh_preferences(PyMenu):
                        """
                        Singleton remesh_preferences.
                        """
                        def __init__(self, service, rules, path):
                            self.corner_angle = self.__class__.corner_angle(service, rules, path + [("corner_angle", "")])
                            self.feature_max_angle = self.__class__.feature_max_angle(service, rules, path + [("feature_max_angle", "")])
                            self.remesh_feature_min_angle = self.__class__.remesh_feature_min_angle(service, rules, path + [("remesh_feature_min_angle", "")])
                            self.show_in_gui = self.__class__.show_in_gui(service, rules, path + [("show_in_gui", "")])
                            super().__init__(service, rules, path)

                        class corner_angle(PyNumerical):
                            """
                            Specify the corner angle for remeshing.
                            """
                            pass

                        class feature_max_angle(PyNumerical):
                            """
                            Specify the maximum angle for which features will be preserved upon remeshing.
                            """
                            pass

                        class remesh_feature_min_angle(PyNumerical):
                            """
                            Specify the minimum angle for which features will be preserved upon remeshing.
                            """
                            pass

                        class show_in_gui(PyParameter):
                            """
                            Display advanced options that you may want to apply to the task.
                            """
                            pass

                    class face_zone_or_label(PyTextual):
                        """
                        Specify whether the size control is to be applied to an indicated zone or a label.
                        """
                        pass

                    class local_max_size(PyNumerical):
                        """
                        Parameter local_max_size of value type float.
                        """
                        pass

                    class local_min_size(PyNumerical):
                        """
                        Parameter local_min_size of value type float.
                        """
                        pass

                    class local_size(PyNumerical):
                        """
                        Specify a value for the local sizing parameter to be applied to the indicated zone.
                        """
                        pass

                    class mesh_object(PyTextual):
                        """
                        Parameter mesh_object of value type str.
                        """
                        pass

                    class remesh_cells_per_gap(PyNumerical):
                        """
                        Parameter remesh_cells_per_gap of value type float.
                        """
                        pass

                    class remesh_control_name(PyTextual):
                        """
                        Provide a name for this specific size control.
                        """
                        pass

                    class remesh_curvature_normal_angle(PyNumerical):
                        """
                        Parameter remesh_curvature_normal_angle of value type float.
                        """
                        pass

                    class remesh_execution(PyTextual):
                        """
                        Specify whether to just add the current size control to the workflow, or to add the size control and perform a remeshing operation immediately thereafter.
                        """
                        pass

                    class remesh_face_label_list(PyTextual):
                        """
                        Choose from the list of zone labels, or enter a text string to filter out the list of face zone labels. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class remesh_face_zone_list(PyTextual):
                        """
                        Choose from the list of zones, or enter a text string to filter out the list of face zones. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class remesh_growth_rate(PyNumerical):
                        """
                        Parameter remesh_growth_rate of value type float.
                        """
                        pass

                    class sizing_type(PyTextual):
                        """
                        Parameter sizing_type of value type str.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _modify_mesh_refinement:
                return super().__getitem__(key)

        class part_replacement_options(PyNamedObjectContainer):
            """
            .
            """
            class _part_replacement_options(PyMenu):
                """
                Singleton _part_replacement_options.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.add_boundary_layer = self.__class__.add_boundary_layer(service, rules, path + [("add_boundary_layer", "")])
                        self.add_local_sizing = self.__class__.add_local_sizing(service, rules, path + [("add_local_sizing", "")])
                        self.add_part_management = self.__class__.add_part_management(service, rules, path + [("add_part_management", "")])
                        self.add_part_replacement = self.__class__.add_part_replacement(service, rules, path + [("add_part_replacement", "")])
                        self.add_update_the_volume_mesh = self.__class__.add_update_the_volume_mesh(service, rules, path + [("add_update_the_volume_mesh", "")])
                        super().__init__(service, rules, path)

                    class add_boundary_layer(PyParameter):
                        """
                        Determine whether or not you will need to apply boundary layer (prism controls) to your replacement parts. Answering Yes will add an Add Boundary Layers for Part Replacement task.
                        """
                        pass

                    class add_local_sizing(PyParameter):
                        """
                        Determine whether or not you will need to apply local sizing controls. Answering Yes will add an Add Local Sizing for Part Replacement task.
                        """
                        pass

                    class add_part_management(PyParameter):
                        """
                        Determine whether or not you will be appending new CAD parts to your original geometry. Answering Yes will add an Import CAD and Part Management task.
                        """
                        pass

                    class add_part_replacement(PyParameter):
                        """
                        Parameter add_part_replacement of value type bool.
                        """
                        pass

                    class add_update_the_volume_mesh(PyParameter):
                        """
                        Use this task to remove the existing volume mesh and to update the volume mesh with your new part replacement changes.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _part_replacement_options:
                return super().__getitem__(key)

        class part_replacement_settings(PyNamedObjectContainer):
            """
            .
            """
            class _part_replacement_settings(PyMenu):
                """
                Singleton _part_replacement_settings.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.advanced_options = self.__class__.advanced_options(service, rules, path + [("advanced_options", "")])
                        self.creation_method = self.__class__.creation_method(service, rules, path + [("creation_method", "")])
                        self.graphical_selection = self.__class__.graphical_selection(service, rules, path + [("graphical_selection", "")])
                        self.management_method = self.__class__.management_method(service, rules, path + [("management_method", "")])
                        self.mpt_method_type = self.__class__.mpt_method_type(service, rules, path + [("mpt_method_type", "")])
                        self.new_object_selection_list = self.__class__.new_object_selection_list(service, rules, path + [("new_object_selection_list", "")])
                        self.old_object_selection_list = self.__class__.old_object_selection_list(service, rules, path + [("old_object_selection_list", "")])
                        self.part_replacement_name = self.__class__.part_replacement_name(service, rules, path + [("part_replacement_name", "")])
                        self.scaling_factor = self.__class__.scaling_factor(service, rules, path + [("scaling_factor", "")])
                        self.show_coordinates = self.__class__.show_coordinates(service, rules, path + [("show_coordinates", "")])
                        self.x = self.__class__.x(service, rules, path + [("x", "")])
                        self.y = self.__class__.y(service, rules, path + [("y", "")])
                        self.z = self.__class__.z(service, rules, path + [("z", "")])
                        super().__init__(service, rules, path)

                    class advanced_options(PyParameter):
                        """
                        Display advanced options that you may want to apply to the task.
                        """
                        pass

                    class creation_method(PyTextual):
                        """
                        Choose the approach for handling meshing for the part replacement task: Surface Mesh Based or Volume Mesh Based. The volume mesh based approach defines a separate region for the area of interest surrounding the part replacement. Volume meshing is performed only in this region and thus is much faster than generating the volume mesh in the entire domain.  The surface mesh approach requires the remeshing of all volume regions.
                        """
                        pass

                    class graphical_selection(PyParameter):
                        """
                        Use this option to have the numerical inputs be automatically filled out based on the centroid of the object(s) selected in the graphics window.
                        """
                        pass

                    class management_method(PyTextual):
                        """
                        Choose whether the part replacement operation will be an Addition, Replacement, or Removal of a part.
                        """
                        pass

                    class mpt_method_type(PyTextual):
                        """
                        Choose how you are going to determine the location of the region around the replacement part - by using numerical inputs directly, or by using the region around the selected object(s).
                        """
                        pass

                    class new_object_selection_list(PyTextual):
                        """
                        For part replacement or addition, use this list to pick the new object(s) that you wish to replace or add. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []).
                        """
                        pass

                    class old_object_selection_list(PyTextual):
                        """
                        For part replacement or removal, use this list to pick the original object(s) that you wish to replace or remove. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []).
                        """
                        pass

                    class part_replacement_name(PyTextual):
                        """
                        Enter a name for the part replacement object, or keep the default value.
                        """
                        pass

                    class scaling_factor(PyNumerical):
                        """
                        Specify a factor to change the size of the bounding box surrounding the selected object(s) for part replacement.
                        """
                        pass

                    class show_coordinates(PyParameter):
                        """
                        Use this option to see the exact coordinate values of the current location point.
                        """
                        pass

                    class x(PyNumerical):
                        """
                        Indicates the x-coordinate of the current point location.
                        """
                        pass

                    class y(PyNumerical):
                        """
                        Indicates the y-coordinate of the current point location.
                        """
                        pass

                    class z(PyNumerical):
                        """
                        Indicates the z-coordinate of the current point location.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _part_replacement_settings:
                return super().__getitem__(key)

        class prepare_for_volume_meshing(PyNamedObjectContainer):
            """
            .
            """
            class _prepare_for_volume_meshing(PyMenu):
                """
                Singleton _prepare_for_volume_meshing.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.hard_target_skewness = self.__class__.hard_target_skewness(service, rules, path + [("hard_target_skewness", "")])
                        self.merge_zones_based_on_labels = self.__class__.merge_zones_based_on_labels(service, rules, path + [("merge_zones_based_on_labels", "")])
                        self.soft_target_skewness = self.__class__.soft_target_skewness(service, rules, path + [("soft_target_skewness", "")])
                        super().__init__(service, rules, path)

                    class hard_target_skewness(PyNumerical):
                        """
                        Parameter hard_target_skewness of value type float.
                        """
                        pass

                    class merge_zones_based_on_labels(PyParameter):
                        """
                        Parameter merge_zones_based_on_labels of value type bool.
                        """
                        pass

                    class soft_target_skewness(PyNumerical):
                        """
                        Parameter soft_target_skewness of value type float.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _prepare_for_volume_meshing:
                return super().__getitem__(key)

        class remesh_surface(PyNamedObjectContainer):
            """
            .
            """
            class _remesh_surface(PyMenu):
                """
                Singleton _remesh_surface.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.remesh_surface_option = self.__class__.remesh_surface_option(service, rules, path + [("remesh_surface_option", "")])
                        super().__init__(service, rules, path)

                    class remesh_surface_option(PyParameter):
                        """
                        Parameter remesh_surface_option of value type bool.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _remesh_surface:
                return super().__getitem__(key)

        class separate_contacts(PyNamedObjectContainer):
            """
            .
            """
            class _separate_contacts(PyMenu):
                """
                Singleton _separate_contacts.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.separate_contacts_option = self.__class__.separate_contacts_option(service, rules, path + [("separate_contacts_option", "")])
                        super().__init__(service, rules, path)

                    class separate_contacts_option(PyParameter):
                        """
                        Use this option to enable or disable the ability to separate any existing contacts between surfaces.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _separate_contacts:
                return super().__getitem__(key)

        class set_up_rotational_periodic_boundaries(PyNamedObjectContainer):
            """
            .
            """
            class _set_up_rotational_periodic_boundaries(PyMenu):
                """
                Singleton _set_up_rotational_periodic_boundaries.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.rotation_axis_direction = self.__class__.rotation_axis_direction(service, rules, path + [("rotation_axis_direction", "")])
                        self.rotation_axis_origin = self.__class__.rotation_axis_origin(service, rules, path + [("rotation_axis_origin", "")])
                        self.trans_shift = self.__class__.trans_shift(service, rules, path + [("trans_shift", "")])
                        self.auto_multiple_periodic = self.__class__.auto_multiple_periodic(service, rules, path + [("auto_multiple_periodic", "")])
                        self.label_list = self.__class__.label_list(service, rules, path + [("label_list", "")])
                        self.list_all_label_toggle = self.__class__.list_all_label_toggle(service, rules, path + [("list_all_label_toggle", "")])
                        self.mesh_object = self.__class__.mesh_object(service, rules, path + [("mesh_object", "")])
                        self.method = self.__class__.method(service, rules, path + [("method", "")])
                        self.multiple_option = self.__class__.multiple_option(service, rules, path + [("multiple_option", "")])
                        self.periodicity_angle = self.__class__.periodicity_angle(service, rules, path + [("periodicity_angle", "")])
                        self.remesh_boundaries_option = self.__class__.remesh_boundaries_option(service, rules, path + [("remesh_boundaries_option", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.topology_list = self.__class__.topology_list(service, rules, path + [("topology_list", "")])
                        self.type = self.__class__.type(service, rules, path + [("type", "")])
                        self.zone_list = self.__class__.zone_list(service, rules, path + [("zone_list", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        super().__init__(service, rules, path)

                    class rotation_axis_direction(PyMenu):
                        """
                        The X, Y, and Z components of the vector for the periodic boundary.
                        """
                        def __init__(self, service, rules, path):
                            self.x = self.__class__.x(service, rules, path + [("x", "")])
                            self.y = self.__class__.y(service, rules, path + [("y", "")])
                            self.z = self.__class__.z(service, rules, path + [("z", "")])
                            super().__init__(service, rules, path)

                        class x(PyNumerical):
                            """
                            The X component of the vector for the periodic boundary.
                            """
                            pass

                        class y(PyNumerical):
                            """
                            The Y component of the vector for the periodic boundary.
                            """
                            pass

                        class z(PyNumerical):
                            """
                            The Z component of the vector for the periodic boundary.
                            """
                            pass

                    class rotation_axis_origin(PyMenu):
                        """
                        The X, Y, and Z components of the origin point for the periodic boundary.
                        """
                        def __init__(self, service, rules, path):
                            self.x = self.__class__.x(service, rules, path + [("x", "")])
                            self.y = self.__class__.y(service, rules, path + [("y", "")])
                            self.z = self.__class__.z(service, rules, path + [("z", "")])
                            super().__init__(service, rules, path)

                        class x(PyNumerical):
                            """
                            The X component of the origin point for the periodic boundary.
                            """
                            pass

                        class y(PyNumerical):
                            """
                            The Y component of the origin point for the periodic boundary.
                            """
                            pass

                        class z(PyNumerical):
                            """
                            The Z component of the origin point for the periodic boundary.
                            """
                            pass

                    class trans_shift(PyMenu):
                        """
                        Singleton trans_shift.
                        """
                        def __init__(self, service, rules, path):
                            self.x = self.__class__.x(service, rules, path + [("x", "")])
                            self.y = self.__class__.y(service, rules, path + [("y", "")])
                            self.z = self.__class__.z(service, rules, path + [("z", "")])
                            super().__init__(service, rules, path)

                        class x(PyNumerical):
                            """
                            Specify the X-coordinate of the translational shift.
                            """
                            pass

                        class y(PyNumerical):
                            """
                            Specify the Y-coordinate of the translational shift.
                            """
                            pass

                        class z(PyNumerical):
                            """
                            Specify the Z-coordinate of the translational shift.
                            """
                            pass

                    class auto_multiple_periodic(PyParameter):
                        """
                        Parameter auto_multiple_periodic of value type bool.
                        """
                        pass

                    class label_list(PyTextual):
                        """
                        Choose from the list of zone labels, or enter a text string to filter out the list of face zone labels. Provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []).  More...
                        """
                        pass

                    class list_all_label_toggle(PyParameter):
                        """
                        View more labels in the table, such as those for fluid-fluid internal boundaries, in addition to external boundaries.
                        """
                        pass

                    class mesh_object(PyTextual):
                        """
                        Parameter mesh_object of value type str.
                        """
                        pass

                    class method(PyTextual):
                        """
                        Choose the method for how you are going to define the periodic boundary. Automatic requires you to select two zones or labels. Manual requires only one zone or label.
                        """
                        pass

                    class multiple_option(PyTextual):
                        """
                        Parameter multiple_option of value type str.
                        """
                        pass

                    class periodicity_angle(PyNumerical):
                        """
                        Specify the angle at which periodicity occurs.
                        """
                        pass

                    class remesh_boundaries_option(PyTextual):
                        """
                        Enable this option to remesh boundaries when there is an asymmetric mesh on the periodic faces.
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Specify whether the periodic boundary is to be applied to an indicated zone or a label.
                        """
                        pass

                    class topology_list(PyTextual):
                        """
                        Parameter topology_list of value type list[str].
                        """
                        pass

                    class type(PyTextual):
                        """
                        Choose the type of periodicity: rotational or translational.
                        """
                        pass

                    class zone_list(PyTextual):
                        """
                        Choose from the list of zones, or enter a text string to filter out the list of face zones. Provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []).  More...
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _set_up_rotational_periodic_boundaries:
                return super().__getitem__(key)

        class setup_size_controls(PyNamedObjectContainer):
            """
            .
            """
            class _setup_size_controls(PyMenu):
                """
                Singleton _setup_size_controls.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.local_size_control_parameters = self.__class__.local_size_control_parameters(service, rules, path + [("local_size_control_parameters", "")])
                        self.complete_edge_selection_list = self.__class__.complete_edge_selection_list(service, rules, path + [("complete_edge_selection_list", "")])
                        self.complete_label_selection_list = self.__class__.complete_label_selection_list(service, rules, path + [("complete_label_selection_list", "")])
                        self.complete_object_selection_list = self.__class__.complete_object_selection_list(service, rules, path + [("complete_object_selection_list", "")])
                        self.complete_zone_selection_list = self.__class__.complete_zone_selection_list(service, rules, path + [("complete_zone_selection_list", "")])
                        self.compute_for_solid_only = self.__class__.compute_for_solid_only(service, rules, path + [("compute_for_solid_only", "")])
                        self.edge_selection_list = self.__class__.edge_selection_list(service, rules, path + [("edge_selection_list", "")])
                        self.label_selection_list = self.__class__.label_selection_list(service, rules, path + [("label_selection_list", "")])
                        self.local_settings_name = self.__class__.local_settings_name(service, rules, path + [("local_settings_name", "")])
                        self.object_selection_list = self.__class__.object_selection_list(service, rules, path + [("object_selection_list", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.value_changed = self.__class__.value_changed(service, rules, path + [("value_changed", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        self.zone_selection_list = self.__class__.zone_selection_list(service, rules, path + [("zone_selection_list", "")])
                        super().__init__(service, rules, path)

                    class local_size_control_parameters(PyMenu):
                        """
                        Singleton local_size_control_parameters.
                        """
                        def __init__(self, service, rules, path):
                            self.advanced_options = self.__class__.advanced_options(service, rules, path + [("advanced_options", "")])
                            self.cells_per_gap = self.__class__.cells_per_gap(service, rules, path + [("cells_per_gap", "")])
                            self.curvature_normal_angle = self.__class__.curvature_normal_angle(service, rules, path + [("curvature_normal_angle", "")])
                            self.growth_rate = self.__class__.growth_rate(service, rules, path + [("growth_rate", "")])
                            self.ignore_self = self.__class__.ignore_self(service, rules, path + [("ignore_self", "")])
                            self.initial_size_control = self.__class__.initial_size_control(service, rules, path + [("initial_size_control", "")])
                            self.max_size = self.__class__.max_size(service, rules, path + [("max_size", "")])
                            self.min_size = self.__class__.min_size(service, rules, path + [("min_size", "")])
                            self.scope_proximity_to = self.__class__.scope_proximity_to(service, rules, path + [("scope_proximity_to", "")])
                            self.sizing_type = self.__class__.sizing_type(service, rules, path + [("sizing_type", "")])
                            self.target_size_control = self.__class__.target_size_control(service, rules, path + [("target_size_control", "")])
                            self.wrap_cells_per_gap = self.__class__.wrap_cells_per_gap(service, rules, path + [("wrap_cells_per_gap", "")])
                            self.wrap_curvature_normal_angle = self.__class__.wrap_curvature_normal_angle(service, rules, path + [("wrap_curvature_normal_angle", "")])
                            self.wrap_growth_rate = self.__class__.wrap_growth_rate(service, rules, path + [("wrap_growth_rate", "")])
                            self.wrap_max = self.__class__.wrap_max(service, rules, path + [("wrap_max", "")])
                            self.wrap_min = self.__class__.wrap_min(service, rules, path + [("wrap_min", "")])
                            super().__init__(service, rules, path)

                        class advanced_options(PyParameter):
                            """
                            Display advanced wrap-specific options that are also applied to the task. See this description  for more information about wrap (and target) mesh size controls.
                            """
                            pass

                        class cells_per_gap(PyNumerical):
                            """
                            Specify the minimum number of layers of elements to be generated in the gaps. The number of cells per gap can be a real value, with a minimum value of 0.01.
                            """
                            pass

                        class curvature_normal_angle(PyNumerical):
                            """
                            Specify the maximum allowable angle (from 0 to 180 degrees) that one element edge is allowed to span given a particular geometry curvature. You can use this field to limit the number of elements that are generated along a curve or surface if the minimum size is too small for that particular curve.
                            """
                            pass

                        class growth_rate(PyNumerical):
                            """
                            Specify the increase in element edge length with each succeeding layer of elements.
                            """
                            pass

                        class ignore_self(PyParameter):
                            """
                            Select this option to ignore the proximity computation between facets within a face zone, and avoid over-refinement.
                            """
                            pass

                        class initial_size_control(PyParameter):
                            """
                            Enable this field to display the initial size control in the graphics window.
                            """
                            pass

                        class max_size(PyNumerical):
                            """
                            Specify the maximum size of the elements for the surface mesh.
                            """
                            pass

                        class min_size(PyNumerical):
                            """
                            Specify the minimum size of the elements for the surface mesh.
                            """
                            pass

                        class scope_proximity_to(PyTextual):
                            """
                            Set proximity based refinement. The edges option considers edge-to-edge proximity, while faces considers face-to-face proximity, and faces and edges considers both. Note that when you use the faces and edges option, you can only select objects.
                            """
                            pass

                        class sizing_type(PyTextual):
                            """
                            Choose the type of sizing control (curvature, proximity, soft, or boi).
                            """
                            pass

                        class target_size_control(PyParameter):
                            """
                            Enable this field to display the target size control in the graphics window.
                            """
                            pass

                        class wrap_cells_per_gap(PyNumerical):
                            """
                            Specify the minimum number of layers of elements to be generated in the gaps. The number of cells per gap can be a real value, with a minimum value of 0.01.
                            """
                            pass

                        class wrap_curvature_normal_angle(PyNumerical):
                            """
                            Specify the maximum allowable angle (from 0 to 180 degrees) that one element edge is allowed to span given a particular geometry curvature. You can use this field to limit the number of elements that are generated along a curve or surface if the minimum size is too small for that particular curve.
                            """
                            pass

                        class wrap_growth_rate(PyNumerical):
                            """
                            Specify the increase in element edge length with each succeeding layer of elements.
                            """
                            pass

                        class wrap_max(PyNumerical):
                            """
                            Specify a value for the maximum wrapping size for the size control. It will wrap with this maximum size and later coarsen through remeshing to the given target size.
                            """
                            pass

                        class wrap_min(PyNumerical):
                            """
                            Specify a value for the minimum wrapping size for the size control. It will wrap with this minimum size and later coarsen through remeshing to the given target size. One of the advantages of the wrapper is that it can automatically de-feature unnecessary small details. The wrap size is used to wrap the geometry and target size is used to remesh. Feature capturing highly depends on the value of the wrap size. The default wrap size is 1/1.5 times smaller than the target size, and you can change the value.
                            """
                            pass

                    class complete_edge_selection_list(PyTextual):
                        """
                        Choose one or more edge zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class complete_label_selection_list(PyTextual):
                        """
                        Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class complete_object_selection_list(PyTextual):
                        """
                        Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class complete_zone_selection_list(PyTextual):
                        """
                        Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class compute_for_solid_only(PyTextual):
                        """
                        Parameter compute_for_solid_only of value type str.
                        """
                        pass

                    class edge_selection_list(PyTextual):
                        """
                        Choose one or more edge zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class label_selection_list(PyTextual):
                        """
                        Choose one or more labels from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class local_settings_name(PyTextual):
                        """
                        Specify a name for the size control or use the default value.
                        """
                        pass

                    class object_selection_list(PyTextual):
                        """
                        Choose one or more objects from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Choose how you want to make your selection (by object, label, or zone name).
                        """
                        pass

                    class value_changed(PyTextual):
                        """
                        Parameter value_changed of value type str.
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                    class zone_selection_list(PyTextual):
                        """
                        Choose one or more face zones from the list below. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _setup_size_controls:
                return super().__getitem__(key)

        class switch_to_solution(PyNamedObjectContainer):
            """
            .
            """
            class _switch_to_solution(PyMenu):
                """
                Singleton _switch_to_solution.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        super().__init__(service, rules, path)

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _switch_to_solution:
                return super().__getitem__(key)

        class transform_volume_mesh(PyNamedObjectContainer):
            """
            .
            """
            class _transform_volume_mesh(PyMenu):
                """
                Singleton _transform_volume_mesh.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.rotation_axis_direction = self.__class__.rotation_axis_direction(service, rules, path + [("rotation_axis_direction", "")])
                        self.rotation_axis_origin = self.__class__.rotation_axis_origin(service, rules, path + [("rotation_axis_origin", "")])
                        self.trans_shift = self.__class__.trans_shift(service, rules, path + [("trans_shift", "")])
                        self.angle = self.__class__.angle(service, rules, path + [("angle", "")])
                        self.cell_zone_list = self.__class__.cell_zone_list(service, rules, path + [("cell_zone_list", "")])
                        self.control_name = self.__class__.control_name(service, rules, path + [("control_name", "")])
                        self.copy = self.__class__.copy(service, rules, path + [("copy", "")])
                        self.merge = self.__class__.merge(service, rules, path + [("merge", "")])
                        self.merge_boundaries = self.__class__.merge_boundaries(service, rules, path + [("merge_boundaries", "")])
                        self.method = self.__class__.method(service, rules, path + [("method", "")])
                        self.num_of_copies = self.__class__.num_of_copies(service, rules, path + [("num_of_copies", "")])
                        self.rename = self.__class__.rename(service, rules, path + [("rename", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.topo_body_list = self.__class__.topo_body_list(service, rules, path + [("topo_body_list", "")])
                        self.type = self.__class__.type(service, rules, path + [("type", "")])
                        super().__init__(service, rules, path)

                    class rotation_axis_direction(PyMenu):
                        """
                        Specify the coordinates of the rotational vector.
                        """
                        def __init__(self, service, rules, path):
                            self.x = self.__class__.x(service, rules, path + [("x", "")])
                            self.y = self.__class__.y(service, rules, path + [("y", "")])
                            self.z = self.__class__.z(service, rules, path + [("z", "")])
                            super().__init__(service, rules, path)

                        class x(PyNumerical):
                            """
                            Specify the X-coordinate of the rotational vector.
                            """
                            pass

                        class y(PyNumerical):
                            """
                            Specify the Y-coordinate of the rotational vector.
                            """
                            pass

                        class z(PyNumerical):
                            """
                            Specify the Z-coordinate of the rotational vector.
                            """
                            pass

                    class rotation_axis_origin(PyMenu):
                        """
                        Specify the coordinates of the rotational origin.
                        """
                        def __init__(self, service, rules, path):
                            self.x = self.__class__.x(service, rules, path + [("x", "")])
                            self.y = self.__class__.y(service, rules, path + [("y", "")])
                            self.z = self.__class__.z(service, rules, path + [("z", "")])
                            super().__init__(service, rules, path)

                        class x(PyNumerical):
                            """
                            Specify the X-coordinate of the rotational origin.
                            """
                            pass

                        class y(PyNumerical):
                            """
                            Specify the Y-coordinate of the rotational origin.
                            """
                            pass

                        class z(PyNumerical):
                            """
                            Specify the Z-coordinate of the rotational origin.
                            """
                            pass

                    class trans_shift(PyMenu):
                        """
                        Specify the coordinates of the translational shift.
                        """
                        def __init__(self, service, rules, path):
                            self.x = self.__class__.x(service, rules, path + [("x", "")])
                            self.y = self.__class__.y(service, rules, path + [("y", "")])
                            self.z = self.__class__.z(service, rules, path + [("z", "")])
                            super().__init__(service, rules, path)

                        class x(PyNumerical):
                            """
                            Specify the X-coordinate of the translational shift.
                            """
                            pass

                        class y(PyNumerical):
                            """
                            Specify the Y-coordinate of the translational shift.
                            """
                            pass

                        class z(PyNumerical):
                            """
                            Specify the Z-coordinate of the translational shift.
                            """
                            pass

                    class angle(PyNumerical):
                        """
                        Specify a value for the angle of rotation for this transformation.
                        """
                        pass

                    class cell_zone_list(PyTextual):
                        """
                        Select one or more objects from the list to which you will apply the transformation. Use the Filter Text drop-down to provide text and/or regular expressions in filtering the list (for example, using \\*, ?, and []). Choose Use Wildcard to provide wildcard expressions in filtering the list. When you use either ? or \\* in your expression, the matching list item(s) are automatically selected in the list. Use ^, |, and & in your expression to indicate boolean operations for NOT, OR, and AND, respectively.  More...
                        """
                        pass

                    class control_name(PyTextual):
                        """
                        Specify a name for the transformation or use the default value.
                        """
                        pass

                    class copy(PyTextual):
                        """
                        Indicate whether or not to make a copy of the volume mesh and apply the transformation to the copy.
                        """
                        pass

                    class merge(PyTextual):
                        """
                        Indicate whether or not you want to merge cell and face zones prior to transforming the volume mesh, in order to avoid duplication.
                        """
                        pass

                    class merge_boundaries(PyTextual):
                        """
                        Parameter merge_boundaries of value type list[str].
                        """
                        pass

                    class method(PyTextual):
                        """
                        By default, the Manual method is utilized, however, when periodics are detected, then Automatic - use existing periodics is the default.
                        """
                        pass

                    class num_of_copies(PyNumerical):
                        """
                        Specify the number of copies that you want to make for this transformation.
                        """
                        pass

                    class rename(PyParameter):
                        """
                        Indicate whether or not you want to rename cell and face zones prior to transforming the volume mesh.
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Indicate the type of transformation: translational or rotational
                        """
                        pass

                    class topo_body_list(PyTextual):
                        """
                        Parameter topo_body_list of value type list[str].
                        """
                        pass

                    class type(PyTextual):
                        """
                        Indicate the type of transformation: translational or rotational
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _transform_volume_mesh:
                return super().__getitem__(key)

        class update_boundaries(PyNamedObjectContainer):
            """
            .
            """
            class _update_boundaries(PyMenu):
                """
                Singleton _update_boundaries.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.boundary_allowed_type_list = self.__class__.boundary_allowed_type_list(service, rules, path + [("boundary_allowed_type_list", "")])
                        self.boundary_current_list = self.__class__.boundary_current_list(service, rules, path + [("boundary_current_list", "")])
                        self.boundary_current_type_list = self.__class__.boundary_current_type_list(service, rules, path + [("boundary_current_type_list", "")])
                        self.boundary_label_list = self.__class__.boundary_label_list(service, rules, path + [("boundary_label_list", "")])
                        self.boundary_label_type_list = self.__class__.boundary_label_type_list(service, rules, path + [("boundary_label_type_list", "")])
                        self.boundary_zone_list = self.__class__.boundary_zone_list(service, rules, path + [("boundary_zone_list", "")])
                        self.boundary_zone_type_list = self.__class__.boundary_zone_type_list(service, rules, path + [("boundary_zone_type_list", "")])
                        self.list_all_boundaries_toggle = self.__class__.list_all_boundaries_toggle(service, rules, path + [("list_all_boundaries_toggle", "")])
                        self.mesh_object = self.__class__.mesh_object(service, rules, path + [("mesh_object", "")])
                        self.old_boundary_label_list = self.__class__.old_boundary_label_list(service, rules, path + [("old_boundary_label_list", "")])
                        self.old_boundary_label_type_list = self.__class__.old_boundary_label_type_list(service, rules, path + [("old_boundary_label_type_list", "")])
                        self.old_boundary_zone_list = self.__class__.old_boundary_zone_list(service, rules, path + [("old_boundary_zone_list", "")])
                        self.old_boundary_zone_type_list = self.__class__.old_boundary_zone_type_list(service, rules, path + [("old_boundary_zone_type_list", "")])
                        self.old_label_zone_list = self.__class__.old_label_zone_list(service, rules, path + [("old_label_zone_list", "")])
                        self.old_topology_list = self.__class__.old_topology_list(service, rules, path + [("old_topology_list", "")])
                        self.old_topology_type_list = self.__class__.old_topology_type_list(service, rules, path + [("old_topology_type_list", "")])
                        self.selection_type = self.__class__.selection_type(service, rules, path + [("selection_type", "")])
                        self.topology_body_list = self.__class__.topology_body_list(service, rules, path + [("topology_body_list", "")])
                        self.topology_list = self.__class__.topology_list(service, rules, path + [("topology_list", "")])
                        self.topology_type_list = self.__class__.topology_type_list(service, rules, path + [("topology_type_list", "")])
                        self.zone_location = self.__class__.zone_location(service, rules, path + [("zone_location", "")])
                        super().__init__(service, rules, path)

                    class boundary_allowed_type_list(PyTextual):
                        """
                        Parameter boundary_allowed_type_list of value type list[str].
                        """
                        pass

                    class boundary_current_list(PyTextual):
                        """
                        Parameter boundary_current_list of value type list[str].
                        """
                        pass

                    class boundary_current_type_list(PyTextual):
                        """
                        Parameter boundary_current_type_list of value type list[str].
                        """
                        pass

                    class boundary_label_list(PyTextual):
                        """
                        Parameter boundary_label_list of value type list[str].
                        """
                        pass

                    class boundary_label_type_list(PyTextual):
                        """
                        Parameter boundary_label_type_list of value type list[str].
                        """
                        pass

                    class boundary_zone_list(PyTextual):
                        """
                        Parameter boundary_zone_list of value type list[str].
                        """
                        pass

                    class boundary_zone_type_list(PyTextual):
                        """
                        Parameter boundary_zone_type_list of value type list[str].
                        """
                        pass

                    class list_all_boundaries_toggle(PyParameter):
                        """
                        View more boundaries in the table, such as fluid-fluid internal boundaries, in addition to external boundaries.
                        """
                        pass

                    class mesh_object(PyTextual):
                        """
                        Parameter mesh_object of value type str.
                        """
                        pass

                    class old_boundary_label_list(PyTextual):
                        """
                        Parameter old_boundary_label_list of value type list[str].
                        """
                        pass

                    class old_boundary_label_type_list(PyTextual):
                        """
                        Parameter old_boundary_label_type_list of value type list[str].
                        """
                        pass

                    class old_boundary_zone_list(PyTextual):
                        """
                        Parameter old_boundary_zone_list of value type list[str].
                        """
                        pass

                    class old_boundary_zone_type_list(PyTextual):
                        """
                        Parameter old_boundary_zone_type_list of value type list[str].
                        """
                        pass

                    class old_label_zone_list(PyTextual):
                        """
                        Parameter old_label_zone_list of value type list[str].
                        """
                        pass

                    class old_topology_list(PyTextual):
                        """
                        Parameter old_topology_list of value type list[str].
                        """
                        pass

                    class old_topology_type_list(PyTextual):
                        """
                        Parameter old_topology_type_list of value type list[str].
                        """
                        pass

                    class selection_type(PyTextual):
                        """
                        Choose how boundaries are displayed in the table.
                        """
                        pass

                    class topology_body_list(PyTextual):
                        """
                        Parameter topology_body_list of value type list[str].
                        """
                        pass

                    class topology_list(PyTextual):
                        """
                        Parameter topology_list of value type list[str].
                        """
                        pass

                    class topology_type_list(PyTextual):
                        """
                        Parameter topology_type_list of value type list[str].
                        """
                        pass

                    class zone_location(PyTextual):
                        """
                        Parameter zone_location of value type list[str].
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _update_boundaries:
                return super().__getitem__(key)

        class update_region_settings(PyNamedObjectContainer):
            """
            .
            """
            class _update_region_settings(PyMenu):
                """
                Singleton _update_region_settings.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.all_region_filter_categories = self.__class__.all_region_filter_categories(service, rules, path + [("all_region_filter_categories", "")])
                        self.all_region_leakage_size_list = self.__class__.all_region_leakage_size_list(service, rules, path + [("all_region_leakage_size_list", "")])
                        self.all_region_linked_construction_surface_list = self.__class__.all_region_linked_construction_surface_list(service, rules, path + [("all_region_linked_construction_surface_list", "")])
                        self.all_region_mesh_method_list = self.__class__.all_region_mesh_method_list(service, rules, path + [("all_region_mesh_method_list", "")])
                        self.all_region_name_list = self.__class__.all_region_name_list(service, rules, path + [("all_region_name_list", "")])
                        self.all_region_overset_componen_list = self.__class__.all_region_overset_componen_list(service, rules, path + [("all_region_overset_componen_list", "")])
                        self.all_region_source_list = self.__class__.all_region_source_list(service, rules, path + [("all_region_source_list", "")])
                        self.all_region_type_list = self.__class__.all_region_type_list(service, rules, path + [("all_region_type_list", "")])
                        self.all_region_volume_fill_list = self.__class__.all_region_volume_fill_list(service, rules, path + [("all_region_volume_fill_list", "")])
                        self.filter_category = self.__class__.filter_category(service, rules, path + [("filter_category", "")])
                        self.main_fluid_region = self.__class__.main_fluid_region(service, rules, path + [("main_fluid_region", "")])
                        self.old_region_leakage_size_list = self.__class__.old_region_leakage_size_list(service, rules, path + [("old_region_leakage_size_list", "")])
                        self.old_region_mesh_method_list = self.__class__.old_region_mesh_method_list(service, rules, path + [("old_region_mesh_method_list", "")])
                        self.old_region_name_list = self.__class__.old_region_name_list(service, rules, path + [("old_region_name_list", "")])
                        self.old_region_overset_componen_list = self.__class__.old_region_overset_componen_list(service, rules, path + [("old_region_overset_componen_list", "")])
                        self.old_region_type_list = self.__class__.old_region_type_list(service, rules, path + [("old_region_type_list", "")])
                        self.old_region_volume_fill_list = self.__class__.old_region_volume_fill_list(service, rules, path + [("old_region_volume_fill_list", "")])
                        self.region_leakage_size_list = self.__class__.region_leakage_size_list(service, rules, path + [("region_leakage_size_list", "")])
                        self.region_mesh_method_list = self.__class__.region_mesh_method_list(service, rules, path + [("region_mesh_method_list", "")])
                        self.region_name_list = self.__class__.region_name_list(service, rules, path + [("region_name_list", "")])
                        self.region_overset_componen_list = self.__class__.region_overset_componen_list(service, rules, path + [("region_overset_componen_list", "")])
                        self.region_type_list = self.__class__.region_type_list(service, rules, path + [("region_type_list", "")])
                        self.region_volume_fill_list = self.__class__.region_volume_fill_list(service, rules, path + [("region_volume_fill_list", "")])
                        super().__init__(service, rules, path)

                    class all_region_filter_categories(PyTextual):
                        """
                        Parameter all_region_filter_categories of value type list[str].
                        """
                        pass

                    class all_region_leakage_size_list(PyTextual):
                        """
                        Parameter all_region_leakage_size_list of value type list[str].
                        """
                        pass

                    class all_region_linked_construction_surface_list(PyTextual):
                        """
                        Parameter all_region_linked_construction_surface_list of value type list[str].
                        """
                        pass

                    class all_region_mesh_method_list(PyTextual):
                        """
                        Parameter all_region_mesh_method_list of value type list[str].
                        """
                        pass

                    class all_region_name_list(PyTextual):
                        """
                        Parameter all_region_name_list of value type list[str].
                        """
                        pass

                    class all_region_overset_componen_list(PyTextual):
                        """
                        Parameter all_region_overset_componen_list of value type list[str].
                        """
                        pass

                    class all_region_source_list(PyTextual):
                        """
                        Parameter all_region_source_list of value type list[str].
                        """
                        pass

                    class all_region_type_list(PyTextual):
                        """
                        Parameter all_region_type_list of value type list[str].
                        """
                        pass

                    class all_region_volume_fill_list(PyTextual):
                        """
                        Parameter all_region_volume_fill_list of value type list[str].
                        """
                        pass

                    class filter_category(PyTextual):
                        """
                        Select how your regions will be displayed in the table. You can choose to view all regions, or specifically identified regions, or only object-based regions.
                        """
                        pass

                    class main_fluid_region(PyTextual):
                        """
                        Identify the main fluid region for your simulation.
                        """
                        pass

                    class old_region_leakage_size_list(PyTextual):
                        """
                        Parameter old_region_leakage_size_list of value type list[str].
                        """
                        pass

                    class old_region_mesh_method_list(PyTextual):
                        """
                        Parameter old_region_mesh_method_list of value type list[str].
                        """
                        pass

                    class old_region_name_list(PyTextual):
                        """
                        Parameter old_region_name_list of value type list[str].
                        """
                        pass

                    class old_region_overset_componen_list(PyTextual):
                        """
                        Parameter old_region_overset_componen_list of value type list[str].
                        """
                        pass

                    class old_region_type_list(PyTextual):
                        """
                        Parameter old_region_type_list of value type list[str].
                        """
                        pass

                    class old_region_volume_fill_list(PyTextual):
                        """
                        Parameter old_region_volume_fill_list of value type list[str].
                        """
                        pass

                    class region_leakage_size_list(PyTextual):
                        """
                        Parameter region_leakage_size_list of value type list[str].
                        """
                        pass

                    class region_mesh_method_list(PyTextual):
                        """
                        Parameter region_mesh_method_list of value type list[str].
                        """
                        pass

                    class region_name_list(PyTextual):
                        """
                        Parameter region_name_list of value type list[str].
                        """
                        pass

                    class region_overset_componen_list(PyTextual):
                        """
                        Parameter region_overset_componen_list of value type list[str].
                        """
                        pass

                    class region_type_list(PyTextual):
                        """
                        Parameter region_type_list of value type list[str].
                        """
                        pass

                    class region_volume_fill_list(PyTextual):
                        """
                        Parameter region_volume_fill_list of value type list[str].
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _update_region_settings:
                return super().__getitem__(key)

        class update_regions(PyNamedObjectContainer):
            """
            .
            """
            class _update_regions(PyMenu):
                """
                Singleton _update_regions.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.mesh_object = self.__class__.mesh_object(service, rules, path + [("mesh_object", "")])
                        self.number_of_listed_regions = self.__class__.number_of_listed_regions(service, rules, path + [("number_of_listed_regions", "")])
                        self.old_region_name_list = self.__class__.old_region_name_list(service, rules, path + [("old_region_name_list", "")])
                        self.old_region_type_list = self.__class__.old_region_type_list(service, rules, path + [("old_region_type_list", "")])
                        self.region_current_list = self.__class__.region_current_list(service, rules, path + [("region_current_list", "")])
                        self.region_current_type_list = self.__class__.region_current_type_list(service, rules, path + [("region_current_type_list", "")])
                        self.region_internal_types = self.__class__.region_internal_types(service, rules, path + [("region_internal_types", "")])
                        self.region_internals = self.__class__.region_internals(service, rules, path + [("region_internals", "")])
                        self.region_name_list = self.__class__.region_name_list(service, rules, path + [("region_name_list", "")])
                        self.region_type_list = self.__class__.region_type_list(service, rules, path + [("region_type_list", "")])
                        super().__init__(service, rules, path)

                    class mesh_object(PyTextual):
                        """
                        Parameter mesh_object of value type str.
                        """
                        pass

                    class number_of_listed_regions(PyNumerical):
                        """
                        Parameter number_of_listed_regions of value type int.
                        """
                        pass

                    class old_region_name_list(PyTextual):
                        """
                        Parameter old_region_name_list of value type list[str].
                        """
                        pass

                    class old_region_type_list(PyTextual):
                        """
                        Parameter old_region_type_list of value type list[str].
                        """
                        pass

                    class region_current_list(PyTextual):
                        """
                        Parameter region_current_list of value type list[str].
                        """
                        pass

                    class region_current_type_list(PyTextual):
                        """
                        Parameter region_current_type_list of value type list[str].
                        """
                        pass

                    class region_internal_types(PyTextual):
                        """
                        Parameter region_internal_types of value type list[str].
                        """
                        pass

                    class region_internals(PyTextual):
                        """
                        Parameter region_internals of value type list[str].
                        """
                        pass

                    class region_name_list(PyTextual):
                        """
                        Parameter region_name_list of value type list[str].
                        """
                        pass

                    class region_type_list(PyTextual):
                        """
                        Parameter region_type_list of value type list[str].
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _update_regions:
                return super().__getitem__(key)

        class update_volume_mesh(PyNamedObjectContainer):
            """
            .
            """
            class _update_volume_mesh(PyMenu):
                """
                Singleton _update_volume_mesh.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.enable_parallel = self.__class__.enable_parallel(service, rules, path + [("enable_parallel", "")])
                        super().__init__(service, rules, path)

                    class enable_parallel(PyParameter):
                        """
                        Enable this option to perform parallel volume and continuous boundary layer (prism) meshing for fluid region(s). Applicable for poly, hexcore and poly-hexcore volume fill types.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _update_volume_mesh:
                return super().__getitem__(key)

        class wrap_main(PyNamedObjectContainer):
            """
            .
            """
            class _wrap_main(PyMenu):
                """
                Singleton _wrap_main.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.wrap_regions_name = self.__class__.wrap_regions_name(service, rules, path + [("wrap_regions_name", "")])
                        super().__init__(service, rules, path)

                    class wrap_regions_name(PyTextual):
                        """
                        Parameter wrap_regions_name of value type str.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _wrap_main:
                return super().__getitem__(key)

        class write_2d_mesh(PyNamedObjectContainer):
            """
            .
            """
            class _write_2d_mesh(PyMenu):
                """
                Singleton _write_2d_mesh.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.file_name = self.__class__.file_name(service, rules, path + [("file_name", "")])
                        self.skip_export = self.__class__.skip_export(service, rules, path + [("skip_export", "")])
                        super().__init__(service, rules, path)

                    class file_name(PyTextual):
                        """
                        Parameter file_name of value type str.
                        """
                        pass

                    class skip_export(PyParameter):
                        """
                        Parameter skip_export of value type bool.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _write_2d_mesh:
                return super().__getitem__(key)

        class write_skin(PyNamedObjectContainer):
            """
            .
            """
            class _write_skin(PyMenu):
                """
                Singleton _write_skin.
                """
                def __init__(self, service, rules, path):
                    self.arguments = self.__class__.arguments(service, rules, path + [("arguments", "")])
                    self._name_ = self.__class__._name_(service, rules, path + [("_name_", "")])
                    self.check_point = self.__class__.check_point(service, rules, path + [("check_point", "")])
                    self.command_name = self.__class__.command_name(service, rules, path + [("command_name", "")])
                    self.errors = self.__class__.errors(service, rules, path + [("errors", "")])
                    self.inactive_task_list = self.__class__.inactive_task_list(service, rules, path + [("inactive_task_list", "")])
                    self.object_path = self.__class__.object_path(service, rules, path + [("object_path", "")])
                    self.state = self.__class__.state(service, rules, path + [("state", "")])
                    self.task_list = self.__class__.task_list(service, rules, path + [("task_list", "")])
                    self.task_type = self.__class__.task_type(service, rules, path + [("task_type", "")])
                    self.warnings = self.__class__.warnings(service, rules, path + [("warnings", "")])
                    self.add_child_and_update = self.__class__.add_child_and_update(service, rules, "add_child_and_update", path)
                    self.add_child_to_task = self.__class__.add_child_to_task(service, rules, "add_child_to_task", path)
                    self.display_model = self.__class__.display_model(service, rules, "display_model", path)
                    self.execute = self.__class__.execute(service, rules, "execute", path)
                    self.execute_upstream_non_executed_and_this_task = self.__class__.execute_upstream_non_executed_and_this_task(service, rules, "execute_upstream_non_executed_and_this_task", path)
                    self.force_upto_date = self.__class__.force_upto_date(service, rules, "force_upto_date", path)
                    self.get_next_possible_tasks = self.__class__.get_next_possible_tasks(service, rules, "get_next_possible_tasks", path)
                    self.insert_composite_child_task = self.__class__.insert_composite_child_task(service, rules, "insert_composite_child_task", path)
                    self.insert_compound_child_task = self.__class__.insert_compound_child_task(service, rules, "insert_compound_child_task", path)
                    self.insert_next_task = self.__class__.insert_next_task(service, rules, "insert_next_task", path)
                    self.rename = self.__class__.rename(service, rules, "rename", path)
                    self.revert = self.__class__.revert(service, rules, "revert", path)
                    self.set_as_current = self.__class__.set_as_current(service, rules, "set_as_current", path)
                    self.update_child_tasks = self.__class__.update_child_tasks(service, rules, "update_child_tasks", path)
                    super().__init__(service, rules, path)

                class arguments(PyMenu):
                    """
                    Task arguments container.
                    """
                    def __init__(self, service, rules, path):
                        self.file_name = self.__class__.file_name(service, rules, path + [("file_name", "")])
                        super().__init__(service, rules, path)

                    class file_name(PyTextual):
                        """
                        Parameter file_name of value type str.
                        """
                        pass

                class _name_(PyTextual):
                    """
                    Parameter _name_ of value type str.
                    """
                    pass

                class check_point(PyTextual):
                    """
                    Parameter check_point of value type str.
                    """
                    pass

                class command_name(PyTextual):
                    """
                    Parameter command_name of value type str.
                    """
                    pass

                class errors(PyTextual):
                    """
                    Parameter errors of value type list[str].
                    """
                    pass

                class inactive_task_list(PyTextual):
                    """
                    Parameter inactive_task_list of value type list[str].
                    """
                    pass

                class object_path(PyTextual):
                    """
                    Parameter object_path of value type str.
                    """
                    pass

                class state(PyTextual):
                    """
                    Parameter state of value type str.
                    """
                    pass

                class task_list(PyTextual):
                    """
                    Parameter task_list of value type list[str].
                    """
                    pass

                class task_type(PyTextual):
                    """
                    Parameter task_type of value type str.
                    """
                    pass

                class warnings(PyTextual):
                    """
                    Parameter warnings of value type list[str].
                    """
                    pass

                class add_child_and_update(PyCommand):
                    """
                    Command add_child_and_update.

                    Parameters
                    ----------
                    defer_update : bool
                    force : bool
                    retain_values : bool

                    Returns
                    -------
                    bool
                    """
                    class _add_child_and_updateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.defer_update = self._defer_update(self, "defer_update", service, rules, path)
                            self.force = self._force(self, "force", service, rules, path)
                            self.retain_values = self._retain_values(self, "retain_values", service, rules, path)

                        class _defer_update(PyArgumentsParameterSubItem):
                            """
                            Argument defer_update.
                            """

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                        class _retain_values(PyArgumentsParameterSubItem):
                            """
                            Argument retain_values.
                            """

                    def create_instance(self) -> _add_child_and_updateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_and_updateArguments(*args)

                class add_child_to_task(PyCommand):
                    """
                    Command add_child_to_task.


                    Returns
                    -------
                    bool
                    """
                    class _add_child_to_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _add_child_to_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._add_child_to_taskArguments(*args)

                class display_model(PyCommand):
                    """
                    Command display_model.


                    Returns
                    -------
                    bool
                    """
                    class _display_modelArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _display_modelArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._display_modelArguments(*args)

                class execute(PyCommand):
                    """
                    Command execute.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _executeArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _executeArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._executeArguments(*args)

                class execute_upstream_non_executed_and_this_task(PyCommand):
                    """
                    Command execute_upstream_non_executed_and_this_task.


                    Returns
                    -------
                    bool
                    """
                    class _execute_upstream_non_executed_and_this_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _execute_upstream_non_executed_and_this_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._execute_upstream_non_executed_and_this_taskArguments(*args)

                class force_upto_date(PyCommand):
                    """
                    Command force_upto_date.

                    Parameters
                    ----------
                    force : bool

                    Returns
                    -------
                    bool
                    """
                    class _force_upto_dateArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.force = self._force(self, "force", service, rules, path)

                        class _force(PyArgumentsParameterSubItem):
                            """
                            Argument force.
                            """

                    def create_instance(self) -> _force_upto_dateArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._force_upto_dateArguments(*args)

                class get_next_possible_tasks(PyCommand):
                    """
                    Command get_next_possible_tasks.


                    Returns
                    -------
                    bool
                    """
                    class _get_next_possible_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _get_next_possible_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._get_next_possible_tasksArguments(*args)

                class insert_composite_child_task(PyCommand):
                    """
                    Command insert_composite_child_task.

                    Parameters
                    ----------
                    command_name : str

                    Returns
                    -------
                    bool
                    """
                    class _insert_composite_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                    def create_instance(self) -> _insert_composite_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_composite_child_taskArguments(*args)

                class insert_compound_child_task(PyCommand):
                    """
                    Command insert_compound_child_task.


                    Returns
                    -------
                    bool
                    """
                    class _insert_compound_child_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _insert_compound_child_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_compound_child_taskArguments(*args)

                class insert_next_task(PyCommand):
                    """
                    Command insert_next_task.

                    Parameters
                    ----------
                    command_name : str
                    select : bool

                    Returns
                    -------
                    bool
                    """
                    class _insert_next_taskArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.command_name = self._command_name(self, "command_name", service, rules, path)
                            self.select = self._select(self, "select", service, rules, path)

                        class _command_name(PyArgumentsTextualSubItem):
                            """
                            Argument command_name.
                            """

                        class _select(PyArgumentsParameterSubItem):
                            """
                            Argument select.
                            """

                    def create_instance(self) -> _insert_next_taskArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._insert_next_taskArguments(*args)

                class rename(PyCommand):
                    """
                    Command rename.

                    Parameters
                    ----------
                    new_name : str

                    Returns
                    -------
                    bool
                    """
                    class _renameArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.new_name = self._new_name(self, "new_name", service, rules, path)

                        class _new_name(PyArgumentsTextualSubItem):
                            """
                            Argument new_name.
                            """

                    def create_instance(self) -> _renameArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._renameArguments(*args)

                class revert(PyCommand):
                    """
                    Command revert.


                    Returns
                    -------
                    bool
                    """
                    class _revertArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _revertArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._revertArguments(*args)

                class set_as_current(PyCommand):
                    """
                    Command set_as_current.


                    Returns
                    -------
                    bool
                    """
                    class _set_as_currentArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)

                    def create_instance(self) -> _set_as_currentArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._set_as_currentArguments(*args)

                class update_child_tasks(PyCommand):
                    """
                    Command update_child_tasks.

                    Parameters
                    ----------
                    setup_type_changed : bool
                    arguments : dict[str, Any]

                    Returns
                    -------
                    bool
                    """
                    class _update_child_tasksArguments(PyArguments):
                        def __init__(self, service, rules, command, path, id):
                            super().__init__(service, rules, command, path, id)
                            self.setup_type_changed = self._setup_type_changed(self, "setup_type_changed", service, rules, path)
                            self.arguments = self._arguments(self, "arguments", service, rules, path)

                        class _setup_type_changed(PyArgumentsParameterSubItem):
                            """
                            Argument setup_type_changed.
                            """

                        class _arguments(PyArgumentsDictionarySubItem):
                            """
                            Argument arguments.
                            """

                    def create_instance(self) -> _update_child_tasksArguments:
                        args = self._get_create_instance_args()
                        if args is not None:
                            return self._update_child_tasksArguments(*args)

            def __getitem__(self, key: str) -> _write_skin:
                return super().__getitem__(key)


"""Fluent solver TUI commands"""
#
# This is an auto-generated file.  DO NOT EDIT!
#
# pylint: disable=line-too-long

from ansys.fluent.core.services.datamodel_tui import PyMenu, TUIMenu, TUIMethod



class main_menu(TUIMenu):
    """
    Fluent solver main menu.
    """
    def __init__(self, service, version, mode, path):
        self.adjoint = self.__class__.adjoint(service, version, mode, path + ["adjoint"])
        self.define = self.__class__.define(service, version, mode, path + ["define"])
        self.display = self.__class__.display(service, version, mode, path + ["display"])
        self.file = self.__class__.file(service, version, mode, path + ["file"])
        self.icing = self.__class__.icing(service, version, mode, path + ["icing"])
        self.mesh = self.__class__.mesh(service, version, mode, path + ["mesh"])
        self.parallel = self.__class__.parallel(service, version, mode, path + ["parallel"])
        self.parameters = self.__class__.parameters(service, version, mode, path + ["parameters"])
        self.parametric_study = self.__class__.parametric_study(service, version, mode, path + ["parametric_study"])
        self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
        self.preferences = self.__class__.preferences(service, version, mode, path + ["preferences"])
        self.report = self.__class__.report(service, version, mode, path + ["report"])
        self.results = self.__class__.results(service, version, mode, path + ["results"])
        self.server = self.__class__.server(service, version, mode, path + ["server"])
        self.setup = self.__class__.setup(service, version, mode, path + ["setup"])
        self.solution = self.__class__.solution(service, version, mode, path + ["solution"])
        self.solve = self.__class__.solve(service, version, mode, path + ["solve"])
        self.surface = self.__class__.surface(service, version, mode, path + ["surface"])
        self.turbo_post = self.__class__.turbo_post(service, version, mode, path + ["turbo_post"])
        self.turbo_workflow = self.__class__.turbo_workflow(service, version, mode, path + ["turbo_workflow"])
        self.views = self.__class__.views(service, version, mode, path + ["views"])
        self.close_fluent = self.__class__.close_fluent(service, version, mode, path + ["close_fluent"])
        self.exit = self.__class__.exit(service, version, mode, path + ["exit"])
        self.print_license_usage = self.__class__.print_license_usage(service, version, mode, path + ["print_license_usage"])
        self.switch_to_meshing_mode = self.__class__.switch_to_meshing_mode(service, version, mode, path + ["switch_to_meshing_mode"])
        super().__init__(service, version, mode, path)
    class close_fluent(TUIMethod):
        """
        Exit program.
        """
    class exit(TUIMethod):
        """
        Exit program.
        """
    class print_license_usage(TUIMethod):
        """
        Print license usage information.
        """
    class switch_to_meshing_mode(TUIMethod):
        """
        Switches from the solution mode to the meshing mode. This text command is only available if you have not yet read a mesh or a case file.
        """

    class adjoint(TUIMenu):
        """
        Adjoint.
        """
        def __init__(self, service, version, mode, path):
            self.controls = self.__class__.controls(service, version, mode, path + ["controls"])
            self.design_tool = self.__class__.design_tool(service, version, mode, path + ["design_tool"])
            self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
            self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
            self.methods = self.__class__.methods(service, version, mode, path + ["methods"])
            self.monitors = self.__class__.monitors(service, version, mode, path + ["monitors"])
            self.morphing = self.__class__.morphing(service, version, mode, path + ["morphing"])
            self.multi_objective = self.__class__.multi_objective(service, version, mode, path + ["multi_objective"])
            self.observable = self.__class__.observable(service, version, mode, path + ["observable"])
            self.optimizer = self.__class__.optimizer(service, version, mode, path + ["optimizer"])
            self.postprocess_options = self.__class__.postprocess_options(service, version, mode, path + ["postprocess_options"])
            self.reporting = self.__class__.reporting(service, version, mode, path + ["reporting"])
            self.run = self.__class__.run(service, version, mode, path + ["run"])
            self.utilities = self.__class__.utilities(service, version, mode, path + ["utilities"])
            super().__init__(service, version, mode, path)
        class controls(TUIMethod):
            """
            Menu to configure adjoint solver controls.
            """
        class design_tool(TUIMethod):
            """
            Enters the design-tool menu.
            """
        class expert(TUIMethod):
            """
            Provides text commands that allow you to undo enhancements to the default adjoint solver behavior.
            """
        class geometry(TUIMethod):
            """
            Geometry menu.
            """
        class methods(TUIMethod):
            """
            Menu to configure adjoint solver settings.
            """
        class monitors(TUIMethod):
            """
            Menu to configure monitors for the adjoint solver.
            """
        class morphing(TUIMethod):
            """
            Morphing menu.
            """
        class multi_objective(TUIMethod):
            """
            Multi-Objective menu.
            """
        class observable(TUIMethod):
            """
            Menu to create and configure observables of interest.
            """
        class optimizer(TUIMethod):
            """
            Enters the optimizer menu, where you can use a gradient-based optimizer to optimize the geometry to meet multiple goals for multiple observables at multiple operating conditions.
            """
        class postprocess_options(TUIMethod):
            """
            Postprocess options.
            """
        class reporting(TUIMethod):
            """
            Menu to report sensitivity data from the adjoint solution.
            """
        class run(TUIMethod):
            """
            Menu to initialize and compute the adjoint solution.
            """
        class utilities(TUIMethod):
            """
            Enters the utilities menu.
            """

    class define(TUIMenu):
        """
        Enter the define menu.
        """
        def __init__(self, service, version, mode, path):
            self.boundary_conditions = self.__class__.boundary_conditions(service, version, mode, path + ["boundary_conditions"])
            self.curvilinear_coordinate_system = self.__class__.curvilinear_coordinate_system(service, version, mode, path + ["curvilinear_coordinate_system"])
            self.custom_field_functions = self.__class__.custom_field_functions(service, version, mode, path + ["custom_field_functions"])
            self.dynamic_mesh = self.__class__.dynamic_mesh(service, version, mode, path + ["dynamic_mesh"])
            self.gap_model = self.__class__.gap_model(service, version, mode, path + ["gap_model"])
            self.materials = self.__class__.materials(service, version, mode, path + ["materials"])
            self.mesh_interfaces = self.__class__.mesh_interfaces(service, version, mode, path + ["mesh_interfaces"])
            self.mixing_planes = self.__class__.mixing_planes(service, version, mode, path + ["mixing_planes"])
            self.models = self.__class__.models(service, version, mode, path + ["models"])
            self.motion_definitions = self.__class__.motion_definitions(service, version, mode, path + ["motion_definitions"])
            self.named_expressions = self.__class__.named_expressions(service, version, mode, path + ["named_expressions"])
            self.operating_conditions = self.__class__.operating_conditions(service, version, mode, path + ["operating_conditions"])
            self.overset_interfaces = self.__class__.overset_interfaces(service, version, mode, path + ["overset_interfaces"])
            self.parameters = self.__class__.parameters(service, version, mode, path + ["parameters"])
            self.periodic_conditions = self.__class__.periodic_conditions(service, version, mode, path + ["periodic_conditions"])
            self.phases = self.__class__.phases(service, version, mode, path + ["phases"])
            self.profiles = self.__class__.profiles(service, version, mode, path + ["profiles"])
            self.reference_frames = self.__class__.reference_frames(service, version, mode, path + ["reference_frames"])
            self.solution_strategy = self.__class__.solution_strategy(service, version, mode, path + ["solution_strategy"])
            self.spectral = self.__class__.spectral(service, version, mode, path + ["spectral"])
            self.turbo_model = self.__class__.turbo_model(service, version, mode, path + ["turbo_model"])
            self.user_defined = self.__class__.user_defined(service, version, mode, path + ["user_defined"])
            self.virtual_boundary = self.__class__.virtual_boundary(service, version, mode, path + ["virtual_boundary"])
            self.beta_feature_access = self.__class__.beta_feature_access(service, version, mode, path + ["beta_feature_access"])
            self.enable_expressions = self.__class__.enable_expressions(service, version, mode, path + ["enable_expressions"])
            self.enable_mesh_morpher_optimizer = self.__class__.enable_mesh_morpher_optimizer(service, version, mode, path + ["enable_mesh_morpher_optimizer"])
            self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
            self.injections = self.__class__.injections(service, version, mode, path + ["injections"])
            self.physics = self.__class__.physics(service, version, mode, path + ["physics"])
            self.set_unit_system = self.__class__.set_unit_system(service, version, mode, path + ["set_unit_system"])
            self.units = self.__class__.units(service, version, mode, path + ["units"])
            super().__init__(service, version, mode, path)
        class boundary_conditions(TUIMethod):
            """
            Enter the boundary conditions menu.
            """
        class beta_feature_access(TUIMethod):
            """
            Enable access to beta features in the interface.
            """
        class enable_expressions(TUIMethod):
            """
            Enable the expressions feature.
            """
        class enable_mesh_morpher_optimizer(TUIMethod):
            """
            Enables the mesh morpher/optimizer. When the mesh morpher/optimizer is enabled, the define/mesh-morpher-optimizer text command becomes available.
            """
        class geometry(TUIMethod):
            """
            Enter Geometry menu.
            """
        class injections(TUIMethod):
            """
            Enters the injections menu.  For a description of the items in this menu, see define/models/dpm/injections.
            """
        class physics(TUIMethod):
            """
            Manage Physics-regions.
            """
        class set_unit_system(TUIMethod):
            """
            Applies a standard set of units to all quantities. The options include default,si, british, andcgs.
            """
        class units(TUIMethod):
            """
            Sets unit conversion factors.
            """

        class curvilinear_coordinate_system(TUIMenu):
            """
            Curvilinear Coordinate System.
            """
            def __init__(self, service, version, mode, path):
                self.calculation_settings = self.__class__.calculation_settings(service, version, mode, path + ["calculation_settings"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                self.display_settings = self.__class__.display_settings(service, version, mode, path + ["display_settings"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.new = self.__class__.new(service, version, mode, path + ["new"])
                super().__init__(service, version, mode, path)
            class calculation_settings(TUIMethod):
                """
                Define Settings for curvilinear coordinate system.
                """
            class delete(TUIMethod):
                """
                Delete Curvilinear Coordinate System.
                """
            class display(TUIMethod):
                """
                Display Curvilinear Coordinate System.
                """
            class display_settings(TUIMethod):
                """
                Display settings for Curvilinear Coordinate System.
                """
            class edit(TUIMethod):
                """
                Edit an existing curvilinear coordinate system.
                """
            class new(TUIMethod):
                """
                Define a new curvilinear coordinate system.
                """

        class custom_field_functions(TUIMenu):
            """
            Enters the custom field functions menu.
            """
            def __init__(self, service, version, mode, path):
                self.define = self.__class__.define(service, version, mode, path + ["define"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.example_cff_definitions = self.__class__.example_cff_definitions(service, version, mode, path + ["example_cff_definitions"])
                self.list_valid_cell_function_names = self.__class__.list_valid_cell_function_names(service, version, mode, path + ["list_valid_cell_function_names"])
                self.load = self.__class__.load(service, version, mode, path + ["load"])
                self.save = self.__class__.save(service, version, mode, path + ["save"])
                super().__init__(service, version, mode, path)
            class define(TUIMethod):
                """
                Defines a custom field function.
                """
            class delete(TUIMethod):
                """
                Deletes a custom field function.
                """
            class example_cff_definitions(TUIMethod):
                """
                Lists example custom field functions.
                """
            class list_valid_cell_function_names(TUIMethod):
                """
                Lists the names of cell functions that can be used in a custom field function.
                """
            class load(TUIMethod):
                """
                Loads a custom field function.
                """
            class save(TUIMethod):
                """
                Saves a custom field function.
                """

        class dynamic_mesh(TUIMenu):
            """
            Enters the dynamic mesh menu.
            """
            def __init__(self, service, version, mode, path):
                self.actions = self.__class__.actions(service, version, mode, path + ["actions"])
                self.controls = self.__class__.controls(service, version, mode, path + ["controls"])
                self.events = self.__class__.events(service, version, mode, path + ["events"])
                self.transient_settings = self.__class__.transient_settings(service, version, mode, path + ["transient_settings"])
                self.zones = self.__class__.zones(service, version, mode, path + ["zones"])
                self.dynamic_mesh = self.__class__.dynamic_mesh(service, version, mode, path + ["dynamic_mesh"])
                super().__init__(service, version, mode, path)
            class dynamic_mesh(TUIMethod):
                """
                Enables/disables the dynamic mesh solver.
                """

            class actions(TUIMenu):
                """
                Enters the dynamic mesh action menu, where you can initiate manual remeshing (that is, remeshing without running a calculation).
                """
                def __init__(self, service, version, mode, path):
                    self.remesh_cell_zone = self.__class__.remesh_cell_zone(service, version, mode, path + ["remesh_cell_zone"])
                    super().__init__(service, version, mode, path)
                class remesh_cell_zone(TUIMethod):
                    """
                    Manually remeshes a cell zone with option to remesh adjacent dynamic face 	zones.
                    """

            class controls(TUIMenu):
                """
                Enters the dynamic mesh controls menu. This text command is only available when the define/dynamic-mesh/dynamic-mesh? text command is enabled.
                """
                def __init__(self, service, version, mode, path):
                    self.contact_parameters = self.__class__.contact_parameters(service, version, mode, path + ["contact_parameters"])
                    self.implicit_update_parameters = self.__class__.implicit_update_parameters(service, version, mode, path + ["implicit_update_parameters"])
                    self.in_cylinder_parameters = self.__class__.in_cylinder_parameters(service, version, mode, path + ["in_cylinder_parameters"])
                    self.layering_parameters = self.__class__.layering_parameters(service, version, mode, path + ["layering_parameters"])
                    self.periodic_displacement_parameters = self.__class__.periodic_displacement_parameters(service, version, mode, path + ["periodic_displacement_parameters"])
                    self.remeshing_parameters = self.__class__.remeshing_parameters(service, version, mode, path + ["remeshing_parameters"])
                    self.six_dof_parameters = self.__class__.six_dof_parameters(service, version, mode, path + ["six_dof_parameters"])
                    self.smoothing_parameters = self.__class__.smoothing_parameters(service, version, mode, path + ["smoothing_parameters"])
                    self.in_cylinder_output = self.__class__.in_cylinder_output(service, version, mode, path + ["in_cylinder_output"])
                    self.layering = self.__class__.layering(service, version, mode, path + ["layering"])
                    self.remeshing = self.__class__.remeshing(service, version, mode, path + ["remeshing"])
                    self.smoothing = self.__class__.smoothing(service, version, mode, path + ["smoothing"])
                    self.steady_pseudo_time_control = self.__class__.steady_pseudo_time_control(service, version, mode, path + ["steady_pseudo_time_control"])
                    super().__init__(service, version, mode, path)
                class in_cylinder_output(TUIMethod):
                    """
                    Enables/disables in-cylinder output.
                    """
                class layering(TUIMethod):
                    """
                    Enables/disables dynamic-layering in quad/hex cell zones.
                    """
                class remeshing(TUIMethod):
                    """
                    Enables/disables local remeshing in tri/tet and mixed cell zones.
                    """
                class smoothing(TUIMethod):
                    """
                    Enables/disables smoothing in cell zones.
                    """
                class steady_pseudo_time_control(TUIMethod):
                    """
                    Enables/disables the pseudo time step control in the 	graphical user interface.
                    """

                class contact_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh contact-parameters menu. This text command is only available 	when you enable contact detection using the prompts of 	the define/dynamic-mesh/dynamic-mesh? 	text command.
                    """
                    def __init__(self, service, version, mode, path):
                        self.flow_control_parameters = self.__class__.flow_control_parameters(service, version, mode, path + ["flow_control_parameters"])
                        self.contact_face_zones = self.__class__.contact_face_zones(service, version, mode, path + ["contact_face_zones"])
                        self.contact_method = self.__class__.contact_method(service, version, mode, path + ["contact_method"])
                        self.contact_threshold = self.__class__.contact_threshold(service, version, mode, path + ["contact_threshold"])
                        self.contact_udf = self.__class__.contact_udf(service, version, mode, path + ["contact_udf"])
                        self.flow_control = self.__class__.flow_control(service, version, mode, path + ["flow_control"])
                        self.render_contact_cells = self.__class__.render_contact_cells(service, version, mode, path + ["render_contact_cells"])
                        self.update_contact_marks = self.__class__.update_contact_marks(service, version, mode, path + ["update_contact_marks"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        super().__init__(service, version, mode, path)
                    class contact_face_zones(TUIMethod):
                        """
                        Selects face zones involved in contact detection.
                        """
                    class contact_method(TUIMethod):
                        """
                        Selects the method used for flow control in the contact region. Enter 0 for the contact zones method (which restricts the flow using additional cell zones with porous zone properties) or 1 for the contact marks method (which blocks the flow using zero-mass-flux boundaries).
                        """
                    class contact_threshold(TUIMethod):
                        """
                        Specifies threshold distance for contact detection.
                        """
                    class contact_udf(TUIMethod):
                        """
                        Selects the UDF to be invoked when contact is detected.
                        """
                    class flow_control(TUIMethod):
                        """
                        Enables/disables flow control in the contact region.
                        """
                    class render_contact_cells(TUIMethod):
                        """
                        Enables/disables the availability of a field variable (contact-cell-mark) that can be used to display contours of cells marked for flow blocking as part of the contact marks method, and allows you to postprocess other field variables on those cells.
                        """
                    class update_contact_marks(TUIMethod):
                        """
                        Updates which cells are marked in order to block flow in the contact region as part of the contact marks method.
                        """
                    class verbosity(TUIMethod):
                        """
                        Sets the level of detail printed in the console regarding contact detection.
                        """

                    class flow_control_parameters(TUIMenu):
                        """
                        Enters the flow control parameters menu, which provides settings related to controlling the flow in the contact region.
                        """
                        def __init__(self, service, version, mode, path):
                            self.create_flow_control_zone = self.__class__.create_flow_control_zone(service, version, mode, path + ["create_flow_control_zone"])
                            self.delete_flow_control_zone = self.__class__.delete_flow_control_zone(service, version, mode, path + ["delete_flow_control_zone"])
                            self.solution_stabilization = self.__class__.solution_stabilization(service, version, mode, path + ["solution_stabilization"])
                            super().__init__(service, version, mode, path)
                        class create_flow_control_zone(TUIMethod):
                            """
                            Creates a flow control zone as part of the contact zones method.
                            """
                        class delete_flow_control_zone(TUIMethod):
                            """
                            Deletes a flow control zone as part of the contact zones method.
                            """
                        class solution_stabilization(TUIMethod):
                            """
                            Enables/disables the performance of additional iterations per time step and the application of solution controls to improve the stability of the solver as part of the contact marks method.
                            """

                class implicit_update_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh implicit update menu. This text command is only available 	when you enable implicit mesh updating using the prompts 	of the define/dynamic-mesh/dynamic-mesh? 	text command.
                    """
                    def __init__(self, service, version, mode, path):
                        self.motion_relaxation = self.__class__.motion_relaxation(service, version, mode, path + ["motion_relaxation"])
                        self.residual_criteria = self.__class__.residual_criteria(service, version, mode, path + ["residual_criteria"])
                        self.update_interval = self.__class__.update_interval(service, version, mode, path + ["update_interval"])
                        super().__init__(service, version, mode, path)
                    class motion_relaxation(TUIMethod):
                        """
                        Specifies a value (within the range of 0 to 1) for the motion relaxation, which is applied during the implicit mesh update.
                        """
                    class residual_criteria(TUIMethod):
                        """
                        Specifies the relative residual threshold that is used to check the motion convergence during the implicit mesh update.
                        """
                    class update_interval(TUIMethod):
                        """
                        Specifies the update interval (that is, the frequency in iterations) at which the mesh is updated within a time step.
                        """

                class in_cylinder_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh in-cylinder menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.crank_angle_step = self.__class__.crank_angle_step(service, version, mode, path + ["crank_angle_step"])
                        self.crank_period = self.__class__.crank_period(service, version, mode, path + ["crank_period"])
                        self.max_crank_angle_step = self.__class__.max_crank_angle_step(service, version, mode, path + ["max_crank_angle_step"])
                        self.minimum_lift = self.__class__.minimum_lift(service, version, mode, path + ["minimum_lift"])
                        self.modify_lift = self.__class__.modify_lift(service, version, mode, path + ["modify_lift"])
                        self.piston_data = self.__class__.piston_data(service, version, mode, path + ["piston_data"])
                        self.piston_stroke_cutoff = self.__class__.piston_stroke_cutoff(service, version, mode, path + ["piston_stroke_cutoff"])
                        self.position_starting_mesh = self.__class__.position_starting_mesh(service, version, mode, path + ["position_starting_mesh"])
                        self.print_plot_lift = self.__class__.print_plot_lift(service, version, mode, path + ["print_plot_lift"])
                        self.starting_crank_angle = self.__class__.starting_crank_angle(service, version, mode, path + ["starting_crank_angle"])
                        super().__init__(service, version, mode, path)
                    class crank_angle_step(TUIMethod):
                        """
                        Specifies crank angle step size.
                        """
                    class crank_period(TUIMethod):
                        """
                        Specifies the crank period.
                        """
                    class max_crank_angle_step(TUIMethod):
                        """
                        Specifies maximum crank angle step size.
                        """
                    class minimum_lift(TUIMethod):
                        """
                        Specifies minimum lift for in-cylinder valves.
                        """
                    class modify_lift(TUIMethod):
                        """
                        Modifies lift curve (shift or scale).
                        """
                    class piston_data(TUIMethod):
                        """
                        Specifies the crank radius and connecting rod length.
                        """
                    class piston_stroke_cutoff(TUIMethod):
                        """
                        Specifies the cut off point for in-cylinder piston.
                        """
                    class position_starting_mesh(TUIMethod):
                        """
                        Moves mesh from top dead center to starting crank angle.
                        """
                    class print_plot_lift(TUIMethod):
                        """
                        Prints or plot valve lift curve.
                        """
                    class starting_crank_angle(TUIMethod):
                        """
                        Specifies the initial value for the crank angle.
                        """

                class layering_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh layering menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.collapse_factor = self.__class__.collapse_factor(service, version, mode, path + ["collapse_factor"])
                        self.constant_height = self.__class__.constant_height(service, version, mode, path + ["constant_height"])
                        self.split_factor = self.__class__.split_factor(service, version, mode, path + ["split_factor"])
                        super().__init__(service, version, mode, path)
                    class collapse_factor(TUIMethod):
                        """
                        Sets the factor determining when to collapse dynamic layers.
                        """
                    class constant_height(TUIMethod):
                        """
                        Enables/disables layering based on constant height, else layering based on constant ratio.
                        """
                    class split_factor(TUIMethod):
                        """
                        Sets the factor determining when to split dynamic layers.
                        """

                class periodic_displacement_parameters(TUIMenu):
                    """
                    Enters the periodic displacement parameters 	menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.copy_displacement = self.__class__.copy_displacement(service, version, mode, path + ["copy_displacement"])
                        self.create_displacement = self.__class__.create_displacement(service, version, mode, path + ["create_displacement"])
                        self.create_group = self.__class__.create_group(service, version, mode, path + ["create_group"])
                        self.delete_all_displacements = self.__class__.delete_all_displacements(service, version, mode, path + ["delete_all_displacements"])
                        self.delete_all_groups = self.__class__.delete_all_groups(service, version, mode, path + ["delete_all_groups"])
                        self.delete_displacement = self.__class__.delete_displacement(service, version, mode, path + ["delete_displacement"])
                        self.delete_group = self.__class__.delete_group(service, version, mode, path + ["delete_group"])
                        self.edit_displacement = self.__class__.edit_displacement(service, version, mode, path + ["edit_displacement"])
                        self.edit_group = self.__class__.edit_group(service, version, mode, path + ["edit_group"])
                        self.list_displacements = self.__class__.list_displacements(service, version, mode, path + ["list_displacements"])
                        self.list_groups = self.__class__.list_groups(service, version, mode, path + ["list_groups"])
                        self.set_active_displacement = self.__class__.set_active_displacement(service, version, mode, path + ["set_active_displacement"])
                        super().__init__(service, version, mode, path)
                    class copy_displacement(TUIMethod):
                        """
                        Copy Periodic Displacement.
                        """
                    class create_displacement(TUIMethod):
                        """
                        Create Periodic Displacement.
                        """
                    class create_group(TUIMethod):
                        """
                        Create Periodic Displacement Group.
                        """
                    class delete_all_displacements(TUIMethod):
                        """
                        Delete All Periodic Displacements.
                        """
                    class delete_all_groups(TUIMethod):
                        """
                        Delete All Periodic Displacement Groups.
                        """
                    class delete_displacement(TUIMethod):
                        """
                        Delete Periodic Displacement.
                        """
                    class delete_group(TUIMethod):
                        """
                        Delete Periodic Displacement Group.
                        """
                    class edit_displacement(TUIMethod):
                        """
                        Edit Periodic Displacement.
                        """
                    class edit_group(TUIMethod):
                        """
                        Edit Periodic Displacement Group.
                        """
                    class list_displacements(TUIMethod):
                        """
                        List Periodic Displacements.
                        """
                    class list_groups(TUIMethod):
                        """
                        List Periodic Displacement Groups.
                        """
                    class set_active_displacement(TUIMethod):
                        """
                        Set Active Periodic Displacement in Group.
                        """

                class remeshing_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh remeshing menu to set 	parameters for all remeshing methods.
                    """
                    def __init__(self, service, version, mode, path):
                        self.prism_controls = self.__class__.prism_controls(service, version, mode, path + ["prism_controls"])
                        self.prism_layer_parameters = self.__class__.prism_layer_parameters(service, version, mode, path + ["prism_layer_parameters"])
                        self.sizing_controls = self.__class__.sizing_controls(service, version, mode, path + ["sizing_controls"])
                        self.cell_skew_max = self.__class__.cell_skew_max(service, version, mode, path + ["cell_skew_max"])
                        self.face_skew_max = self.__class__.face_skew_max(service, version, mode, path + ["face_skew_max"])
                        self.length_max = self.__class__.length_max(service, version, mode, path + ["length_max"])
                        self.length_min = self.__class__.length_min(service, version, mode, path + ["length_min"])
                        self.parallel_remeshing = self.__class__.parallel_remeshing(service, version, mode, path + ["parallel_remeshing"])
                        self.poly_remeshing = self.__class__.poly_remeshing(service, version, mode, path + ["poly_remeshing"])
                        self.remeshing_after_moving = self.__class__.remeshing_after_moving(service, version, mode, path + ["remeshing_after_moving"])
                        self.remeshing_methods = self.__class__.remeshing_methods(service, version, mode, path + ["remeshing_methods"])
                        self.retain_size_distribution = self.__class__.retain_size_distribution(service, version, mode, path + ["retain_size_distribution"])
                        self.size_remesh_interval = self.__class__.size_remesh_interval(service, version, mode, path + ["size_remesh_interval"])
                        self.sizing_funct_defaults = self.__class__.sizing_funct_defaults(service, version, mode, path + ["sizing_funct_defaults"])
                        self.sizing_funct_rate = self.__class__.sizing_funct_rate(service, version, mode, path + ["sizing_funct_rate"])
                        self.sizing_funct_resolution = self.__class__.sizing_funct_resolution(service, version, mode, path + ["sizing_funct_resolution"])
                        self.sizing_funct_variation = self.__class__.sizing_funct_variation(service, version, mode, path + ["sizing_funct_variation"])
                        self.sizing_function = self.__class__.sizing_function(service, version, mode, path + ["sizing_function"])
                        self.unified_remeshing = self.__class__.unified_remeshing(service, version, mode, path + ["unified_remeshing"])
                        self.zone_remeshing = self.__class__.zone_remeshing(service, version, mode, path + ["zone_remeshing"])
                        super().__init__(service, version, mode, path)
                    class cell_skew_max(TUIMethod):
                        """
                        Sets the cell skewness threshold above which cells will be remeshed.
                        """
                    class face_skew_max(TUIMethod):
                        """
                        Sets the face skewness threshold above which faces will be remeshed.
                        """
                    class length_max(TUIMethod):
                        """
                        Sets the length threshold above which cells will be remeshed.
                        """
                    class length_min(TUIMethod):
                        """
                        Sets the length threshold below which cells will be remeshed.
                        """
                    class parallel_remeshing(TUIMethod):
                        """
                        Disables/enables parallel remeshing as part of methods-based remeshing..
                        """
                    class poly_remeshing(TUIMethod):
                        """
                        Enable/disable poly remeshing.
                        """
                    class remeshing_after_moving(TUIMethod):
                        """
                        Enables a second round of remeshing based on the skewness parameters after the boundary has moved as part of methods-based remeshing.
                        """
                    class remeshing_methods(TUIMethod):
                        """
                        Enables/disables individual remeshing options as part of methods-based remeshing.
                        """
                    class retain_size_distribution(TUIMethod):
                        """
                        Enables/disables the use of local size criteria when marking cells for unified remeshing (in an attempt to maintain the initial mesh size distribution even as the mesh moves), rather than marking cells based on the minimum and maximum length scale values of the cell zone in the initial mesh. Either marking can be overridden if more restrictive values are specified using the define/dynamic-mesh/controls/remeshing-parameters/length-min and define/dynamic-mesh/controls/remeshing-parameters/length-max text commands.
                        """
                    class size_remesh_interval(TUIMethod):
                        """
                        Sets the interval (in time steps) when remeshing based on size is done for methods-based remeshing.
                        """
                    class sizing_funct_defaults(TUIMethod):
                        """
                        Sets sizing function defaults.
                        """
                    class sizing_funct_rate(TUIMethod):
                        """
                        Determines how far from the boundary the increase/decrease happens.
                        """
                    class sizing_funct_resolution(TUIMethod):
                        """
                        Sets the sizing function resolution with respect to shortest boundary.
                        """
                    class sizing_funct_variation(TUIMethod):
                        """
                        Sets the maximum sizing function increase/decrease in the interior.
                        """
                    class sizing_function(TUIMethod):
                        """
                        Enables/disables the sizing function as part of methods-based remeshing.
                        """
                    class unified_remeshing(TUIMethod):
                        """
                        Enables/disables unified remeshing, which specifies that an algorithm is used that combines aspects of a variety of remeshing methods. It is applied to triangular or tetrahedral cells and can produce wedge cells in 3D boundary layer meshes. Unified remeshing simplifies the remeshing setup and can provide increased robustness compared to methods-based remeshing, especially for parallel simulations.
                        """
                    class zone_remeshing(TUIMethod):
                        """
                        Enables/disables the cell zone remeshing method as part of methods-based remeshing.
                        """

                    class prism_controls(TUIMenu):
                        """
                        Enters the dynamic mesh prism controls menu, which provides text commands that can be useful when you want to modify the algorithm that attempts to retain the size distribution during unified remeshing. Each prism control definition is applied to one or more boundary zones, and then affects the height distribution and number of layers of the wedge cells in the adjacent boundary layers.
                        """
                        def __init__(self, service, version, mode, path):
                            self.add = self.__class__.add(service, version, mode, path + ["add"])
                            self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                            self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                            self.list = self.__class__.list(service, version, mode, path + ["list"])
                            self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                            super().__init__(service, version, mode, path)
                        class add(TUIMethod):
                            """
                            Adds a new prism controls definition.   After being prompted for a name, you can enter the following to complete the definition:
                            first-height  Sets the height of the first layer of wedge cells in the boundary layer adjacent to the specified zones.
                            growth-method  Specifies the method used to determine the increase in height of the wedge cell layers beyond the first layer. The only available option is geometric, so that the height of each layer is the height of the previous layer multiplied by the rate.
                            name  Specifies the name of the prism controls definition.
                            nlayers  Sets the number of layers of wedge cells in the boundary layer adjacent to the specified zones.
                            rate  Sets the coefficient for the growth-method used to determine the increase in height of the wedge cell layers beyond the first layer.
                            zones  Specifies all of the boundary zones on which this prism controls definition is applied.
                            Enter q when the definition is complete to return to the text command menu.
                            """
                        class delete(TUIMethod):
                            """
                            Deletes an existing prism controls definition.
                            """
                        class edit(TUIMethod):
                            """
                            Edits an existing prism controls definition. You can revise the fields listed previously for the define/dynamic-mesh/controls/remeshing-parameters/prism-controls/add text command.
                            """
                        class list(TUIMethod):
                            """
                            Prints a list of the existing prism controls definitions in the console.
                            """
                        class list_properties(TUIMethod):
                            """
                            Prints the properties of an existing prism controls definition of your choice in the console.
                            """

                    class prism_layer_parameters(TUIMenu):
                        """
                        Enters the dynamic mesh prism layer parameters menu, where you can define the parameters of the prism layers as part of methods-based remeshing.
                        """
                        def __init__(self, service, version, mode, path):
                            self.first_height = self.__class__.first_height(service, version, mode, path + ["first_height"])
                            self.growth_rate = self.__class__.growth_rate(service, version, mode, path + ["growth_rate"])
                            self.number_of_layers = self.__class__.number_of_layers(service, version, mode, path + ["number_of_layers"])
                            super().__init__(service, version, mode, path)
                        class first_height(TUIMethod):
                            """
                            Sets the first cell height in the prism layer.
                            """
                        class growth_rate(TUIMethod):
                            """
                            Sets the geometric growth rate of the prism layer.
                            """
                        class number_of_layers(TUIMethod):
                            """
                            Sets the number of elements in the prism layer.
                            """

                    class sizing_controls(TUIMenu):
                        """
                        Enters the dynamic mesh sizing controls menu, which provides text commands that can be useful when you want to modify the algorithm that attempts to retain the size distribution during unified remeshing. Each sizing control definition is applied to one or more boundary zones, and then affects the size of the cells throughout the mesh based on their distance from those boundary zone(s) and your settings in the definition.
                        """
                        def __init__(self, service, version, mode, path):
                            self.add = self.__class__.add(service, version, mode, path + ["add"])
                            self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                            self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                            self.list = self.__class__.list(service, version, mode, path + ["list"])
                            self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                            super().__init__(service, version, mode, path)
                        class add(TUIMethod):
                            """
                            Adds a new sizing controls definition.   After being prompted for a name, you can enter the following to complete the definition:
                            growth-rate  Sets the growth rate of the sizing controls definition.
                            max-length  Sets a maximum length threshold that is used when the type is set to auto or soft.
                            min-length  Sets a maximum length threshold that is used when the type is set to auto.
                            motion  Determines whether the size control definition affects the remeshing based on whether the mesh undergoes motion: auto specifies that it is applied whether or not there is motion; and static specifies that it is only applied if there is no motion.
                            name  Specifies the name of the sizing controls definition.
                            type  Specifies how the sizing is affected by the selected boundary zones: auto specifies that the default size distribution (rather than the initial size distribution in your selected boundary zones) is used, along with your specified max-length and min-length values; soft specifies that the maximum length scale of your selected boundary zones is used, along with your specified min-length value; and meshed specifies that the maximum and minimum length scales of your selected boundary zones are used, in order to respect their initial size distribution. This setting is only relevant if you have more than one sizing controls definition.
                            zones  Specifies all of the boundary zones on which the sizing controls definition is applied.
                            Enter q when the definition is complete to return to the text command menu.
                            """
                        class delete(TUIMethod):
                            """
                            Deletes an existing sizing controls definition.
                            """
                        class edit(TUIMethod):
                            """
                            Edits an existing sizing controls definition. You can revise the fields listed previously for the define/dynamic-mesh/controls/remeshing-parameters/sizing-controls/add text command.
                            """
                        class list(TUIMethod):
                            """
                            Prints a list of the existing sizing controls definitions in the console.
                            """
                        class list_properties(TUIMethod):
                            """
                            Prints the properties of an existing sizing controls definition of your choice in the console.
                            """

                class six_dof_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh six degrees of freedom (DOF) solver menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.create_properties = self.__class__.create_properties(service, version, mode, path + ["create_properties"])
                        self.delete_properties = self.__class__.delete_properties(service, version, mode, path + ["delete_properties"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.motion_history = self.__class__.motion_history(service, version, mode, path + ["motion_history"])
                        self.motion_history_file_name = self.__class__.motion_history_file_name(service, version, mode, path + ["motion_history_file_name"])
                        self.second_order = self.__class__.second_order(service, version, mode, path + ["second_order"])
                        self.x_component_of_gravity = self.__class__.x_component_of_gravity(service, version, mode, path + ["x_component_of_gravity"])
                        self.y_component_of_gravity = self.__class__.y_component_of_gravity(service, version, mode, path + ["y_component_of_gravity"])
                        self.z_component_of_gravity = self.__class__.z_component_of_gravity(service, version, mode, path + ["z_component_of_gravity"])
                        super().__init__(service, version, mode, path)
                    class create_properties(TUIMethod):
                        """
                        Creates/edits a set of six DOF properties for rigid body motion.
                        """
                    class delete_properties(TUIMethod):
                        """
                        Deletes a set of six DOF properties for rigid body motion.
                        """
                    class list_properties(TUIMethod):
                        """
                        Prints summaries of the existing sets of six DOF properties for rigid body motion.
                        """
                    class motion_history(TUIMethod):
                        """
                        Enables/disables writing position/orientation of six DOF zones to file.
                        """
                    class motion_history_file_name(TUIMethod):
                        """
                        Specifies the name and location of the six DOF motion history file.
                        """
                    class second_order(TUIMethod):
                        """
                        Enables/disables the second order six degrees of freedom solver.
                        """
                    class x_component_of_gravity(TUIMethod):
                        """
                        Specifies x-component of gravity.
                        """
                    class y_component_of_gravity(TUIMethod):
                        """
                        Specifies y-component of gravity.
                        """
                    class z_component_of_gravity(TUIMethod):
                        """
                        Specifies z-component of gravity.
                        """

                class smoothing_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh smoothing-parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.amg_stabilization = self.__class__.amg_stabilization(service, version, mode, path + ["amg_stabilization"])
                        self.bnd_node_relaxation = self.__class__.bnd_node_relaxation(service, version, mode, path + ["bnd_node_relaxation"])
                        self.bnd_stiffness_factor = self.__class__.bnd_stiffness_factor(service, version, mode, path + ["bnd_stiffness_factor"])
                        self.boundary_distance_method = self.__class__.boundary_distance_method(service, version, mode, path + ["boundary_distance_method"])
                        self.constant_factor = self.__class__.constant_factor(service, version, mode, path + ["constant_factor"])
                        self.convergence_tolerance = self.__class__.convergence_tolerance(service, version, mode, path + ["convergence_tolerance"])
                        self.diffusion_coeff_function = self.__class__.diffusion_coeff_function(service, version, mode, path + ["diffusion_coeff_function"])
                        self.diffusion_coeff_parameter = self.__class__.diffusion_coeff_parameter(service, version, mode, path + ["diffusion_coeff_parameter"])
                        self.diffusion_fvm = self.__class__.diffusion_fvm(service, version, mode, path + ["diffusion_fvm"])
                        self.laplace_node_relaxation = self.__class__.laplace_node_relaxation(service, version, mode, path + ["laplace_node_relaxation"])
                        self.local_smoothing = self.__class__.local_smoothing(service, version, mode, path + ["local_smoothing"])
                        self.max_iter = self.__class__.max_iter(service, version, mode, path + ["max_iter"])
                        self.number_local_layers = self.__class__.number_local_layers(service, version, mode, path + ["number_local_layers"])
                        self.poisson_ratio = self.__class__.poisson_ratio(service, version, mode, path + ["poisson_ratio"])
                        self.relative_convergence_tolerance = self.__class__.relative_convergence_tolerance(service, version, mode, path + ["relative_convergence_tolerance"])
                        self.skew_smooth_all_deforming_boundaries = self.__class__.skew_smooth_all_deforming_boundaries(service, version, mode, path + ["skew_smooth_all_deforming_boundaries"])
                        self.skew_smooth_cell_skew_max = self.__class__.skew_smooth_cell_skew_max(service, version, mode, path + ["skew_smooth_cell_skew_max"])
                        self.skew_smooth_face_skew_max = self.__class__.skew_smooth_face_skew_max(service, version, mode, path + ["skew_smooth_face_skew_max"])
                        self.skew_smooth_niter = self.__class__.skew_smooth_niter(service, version, mode, path + ["skew_smooth_niter"])
                        self.smooth_boundary_layers_with_adjacent_zone = self.__class__.smooth_boundary_layers_with_adjacent_zone(service, version, mode, path + ["smooth_boundary_layers_with_adjacent_zone"])
                        self.smooth_from_reference_position = self.__class__.smooth_from_reference_position(service, version, mode, path + ["smooth_from_reference_position"])
                        self.smoothing_method = self.__class__.smoothing_method(service, version, mode, path + ["smoothing_method"])
                        self.spring_on_all_elements = self.__class__.spring_on_all_elements(service, version, mode, path + ["spring_on_all_elements"])
                        self.spring_on_simplex_elements = self.__class__.spring_on_simplex_elements(service, version, mode, path + ["spring_on_simplex_elements"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        super().__init__(service, version, mode, path)
                    class amg_stabilization(TUIMethod):
                        """
                        Set the AMG stabilization method for mesh smoothing (FEM).
                        """
                    class bnd_node_relaxation(TUIMethod):
                        """
                        The boundary node relaxation is used by spring smoothing. The boundary node relaxation allows you to relax the update of the node positions at deforming boundaries. A value of 0 prevents deforming boundary nodes from moving and a value of 1 indicates no under-relaxation.
                        """
                    class bnd_stiffness_factor(TUIMethod):
                        """
                        Sets the stiffness factor for springs connected to boundary nodes.
                        """
                    class boundary_distance_method(TUIMethod):
                        """
                        Sets the method used to evaluate the boundary distance for the diffusion coefficient calculation, when diffusion-based smoothing is enabled.
                        """
                    class constant_factor(TUIMethod):
                        """
                        Sets the spring constant relaxation factor.
                        """
                    class convergence_tolerance(TUIMethod):
                        """
                        Sets the convergence tolerance for spring-based solver.
                        """
                    class diffusion_coeff_function(TUIMethod):
                        """
                        Specifies whether the diffusion coefficient for diffusion-based smoothing is based on the boundary distance or the cell volume.
                        """
                    class diffusion_coeff_parameter(TUIMethod):
                        """
                        Sets the diffusion coefficient parameter used for diffusion-based smoothing.
                        """
                    class diffusion_fvm(TUIMethod):
                        """
                        Answering yes at the prompt changes the diffusion-based smoothing method to the cell-based finite volume approach that was the default in releases prior to Fluent 15.0. Answering no at the prompt changes the diffusion-based smoothing method to the default node-based finite element method.
                        """
                    class laplace_node_relaxation(TUIMethod):
                        """
                        Set the Laplace boundary node relaxation factor.
                        """
                    class local_smoothing(TUIMethod):
                        """
                        Enable local smoothing (Radial Basis Function).
                        """
                    class max_iter(TUIMethod):
                        """
                        Set the maximum number of iterations for spring-based solver.
                        """
                    class number_local_layers(TUIMethod):
                        """
                        Set number of layers for local smoothing (Radial Basis Function).
                        """
                    class poisson_ratio(TUIMethod):
                        """
                        Sets the Poissons ratio used for smoothing based on the linearly elastic solid model.
                        """
                    class relative_convergence_tolerance(TUIMethod):
                        """
                        Sets the relative residual convergence tolerance for smoothing based on diffusion or the linearly elastic solid model.
                        """
                    class skew_smooth_all_deforming_boundaries(TUIMethod):
                        """
                        Enables/disables skewness smoothing for all deforming dynamic boundary zones. This is enabled by default. If disabled, skewness smoothing is only applied to the deforming dynamic boundary zones that have smoothing explicitly enabled or use local face remeshing.
                        """
                    class skew_smooth_cell_skew_max(TUIMethod):
                        """
                        Sets the skewness threshold, above which cells will be smoothed using the skewness method.
                        """
                    class skew_smooth_face_skew_max(TUIMethod):
                        """
                        Sets the skewness threshold, above which faces will be smoothed using the skewness method.
                        """
                    class skew_smooth_niter(TUIMethod):
                        """
                        Sets the number of skewness-based smoothing cycles.
                        """
                    class smooth_boundary_layers_with_adjacent_zone(TUIMethod):
                        """
                        Enable smoothing of boundary layers solely on adjacent zone motion (Radial Basis Function).
                        """
                    class smooth_from_reference_position(TUIMethod):
                        """
                        Enables/disables smoothing from a reference position. Such smoothing may produce greater mesh quality consistency for stationary or moving meshes with periodic or quasi-periodic motion, and is only available when the smoothing method is based on diffusion or the linearly elastic solid model.
                        """
                    class smoothing_method(TUIMethod):
                        """
                        Specify the smoothing method used by the dynamic mesh model.
                        """
                    class spring_on_all_elements(TUIMethod):
                        """
                        Enables/disables spring-based smoothing for all cell shapes; if disabled, the spring-based smoothing is applied based on the setting of the define/dynamic-mesh/controls/smoothing-parameters/spring-on-simplex-shapes? text command.
                        """
                    class spring_on_simplex_elements(TUIMethod):
                        """
                        Enable/disable spring-based smoothing for tri/tet elements in mixed element zones.
                        """
                    class verbosity(TUIMethod):
                        """
                        Set the verbosity for spring smoothing.
                        """

            class events(TUIMenu):
                """
                Enters the dynamic mesh events menu.
                """
                def __init__(self, service, version, mode, path):
                    self.export_event_file = self.__class__.export_event_file(service, version, mode, path + ["export_event_file"])
                    self.import_event_file = self.__class__.import_event_file(service, version, mode, path + ["import_event_file"])
                    super().__init__(service, version, mode, path)
                class export_event_file(TUIMethod):
                    """
                    Exports dynamic mesh events to file.
                    """
                class import_event_file(TUIMethod):
                    """
                    Imports dynamic mesh event file.
                    """

            class transient_settings(TUIMenu):
                """
                Enters the transient dynamic mesh settings menu. This text command is only available when you enable dynamic mesh using the prompts of the define/dynamic-mesh/dynamic-mesh? text command. Solver time must also be set to Transient.
                """
                def __init__(self, service, version, mode, path):
                    self.allow_second_order = self.__class__.allow_second_order(service, version, mode, path + ["allow_second_order"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    super().__init__(service, version, mode, path)
                class allow_second_order(TUIMethod):
                    """
                    Enables/disables second order transient scheme for dynamic mesh cases.
                    """
                class verbosity(TUIMethod):
                    """
                    Enables/disables transient scheme verbosity for dynamic mesh cases.
                    """

            class zones(TUIMenu):
                """
                Enters the dynamic mesh zones menu.
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.insert_boundary_layer = self.__class__.insert_boundary_layer(service, version, mode, path + ["insert_boundary_layer"])
                    self.insert_interior_layer = self.__class__.insert_interior_layer(service, version, mode, path + ["insert_interior_layer"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.remove_boundary_layer = self.__class__.remove_boundary_layer(service, version, mode, path + ["remove_boundary_layer"])
                    self.remove_interior_layer = self.__class__.remove_interior_layer(service, version, mode, path + ["remove_interior_layer"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create dynamic zone.
                    """
                class delete(TUIMethod):
                    """
                    Deletes a dynamic zone.
                    """
                class insert_boundary_layer(TUIMethod):
                    """
                    Inserts a new cell zone.
                    """
                class insert_interior_layer(TUIMethod):
                    """
                    Inserts a new layer cell zone at a specified location.
                    """
                class list(TUIMethod):
                    """
                    Lists the dynamic zones.
                    """
                class remove_boundary_layer(TUIMethod):
                    """
                    Removes a cell zone.
                    """
                class remove_interior_layer(TUIMethod):
                    """
                    Removes an interior layer cell zone.
                    """

        class gap_model(TUIMenu):
            """
            Enters the gap model menu, where you can define one or more gap regions where the flow is blocked or decelerated when face zones move within a specified proximity threshold of each other.
            """
            def __init__(self, service, version, mode, path):
                self.advanced_options = self.__class__.advanced_options(service, version, mode, path + ["advanced_options"])
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                self.list_gap_cell_zones = self.__class__.list_gap_cell_zones(service, version, mode, path + ["list_gap_cell_zones"])
                self.list_gap_face_zones = self.__class__.list_gap_face_zones(service, version, mode, path + ["list_gap_face_zones"])
                self.list_gap_regions = self.__class__.list_gap_regions(service, version, mode, path + ["list_gap_regions"])
                self.render_gap_regions = self.__class__.render_gap_regions(service, version, mode, path + ["render_gap_regions"])
                super().__init__(service, version, mode, path)
            class create(TUIMethod):
                """
                Creates a single gap region, so that when selected face zones move within a specified proximity threshold of each other, flow blockage / deceleration is applied to the cells that lie within the threshold.
                """
            class delete(TUIMethod):
                """
                Deletes an existing gap region.
                """
            class delete_all(TUIMethod):
                """
                Deletes all of the existing gap regions.
                """
            class edit(TUIMethod):
                """
                Edits an existing gap region.
                """
            class enable(TUIMethod):
                """
                Enables/disables the gap model.
                """
            class list_gap_cell_zones(TUIMethod):
                """
                Lists the names of the cell zones that can be excluded for individual gap regions (so that such cells are not marked for flow blockage / deceleration).
                """
            class list_gap_face_zones(TUIMethod):
                """
                Lists the names of the face zones that can be used for creating gap regions.
                """
            class list_gap_regions(TUIMethod):
                """
                Lists the properties of the gap regions.
                """
            class render_gap_regions(TUIMethod):
                """
                Update gap regions for postprocessing.
                """

            class advanced_options(TUIMenu):
                """
                Enters the advanced options menu for the gap model.
                """
                def __init__(self, service, version, mode, path):
                    self.alternative_marking = self.__class__.alternative_marking(service, version, mode, path + ["alternative_marking"])
                    self.cell_check_distance_factor = self.__class__.cell_check_distance_factor(service, version, mode, path + ["cell_check_distance_factor"])
                    self.check_cfl_condition = self.__class__.check_cfl_condition(service, version, mode, path + ["check_cfl_condition"])
                    self.clear_gap_regions = self.__class__.clear_gap_regions(service, version, mode, path + ["clear_gap_regions"])
                    self.enhanced_data_interpolation = self.__class__.enhanced_data_interpolation(service, version, mode, path + ["enhanced_data_interpolation"])
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.extend_gap_regions = self.__class__.extend_gap_regions(service, version, mode, path + ["extend_gap_regions"])
                    self.fill_data_in_gap_regions = self.__class__.fill_data_in_gap_regions(service, version, mode, path + ["fill_data_in_gap_regions"])
                    self.flow_blocking_stabilization_parameters = self.__class__.flow_blocking_stabilization_parameters(service, version, mode, path + ["flow_blocking_stabilization_parameters"])
                    self.include_coupled_walls = self.__class__.include_coupled_walls(service, version, mode, path + ["include_coupled_walls"])
                    self.precise_gap_marking = self.__class__.precise_gap_marking(service, version, mode, path + ["precise_gap_marking"])
                    self.reduce_gap_regions = self.__class__.reduce_gap_regions(service, version, mode, path + ["reduce_gap_regions"])
                    self.render_flow_modeling_gaps = self.__class__.render_flow_modeling_gaps(service, version, mode, path + ["render_flow_modeling_gaps"])
                    self.render_gap_interface = self.__class__.render_gap_interface(service, version, mode, path + ["render_gap_interface"])
                    self.revert_controls_to_default = self.__class__.revert_controls_to_default(service, version, mode, path + ["revert_controls_to_default"])
                    self.solution_stabilization = self.__class__.solution_stabilization(service, version, mode, path + ["solution_stabilization"])
                    self.sponge_layer = self.__class__.sponge_layer(service, version, mode, path + ["sponge_layer"])
                    self.update_gap_regions = self.__class__.update_gap_regions(service, version, mode, path + ["update_gap_regions"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    super().__init__(service, version, mode, path)
                class alternative_marking(TUIMethod):
                    """
                    Mark gap regions using an alternative marking algorithm.
                    """
                class cell_check_distance_factor(TUIMethod):
                    """
                    Enter value of the cell distance factor.
                    """
                class check_cfl_condition(TUIMethod):
                    """
                    Enables/disables the printing of warnings if the time 	step size is too large based on a Courant (CFL) number 	automatically determined for your specified solution 	stability level.
                    """
                class clear_gap_regions(TUIMethod):
                    """
                    Clear gap model solution information and marks.
                    """
                class enhanced_data_interpolation(TUIMethod):
                    """
                    Enables/disables the use of enhanced data 	interpolation when updating information in gap regions. 	This text command is only available if you have enabled 	the 	define/gap-model/advanced-options/expert? 	text command.
                    """
                class expert(TUIMethod):
                    """
                    Enables/disables access to expert-level text commands 	for the gap model.
                    """
                class extend_gap_regions(TUIMethod):
                    """
                    Enables/disables the extending of the gap regions by including additional cells in 	the vicinity of the gap interfaces during marking. This 	is useful when the default shape of the marked cells is 	negatively affecting solution stability or convergence 	behavior.
                    """
                class fill_data_in_gap_regions(TUIMethod):
                    """
                    Enables/disables the interpolation of solution data throughout the gap regions. This 	text command is only available if you have enabled the 	define/gap-model/advanced-options/expert? 	text command.
                    """
                class flow_blocking_stabilization_parameters(TUIMethod):
                    """
                    Adjust stabilization settings for the sponge layer used for blocked gap regions.
                    """
                class include_coupled_walls(TUIMethod):
                    """
                    Include coupled walls in gap face zones.
                    """
                class precise_gap_marking(TUIMethod):
                    """
                    Enables/disables the use of a more accurate search algorithm for marking cells in 	gap regions. Note that it can be costly, particularly 	for 3D cases or those with a large number of cells 	inside the gap regions. This text command is only 	available if you have enabled the 	define/gap-model/advanced-options/expert? 	text command.
                    """
                class reduce_gap_regions(TUIMethod):
                    """
                    Enables/disables a more restrictive algorithm for marking cells in gap regions. This 	text command is only available if you have enabled the 	define/gap-model/advanced-options/expert? 	text command.
                    """
                class render_flow_modeling_gaps(TUIMethod):
                    """
                    Enables/disables the rendering of the solution in the cells of flow-modeling gap 	regions during postprocessing. This text command is only 	available if you have enabled the 	define/gap-model/advanced-options/expert? 	text command.
                    """
                class render_gap_interface(TUIMethod):
                    """
                    Enables/disables the rendering of the mesh surfaces inside the gap regions when 	displaying the mesh with contours. Note that the 	solution is still not rendered inside the flow-blocking 	gap regions.
                    """
                class revert_controls_to_default(TUIMethod):
                    """
                    Reverts the global gap stabilization level and any related 	solver settings to the default.
                    """
                class solution_stabilization(TUIMethod):
                    """
                    Sets the global solution stabilization level for the gap 	regions.
                    """
                class sponge_layer(TUIMethod):
                    """
                    Allows you to edit the solution stabilization settings for flow-modeling gap regions 	that have sponge-layer local stabilization 	enabled.
                    """
                class update_gap_regions(TUIMethod):
                    """
                    Update gap regions and gap model solution information.
                    """
                class verbosity(TUIMethod):
                    """
                    Sets the verbosity for messages printed in the console 	related to the gap model.
                    """

        class materials(TUIMenu):
            """
            Enters the materials menu.
            """
            def __init__(self, service, version, mode, path):
                self.data_base = self.__class__.data_base(service, version, mode, path + ["data_base"])
                self.change_create = self.__class__.change_create(service, version, mode, path + ["change_create"])
                self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                self.copy_by_formula = self.__class__.copy_by_formula(service, version, mode, path + ["copy_by_formula"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.list_materials = self.__class__.list_materials(service, version, mode, path + ["list_materials"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                super().__init__(service, version, mode, path)
            class change_create(TUIMethod):
                """
                Changes the properties of a locally-stored material or create a new material.   Generally, the properties you enter at the prompts will be filtered according to your case and model settings. However, some of the listed properties may not match the selection choice in the Graphics User Interface. Typically, those excessive properties in the Text User Interface will not be used in your simulation.
                """
            class copy(TUIMethod):
                """
                Copies a material from the database.
                """
            class copy_by_formula(TUIMethod):
                """
                Copies a material from the database by formula.
                """
            class delete(TUIMethod):
                """
                Deletes a material from local storage.
                """
            class list_materials(TUIMethod):
                """
                Lists all locally-stored materials.
                """
            class list_properties(TUIMethod):
                """
                Lists the properties of a locally-stored material.
                """

            class data_base(TUIMenu):
                """
                Enters the material database menu.
                """
                def __init__(self, service, version, mode, path):
                    self.database_type = self.__class__.database_type(service, version, mode, path + ["database_type"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list_materials = self.__class__.list_materials(service, version, mode, path + ["list_materials"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.new = self.__class__.new(service, version, mode, path + ["new"])
                    self.save = self.__class__.save(service, version, mode, path + ["save"])
                    super().__init__(service, version, mode, path)
                class database_type(TUIMethod):
                    """
                    Sets the database type 	(fluent-database, 	granta-mds, or 	user-defined).
                    """
                class edit(TUIMethod):
                    """
                    Edits material.
                    """
                class list_materials(TUIMethod):
                    """
                    Lists all materials in the database.
                    """
                class list_properties(TUIMethod):
                    """
                    Lists the properties of a material in the database.
                    """
                class new(TUIMethod):
                    """
                    Defines new material.
                    """
                class save(TUIMethod):
                    """
                    Saves user-defined database.
                    """

        class mesh_interfaces(TUIMenu):
            """
            Enters the mesh-interfaces menu.
            """
            def __init__(self, service, version, mode, path):
                self.auto_options = self.__class__.auto_options(service, version, mode, path + ["auto_options"])
                self.mapped_interface_options = self.__class__.mapped_interface_options(service, version, mode, path + ["mapped_interface_options"])
                self.non_conformal_interface_numerics = self.__class__.non_conformal_interface_numerics(service, version, mode, path + ["non_conformal_interface_numerics"])
                self.auto_pairing = self.__class__.auto_pairing(service, version, mode, path + ["auto_pairing"])
                self.coupled_interfaces_inherit_bcs = self.__class__.coupled_interfaces_inherit_bcs(service, version, mode, path + ["coupled_interfaces_inherit_bcs"])
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                self.delete_interfaces_with_small_overlap = self.__class__.delete_interfaces_with_small_overlap(service, version, mode, path + ["delete_interfaces_with_small_overlap"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.enable_si_with_nodes = self.__class__.enable_si_with_nodes(service, version, mode, path + ["enable_si_with_nodes"])
                self.enable_visualization_of_interfaces = self.__class__.enable_visualization_of_interfaces(service, version, mode, path + ["enable_visualization_of_interfaces"])
                self.enforce_continuity_after_bc = self.__class__.enforce_continuity_after_bc(service, version, mode, path + ["enforce_continuity_after_bc"])
                self.enforce_coupled_wall_between_solids = self.__class__.enforce_coupled_wall_between_solids(service, version, mode, path + ["enforce_coupled_wall_between_solids"])
                self.improve_quality = self.__class__.improve_quality(service, version, mode, path + ["improve_quality"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.make_periodic = self.__class__.make_periodic(service, version, mode, path + ["make_periodic"])
                self.make_phaselag_from_boundaries = self.__class__.make_phaselag_from_boundaries(service, version, mode, path + ["make_phaselag_from_boundaries"])
                self.make_phaselag_from_periodic = self.__class__.make_phaselag_from_periodic(service, version, mode, path + ["make_phaselag_from_periodic"])
                self.non_overlapping_zone_name = self.__class__.non_overlapping_zone_name(service, version, mode, path + ["non_overlapping_zone_name"])
                self.one_to_one_pairing = self.__class__.one_to_one_pairing(service, version, mode, path + ["one_to_one_pairing"])
                self.remove_left_handed_interface_faces = self.__class__.remove_left_handed_interface_faces(service, version, mode, path + ["remove_left_handed_interface_faces"])
                self.transfer_motion_across_interfaces = self.__class__.transfer_motion_across_interfaces(service, version, mode, path + ["transfer_motion_across_interfaces"])
                self.turbo_create = self.__class__.turbo_create(service, version, mode, path + ["turbo_create"])
                self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                super().__init__(service, version, mode, path)
            class auto_pairing(TUIMethod):
                """
                Automatically "pairs" some or all of the interface zones, in order to create mesh interfaces. This text command is only available when the define/mesh-interfaces/one-to-one-pairing? text command is disabled.
                """
            class coupled_interfaces_inherit_bcs(TUIMethod):
                """
                .
                """
            class create(TUIMethod):
                """
                Creates mesh interfaces.
                """
            class delete(TUIMethod):
                """
                Deletes a mesh interface.
                """
            class delete_all(TUIMethod):
                """
                Deletes all mesh interfaces.
                """
            class delete_interfaces_with_small_overlap(TUIMethod):
                """
                .
                """
            class display(TUIMethod):
                """
                Displays the specified mesh interface zone.
                """
            class edit(TUIMethod):
                """
                Edits attributes of existing mesh interfaces. For one-to-one interfaces, you can edit the name; for many-to-many interfaces, you can edit the interface options and (for a single interface) the name and the list of interface zones assigned to the interface.
                """
            class enable_si_with_nodes(TUIMethod):
                """
                .
                """
            class enable_visualization_of_interfaces(TUIMethod):
                """
                Enables/disables the filling of node coordinates on the zones of mesh interfaces, so that they can be displayed in the graphics window.
                """
            class enforce_continuity_after_bc(TUIMethod):
                """
                Enables/disables continuity across the boundary condition interface for contour plots in postprocessing.
                """
            class enforce_coupled_wall_between_solids(TUIMethod):
                """
                Enables/disables automatic definition of solid-solid interfaces as coupled walls. By default this option is disabled and ANSYS Fluent creates interior boundaries at solid-solid interfaces.
                """
            class improve_quality(TUIMethod):
                """
                Checks the quality of all mapped interfaces. If Fluent finds any mapped interfaces that require improvement it will list them and ask you if you would like to increase the tolerance to improve the interfaces.
                """
            class list(TUIMethod):
                """
                Lists all mesh interfaces.
                """
            class make_periodic(TUIMethod):
                """
                Make interface zones periodic.
                """
            class make_phaselag_from_boundaries(TUIMethod):
                """
                .
                """
            class make_phaselag_from_periodic(TUIMethod):
                """
                .
                """
            class non_overlapping_zone_name(TUIMethod):
                """
                .
                """
            class one_to_one_pairing(TUIMethod):
                """
                .
                """
            class remove_left_handed_interface_faces(TUIMethod):
                """
                Removes left-handed faces (which can cause the mesh to be invalid) during mesh interface creation.
                """
            class transfer_motion_across_interfaces(TUIMethod):
                """
                Enables/disables the automatic transfer of motion across a mesh interface when only one side is moving as a result of user-defined or system coupling motion. You can specify the method by which the motion is transferred: transfer-displacements (the default) interpolates nodal displacement from the active side of the interface to the passive side, and is recommended when there are gaps and/or penetrations in the mesh interface that must be maintained; project-nodes projects the passive nodes onto the faces of active side, and is recommended when the active side includes significant tangential motion (as only the normal displacement is effectively transferred in this method).
                """
            class turbo_create(TUIMethod):
                """
                Creates a general turbo interface. This text command is only available if the define/turbo-model/enable-turbo-model? text command is enabled.
                """
            class verbosity(TUIMethod):
                """
                Sets the mesh interface verbosity.
                """

            class auto_options(TUIMenu):
                """
                Enters the auto-options menu. This menu is only available when the define/mesh-interfaces/one-to-one-pairing? text command is enabled.
                """
                def __init__(self, service, version, mode, path):
                    self.keep_empty_interface = self.__class__.keep_empty_interface(service, version, mode, path + ["keep_empty_interface"])
                    self.naming_option = self.__class__.naming_option(service, version, mode, path + ["naming_option"])
                    self.pairing_between_different_cell_zones_only = self.__class__.pairing_between_different_cell_zones_only(service, version, mode, path + ["pairing_between_different_cell_zones_only"])
                    self.pairing_between_interface_zones_only = self.__class__.pairing_between_interface_zones_only(service, version, mode, path + ["pairing_between_interface_zones_only"])
                    self.proximity_tolerance = self.__class__.proximity_tolerance(service, version, mode, path + ["proximity_tolerance"])
                    self.set_default_name_prefix = self.__class__.set_default_name_prefix(service, version, mode, path + ["set_default_name_prefix"])
                    self.set_minimum_area_percentage = self.__class__.set_minimum_area_percentage(service, version, mode, path + ["set_minimum_area_percentage"])
                    self.set_one_to_one_pairing_tolerance = self.__class__.set_one_to_one_pairing_tolerance(service, version, mode, path + ["set_one_to_one_pairing_tolerance"])
                    super().__init__(service, version, mode, path)
                class keep_empty_interface(TUIMethod):
                    """
                    .
                    """
                class naming_option(TUIMethod):
                    """
                    Specifies whether the name of each new one-to-one mesh 	interface (as well as existing mesh interfaces, if you 	so desire) has no additional suffix, or a suffix that 	includes the names of the associated boundary zones, the 	IDs of the associated boundary zones, or the names of 	the adjacent cell zones.
                    """
                class pairing_between_different_cell_zones_only(TUIMethod):
                    """
                    Specifies whether the 	one-to-one mesh interfaces are only created between 	different cell zones.
                    """
                class pairing_between_interface_zones_only(TUIMethod):
                    """
                    .
                    """
                class proximity_tolerance(TUIMethod):
                    """
                    Sets the tolerance used as part 	of the automatic grouping of zones to create mesh 	interfaces when the define/mesh-interfaces/one-to-one-pairing? 	text command is disabled. The proximity tolerance is 	defined relative to the edge lengths in the interface 	zones, and can range from 0 to 1 (representing the minimum 	and maximum edge lengths, respectively).
                    """
                class set_default_name_prefix(TUIMethod):
                    """
                    Specifies the default interface 	name prefix used for one-to-one mesh interfaces.
                    """
                class set_minimum_area_percentage(TUIMethod):
                    """
                    .
                    """
                class set_one_to_one_pairing_tolerance(TUIMethod):
                    """
                    Enables/disables the use of adjustable tolerances to 	determine which of the selected boundary zones can be 	paired up to make the mesh interfaces, in order to 	account for gaps, thin layers, and/or complex 	geometries.
                    """

            class mapped_interface_options(TUIMenu):
                """
                Enter the mapped-interface-options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.convert_to_mapped_interface = self.__class__.convert_to_mapped_interface(service, version, mode, path + ["convert_to_mapped_interface"])
                    self.solution_controls = self.__class__.solution_controls(service, version, mode, path + ["solution_controls"])
                    self.tolerance = self.__class__.tolerance(service, version, mode, path + ["tolerance"])
                    super().__init__(service, version, mode, path)
                class convert_to_mapped_interface(TUIMethod):
                    """
                    .
                    """
                class solution_controls(TUIMethod):
                    """
                    .
                    """
                class tolerance(TUIMethod):
                    """
                    .
                    """

            class non_conformal_interface_numerics(TUIMenu):
                """
                Setting non-conformal numerics options.
                """
                def __init__(self, service, version, mode, path):
                    self.change_numerics = self.__class__.change_numerics(service, version, mode, path + ["change_numerics"])
                    super().__init__(service, version, mode, path)
                class change_numerics(TUIMethod):
                    """
                    .
                    """

        class mixing_planes(TUIMenu):
            """
            Enters the mixing planes menu.
            """
            def __init__(self, service, version, mode, path):
                self.set = self.__class__.set(service, version, mode, path + ["set"])
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                super().__init__(service, version, mode, path)
            class create(TUIMethod):
                """
                Creates a mixing plane.
                """
            class delete(TUIMethod):
                """
                Deletes a mixing plane.
                """
            class list(TUIMethod):
                """
                Lists defined mixing plane(s).
                """

            class set(TUIMenu):
                """
                Sets global parameters relevant to mixing planes.
                """
                def __init__(self, service, version, mode, path):
                    self.conserve_swirl = self.__class__.conserve_swirl(service, version, mode, path + ["conserve_swirl"])
                    self.conserve_total_enthalpy = self.__class__.conserve_total_enthalpy(service, version, mode, path + ["conserve_total_enthalpy"])
                    self.averaging_method = self.__class__.averaging_method(service, version, mode, path + ["averaging_method"])
                    self.fix_pressure_level = self.__class__.fix_pressure_level(service, version, mode, path + ["fix_pressure_level"])
                    self.under_relaxation = self.__class__.under_relaxation(service, version, mode, path + ["under_relaxation"])
                    super().__init__(service, version, mode, path)
                class averaging_method(TUIMethod):
                    """
                    Sets the mixing plane profile averaging method.
                    """
                class fix_pressure_level(TUIMethod):
                    """
                    Sets fixed pressure level using value based on define/reference-pressure-location.
                    """
                class under_relaxation(TUIMethod):
                    """
                    Sets mixing plane under-relaxation factor.
                    """

                class conserve_swirl(TUIMenu):
                    """
                    Enters the menu to set swirl conservation in mixing plane menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                        self.report_swirl_integration = self.__class__.report_swirl_integration(service, version, mode, path + ["report_swirl_integration"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        super().__init__(service, version, mode, path)
                    class enable(TUIMethod):
                        """
                        Enables/disables swirl conservation in mixing plane.
                        """
                    class report_swirl_integration(TUIMethod):
                        """
                        Reports swirl integration (Torque) on inflow and outflow zones.
                        """
                    class verbosity(TUIMethod):
                        """
                        Enables/disables verbosity in swirl conservation calculations.
                        """

                class conserve_total_enthalpy(TUIMenu):
                    """
                    Enters the menu to set total enthalpy conservation in mixing plane menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        super().__init__(service, version, mode, path)
                    class enable(TUIMethod):
                        """
                        Enables/disables total enthalpy conservation in mixing plane.
                        """
                    class verbosity(TUIMethod):
                        """
                        Enables/disables verbosity in total-enthalpy conservation calculations.
                        """

        class models(TUIMenu):
            """
            Enters the models menu to configure the solver.
            """
            def __init__(self, service, version, mode, path):
                self.acoustics = self.__class__.acoustics(service, version, mode, path + ["acoustics"])
                self.cht = self.__class__.cht(service, version, mode, path + ["cht"])
                self.dpm = self.__class__.dpm(service, version, mode, path + ["dpm"])
                self.electrolysis_setup = self.__class__.electrolysis_setup(service, version, mode, path + ["electrolysis_setup"])
                self.eulerian_wallfilm = self.__class__.eulerian_wallfilm(service, version, mode, path + ["eulerian_wallfilm"])
                self.heat_exchanger = self.__class__.heat_exchanger(service, version, mode, path + ["heat_exchanger"])
                self.multiphase = self.__class__.multiphase(service, version, mode, path + ["multiphase"])
                self.nox_parameters = self.__class__.nox_parameters(service, version, mode, path + ["nox_parameters"])
                self.optics = self.__class__.optics(service, version, mode, path + ["optics"])
                self.radiation = self.__class__.radiation(service, version, mode, path + ["radiation"])
                self.shell_conduction = self.__class__.shell_conduction(service, version, mode, path + ["shell_conduction"])
                self.solver = self.__class__.solver(service, version, mode, path + ["solver"])
                self.soot_parameters = self.__class__.soot_parameters(service, version, mode, path + ["soot_parameters"])
                self.species = self.__class__.species(service, version, mode, path + ["species"])
                self.structure = self.__class__.structure(service, version, mode, path + ["structure"])
                self.system_coupling_settings = self.__class__.system_coupling_settings(service, version, mode, path + ["system_coupling_settings"])
                self.two_temperature = self.__class__.two_temperature(service, version, mode, path + ["two_temperature"])
                self.virtual_blade_model = self.__class__.virtual_blade_model(service, version, mode, path + ["virtual_blade_model"])
                self.viscous = self.__class__.viscous(service, version, mode, path + ["viscous"])
                self.ablation = self.__class__.ablation(service, version, mode, path + ["ablation"])
                self.addon_module = self.__class__.addon_module(service, version, mode, path + ["addon_module"])
                self.axisymmetric = self.__class__.axisymmetric(service, version, mode, path + ["axisymmetric"])
                self.battery_model = self.__class__.battery_model(service, version, mode, path + ["battery_model"])
                self.crevice_model = self.__class__.crevice_model(service, version, mode, path + ["crevice_model"])
                self.crevice_model_controls = self.__class__.crevice_model_controls(service, version, mode, path + ["crevice_model_controls"])
                self.energy = self.__class__.energy(service, version, mode, path + ["energy"])
                self.frozen_flux = self.__class__.frozen_flux(service, version, mode, path + ["frozen_flux"])
                self.noniterative_time_advance = self.__class__.noniterative_time_advance(service, version, mode, path + ["noniterative_time_advance"])
                self.nox = self.__class__.nox(service, version, mode, path + ["nox"])
                self.potential_and_li_ion_battery = self.__class__.potential_and_li_ion_battery(service, version, mode, path + ["potential_and_li_ion_battery"])
                self.solidification_melting = self.__class__.solidification_melting(service, version, mode, path + ["solidification_melting"])
                self.soot = self.__class__.soot(service, version, mode, path + ["soot"])
                self.steady = self.__class__.steady(service, version, mode, path + ["steady"])
                self.swirl = self.__class__.swirl(service, version, mode, path + ["swirl"])
                self.unsteady_1st_order = self.__class__.unsteady_1st_order(service, version, mode, path + ["unsteady_1st_order"])
                self.unsteady_2nd_order = self.__class__.unsteady_2nd_order(service, version, mode, path + ["unsteady_2nd_order"])
                self.unsteady_2nd_order_bounded = self.__class__.unsteady_2nd_order_bounded(service, version, mode, path + ["unsteady_2nd_order_bounded"])
                self.unsteady_global_time = self.__class__.unsteady_global_time(service, version, mode, path + ["unsteady_global_time"])
                self.unsteady_structure_euler = self.__class__.unsteady_structure_euler(service, version, mode, path + ["unsteady_structure_euler"])
                self.unsteady_structure_newmark = self.__class__.unsteady_structure_newmark(service, version, mode, path + ["unsteady_structure_newmark"])
                super().__init__(service, version, mode, path)
            class ablation(TUIMethod):
                """
                Enables/disables the ablation model.
                """
            class addon_module(TUIMethod):
                """
                Loads addon module.
                """
            class axisymmetric(TUIMethod):
                """
                Specifies whether or not the domain is axisymmetric.
                """
            class battery_model(TUIMethod):
                """
                Enables the dual potential MSMD battery model. For text commands that become available when the battery model is enabled, refer to Battery Model Text Commands.
                """
            class crevice_model(TUIMethod):
                """
                Enables/disables the crevice model.
                """
            class crevice_model_controls(TUIMethod):
                """
                Enters the crevice model controls menu.
                """
            class energy(TUIMethod):
                """
                .
                """
            class frozen_flux(TUIMethod):
                """
                Enables/disables frozen flux formulation for transient flows.
                """
            class noniterative_time_advance(TUIMethod):
                """
                Enables/disables noniterative time advancement scheme.
                """
            class nox(TUIMethod):
                """
                Enables/disables the NOx model.
                """
            class potential_and_li_ion_battery(TUIMethod):
                """
                Enables/disables the electric-potential model.
                """
            class solidification_melting(TUIMethod):
                """
                Enables/disables the solidification and melting model.
                """
            class soot(TUIMethod):
                """
                Enables/disables the soot model.
                """
            class steady(TUIMethod):
                """
                Enables/disables the steady solution model.
                """
            class swirl(TUIMethod):
                """
                Enables/disables axisymmetric swirl velocity.
                """
            class unsteady_1st_order(TUIMethod):
                """
                Selects the first-order implicit formulation for transient simulations.
                """
            class unsteady_2nd_order(TUIMethod):
                """
                Selects the second-order implicit formulation for transient simulations.
                """
            class unsteady_2nd_order_bounded(TUIMethod):
                """
                Selects the bounded second-order implicit formulation for transient simulations.
                """
            class unsteady_global_time(TUIMethod):
                """
                Selects the explicit transient formulation. This text command is only available for unsteady cases that use the density-based solver with the explicit formulation.
                """
            class unsteady_structure_euler(TUIMethod):
                """
                Selects the backward Euler method for the direct time integration of the finite element semi-discrete equation of motion. This text command is only available for transient simulations that use the structural model.
                """
            class unsteady_structure_newmark(TUIMethod):
                """
                Selects the Newmark method for the direct time integration of the finite element semi-discrete equation of motion. This text command is only available for transient simulations that use the structural model.
                """

            class acoustics(TUIMenu):
                """
                Enters the acoustics menu.
                """
                def __init__(self, service, version, mode, path):
                    self.far_field_parameters = self.__class__.far_field_parameters(service, version, mode, path + ["far_field_parameters"])
                    self.sources_fft = self.__class__.sources_fft(service, version, mode, path + ["sources_fft"])
                    self.sponge_layers = self.__class__.sponge_layers(service, version, mode, path + ["sponge_layers"])
                    self.wave_equation_options = self.__class__.wave_equation_options(service, version, mode, path + ["wave_equation_options"])
                    self.acoustic_modal_analysis = self.__class__.acoustic_modal_analysis(service, version, mode, path + ["acoustic_modal_analysis"])
                    self.auto_prune = self.__class__.auto_prune(service, version, mode, path + ["auto_prune"])
                    self.broad_band_noise = self.__class__.broad_band_noise(service, version, mode, path + ["broad_band_noise"])
                    self.compute_write = self.__class__.compute_write(service, version, mode, path + ["compute_write"])
                    self.convective_effects = self.__class__.convective_effects(service, version, mode, path + ["convective_effects"])
                    self.cylindrical_export = self.__class__.cylindrical_export(service, version, mode, path + ["cylindrical_export"])
                    self.display_flow_time = self.__class__.display_flow_time(service, version, mode, path + ["display_flow_time"])
                    self.display_frequencies = self.__class__.display_frequencies(service, version, mode, path + ["display_frequencies"])
                    self.export_source_data = self.__class__.export_source_data(service, version, mode, path + ["export_source_data"])
                    self.export_source_data_cgns = self.__class__.export_source_data_cgns(service, version, mode, path + ["export_source_data_cgns"])
                    self.export_volumetric_sources = self.__class__.export_volumetric_sources(service, version, mode, path + ["export_volumetric_sources"])
                    self.export_volumetric_sources_cgns = self.__class__.export_volumetric_sources_cgns(service, version, mode, path + ["export_volumetric_sources_cgns"])
                    self.ffowcs_williams = self.__class__.ffowcs_williams(service, version, mode, path + ["ffowcs_williams"])
                    self.modal_analysis = self.__class__.modal_analysis(service, version, mode, path + ["modal_analysis"])
                    self.moving_receiver = self.__class__.moving_receiver(service, version, mode, path + ["moving_receiver"])
                    self.off = self.__class__.off(service, version, mode, path + ["off"])
                    self.read_compute_write = self.__class__.read_compute_write(service, version, mode, path + ["read_compute_write"])
                    self.receivers = self.__class__.receivers(service, version, mode, path + ["receivers"])
                    self.sources = self.__class__.sources(service, version, mode, path + ["sources"])
                    self.wave_equation = self.__class__.wave_equation(service, version, mode, path + ["wave_equation"])
                    self.write_acoustic_signals = self.__class__.write_acoustic_signals(service, version, mode, path + ["write_acoustic_signals"])
                    self.write_centroid_info = self.__class__.write_centroid_info(service, version, mode, path + ["write_centroid_info"])
                    super().__init__(service, version, mode, path)
                class acoustic_modal_analysis(TUIMethod):
                    """
                    Iterate linear acoustic solver to compute the resonance frequencies and the acoustic modes.
                    """
                class auto_prune(TUIMethod):
                    """
                    Enables/disables auto prune of the receiver signal(s) during 	read-and-compute.
                    """
                class broad_band_noise(TUIMethod):
                    """
                    Enables/disables the broadband noise model.
                    """
                class compute_write(TUIMethod):
                    """
                    Computes sound pressure.
                    """
                class convective_effects(TUIMethod):
                    """
                    Enables/disables the convective effects option.
                    """
                class cylindrical_export(TUIMethod):
                    """
                    Enables/disables the export of data in cylindrical coordinates.
                    """
                class display_flow_time(TUIMethod):
                    """
                    Enables/disables the display of flow time during read-and-compute.
                    """
                class display_frequencies(TUIMethod):
                    """
                    Display resonance frequencies.
                    """
                class export_source_data(TUIMethod):
                    """
                    Enables/disables the export of acoustic source data in 	ASD format during the wave equation model run.
                    """
                class export_source_data_cgns(TUIMethod):
                    """
                    Enables/disables the export of acoustic source data in CGNS format.
                    """
                class export_volumetric_sources(TUIMethod):
                    """
                    Enables/disables the export of fluid zones.
                    """
                class export_volumetric_sources_cgns(TUIMethod):
                    """
                    Enables/disables the export of fluid zones.
                    """
                class ffowcs_williams(TUIMethod):
                    """
                    Enables/disables the Ffowcs-Williams-and-Hawkings model.
                    """
                class modal_analysis(TUIMethod):
                    """
                    Enable/disable the modal analysis model.
                    """
                class moving_receiver(TUIMethod):
                    """
                    Enables/disables the moving receiver option.
                    """
                class off(TUIMethod):
                    """
                    Enables/disables the acoustics model.
                    """
                class read_compute_write(TUIMethod):
                    """
                    Reads acoustic source data files and computes sound pressure.
                    """
                class receivers(TUIMethod):
                    """
                    Sets acoustic receivers.
                    """
                class sources(TUIMethod):
                    """
                    Sets acoustic sources.
                    """
                class wave_equation(TUIMethod):
                    """
                    Enables/disables the wave equation model.
                    """
                class write_acoustic_signals(TUIMethod):
                    """
                    Writes on-the-fly sound pressure.
                    """
                class write_centroid_info(TUIMethod):
                    """
                    Writes centroid info.
                    """

                class far_field_parameters(TUIMenu):
                    """
                    Enters the menu to specify the far-field density and 	speed of sound. Note that this menu is currently 	available only with the acoustics wave equation model.
                    """
                    def __init__(self, service, version, mode, path):
                        self.far_field_density = self.__class__.far_field_density(service, version, mode, path + ["far_field_density"])
                        self.far_field_sound_speed = self.__class__.far_field_sound_speed(service, version, mode, path + ["far_field_sound_speed"])
                        super().__init__(service, version, mode, path)
                    class far_field_density(TUIMethod):
                        """
                        Specifies the far-field density value for the acoustics wave equation model.
                        """
                    class far_field_sound_speed(TUIMethod):
                        """
                        Specifies the far-field speed of sound value for the acoustics wave equation model.
                        """

                class sources_fft(TUIMenu):
                    """
                    Enters the acoustic sources fast Fourier transform (FFT) menu, to compute Fourier 	spectra from acoustic source data (ASD) files, create 	postprocessing variables for the pressure signals, and 	write CGNS files of the spectrum data.
                    """
                    def __init__(self, service, version, mode, path):
                        self.fft_surface_variables = self.__class__.fft_surface_variables(service, version, mode, path + ["fft_surface_variables"])
                        self.clean_up_storage_area = self.__class__.clean_up_storage_area(service, version, mode, path + ["clean_up_storage_area"])
                        self.compute_fft_fields = self.__class__.compute_fft_fields(service, version, mode, path + ["compute_fft_fields"])
                        self.read_asd_files = self.__class__.read_asd_files(service, version, mode, path + ["read_asd_files"])
                        self.write_cgns_files = self.__class__.write_cgns_files(service, version, mode, path + ["write_cgns_files"])
                        super().__init__(service, version, mode, path)
                    class clean_up_storage_area(TUIMethod):
                        """
                        De-allocates memory used to store the pressure histories and their Fourier spectra, as well as any created surface variables for the visualization.
                        """
                    class compute_fft_fields(TUIMethod):
                        """
                        Computes FFT of the read pressure histories. The computed spectra replace the pressure histories in memory.
                        """
                    class read_asd_files(TUIMethod):
                        """
                        Reads ASD files to perform FFT of the pressure history field.
                        """
                    class write_cgns_files(TUIMethod):
                        """
                        Writes surface pressure spectra in CGNS format, which can be used for one-way coupling with Ansys Mechanical in the frequency domain.
                        """

                    class fft_surface_variables(TUIMenu):
                        """
                        Enters the menu to create surface variables from the computed Fourier spectra for visualization.
                        """
                        def __init__(self, service, version, mode, path):
                            self.create_constant_width_bands = self.__class__.create_constant_width_bands(service, version, mode, path + ["create_constant_width_bands"])
                            self.create_octave_bands = self.__class__.create_octave_bands(service, version, mode, path + ["create_octave_bands"])
                            self.create_set_of_modes = self.__class__.create_set_of_modes(service, version, mode, path + ["create_set_of_modes"])
                            self.create_third_bands = self.__class__.create_third_bands(service, version, mode, path + ["create_third_bands"])
                            self.remove_variables = self.__class__.remove_variables(service, version, mode, path + ["remove_variables"])
                            super().__init__(service, version, mode, path)
                        class create_constant_width_bands(TUIMethod):
                            """
                            Selects up to 20 constant width bands and creates either the surface pressures level (SPL) variables or the PSD of dp/dt variables for them.
                            """
                        class create_octave_bands(TUIMethod):
                            """
                            Creates either the surface pressure level (SPL) variables or the PSD of dp/dt variables for 17 technical octaves.
                            """
                        class create_set_of_modes(TUIMethod):
                            """
                            Selects up to 20 individual Fourier modes and create variable pairs for them, containing the real and the imaginary parts of the complex Fourier amplitudes.
                            """
                        class create_third_bands(TUIMethod):
                            """
                            Creates either the surface pressure level (SPL) variables or the PSD of dp/dt variables for 54 technical thirds.
                            """
                        class remove_variables(TUIMethod):
                            """
                            Removes all variables created in this menu.
                            """

                class sponge_layers(TUIMenu):
                    """
                    Manage sponge layers where density is blended to eliminate reflections from boundary zones.
                    """
                    def __init__(self, service, version, mode, path):
                        self.activate = self.__class__.activate(service, version, mode, path + ["activate"])
                        self.add = self.__class__.add(service, version, mode, path + ["add"])
                        self.deactivate = self.__class__.deactivate(service, version, mode, path + ["deactivate"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.list_active = self.__class__.list_active(service, version, mode, path + ["list_active"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        super().__init__(service, version, mode, path)
                    class activate(TUIMethod):
                        """
                        Activate a sponge object.
                        """
                    class add(TUIMethod):
                        """
                        Add a new sponge layer definition.
                        """
                    class deactivate(TUIMethod):
                        """
                        Deactivate a sponge layer definition.
                        """
                    class delete(TUIMethod):
                        """
                        Deletes an existing sponge layer definition.
                        """
                    class edit(TUIMethod):
                        """
                        Edits an existing sponge layer. You can revise the fields listed previously for the define/models/acoustics/sponge-layers/add text command.
                        """
                    class list(TUIMethod):
                        """
                        Prints a list of the existing sponge layers in the console.
                        """
                    class list_active(TUIMethod):
                        """
                        List the names of the active sponge layer definitions.
                        """
                    class list_properties(TUIMethod):
                        """
                        Prints the properties of an existing sponge layer of your choice in the console.
                        """

                class wave_equation_options(TUIMenu):
                    """
                    Enters the menu to define the acoustics wave equation 	model options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.basic_shapes = self.__class__.basic_shapes(service, version, mode, path + ["basic_shapes"])
                        self.remote_receivers_options = self.__class__.remote_receivers_options(service, version, mode, path + ["remote_receivers_options"])
                        self.remote_receivers = self.__class__.remote_receivers(service, version, mode, path + ["remote_receivers"])
                        self.source_mask_udf = self.__class__.source_mask_udf(service, version, mode, path + ["source_mask_udf"])
                        self.sponge_layer_base_level = self.__class__.sponge_layer_base_level(service, version, mode, path + ["sponge_layer_base_level"])
                        self.sponge_layer_factor = self.__class__.sponge_layer_factor(service, version, mode, path + ["sponge_layer_factor"])
                        self.sponge_layer_udf = self.__class__.sponge_layer_udf(service, version, mode, path + ["sponge_layer_udf"])
                        self.time_filter_source = self.__class__.time_filter_source(service, version, mode, path + ["time_filter_source"])
                        super().__init__(service, version, mode, path)
                    class remote_receivers(TUIMethod):
                        """
                        Enables/disables the Kirchhoff integral model.
                        """
                    class source_mask_udf(TUIMethod):
                        """
                        Specifies the name of a user-defined function, which defines geometry of the source mask.
                        """
                    class sponge_layer_base_level(TUIMethod):
                        """
                        Specify artificial viscosity base level applied everywhere.
                        """
                    class sponge_layer_factor(TUIMethod):
                        """
                        Specifies the factor of the artificial viscosity coefficient.
                        """
                    class sponge_layer_udf(TUIMethod):
                        """
                        Specifies the name of a user-defined function, which defines geometry of the sponge layer.
                        """
                    class time_filter_source(TUIMethod):
                        """
                        Enables/disables a time filter for the sound source.
                        """

                    class basic_shapes(TUIMenu):
                        """
                        Enters the menu to define the geometry of the source mask and sponge layer using the basic shapes, represented by the cell registers of the type "Region".
                        """
                        def __init__(self, service, version, mode, path):
                            self.add_source_mask_shape = self.__class__.add_source_mask_shape(service, version, mode, path + ["add_source_mask_shape"])
                            self.add_sponge_layer_shape = self.__class__.add_sponge_layer_shape(service, version, mode, path + ["add_sponge_layer_shape"])
                            self.list_region_registers = self.__class__.list_region_registers(service, version, mode, path + ["list_region_registers"])
                            self.list_source_mask_shapes = self.__class__.list_source_mask_shapes(service, version, mode, path + ["list_source_mask_shapes"])
                            self.list_sponge_layer_shapes = self.__class__.list_sponge_layer_shapes(service, version, mode, path + ["list_sponge_layer_shapes"])
                            self.remove_source_mask_shape = self.__class__.remove_source_mask_shape(service, version, mode, path + ["remove_source_mask_shape"])
                            self.remove_sponge_layer_shape = self.__class__.remove_sponge_layer_shape(service, version, mode, path + ["remove_sponge_layer_shape"])
                            super().__init__(service, version, mode, path)
                        class add_source_mask_shape(TUIMethod):
                            """
                            Adds a basic shape to the definition of the source mask geometry.
                            """
                        class add_sponge_layer_shape(TUIMethod):
                            """
                            Adds a basic shape to the definition of the sponge layer geometry.
                            """
                        class list_region_registers(TUIMethod):
                            """
                            List all available cell registers of the type "Region".
                            """
                        class list_source_mask_shapes(TUIMethod):
                            """
                            List basic shapes, which are currently used in the definition of the source mask geometry.
                            """
                        class list_sponge_layer_shapes(TUIMethod):
                            """
                            List basic shapes, which are currently used in the definition of the sponge layer geometry.
                            """
                        class remove_source_mask_shape(TUIMethod):
                            """
                            Remove a basic shape from the definition of the source mask geometry.
                            """
                        class remove_sponge_layer_shape(TUIMethod):
                            """
                            Remove a basic shape from the definition of the sponge layer geometry.
                            """

                    class remote_receivers_options(TUIMenu):
                        """
                        Enters the menu to define remote receivers for the Kirchhoff integral model.
                        """
                        def __init__(self, service, version, mode, path):
                            self.integration_surface = self.__class__.integration_surface(service, version, mode, path + ["integration_surface"])
                            self.write_signals = self.__class__.write_signals(service, version, mode, path + ["write_signals"])
                            super().__init__(service, version, mode, path)
                        class integration_surface(TUIMethod):
                            """
                            Selects the integration surface for the Kirchhoff model.
                            """
                        class write_signals(TUIMethod):
                            """
                            Writes the computed receiver signals to the ASCII files.
                            """

            class cht(TUIMenu):
                """
                Enters the cht (conjugate heat transfer) menu.
                """
                def __init__(self, service, version, mode, path):
                    self.explicit_time_averaged_coupling = self.__class__.explicit_time_averaged_coupling(service, version, mode, path + ["explicit_time_averaged_coupling"])
                    self.implicit_coupling = self.__class__.implicit_coupling(service, version, mode, path + ["implicit_coupling"])
                    self.read_mi_type_wall = self.__class__.read_mi_type_wall(service, version, mode, path + ["read_mi_type_wall"])
                    self.write_mi_type_wall = self.__class__.write_mi_type_wall(service, version, mode, path + ["write_mi_type_wall"])
                    super().__init__(service, version, mode, path)
                class implicit_coupling(TUIMethod):
                    """
                    Enables the implicit mapping scheme for any 	fluid-solid pair with a mapped mesh interface (only 	required for cases set up in version 19.2 or 	earlier).
                    """
                class read_mi_type_wall(TUIMethod):
                    """
                    Read mapped interface data settings from a csv file.
                    """
                class write_mi_type_wall(TUIMethod):
                    """
                    Write mapped interface settings to a scv file.
                    """

                class explicit_time_averaged_coupling(TUIMenu):
                    """
                    Enters the explicit time averaged thermal coupling 	menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.conformal_coupled_walls = self.__class__.conformal_coupled_walls(service, version, mode, path + ["conformal_coupled_walls"])
                        self.coupling_controls = self.__class__.coupling_controls(service, version, mode, path + ["coupling_controls"])
                        self.fuse_explicit_cht_zones = self.__class__.fuse_explicit_cht_zones(service, version, mode, path + ["fuse_explicit_cht_zones"])
                        self.mapped_interfaces = self.__class__.mapped_interfaces(service, version, mode, path + ["mapped_interfaces"])
                        super().__init__(service, version, mode, path)
                    class conformal_coupled_walls(TUIMethod):
                        """
                        Select fluid-solid coupled walls (without shell) for explicit coupling using time averaged thermal variables.
                        """
                    class coupling_controls(TUIMethod):
                        """
                        Specify explcit coupling controls.
                        """
                    class fuse_explicit_cht_zones(TUIMethod):
                        """
                        Fuse slitted conformal coupled walls marked for transient explicit thermal coupling.
                        """
                    class mapped_interfaces(TUIMethod):
                        """
                        Select fluid-solid mapped interfaces for explicit coupling using time averaged thermal variables.
                        """

            class dpm(TUIMenu):
                """
                Enters the dispersed phase model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.collisions = self.__class__.collisions(service, version, mode, path + ["collisions"])
                    self.erosion_dynamic_mesh = self.__class__.erosion_dynamic_mesh(service, version, mode, path + ["erosion_dynamic_mesh"])
                    self.interaction = self.__class__.interaction(service, version, mode, path + ["interaction"])
                    self.numerics = self.__class__.numerics(service, version, mode, path + ["numerics"])
                    self.options = self.__class__.options(service, version, mode, path + ["options"])
                    self.parallel = self.__class__.parallel(service, version, mode, path + ["parallel"])
                    self.splash_options = self.__class__.splash_options(service, version, mode, path + ["splash_options"])
                    self.stripping_options = self.__class__.stripping_options(service, version, mode, path + ["stripping_options"])
                    self.clear_particles_from_domain = self.__class__.clear_particles_from_domain(service, version, mode, path + ["clear_particles_from_domain"])
                    self.fill_injection_material_sources = self.__class__.fill_injection_material_sources(service, version, mode, path + ["fill_injection_material_sources"])
                    self.injections = self.__class__.injections(service, version, mode, path + ["injections"])
                    self.spray_model = self.__class__.spray_model(service, version, mode, path + ["spray_model"])
                    self.unsteady_tracking = self.__class__.unsteady_tracking(service, version, mode, path + ["unsteady_tracking"])
                    self.user_defined = self.__class__.user_defined(service, version, mode, path + ["user_defined"])
                    super().__init__(service, version, mode, path)
                class clear_particles_from_domain(TUIMethod):
                    """
                    Removes/keeps all particles currently in the domain.
                    """
                class fill_injection_material_sources(TUIMethod):
                    """
                    Initialize the DPM sources corresponding to each material.
                    """
                class injections(TUIMethod):
                    """
                    Enters the injections menu.
                    """
                class spray_model(TUIMethod):
                    """
                    Enters the spray model menu. This command is available only if the breakup model 	enabled globally.
                    """
                class unsteady_tracking(TUIMethod):
                    """
                    Enables/disables unsteady particle tracking.
                    """
                class user_defined(TUIMethod):
                    """
                    Sets DPM user-defined functions.
                    """

                class collisions(TUIMenu):
                    """
                    Enters the DEM collisions menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.collision_partners = self.__class__.collision_partners(service, version, mode, path + ["collision_partners"])
                        self.collision_mesh = self.__class__.collision_mesh(service, version, mode, path + ["collision_mesh"])
                        self.collision_pair_settings = self.__class__.collision_pair_settings(service, version, mode, path + ["collision_pair_settings"])
                        self.dem_collisions = self.__class__.dem_collisions(service, version, mode, path + ["dem_collisions"])
                        self.list_all_pair_settings = self.__class__.list_all_pair_settings(service, version, mode, path + ["list_all_pair_settings"])
                        self.max_particle_velocity = self.__class__.max_particle_velocity(service, version, mode, path + ["max_particle_velocity"])
                        super().__init__(service, version, mode, path)
                    class collision_mesh(TUIMethod):
                        """
                        Input for the collision mesh.
                        """
                    class collision_pair_settings(TUIMethod):
                        """
                        Supplies settings for collisions to a pair of collision partners. You will be prompted to specify theImpact collision partner and the Target collision partner.
                        """
                    class dem_collisions(TUIMethod):
                        """
                        Enables/disables the DEM collision model.
                        """
                    class list_all_pair_settings(TUIMethod):
                        """
                        For each pair of collision partners, lists the collision laws and their parameters.
                        """
                    class max_particle_velocity(TUIMethod):
                        """
                        Sets the maximum particle velocity that may arise from collisions.
                        """

                    class collision_partners(TUIMenu):
                        """
                        Manages collision partners.
                        """
                        def __init__(self, service, version, mode, path):
                            self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                            self.create = self.__class__.create(service, version, mode, path + ["create"])
                            self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                            self.list = self.__class__.list(service, version, mode, path + ["list"])
                            self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                            super().__init__(service, version, mode, path)
                        class copy(TUIMethod):
                            """
                            Copies a collision partner.
                            """
                        class create(TUIMethod):
                            """
                            Creates a collision partner.
                            """
                        class delete(TUIMethod):
                            """
                            Deletes a collision partner.
                            """
                        class list(TUIMethod):
                            """
                            Lists all known collision partners.
                            """
                        class rename(TUIMethod):
                            """
                            Renames a collision partner.
                            """

                class erosion_dynamic_mesh(TUIMenu):
                    """
                    Enters the menu to enable/configure/run the erosion-dynamic mesh interaction.
                    """
                    def __init__(self, service, version, mode, path):
                        self.general_parameters = self.__class__.general_parameters(service, version, mode, path + ["general_parameters"])
                        self.run_parameters = self.__class__.run_parameters(service, version, mode, path + ["run_parameters"])
                        self.enable_erosion_dynamic_mesh_coupling = self.__class__.enable_erosion_dynamic_mesh_coupling(service, version, mode, path + ["enable_erosion_dynamic_mesh_coupling"])
                        self.run_simulation = self.__class__.run_simulation(service, version, mode, path + ["run_simulation"])
                        super().__init__(service, version, mode, path)
                    class enable_erosion_dynamic_mesh_coupling(TUIMethod):
                        """
                        Enables mesh deformation due to wall erosion.
                        """
                    class run_simulation(TUIMethod):
                        """
                        Performs a coupled erosion-dynamic mesh simulation.
                        """

                    class general_parameters(TUIMenu):
                        """
                        Enters the menu for setting erosion coupling with dynamic mesh.
                        """
                        def __init__(self, service, version, mode, path):
                            self.dynamic_mesh_settings = self.__class__.dynamic_mesh_settings(service, version, mode, path + ["dynamic_mesh_settings"])
                            self.erosion_settings = self.__class__.erosion_settings(service, version, mode, path + ["erosion_settings"])
                            self.participating_walls = self.__class__.participating_walls(service, version, mode, path + ["participating_walls"])
                            super().__init__(service, version, mode, path)
                        class dynamic_mesh_settings(TUIMethod):
                            """
                            Sets parameters for dynamic mesh calculations.
                            """
                        class erosion_settings(TUIMethod):
                            """
                            Sets parameters for erosion calculations.
                            """
                        class participating_walls(TUIMethod):
                            """
                            Specifies all participating walls.
                            """

                    class run_parameters(TUIMenu):
                        """
                        Manages erosion-dynamic mesh run settings.
                        """
                        def __init__(self, service, version, mode, path):
                            self.autosave_files = self.__class__.autosave_files(service, version, mode, path + ["autosave_files"])
                            self.autosave_graphics = self.__class__.autosave_graphics(service, version, mode, path + ["autosave_graphics"])
                            self.flow_simulation_control = self.__class__.flow_simulation_control(service, version, mode, path + ["flow_simulation_control"])
                            self.mesh_motion_time_step = self.__class__.mesh_motion_time_step(service, version, mode, path + ["mesh_motion_time_step"])
                            self.simulation_termination = self.__class__.simulation_termination(service, version, mode, path + ["simulation_termination"])
                            super().__init__(service, version, mode, path)
                        class autosave_files(TUIMethod):
                            """
                            Sets the iteration increment and filename to save data files.
                            """
                        class autosave_graphics(TUIMethod):
                            """
                            Sets the iteration increment to save graphics files.
                            """
                        class flow_simulation_control(TUIMethod):
                            """
                            Sets the number of iterations per flow simulation step.
                            """
                        class mesh_motion_time_step(TUIMethod):
                            """
                            Sets the mesh motion time stepping parameters and method.
                            """
                        class simulation_termination(TUIMethod):
                            """
                            Sets the total time of erosion.
                            """

                class interaction(TUIMenu):
                    """
                    Sets parameters for coupled discrete phase calculations.
                    """
                    def __init__(self, service, version, mode, path):
                        self.choice_of_eulerian_phase_for_interaction = self.__class__.choice_of_eulerian_phase_for_interaction(service, version, mode, path + ["choice_of_eulerian_phase_for_interaction"])
                        self.coupled_calculations = self.__class__.coupled_calculations(service, version, mode, path + ["coupled_calculations"])
                        self.ddpm_energy_coupling_via_source_term = self.__class__.ddpm_energy_coupling_via_source_term(service, version, mode, path + ["ddpm_energy_coupling_via_source_term"])
                        self.ddpm_enhanced_inter_phase_exchange = self.__class__.ddpm_enhanced_inter_phase_exchange(service, version, mode, path + ["ddpm_enhanced_inter_phase_exchange"])
                        self.ddpm_iad_particle = self.__class__.ddpm_iad_particle(service, version, mode, path + ["ddpm_iad_particle"])
                        self.dpm_iteration_interval = self.__class__.dpm_iteration_interval(service, version, mode, path + ["dpm_iteration_interval"])
                        self.enable_drag_scaling_due_to_flow_blocking = self.__class__.enable_drag_scaling_due_to_flow_blocking(service, version, mode, path + ["enable_drag_scaling_due_to_flow_blocking"])
                        self.enable_flow_blocking_by_particles = self.__class__.enable_flow_blocking_by_particles(service, version, mode, path + ["enable_flow_blocking_by_particles"])
                        self.enable_mom_source_scaling_due_to_flow_blocking = self.__class__.enable_mom_source_scaling_due_to_flow_blocking(service, version, mode, path + ["enable_mom_source_scaling_due_to_flow_blocking"])
                        self.enable_other_source_scaling_due_to_flow_blocking = self.__class__.enable_other_source_scaling_due_to_flow_blocking(service, version, mode, path + ["enable_other_source_scaling_due_to_flow_blocking"])
                        self.enable_source_scaling_due_to_flow_blocking = self.__class__.enable_source_scaling_due_to_flow_blocking(service, version, mode, path + ["enable_source_scaling_due_to_flow_blocking"])
                        self.enhanced_source_term_linearization_enabled = self.__class__.enhanced_source_term_linearization_enabled(service, version, mode, path + ["enhanced_source_term_linearization_enabled"])
                        self.implicit_momentum_coupling = self.__class__.implicit_momentum_coupling(service, version, mode, path + ["implicit_momentum_coupling"])
                        self.implicit_source_term_coupling = self.__class__.implicit_source_term_coupling(service, version, mode, path + ["implicit_source_term_coupling"])
                        self.keep_linearized_dpm_source_terms_constant = self.__class__.keep_linearized_dpm_source_terms_constant(service, version, mode, path + ["keep_linearized_dpm_source_terms_constant"])
                        self.linear_growth_of_dpm_source_term = self.__class__.linear_growth_of_dpm_source_term(service, version, mode, path + ["linear_growth_of_dpm_source_term"])
                        self.linearized_dpm_mixture_fraction_source_terms = self.__class__.linearized_dpm_mixture_fraction_source_terms(service, version, mode, path + ["linearized_dpm_mixture_fraction_source_terms"])
                        self.linearized_dpm_source_terms = self.__class__.linearized_dpm_source_terms(service, version, mode, path + ["linearized_dpm_source_terms"])
                        self.linearized_dpm_source_terms_limiter = self.__class__.linearized_dpm_source_terms_limiter(service, version, mode, path + ["linearized_dpm_source_terms_limiter"])
                        self.linearized_dpm_species_source_terms = self.__class__.linearized_dpm_species_source_terms(service, version, mode, path + ["linearized_dpm_species_source_terms"])
                        self.max_vf_allowed_for_blocking = self.__class__.max_vf_allowed_for_blocking(service, version, mode, path + ["max_vf_allowed_for_blocking"])
                        self.min_vf_threshold_for_dpm_src_scaling = self.__class__.min_vf_threshold_for_dpm_src_scaling(service, version, mode, path + ["min_vf_threshold_for_dpm_src_scaling"])
                        self.replace_dpm_mass_source_by_mixture_fraction = self.__class__.replace_dpm_mass_source_by_mixture_fraction(service, version, mode, path + ["replace_dpm_mass_source_by_mixture_fraction"])
                        self.reset_sources_at_timestep = self.__class__.reset_sources_at_timestep(service, version, mode, path + ["reset_sources_at_timestep"])
                        self.second_order_time_accurate_sources_enabled = self.__class__.second_order_time_accurate_sources_enabled(service, version, mode, path + ["second_order_time_accurate_sources_enabled"])
                        self.underrelaxation_factor = self.__class__.underrelaxation_factor(service, version, mode, path + ["underrelaxation_factor"])
                        self.update_dpm_sources_every_flow_iteration = self.__class__.update_dpm_sources_every_flow_iteration(service, version, mode, path + ["update_dpm_sources_every_flow_iteration"])
                        super().__init__(service, version, mode, path)
                    class choice_of_eulerian_phase_for_interaction(TUIMethod):
                        """
                        Enable/disable the option to choose for every injection the Eulerian phase for the DPM continuous phase interaction.
                        """
                    class coupled_calculations(TUIMethod):
                        """
                        Selects whether or not to couple continuous and discrete phase calculations.
                        """
                    class ddpm_energy_coupling_via_source_term(TUIMethod):
                        """
                        Energy coupling in DDPM established via source term.
                        """
                    class ddpm_enhanced_inter_phase_exchange(TUIMethod):
                        """
                        Enhanced Eulerian inter-phase exchange.
                        """
                    class ddpm_iad_particle(TUIMethod):
                        """
                        Enable/disable the non-default interfacial area method IA-particle.
                        """
                    class dpm_iteration_interval(TUIMethod):
                        """
                        Sets the frequency with which the particle trajectory calculations are introduced.
                        """
                    class enable_drag_scaling_due_to_flow_blocking(TUIMethod):
                        """
                        .
                        """
                    class enable_flow_blocking_by_particles(TUIMethod):
                        """
                        .
                        """
                    class enable_mom_source_scaling_due_to_flow_blocking(TUIMethod):
                        """
                        .
                        """
                    class enable_other_source_scaling_due_to_flow_blocking(TUIMethod):
                        """
                        .
                        """
                    class enable_source_scaling_due_to_flow_blocking(TUIMethod):
                        """
                        Enable/disable scaling of DPM source terms due to inclusion of DPM volume fraction in continuous flow.
                        """
                    class enhanced_source_term_linearization_enabled(TUIMethod):
                        """
                        .
                        """
                    class implicit_momentum_coupling(TUIMethod):
                        """
                        Enables/disables implicit treatment for the DPM momentum source terms.
                        """
                    class implicit_source_term_coupling(TUIMethod):
                        """
                        Enables/disables implicit treatment for all DPM source terms.
                        """
                    class keep_linearized_dpm_source_terms_constant(TUIMethod):
                        """
                        .
                        """
                    class linear_growth_of_dpm_source_term(TUIMethod):
                        """
                        Enables/disables the linear ramping up of the DPM source terms at every DPM iteration.
                        """
                    class linearized_dpm_mixture_fraction_source_terms(TUIMethod):
                        """
                        Enables/disables linearization of mixture fraction source terms. This command is available only for non- or partially-premixed combustion cases.
                        """
                    class linearized_dpm_source_terms(TUIMethod):
                        """
                        Enables/disables linearization of source terms for the discrete phase.
                        """
                    class linearized_dpm_source_terms_limiter(TUIMethod):
                        """
                        .
                        """
                    class linearized_dpm_species_source_terms(TUIMethod):
                        """
                        Perform linearization of species source terms.
                        """
                    class max_vf_allowed_for_blocking(TUIMethod):
                        """
                        .
                        """
                    class min_vf_threshold_for_dpm_src_scaling(TUIMethod):
                        """
                        Minimum DPM volume fraction below which no DPM source scaling is applied.
                        """
                    class replace_dpm_mass_source_by_mixture_fraction(TUIMethod):
                        """
                        When enabled, recalculates the mixture fraction source terms as a function of the primary mixture fraction. This command is available for non- or partially-premixed combustion cases only.
                        """
                    class reset_sources_at_timestep(TUIMethod):
                        """
                        Enables/disables flush of DPM source terms at beginning of every time step.
                        """
                    class second_order_time_accurate_sources_enabled(TUIMethod):
                        """
                        .
                        """
                    class underrelaxation_factor(TUIMethod):
                        """
                        Sets the under-relaxation factor for the discrete phase sources.
                        """
                    class update_dpm_sources_every_flow_iteration(TUIMethod):
                        """
                        Enables/disables the update of DPM source terms every flow iteration (if this option is not enabled, the terms will be updated every DPM iteration).
                        """

                class numerics(TUIMenu):
                    """
                    Enters the numerics menu to set numerical solution parameters.
                    """
                    def __init__(self, service, version, mode, path):
                        self.high_resolution_tracking = self.__class__.high_resolution_tracking(service, version, mode, path + ["high_resolution_tracking"])
                        self.automated_scheme_selection = self.__class__.automated_scheme_selection(service, version, mode, path + ["automated_scheme_selection"])
                        self.average_DDPM_variables = self.__class__.average_DDPM_variables(service, version, mode, path + ["average_DDPM_variables"])
                        self.average_each_step = self.__class__.average_each_step(service, version, mode, path + ["average_each_step"])
                        self.average_kernel = self.__class__.average_kernel(service, version, mode, path + ["average_kernel"])
                        self.average_source_terms = self.__class__.average_source_terms(service, version, mode, path + ["average_source_terms"])
                        self.coupled_heat_mass_update = self.__class__.coupled_heat_mass_update(service, version, mode, path + ["coupled_heat_mass_update"])
                        self.drag_law = self.__class__.drag_law(service, version, mode, path + ["drag_law"])
                        self.dynamic_interaction = self.__class__.dynamic_interaction(service, version, mode, path + ["dynamic_interaction"])
                        self.enable_node_based_averaging = self.__class__.enable_node_based_averaging(service, version, mode, path + ["enable_node_based_averaging"])
                        self.enhanced_packing_limit_numerics = self.__class__.enhanced_packing_limit_numerics(service, version, mode, path + ["enhanced_packing_limit_numerics"])
                        self.error_control = self.__class__.error_control(service, version, mode, path + ["error_control"])
                        self.gaussian_factor = self.__class__.gaussian_factor(service, version, mode, path + ["gaussian_factor"])
                        self.granular_stress_tensor = self.__class__.granular_stress_tensor(service, version, mode, path + ["granular_stress_tensor"])
                        self.limit_granular_forces = self.__class__.limit_granular_forces(service, version, mode, path + ["limit_granular_forces"])
                        self.minimum_liquid_fraction = self.__class__.minimum_liquid_fraction(service, version, mode, path + ["minimum_liquid_fraction"])
                        self.mppic_settings = self.__class__.mppic_settings(service, version, mode, path + ["mppic_settings"])
                        self.packed_region_detection_enabled = self.__class__.packed_region_detection_enabled(service, version, mode, path + ["packed_region_detection_enabled"])
                        self.predictor_corrector = self.__class__.predictor_corrector(service, version, mode, path + ["predictor_corrector"])
                        self.re_randomize_every_iteration = self.__class__.re_randomize_every_iteration(service, version, mode, path + ["re_randomize_every_iteration"])
                        self.re_randomize_every_timestep = self.__class__.re_randomize_every_timestep(service, version, mode, path + ["re_randomize_every_timestep"])
                        self.tracking_parameters = self.__class__.tracking_parameters(service, version, mode, path + ["tracking_parameters"])
                        self.tracking_scheme = self.__class__.tracking_scheme(service, version, mode, path + ["tracking_scheme"])
                        self.tracking_statistics = self.__class__.tracking_statistics(service, version, mode, path + ["tracking_statistics"])
                        self.underrelax_film_height = self.__class__.underrelax_film_height(service, version, mode, path + ["underrelax_film_height"])
                        self.vaporization_limiting_factors = self.__class__.vaporization_limiting_factors(service, version, mode, path + ["vaporization_limiting_factors"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        super().__init__(service, version, mode, path)
                    class automated_scheme_selection(TUIMethod):
                        """
                        Enables/disables the adaptation of integration step length based on a maximum error.
                        """
                    class average_DDPM_variables(TUIMethod):
                        """
                        Enables/disables mesh node averaging of DDPM quantities.
                        """
                    class average_each_step(TUIMethod):
                        """
                        Enables/disables mesh node averaging during integration time step.
                        """
                    class average_kernel(TUIMethod):
                        """
                        Specifies the averaging kernel to use for mesh node averaging.
                        """
                    class average_source_terms(TUIMethod):
                        """
                        Enables/disables mesh node averaging of DPM source terms.
                        """
                    class coupled_heat_mass_update(TUIMethod):
                        """
                        Enables/disables coupled heat and mass update.
                        """
                    class drag_law(TUIMethod):
                        """
                        Sets the drag law.
                        """
                    class dynamic_interaction(TUIMethod):
                        """
                        Enable/disable dynamic interaction range.
                        """
                    class enable_node_based_averaging(TUIMethod):
                        """
                        Enables/disables mesh node averaging of DPM quantities.
                        """
                    class enhanced_packing_limit_numerics(TUIMethod):
                        """
                        Enable enhanced packing limit numerics to avoid exceeding of packing limit for granular phases.
                        """
                    class error_control(TUIMethod):
                        """
                        Adapts integration step length based on a maximum error.
                        """
                    class gaussian_factor(TUIMethod):
                        """
                        Specifies the Gaussian constant when using thegaussian kernel for mesh node averaging.
                        """
                    class granular_stress_tensor(TUIMethod):
                        """
                        Enable granular stress tensor to be considered with solid pressure gradient as collision force.
                        """
                    class limit_granular_forces(TUIMethod):
                        """
                        Enable limiting of granular forces from solid pressure gradients to avoid particle velocity overshoots.
                        """
                    class minimum_liquid_fraction(TUIMethod):
                        """
                        A droplet evaporates completely when the remaining mass is below this fraction of the initial droplet mass.
                        """
                    class mppic_settings(TUIMethod):
                        """
                        Enable PIC and MPPIC to compute DPM and DDPM source terms.
                        """
                    class packed_region_detection_enabled(TUIMethod):
                        """
                        Identify cells in packed region to apply limiting of granular forces.
                        """
                    class predictor_corrector(TUIMethod):
                        """
                        Enable predictor/corrector approach to track particles.
                        """
                    class re_randomize_every_iteration(TUIMethod):
                        """
                        Determines whether or not the initial particle positions will vary from iteration to iteration.
                        """
                    class re_randomize_every_timestep(TUIMethod):
                        """
                        Determines whether or not the initial particle positions will vary from time step to time step.
                        """
                    class tracking_parameters(TUIMethod):
                        """
                        Sets parameters for the (initial) tracking step length.
                        """
                    class tracking_scheme(TUIMethod):
                        """
                        Specifies a tracking scheme.
                        """
                    class tracking_statistics(TUIMethod):
                        """
                        Controls the format of the one-line tracking statistics to be printed after every DPM tracking pass. A value of 0 (the default) prints only fates with non-zero values. A value of 1 prints all fates, including fates with zero values.
                        """
                    class underrelax_film_height(TUIMethod):
                        """
                        Sets the under-relaxation factor for the film height calculation. The recommended values range between 0.5 (default) and 0.9.
                        """
                    class vaporization_limiting_factors(TUIMethod):
                        """
                        Sets the Vaporization Fractional Change Limits.
                        """
                    class verbosity(TUIMethod):
                        """
                        .
                        """

                    class high_resolution_tracking(TUIMenu):
                        """
                        Enters the high resolution tracking menu. See  for more information about these options.
                        """
                        def __init__(self, service, version, mode, path):
                            self.barycentric_interpolation = self.__class__.barycentric_interpolation(service, version, mode, path + ["barycentric_interpolation"])
                            self.particle_relocation = self.__class__.particle_relocation(service, version, mode, path + ["particle_relocation"])
                            self.always_use_face_centroid_with_periodics = self.__class__.always_use_face_centroid_with_periodics(service, version, mode, path + ["always_use_face_centroid_with_periodics"])
                            self.boundary_layer_tracking = self.__class__.boundary_layer_tracking(service, version, mode, path + ["boundary_layer_tracking"])
                            self.check_subtet_validity = self.__class__.check_subtet_validity(service, version, mode, path + ["check_subtet_validity"])
                            self.enable_automatic_intersection_tolerance = self.__class__.enable_automatic_intersection_tolerance(service, version, mode, path + ["enable_automatic_intersection_tolerance"])
                            self.enable_barycentric_intersections = self.__class__.enable_barycentric_intersections(service, version, mode, path + ["enable_barycentric_intersections"])
                            self.enable_high_resolution_tracking = self.__class__.enable_high_resolution_tracking(service, version, mode, path + ["enable_high_resolution_tracking"])
                            self.enhanced_wallfilm_location_method = self.__class__.enhanced_wallfilm_location_method(service, version, mode, path + ["enhanced_wallfilm_location_method"])
                            self.load_legacy_particles = self.__class__.load_legacy_particles(service, version, mode, path + ["load_legacy_particles"])
                            self.project_wall_film_particles_to_film = self.__class__.project_wall_film_particles_to_film(service, version, mode, path + ["project_wall_film_particles_to_film"])
                            self.remove_stuck_particles = self.__class__.remove_stuck_particles(service, version, mode, path + ["remove_stuck_particles"])
                            self.set_film_spreading_parameter = self.__class__.set_film_spreading_parameter(service, version, mode, path + ["set_film_spreading_parameter"])
                            self.set_subtet_intersection_tolerance = self.__class__.set_subtet_intersection_tolerance(service, version, mode, path + ["set_subtet_intersection_tolerance"])
                            self.sliding_interface_crossover_fraction = self.__class__.sliding_interface_crossover_fraction(service, version, mode, path + ["sliding_interface_crossover_fraction"])
                            self.use_barycentric_sampling = self.__class__.use_barycentric_sampling(service, version, mode, path + ["use_barycentric_sampling"])
                            self.use_legacy_particle_location_method = self.__class__.use_legacy_particle_location_method(service, version, mode, path + ["use_legacy_particle_location_method"])
                            self.use_particle_timestep_for_intersection_tolerance = self.__class__.use_particle_timestep_for_intersection_tolerance(service, version, mode, path + ["use_particle_timestep_for_intersection_tolerance"])
                            self.use_quad_face_centroid = self.__class__.use_quad_face_centroid(service, version, mode, path + ["use_quad_face_centroid"])
                            self.use_velocity_based_error_control = self.__class__.use_velocity_based_error_control(service, version, mode, path + ["use_velocity_based_error_control"])
                            self.wallfilm_relocation_tolerance = self.__class__.wallfilm_relocation_tolerance(service, version, mode, path + ["wallfilm_relocation_tolerance"])
                            super().__init__(service, version, mode, path)
                        class always_use_face_centroid_with_periodics(TUIMethod):
                            """
                            When enabled, ANSYS Fluent uses quad face centroids when creating subtets in cases with periodic boundaries.
                            """
                        class boundary_layer_tracking(TUIMethod):
                            """
                            Enables/disables the calculation of the particle time step that considers both the cell aspect ratio and the particle trajectory. This method improves the accuracy of the predictions in boundary layer cells, particularly in layers where flow gradients are large.
                            """
                        class check_subtet_validity(TUIMethod):
                            """
                            When enabled, checks the validity of a subtet when the particle first enters it. If the subtet is found to be degenerate, the tracking algorithm modifies to accommodate it.
                            """
                        class enable_automatic_intersection_tolerance(TUIMethod):
                            """
                            Enables/disables the automatic calculation of intersection tolerance. By default, the tolerance used in intersection calculations is scaled by the residence time of the particle in the cell to improve robustness. For most cases, the scaled tolerance is sufficient to identify all intersections of the particle trajectory and the subtet faces. You can set the intersection tolerance manually using the set-subtet-intersection-tolerance text command.
                            """
                        class enable_barycentric_intersections(TUIMethod):
                            """
                            Enables/disables an alternative method of calculating intersections with cell boundaries. Barycentric intersections are linear calculations and are faster than the default intersection algorithm. The default intersection algorithm is second-order for stationary meshes; therefore, using the barycentric intersection may sacrifice accuracy. You must verify that the barycentric intersections provide comparable results to the default intersection method. This option is available only for 3D stationary meshes and the double precision solver.
                            """
                        class enable_high_resolution_tracking(TUIMethod):
                            """
                            Enables/disables high resolution tracking.
                            """
                        class enhanced_wallfilm_location_method(TUIMethod):
                            """
                            Enable enhanced method of locating film particles on faces.
                            """
                        class load_legacy_particles(TUIMethod):
                            """
                            Load particles that were tracked without high-resolution tracking enabled.
                            """
                        class project_wall_film_particles_to_film(TUIMethod):
                            """
                            Enables/disables projecting existing particles to Lagrangian wall film to track using high-resolution tracking.  When reading in a data file that contains wall film particles previously tracked with the existing ANSYS Fluent tracking method, you need to either clear the particles from the domain or project their positions to the wall film surface using the project-wall-film-particles-to-film? text command prior to using the high-resolution tracking method. After tracking the particles for one timestep, this option can be disabled to improve performance.
                            """
                        class remove_stuck_particles(TUIMethod):
                            """
                            .
                            """
                        class set_film_spreading_parameter(TUIMethod):
                            """
                            Set the spreading parameter for Lagrangian wallfilm particles.
                            """
                        class set_subtet_intersection_tolerance(TUIMethod):
                            """
                            Specifies the tolerance used in intersection calculations. This tolerance will be scaled by the characteristic cell crossing time of the particle if the enable-automatic-intersection-tolerance? text command is enabled. If that option is disabled, the specified tolerance will be used without scaling. The default intersection tolerance is 10-5.
                            """
                        class sliding_interface_crossover_fraction(TUIMethod):
                            """
                            Specifies the fraction of the distance to the subtet center to move the particle.  At non-conformal interfaces, the nodes used for the barycentric interpolation are different on either side of the interface. This may result in incomplete particles due to discontinuities in the variable interpolation. The number of incomplete particles may be reduced by moving the particles slightly off of the sliding interface. Recommended values range between 0 and 0.5.
                            """
                        class use_barycentric_sampling(TUIMethod):
                            """
                            When enabled, this option provides improved accuracy and parallel consistency when sampling particles at planes. This item is available only with the 3D solver. Using the double-precision solver and bounded planes is recommended.
                            """
                        class use_legacy_particle_location_method(TUIMethod):
                            """
                            Enable legacy method of locating particles in cells.
                            """
                        class use_particle_timestep_for_intersection_tolerance(TUIMethod):
                            """
                            Enables/disables the use of the particle timestep for the subtet intersection tolerance with axisymmetric grids (default: enabled). If disabled, the tolerance will be calculated in the same manner as non-axisymmetric meshes (a scaled value of the tolerance which is set using the define/models/dpm/numerics/high-resolution-tracking/set-subtet-intersection-tolerance text command).
                            """
                        class use_quad_face_centroid(TUIMethod):
                            """
                            Enables/disables using quad face centroids when creating subtets. This option changes the way hexahedral cells are decomposed to avoid creating degenerate subtets.
                            """
                        class use_velocity_based_error_control(TUIMethod):
                            """
                            Enables/disables an alternative method of timestep adaption. By default, ANSYS Fluent uses the half-step method of timestep adaption with particle integration. This alternative method of controlling the integration timestep based upon velocity changes is faster; however, you need to ensure that the accuracy is comparable for your specific application.
                            """
                        class wallfilm_relocation_tolerance(TUIMethod):
                            """
                            Set the relocation tolerance for wallfilm particles after remeshing.
                            """

                        class barycentric_interpolation(TUIMenu):
                            """
                            Enter the barycentric interpolation menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.enable_transient_variable_interpolation = self.__class__.enable_transient_variable_interpolation(service, version, mode, path + ["enable_transient_variable_interpolation"])
                                self.interpolate_flow_cp = self.__class__.interpolate_flow_cp(service, version, mode, path + ["interpolate_flow_cp"])
                                self.interpolate_flow_density = self.__class__.interpolate_flow_density(service, version, mode, path + ["interpolate_flow_density"])
                                self.interpolate_flow_solution_gradients = self.__class__.interpolate_flow_solution_gradients(service, version, mode, path + ["interpolate_flow_solution_gradients"])
                                self.interpolate_flow_viscosity = self.__class__.interpolate_flow_viscosity(service, version, mode, path + ["interpolate_flow_viscosity"])
                                self.interpolate_temperature = self.__class__.interpolate_temperature(service, version, mode, path + ["interpolate_temperature"])
                                self.interpolate_wallfilm_properties = self.__class__.interpolate_wallfilm_properties(service, version, mode, path + ["interpolate_wallfilm_properties"])
                                self.nodal_reconstruction_frequency = self.__class__.nodal_reconstruction_frequency(service, version, mode, path + ["nodal_reconstruction_frequency"])
                                self.precompute_pdf_species = self.__class__.precompute_pdf_species(service, version, mode, path + ["precompute_pdf_species"])
                                self.user_interpolation_function = self.__class__.user_interpolation_function(service, version, mode, path + ["user_interpolation_function"])
                                self.zero_nodal_velocity_on_walls = self.__class__.zero_nodal_velocity_on_walls(service, version, mode, path + ["zero_nodal_velocity_on_walls"])
                                super().__init__(service, version, mode, path)
                            class enable_transient_variable_interpolation(TUIMethod):
                                """
                                Enable transient variable interpolation.
                                """
                            class interpolate_flow_cp(TUIMethod):
                                """
                                Enables/disables the barycentric interpolation of specific heat to the particle position. This option is recommended when the specific heat varies with position to avoid discontinuities in the interpolated variable at cell boundaries. For flows with constant specific heat, this option is unnecessary.
                                """
                            class interpolate_flow_density(TUIMethod):
                                """
                                Enables/disables the barycentric interpolation of the flow density. This option is recommended when the density varies with position to avoid discontinuities in the interpolated variable at cell boundaries. For constant density flows, this option is unnecessary.
                                """
                            class interpolate_flow_solution_gradients(TUIMethod):
                                """
                                When enabled, flow solution gradients are interpolated to the particle position. This can be useful when using physical models that depend on these gradients (for example, the thermophoretic force, pressure-gradient force, or virtual mass force). Interpolating the gradients also improves the accuracy and robustness of the trapezoidal numerics scheme, which is the default method for pathlines.
                                """
                            class interpolate_flow_viscosity(TUIMethod):
                                """
                                Enables/disables the barycentric interpolation of flow viscosity to the particle position. This option is recommended when the flow viscosity varies with position to avoid discontinuities in the interpolated variable at cell boundaries. For flows with constant viscosity, this option is unnecessary.
                                """
                            class interpolate_temperature(TUIMethod):
                                """
                                Enables/disables the barycentric interpolation of temperature to the particle position. The cell temperature is used by default in calculations of heat transfer to/from the particle.
                                """
                            class interpolate_wallfilm_properties(TUIMethod):
                                """
                                When enabled, the wall film properties (film height, film mass, and wall shear) are interpolated to the particle position.
                                """
                            class nodal_reconstruction_frequency(TUIMethod):
                                """
                                Update nodal reconstruction every N'th DPM iteration.
                                """
                            class precompute_pdf_species(TUIMethod):
                                """
                                When this option is enabled for premixed or non-premixed combustion simulations, the species composition in each cell is precomputed prior to tracking particles. This approach may improve performance for cases with many particles and relatively few cells. By default, this option is set to no, and ANSYS Fluent calculates the species composition during particle tracking. The solution results will be identical for both methods.
                                """
                            class user_interpolation_function(TUIMethod):
                                """
                                .
                                """
                            class zero_nodal_velocity_on_walls(TUIMethod):
                                """
                                When enabled, sets the velocity at wall nodes to zero. (By default, the nodal velocities on walls are first reconstructed from cell and face values and then corrected to ensure that there are no velocity components directed towards the walls). This may be useful if you want to consider particle impingement on the walls. Note that enabling this option will more likely produce incomplete particles as some particles may settle on the walls.
                                """

                        class particle_relocation(TUIMenu):
                            """
                            Enter the particle relocation menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.enhanced_cell_relocation_method = self.__class__.enhanced_cell_relocation_method(service, version, mode, path + ["enhanced_cell_relocation_method"])
                                self.enhanced_wallfilm_location_method = self.__class__.enhanced_wallfilm_location_method(service, version, mode, path + ["enhanced_wallfilm_location_method"])
                                self.load_legacy_particles = self.__class__.load_legacy_particles(service, version, mode, path + ["load_legacy_particles"])
                                self.overset_relocation_robustness_level = self.__class__.overset_relocation_robustness_level(service, version, mode, path + ["overset_relocation_robustness_level"])
                                self.use_legacy_particle_location_method = self.__class__.use_legacy_particle_location_method(service, version, mode, path + ["use_legacy_particle_location_method"])
                                self.wallfilm_relocation_tolerance_scale_factor = self.__class__.wallfilm_relocation_tolerance_scale_factor(service, version, mode, path + ["wallfilm_relocation_tolerance_scale_factor"])
                                super().__init__(service, version, mode, path)
                            class enhanced_cell_relocation_method(TUIMethod):
                                """
                                .
                                """
                            class enhanced_wallfilm_location_method(TUIMethod):
                                """
                                Enable enhanced method of locating film particles on faces.
                                """
                            class load_legacy_particles(TUIMethod):
                                """
                                .
                                """
                            class overset_relocation_robustness_level(TUIMethod):
                                """
                                .
                                """
                            class use_legacy_particle_location_method(TUIMethod):
                                """
                                .
                                """
                            class wallfilm_relocation_tolerance_scale_factor(TUIMethod):
                                """
                                Set the relocation tolerance scaling factor for wallfilm particles after remeshing.
                                """

                class options(TUIMenu):
                    """
                    Enters the options menu to set optional models.
                    """
                    def __init__(self, service, version, mode, path):
                        self.allow_supercritical_pressure_vaporization = self.__class__.allow_supercritical_pressure_vaporization(service, version, mode, path + ["allow_supercritical_pressure_vaporization"])
                        self.brownian_motion = self.__class__.brownian_motion(service, version, mode, path + ["brownian_motion"])
                        self.convective_film_heat_transfer = self.__class__.convective_film_heat_transfer(service, version, mode, path + ["convective_film_heat_transfer"])
                        self.current_positions_in_sample_file_format = self.__class__.current_positions_in_sample_file_format(service, version, mode, path + ["current_positions_in_sample_file_format"])
                        self.enable_contour_plots = self.__class__.enable_contour_plots(service, version, mode, path + ["enable_contour_plots"])
                        self.ensemble_average = self.__class__.ensemble_average(service, version, mode, path + ["ensemble_average"])
                        self.erosion_accretion = self.__class__.erosion_accretion(service, version, mode, path + ["erosion_accretion"])
                        self.film_movement = self.__class__.film_movement(service, version, mode, path + ["film_movement"])
                        self.include_lwf_particles_in_dpm_concentration = self.__class__.include_lwf_particles_in_dpm_concentration(service, version, mode, path + ["include_lwf_particles_in_dpm_concentration"])
                        self.init_erosion_accretion_rate = self.__class__.init_erosion_accretion_rate(service, version, mode, path + ["init_erosion_accretion_rate"])
                        self.lowest_volatiles_mass_fraction = self.__class__.lowest_volatiles_mass_fraction(service, version, mode, path + ["lowest_volatiles_mass_fraction"])
                        self.maximum_udf_species = self.__class__.maximum_udf_species(service, version, mode, path + ["maximum_udf_species"])
                        self.particle_radiation = self.__class__.particle_radiation(service, version, mode, path + ["particle_radiation"])
                        self.pressure_gradient_force = self.__class__.pressure_gradient_force(service, version, mode, path + ["pressure_gradient_force"])
                        self.remove_wall_film_temperature_limiter = self.__class__.remove_wall_film_temperature_limiter(service, version, mode, path + ["remove_wall_film_temperature_limiter"])
                        self.saffman_lift_force = self.__class__.saffman_lift_force(service, version, mode, path + ["saffman_lift_force"])
                        self.scr_urea_deposition_risk_analysis = self.__class__.scr_urea_deposition_risk_analysis(service, version, mode, path + ["scr_urea_deposition_risk_analysis"])
                        self.set_minimum_particle_diameter = self.__class__.set_minimum_particle_diameter(service, version, mode, path + ["set_minimum_particle_diameter"])
                        self.set_thermolysis_limit = self.__class__.set_thermolysis_limit(service, version, mode, path + ["set_thermolysis_limit"])
                        self.stagger_radius = self.__class__.stagger_radius(service, version, mode, path + ["stagger_radius"])
                        self.stagger_spatially_atomizer_injections = self.__class__.stagger_spatially_atomizer_injections(service, version, mode, path + ["stagger_spatially_atomizer_injections"])
                        self.stagger_spatially_standard_injections = self.__class__.stagger_spatially_standard_injections(service, version, mode, path + ["stagger_spatially_standard_injections"])
                        self.stagger_temporally = self.__class__.stagger_temporally(service, version, mode, path + ["stagger_temporally"])
                        self.staggering_factor = self.__class__.staggering_factor(service, version, mode, path + ["staggering_factor"])
                        self.step_report_sig_figures = self.__class__.step_report_sig_figures(service, version, mode, path + ["step_report_sig_figures"])
                        self.thermophoretic_force = self.__class__.thermophoretic_force(service, version, mode, path + ["thermophoretic_force"])
                        self.track_in_absolute_frame = self.__class__.track_in_absolute_frame(service, version, mode, path + ["track_in_absolute_frame"])
                        self.treat_multicomponent_saturation_temperature_failure = self.__class__.treat_multicomponent_saturation_temperature_failure(service, version, mode, path + ["treat_multicomponent_saturation_temperature_failure"])
                        self.two_way_coupling = self.__class__.two_way_coupling(service, version, mode, path + ["two_way_coupling"])
                        self.uniform_mass_distribution_for_injections = self.__class__.uniform_mass_distribution_for_injections(service, version, mode, path + ["uniform_mass_distribution_for_injections"])
                        self.use_absolute_pressure_for_vaporization = self.__class__.use_absolute_pressure_for_vaporization(service, version, mode, path + ["use_absolute_pressure_for_vaporization"])
                        self.vaporization_heat_transfer_averaging = self.__class__.vaporization_heat_transfer_averaging(service, version, mode, path + ["vaporization_heat_transfer_averaging"])
                        self.vaporization_options = self.__class__.vaporization_options(service, version, mode, path + ["vaporization_options"])
                        self.virtual_mass_force = self.__class__.virtual_mass_force(service, version, mode, path + ["virtual_mass_force"])
                        super().__init__(service, version, mode, path)
                    class allow_supercritical_pressure_vaporization(TUIMethod):
                        """
                        Enforces the switching from vaporization to boiling even if the boiling point is not calculated from the vapor pressure data. If the pressure in your model is above critical you must retain the default setting (yes). This options is available only if whenPressure Dependent Boiling is enabled in the Physical Models tab of the Discrete Phase Models dialog box. For more details, see .
                        """
                    class brownian_motion(TUIMethod):
                        """
                        Enables/disables Brownian motion of particles.
                        """
                    class convective_film_heat_transfer(TUIMethod):
                        """
                        Enable/disable convection/conduction film to wall heat transfer model.
                        """
                    class current_positions_in_sample_file_format(TUIMethod):
                        """
                        When enabled, generates a file containing particle current positions (step-by-step history report for unsteady tracking) in the sampling file format.
                        """
                    class enable_contour_plots(TUIMethod):
                        """
                        Enables computation of mean and/or RMS values of additional discrete phase variables for postprocessing.
                        """
                    class ensemble_average(TUIMethod):
                        """
                        Ensembles average cloud properties.
                        """
                    class erosion_accretion(TUIMethod):
                        """
                        Enables/disables erosion/accretion.
                        """
                    class film_movement(TUIMethod):
                        """
                        .
                        """
                    class include_lwf_particles_in_dpm_concentration(TUIMethod):
                        """
                        .
                        """
                    class init_erosion_accretion_rate(TUIMethod):
                        """
                        Initializes the erosion/accretion rates with zero.
                        """
                    class lowest_volatiles_mass_fraction(TUIMethod):
                        """
                        Set the lowest volatiles mass fraction.
                        """
                    class maximum_udf_species(TUIMethod):
                        """
                        Specifies the maximum number of species that will be accessible from discrete phase model UDFs. Only species with indices up to this value are accessible in discrete phase model UDFs.
                        """
                    class particle_radiation(TUIMethod):
                        """
                        Enables/disables particle radiation.
                        """
                    class pressure_gradient_force(TUIMethod):
                        """
                        Enables/disables inclusion of pressure gradient effects in the particle force balance.
                        """
                    class remove_wall_film_temperature_limiter(TUIMethod):
                        """
                        Answering yes at the prompt removes the wall temperature limiter for Lagrangian wall-film walls. If you enter no (default), two additional prompts will appear in the console allowing you to define the temperature difference above the boiling point and to enable/disable the reporting of the Leidenfrost temperature on the wall faces.
                        """
                    class saffman_lift_force(TUIMethod):
                        """
                        Enables/disables Saffman lift force.
                        """
                    class scr_urea_deposition_risk_analysis(TUIMethod):
                        """
                        Enters the menu for setting up the risk for solids deposit formation for the Selective Catalytic Reduction (SCR) process. For more information, see .
                        """
                    class set_minimum_particle_diameter(TUIMethod):
                        """
                        Set the minimum particle diameter.
                        """
                    class set_thermolysis_limit(TUIMethod):
                        """
                        Sets the limit for the thermolysis model.
                        """
                    class stagger_radius(TUIMethod):
                        """
                        Specifies the region over which to spatially stagger particles when particle-staggering is enabled for non-atomizer injections.
                        """
                    class stagger_spatially_atomizer_injections(TUIMethod):
                        """
                        Enables/disables spatial staggering for atomizer and solid-cone injections.
                        """
                    class stagger_spatially_standard_injections(TUIMethod):
                        """
                        Enables/disables spatial staggering for standard (non-atomizer and non-solid-cone) injections.
                        """
                    class stagger_temporally(TUIMethod):
                        """
                        Enables/disables temporal staggering.
                        """
                    class staggering_factor(TUIMethod):
                        """
                        S.
                        """
                    class step_report_sig_figures(TUIMethod):
                        """
                        Sets significant figures in the step-by-step report.
                        """
                    class thermophoretic_force(TUIMethod):
                        """
                        Enables/disables thermophoretic force.
                        """
                    class track_in_absolute_frame(TUIMethod):
                        """
                        Enables/disables tracking in absolute frame.
                        """
                    class treat_multicomponent_saturation_temperature_failure(TUIMethod):
                        """
                        Enables/disables dumping multicomponent particle mass into the continuous phase if the saturation temperature calculation fails.
                        """
                    class two_way_coupling(TUIMethod):
                        """
                        Enables/disables calculation of DPM sources in TKE equation.
                        """
                    class uniform_mass_distribution_for_injections(TUIMethod):
                        """
                        Specifies a uniform distribution of mass over the cross-section of solid cone and atomizer injections. This can become important when the mesh is smaller than the diameter (or another characteristic size) of the injection.
                        """
                    class use_absolute_pressure_for_vaporization(TUIMethod):
                        """
                        Determines whether the absolute pressure or constant operating pressure (specified in define/operating-conditions/operating-pressure) will be used in vaporization rates calculations.
                        """
                    class vaporization_heat_transfer_averaging(TUIMethod):
                        """
                        Enables averaging of the Spalding heat transfer term for the convection/diffusion-controlled model.
                        """
                    class vaporization_options(TUIMethod):
                        """
                        Sets Vaporization options.
                        """
                    class virtual_mass_force(TUIMethod):
                        """
                        Enables/disables inclusion of the virtual mass force in the particle force balance.
                        """

                class parallel(TUIMenu):
                    """
                    Enters the parallel menu to set parameters for parallel DPM calculations.
                    """
                    def __init__(self, service, version, mode, path):
                        self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                        self.enable_workpile = self.__class__.enable_workpile(service, version, mode, path + ["enable_workpile"])
                        self.fix_source_term_accumulation_order = self.__class__.fix_source_term_accumulation_order(service, version, mode, path + ["fix_source_term_accumulation_order"])
                        self.hybrid_2domain = self.__class__.hybrid_2domain(service, version, mode, path + ["hybrid_2domain"])
                        self.hybrid_collision_model = self.__class__.hybrid_collision_model(service, version, mode, path + ["hybrid_collision_model"])
                        self.hybrid_collision_unidirectional = self.__class__.hybrid_collision_unidirectional(service, version, mode, path + ["hybrid_collision_unidirectional"])
                        self.hybrid_collision_variant = self.__class__.hybrid_collision_variant(service, version, mode, path + ["hybrid_collision_variant"])
                        self.hybrid_workpile = self.__class__.hybrid_workpile(service, version, mode, path + ["hybrid_workpile"])
                        self.n_threads = self.__class__.n_threads(service, version, mode, path + ["n_threads"])
                        self.report = self.__class__.report(service, version, mode, path + ["report"])
                        self.use_hybrid = self.__class__.use_hybrid(service, version, mode, path + ["use_hybrid"])
                        self.use_message_passing = self.__class__.use_message_passing(service, version, mode, path + ["use_message_passing"])
                        self.use_shared_memory = self.__class__.use_shared_memory(service, version, mode, path + ["use_shared_memory"])
                        super().__init__(service, version, mode, path)
                    class enable_workpile(TUIMethod):
                        """
                        Turns on/off particle workpile algorithm. This option is only available when the define/models/dpm/parallel/use-shared-memory option is selected.
                        """
                    class fix_source_term_accumulation_order(TUIMethod):
                        """
                        .
                        """
                    class hybrid_2domain(TUIMethod):
                        """
                        Enables/disables the use of a second domain for DPM particle tracking.
                        """
                    class hybrid_collision_model(TUIMethod):
                        """
                        An EXPERIMENTAL feature to allow 'hybrid' DPM parallel tracking with the collision / coalescence model.
                        """
                    class hybrid_collision_unidirectional(TUIMethod):
                        """
                        A faster, yet potentially somewhat less accurate, modification to the beta feature
                        that allows 'hybrid' DPM parallel tracking with the collision / coalescence model.
                        """
                    class hybrid_collision_variant(TUIMethod):
                        """
                        Further reduce the residual risk of dead-locks in the experimental feature that
                        allows 'hybrid' DPM parallel tracking with the collision / coalescence model.
                        """
                    class hybrid_workpile(TUIMethod):
                        """
                        Optimize multi-thread load balancing within each partition in hybrid-parallel DPM tracking.
                        """
                    class n_threads(TUIMethod):
                        """
                        Sets the number of processors to use for DPM. This option is only available when the define/models/dpm/parallel/enable-workpile? option is enabled.
                        """
                    class report(TUIMethod):
                        """
                        Prints particle workpile statistics. This option is only available when the define/models/dpm/parallel/enable-workpile? option is enabled.
                        """
                    class use_hybrid(TUIMethod):
                        """
                        Specifies that the calculations are performed using multicore cluster computing or shared-memory machines. This option works in conjunction withopenmpi for a dynamic load balancing without migration of cells.
                        """
                    class use_message_passing(TUIMethod):
                        """
                        Specifies that the calculations are performed using cluster computing or shared-memory machines. With this option, the compute node processes themselves perform the particle work on their local partitions and particle migration to other compute nodes is implemented using message passing primitives.
                        """
                    class use_shared_memory(TUIMethod):
                        """
                        Specifies that the calculations are performed on shared-memory multiprocessor machines.
                        """

                    class expert(TUIMenu):
                        """
                        Enters the menu for expert DPM parallel text commands.
                        """
                        def __init__(self, service, version, mode, path):
                            self.partition_method_hybrid_2domain = self.__class__.partition_method_hybrid_2domain(service, version, mode, path + ["partition_method_hybrid_2domain"])
                            super().__init__(service, version, mode, path)
                        class partition_method_hybrid_2domain(TUIMethod):
                            """
                            Enables/disables a partitioning method that is more granular and can yield faster calculations (especially for cases that are running on a low to moderate number of processors). This partitioning method is only applied when you use the DPM domain for the hybrid parallel DPM tracking mode (that is, when you have enabled the define/models/dpm/parallel/hybrid-2domain? text command).
                            """

                class splash_options(TUIMenu):
                    """
                    Enters the splash option menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.orourke_splash_fraction = self.__class__.orourke_splash_fraction(service, version, mode, path + ["orourke_splash_fraction"])
                        self.splash_pdf_limiting = self.__class__.splash_pdf_limiting(service, version, mode, path + ["splash_pdf_limiting"])
                        super().__init__(service, version, mode, path)
                    class orourke_splash_fraction(TUIMethod):
                        """
                        Enables/disables the ORourke formulation (default for the Lagrangian Wall Film (LWF) model). If the ORourke formulation is disabled, the Stanton formulation (default for the Eulerian Wall Film (EWF) model) is used in a simulation.
                        """
                    class splash_pdf_limiting(TUIMethod):
                        """
                        Sets the splash pdf limiting method. Available methods are: the splash pdf tail limiting (default for the LWF model) and the splash pdf peak limiting (default for the EWF model). For the splash pdf peak limiting, you will be prompted to specify the peak limiting value.
                        """

                class stripping_options(TUIMenu):
                    """
                    Enters the stripping options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.diameter_coefficient = self.__class__.diameter_coefficient(service, version, mode, path + ["diameter_coefficient"])
                        self.mass_coefficient = self.__class__.mass_coefficient(service, version, mode, path + ["mass_coefficient"])
                        super().__init__(service, version, mode, path)
                    class diameter_coefficient(TUIMethod):
                        """
                        Sets the diameter coefficient (  in  in the Theory Guide).
                        """
                    class mass_coefficient(TUIMethod):
                        """
                        Sets the mass coefficient (  in  in the Theory Guide).
                        """

            class electrolysis_setup(TUIMenu):
                """
                Enter the electrolysis and H2 pump model setup menu.
                """
                def __init__(self, service, version, mode, path):
                    self.advanced_setup = self.__class__.advanced_setup(service, version, mode, path + ["advanced_setup"])
                    self.anode_setup = self.__class__.anode_setup(service, version, mode, path + ["anode_setup"])
                    self.cathode_setup = self.__class__.cathode_setup(service, version, mode, path + ["cathode_setup"])
                    self.membrane_setup = self.__class__.membrane_setup(service, version, mode, path + ["membrane_setup"])
                    self.electrical_tabs_setup = self.__class__.electrical_tabs_setup(service, version, mode, path + ["electrical_tabs_setup"])
                    self.model_options = self.__class__.model_options(service, version, mode, path + ["model_options"])
                    self.parameters = self.__class__.parameters(service, version, mode, path + ["parameters"])
                    super().__init__(service, version, mode, path)
                class electrical_tabs_setup(TUIMethod):
                    """
                    Specify settings for the electrical tabs.
                    """
                class model_options(TUIMethod):
                    """
                    Specify electrolysis model options.
                    """
                class parameters(TUIMethod):
                    """
                    Specify electrolysis model parameters.
                    """

                class advanced_setup(TUIMenu):
                    """
                    Enter the menu for the advanced controls.
                    """
                    def __init__(self, service, version, mode, path):
                        self.contact_resistivity = self.__class__.contact_resistivity(service, version, mode, path + ["contact_resistivity"])
                        super().__init__(service, version, mode, path)
                    class contact_resistivity(TUIMethod):
                        """
                        Set Contact Resistivity.
                        """

                class anode_setup(TUIMenu):
                    """
                    Enter the menu for the anode controls.
                    """
                    def __init__(self, service, version, mode, path):
                        self.catalyst_layer = self.__class__.catalyst_layer(service, version, mode, path + ["catalyst_layer"])
                        self.current_collector = self.__class__.current_collector(service, version, mode, path + ["current_collector"])
                        self.electrolyte = self.__class__.electrolyte(service, version, mode, path + ["electrolyte"])
                        self.flow_channel = self.__class__.flow_channel(service, version, mode, path + ["flow_channel"])
                        self.porous_layer = self.__class__.porous_layer(service, version, mode, path + ["porous_layer"])
                        super().__init__(service, version, mode, path)
                    class catalyst_layer(TUIMethod):
                        """
                        Set parameters for the catalyst layer.
                        """
                    class current_collector(TUIMethod):
                        """
                        Set parameters for the current collector.
                        """
                    class electrolyte(TUIMethod):
                        """
                        Set parameters for the electrolyte.
                        """
                    class flow_channel(TUIMethod):
                        """
                        Set parameters for the flow channel.
                        """
                    class porous_layer(TUIMethod):
                        """
                        Set parameters for the porous layer.
                        """

                class cathode_setup(TUIMenu):
                    """
                    Enter the menu for the cathode controls.
                    """
                    def __init__(self, service, version, mode, path):
                        self.catalyst_layer = self.__class__.catalyst_layer(service, version, mode, path + ["catalyst_layer"])
                        self.current_collector = self.__class__.current_collector(service, version, mode, path + ["current_collector"])
                        self.electrolyte = self.__class__.electrolyte(service, version, mode, path + ["electrolyte"])
                        self.flow_channel = self.__class__.flow_channel(service, version, mode, path + ["flow_channel"])
                        self.porous_layer = self.__class__.porous_layer(service, version, mode, path + ["porous_layer"])
                        super().__init__(service, version, mode, path)
                    class catalyst_layer(TUIMethod):
                        """
                        Set parameters for the catalyst layer.
                        """
                    class current_collector(TUIMethod):
                        """
                        Set parameters for the current collector.
                        """
                    class electrolyte(TUIMethod):
                        """
                        Set parameters for the electrolyte.
                        """
                    class flow_channel(TUIMethod):
                        """
                        Set parameters for the flow channel.
                        """
                    class porous_layer(TUIMethod):
                        """
                        Set parameters for the porous layer.
                        """

                class membrane_setup(TUIMenu):
                    """
                    Specify parameters for electrolyte.
                    """
                    def __init__(self, service, version, mode, path):
                        self.catalyst_layer = self.__class__.catalyst_layer(service, version, mode, path + ["catalyst_layer"])
                        self.current_collector = self.__class__.current_collector(service, version, mode, path + ["current_collector"])
                        self.electrolyte = self.__class__.electrolyte(service, version, mode, path + ["electrolyte"])
                        self.flow_channel = self.__class__.flow_channel(service, version, mode, path + ["flow_channel"])
                        self.porous_layer = self.__class__.porous_layer(service, version, mode, path + ["porous_layer"])
                        super().__init__(service, version, mode, path)
                    class catalyst_layer(TUIMethod):
                        """
                        Set parameters for the catalyst layer.
                        """
                    class current_collector(TUIMethod):
                        """
                        Set parameters for the current collector.
                        """
                    class electrolyte(TUIMethod):
                        """
                        Set parameters for the electrolyte.
                        """
                    class flow_channel(TUIMethod):
                        """
                        Set parameters for the flow channel.
                        """
                    class porous_layer(TUIMethod):
                        """
                        Set parameters for the porous layer.
                        """

            class eulerian_wallfilm(TUIMenu):
                """
                Enters the Eulerian wall film model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.coupled_solution = self.__class__.coupled_solution(service, version, mode, path + ["coupled_solution"])
                    self.implicit_options = self.__class__.implicit_options(service, version, mode, path + ["implicit_options"])
                    self.enable_film_nci_support = self.__class__.enable_film_nci_support(service, version, mode, path + ["enable_film_nci_support"])
                    self.enable_film_vof_transition_message = self.__class__.enable_film_vof_transition_message(service, version, mode, path + ["enable_film_vof_transition_message"])
                    self.enable_wallfilm_model = self.__class__.enable_wallfilm_model(service, version, mode, path + ["enable_wallfilm_model"])
                    self.film_material = self.__class__.film_material(service, version, mode, path + ["film_material"])
                    self.initialize_wallfilm_model = self.__class__.initialize_wallfilm_model(service, version, mode, path + ["initialize_wallfilm_model"])
                    self.list_film_walls = self.__class__.list_film_walls(service, version, mode, path + ["list_film_walls"])
                    self.model_options = self.__class__.model_options(service, version, mode, path + ["model_options"])
                    self.solution_options = self.__class__.solution_options(service, version, mode, path + ["solution_options"])
                    self.solve_wallfilm_equation = self.__class__.solve_wallfilm_equation(service, version, mode, path + ["solve_wallfilm_equation"])
                    super().__init__(service, version, mode, path)
                class enable_film_nci_support(TUIMethod):
                    """
                    Enable wall film NCI support.
                    """
                class enable_film_vof_transition_message(TUIMethod):
                    """
                    Enable film-VOF transition message.
                    """
                class enable_wallfilm_model(TUIMethod):
                    """
                    Enables/disables Eulerian Wall Film Model.
                    """
                class film_material(TUIMethod):
                    """
                    Sets Film Material and Properties.
                    """
                class initialize_wallfilm_model(TUIMethod):
                    """
                    Initializes Eulerian Wall Film Model.
                    """
                class list_film_walls(TUIMethod):
                    """
                    List film walls.
                    """
                class model_options(TUIMethod):
                    """
                    Set Eulerian wall film model options.
                    """
                class solution_options(TUIMethod):
                    """
                    Sets Eulerian Wall Film Model Solution Options.
                    """
                class solve_wallfilm_equation(TUIMethod):
                    """
                    Activates Eulerian Wall Film Equations.
                    """

                class coupled_solution(TUIMenu):
                    """
                    Enters the Coupled-Solution menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enable_coupled_solution = self.__class__.enable_coupled_solution(service, version, mode, path + ["enable_coupled_solution"])
                        self.enable_curvature_smoothing = self.__class__.enable_curvature_smoothing(service, version, mode, path + ["enable_curvature_smoothing"])
                        super().__init__(service, version, mode, path)
                    class enable_coupled_solution(TUIMethod):
                        """
                        Enables/disables the coupled solution method.
                        """
                    class enable_curvature_smoothing(TUIMethod):
                        """
                        Enables/disables the film curvature smoothing option and sets the smoothing parameters.
                        """

                class implicit_options(TUIMenu):
                    """
                    Enter Implicit Scheme Option (beta).
                    """
                    def __init__(self, service, version, mode, path):
                        self.new_implicit_scheme = self.__class__.new_implicit_scheme(service, version, mode, path + ["new_implicit_scheme"])
                        self.relative_error_residual = self.__class__.relative_error_residual(service, version, mode, path + ["relative_error_residual"])
                        super().__init__(service, version, mode, path)
                    class new_implicit_scheme(TUIMethod):
                        """
                        Enable alternative implicit scheme.
                        """
                    class relative_error_residual(TUIMethod):
                        """
                        Enable relative error residual.
                        """

            class heat_exchanger(TUIMenu):
                """
                Enters the heat exchanger menu.
                """
                def __init__(self, service, version, mode, path):
                    self.dual_cell_model = self.__class__.dual_cell_model(service, version, mode, path + ["dual_cell_model"])
                    self.macro_model = self.__class__.macro_model(service, version, mode, path + ["macro_model"])
                    super().__init__(service, version, mode, path)

                class dual_cell_model(TUIMenu):
                    """
                    Enters the dual cell model menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.add_heat_exchanger = self.__class__.add_heat_exchanger(service, version, mode, path + ["add_heat_exchanger"])
                        self.alternative_formulation = self.__class__.alternative_formulation(service, version, mode, path + ["alternative_formulation"])
                        self.delete_heat_exchanger = self.__class__.delete_heat_exchanger(service, version, mode, path + ["delete_heat_exchanger"])
                        self.heat_exchanger = self.__class__.heat_exchanger(service, version, mode, path + ["heat_exchanger"])
                        self.modify_heat_exchanger = self.__class__.modify_heat_exchanger(service, version, mode, path + ["modify_heat_exchanger"])
                        self.plot_NTU = self.__class__.plot_NTU(service, version, mode, path + ["plot_NTU"])
                        self.write_NTU = self.__class__.write_NTU(service, version, mode, path + ["write_NTU"])
                        super().__init__(service, version, mode, path)
                    class add_heat_exchanger(TUIMethod):
                        """
                        Adds heat-exchanger.
                        """
                    class alternative_formulation(TUIMethod):
                        """
                        Enables/disables alternative formulation for heat transfer calculations.
                        """
                    class delete_heat_exchanger(TUIMethod):
                        """
                        Deletes heat-exchanger.
                        """
                    class heat_exchanger(TUIMethod):
                        """
                        Enables/disables the dual cell heat-exchanger model.
                        """
                    class modify_heat_exchanger(TUIMethod):
                        """
                        Modifies heat-exchanger.
                        """
                    class plot_NTU(TUIMethod):
                        """
                        Plots NTU vs. primary mass flow rate for each auxiliary mass flow rate.
                        """
                    class write_NTU(TUIMethod):
                        """
                        Writes NTU vs. primary mass flow rate for each auxiliary mass flow rate.
                        """

                class macro_model(TUIMenu):
                    """
                    Enters the heat macro-model menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.delete_heat_exchanger_group = self.__class__.delete_heat_exchanger_group(service, version, mode, path + ["delete_heat_exchanger_group"])
                        self.heat_exchanger = self.__class__.heat_exchanger(service, version, mode, path + ["heat_exchanger"])
                        self.heat_exchanger_group = self.__class__.heat_exchanger_group(service, version, mode, path + ["heat_exchanger_group"])
                        self.heat_exchanger_macro_report = self.__class__.heat_exchanger_macro_report(service, version, mode, path + ["heat_exchanger_macro_report"])
                        self.heat_exchanger_model = self.__class__.heat_exchanger_model(service, version, mode, path + ["heat_exchanger_model"])
                        self.heat_exchanger_report = self.__class__.heat_exchanger_report(service, version, mode, path + ["heat_exchanger_report"])
                        self.heat_exchanger_zone = self.__class__.heat_exchanger_zone(service, version, mode, path + ["heat_exchanger_zone"])
                        self.plot_NTU = self.__class__.plot_NTU(service, version, mode, path + ["plot_NTU"])
                        self.write_NTU = self.__class__.write_NTU(service, version, mode, path + ["write_NTU"])
                        super().__init__(service, version, mode, path)
                    class delete_heat_exchanger_group(TUIMethod):
                        """
                        Deletes heat-exchanger group.
                        """
                    class heat_exchanger(TUIMethod):
                        """
                        Enables/disables heat-exchanger model.
                        """
                    class heat_exchanger_group(TUIMethod):
                        """
                        Defines heat-exchanger group.
                        """
                    class heat_exchanger_macro_report(TUIMethod):
                        """
                        Reports the computed values of heat rejection, outlet temperature, and inlet temperature for the macroscopic cells (macros) in a heat exchanger.
                        """
                    class heat_exchanger_model(TUIMethod):
                        """
                        Defines heat-exchanger core model.
                        """
                    class heat_exchanger_report(TUIMethod):
                        """
                        Reports the computed values of total heat rejection, outlet temperature, and inlet temperature for a specified heat-exchanger core.
                        """
                    class heat_exchanger_zone(TUIMethod):
                        """
                        Specifies the zone that represents the heat exchanger, the dimensions of the heat exchanger, the macro grid, and the coolant direction and properties.
                        """
                    class plot_NTU(TUIMethod):
                        """
                        Plots NTU vs. primary mass flow rate for each auxiliary mass flow rate.
                        """
                    class write_NTU(TUIMethod):
                        """
                        Writes NTU vs. primary mass flow rate for each auxiliary mass flow rate.
                        """

            class multiphase(TUIMenu):
                """
                Enters the multiphase model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.explicit_expert_options = self.__class__.explicit_expert_options(service, version, mode, path + ["explicit_expert_options"])
                    self.flow_regime_modeling = self.__class__.flow_regime_modeling(service, version, mode, path + ["flow_regime_modeling"])
                    self.hybrid_models = self.__class__.hybrid_models(service, version, mode, path + ["hybrid_models"])
                    self.population_balance = self.__class__.population_balance(service, version, mode, path + ["population_balance"])
                    self.sub_models = self.__class__.sub_models(service, version, mode, path + ["sub_models"])
                    self.volume_fraction_parameters = self.__class__.volume_fraction_parameters(service, version, mode, path + ["volume_fraction_parameters"])
                    self.wet_steam = self.__class__.wet_steam(service, version, mode, path + ["wet_steam"])
                    self.body_force_formulation = self.__class__.body_force_formulation(service, version, mode, path + ["body_force_formulation"])
                    self.boiling_model_options = self.__class__.boiling_model_options(service, version, mode, path + ["boiling_model_options"])
                    self.coupled_level_set = self.__class__.coupled_level_set(service, version, mode, path + ["coupled_level_set"])
                    self.eulerian_parameters = self.__class__.eulerian_parameters(service, version, mode, path + ["eulerian_parameters"])
                    self.expert_options = self.__class__.expert_options(service, version, mode, path + ["expert_options"])
                    self.interface_modeling_options = self.__class__.interface_modeling_options(service, version, mode, path + ["interface_modeling_options"])
                    self.mixture_parameters = self.__class__.mixture_parameters(service, version, mode, path + ["mixture_parameters"])
                    self.model = self.__class__.model(service, version, mode, path + ["model"])
                    self.number_of_phases = self.__class__.number_of_phases(service, version, mode, path + ["number_of_phases"])
                    self.regime_transition_modeling = self.__class__.regime_transition_modeling(service, version, mode, path + ["regime_transition_modeling"])
                    self.vof_sub_models = self.__class__.vof_sub_models(service, version, mode, path + ["vof_sub_models"])
                    super().__init__(service, version, mode, path)
                class volume_fraction_parameters(TUIMethod):
                    """
                    Volume fraction parameters.
                    """
                class body_force_formulation(TUIMethod):
                    """
                    Specifies body force formulation.
                    """
                class boiling_model_options(TUIMethod):
                    """
                    Specifies the boiling model options. You can choose theRPI boiling model,Non-equilibrium boiling, orCritical heat flux.
                    """
                class coupled_level_set(TUIMethod):
                    """
                    Enables coupled level set interface tracking method.
                    """
                class eulerian_parameters(TUIMethod):
                    """
                    Specifies Eulerian parameters.
                    """
                class expert_options(TUIMethod):
                    """
                    Expert Options.
                    """
                class interface_modeling_options(TUIMethod):
                    """
                    Specifies interface modeling options.
                    """
                class mixture_parameters(TUIMethod):
                    """
                    Specifies mixture parameters.
                    """
                class model(TUIMethod):
                    """
                    Specifies multiphase model.
                    """
                class number_of_phases(TUIMethod):
                    """
                    Specifies the number of phases.
                    """
                class regime_transition_modeling(TUIMethod):
                    """
                    Enables the Algebraic Interfacial Area Density (AIAD) 	model and sets the AIAD secondary continuous phase and 	the secondary entrained phase. Entering 0 as a phase ID cancels any 	previous phase selection. Note that you must define the 	phases in your simulation using the define/phases/ text command 	prior to using the regime-transition-modeling 	text command. This option is available only with the 	Eulerian multiphase model.
                    """
                class vof_sub_models(TUIMethod):
                    """
                    Enables the Open Channel sub-model and/or the Open Channel Wave Boundary Condition 	sub-model.
                    """

                class explicit_expert_options(TUIMenu):
                    """
                    Enters the menu to set explicit VOF expert 	options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.volume_fraction_filtering = self.__class__.volume_fraction_filtering(service, version, mode, path + ["volume_fraction_filtering"])
                        self.solve_vof_every_iter = self.__class__.solve_vof_every_iter(service, version, mode, path + ["solve_vof_every_iter"])
                        self.sub_time_step_method = self.__class__.sub_time_step_method(service, version, mode, path + ["sub_time_step_method"])
                        super().__init__(service, version, mode, path)
                    class solve_vof_every_iter(TUIMethod):
                        """
                        If you enter yes, the volume fraction equations will be solved every iteration. By default, the volume fraction equations will be solved only once per time step.
                        """
                    class sub_time_step_method(TUIMethod):
                        """
                        Selects the sub-time step method.
                        """

                    class volume_fraction_filtering(TUIMenu):
                        """
                        Enters the volume fraction filtering menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                            self.filtering_options = self.__class__.filtering_options(service, version, mode, path + ["filtering_options"])
                            self.vol_frac_cutoff = self.__class__.vol_frac_cutoff(service, version, mode, path + ["vol_frac_cutoff"])
                            super().__init__(service, version, mode, path)
                        class enable(TUIMethod):
                            """
                            Enables/disables the volume fraction filtering treatment.
                            """
                        class filtering_options(TUIMethod):
                            """
                            Selects the volume fraction filtering method. This command becomes available once the define/models/multiphase/explicit-expert-options/volume-fraction-filtering/enable? text option has been set to yes.
                            """
                        class vol_frac_cutoff(TUIMethod):
                            """
                            Specifies a cut-off value for the volume fraction filtering. This command becomes available after you select the node averaged cutoff method using the define/models/multiphase/explicit-expert-options/volume-fraction-filtering/filtering-options text command.
                            """

                class flow_regime_modeling(TUIMenu):
                    """
                    Flow Regime Modeling.
                    """
                    def __init__(self, service, version, mode, path):
                        self.aiad_parameters = self.__class__.aiad_parameters(service, version, mode, path + ["aiad_parameters"])
                        self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                        super().__init__(service, version, mode, path)
                    class enable(TUIMethod):
                        """
                        Enable flow regime modeling framework including phase state and morphology.
                        """

                    class aiad_parameters(TUIMenu):
                        """
                        AIAD parameters.
                        """
                        def __init__(self, service, version, mode, path):
                            self.critical_vf = self.__class__.critical_vf(service, version, mode, path + ["critical_vf"])
                            self.delta_grad = self.__class__.delta_grad(service, version, mode, path + ["delta_grad"])
                            self.delta_vf = self.__class__.delta_vf(service, version, mode, path + ["delta_vf"])
                            self.ncells_fs = self.__class__.ncells_fs(service, version, mode, path + ["ncells_fs"])
                            super().__init__(service, version, mode, path)
                        class critical_vf(TUIMethod):
                            """
                            Critical volume fraction for bubbly and droplet flow blending factors.
                            """
                        class delta_grad(TUIMethod):
                            """
                            Parameter for determining transition width for free surface blending factor.
                            """
                        class delta_vf(TUIMethod):
                            """
                            Parameter for transition width for bubbly and droplet flow blending factors.
                            """
                        class ncells_fs(TUIMethod):
                            """
                            Parameter for determining interfacial width.
                            """

                class hybrid_models(TUIMenu):
                    """
                    Enter the menu to select hybrid models.
                    """
                    def __init__(self, service, version, mode, path):
                        self.ddpm = self.__class__.ddpm(service, version, mode, path + ["ddpm"])
                        self.multi_fluid_vof = self.__class__.multi_fluid_vof(service, version, mode, path + ["multi_fluid_vof"])
                        super().__init__(service, version, mode, path)
                    class ddpm(TUIMethod):
                        """
                        Enable the dense discrete phase model.
                        """
                    class multi_fluid_vof(TUIMethod):
                        """
                        Enable the multi-fluid VOF model.
                        """

                class population_balance(TUIMenu):
                    """
                    Enters the population balance models menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                        self.phenomena = self.__class__.phenomena(service, version, mode, path + ["phenomena"])
                        self.include_expansion = self.__class__.include_expansion(service, version, mode, path + ["include_expansion"])
                        self.model = self.__class__.model(service, version, mode, path + ["model"])
                        self.size_calculator = self.__class__.size_calculator(service, version, mode, path + ["size_calculator"])
                        super().__init__(service, version, mode, path)
                    class include_expansion(TUIMethod):
                        """
                        Set expansion.
                        """
                    class model(TUIMethod):
                        """
                        Allows you to select the population balance model and set its parameters.
                        """
                    class size_calculator(TUIMethod):
                        """
                        Gives you recommendations for appropriate bubble sizes and/or droplet size limits.
                        """

                    class expert(TUIMenu):
                        """
                        Enter the expert menu for quadrature-based population balance method.
                        """
                        def __init__(self, service, version, mode, path):
                            self.qbmm = self.__class__.qbmm(service, version, mode, path + ["qbmm"])
                            self.qmom = self.__class__.qmom(service, version, mode, path + ["qmom"])
                            super().__init__(service, version, mode, path)

                        class qbmm(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.advection_cfl = self.__class__.advection_cfl(service, version, mode, path + ["advection_cfl"])
                                self.advection_int_scheme = self.__class__.advection_int_scheme(service, version, mode, path + ["advection_int_scheme"])
                                self.exit_on_non_real = self.__class__.exit_on_non_real(service, version, mode, path + ["exit_on_non_real"])
                                self.solve_advection = self.__class__.solve_advection(service, version, mode, path + ["solve_advection"])
                                self.sort_abscissas = self.__class__.sort_abscissas(service, version, mode, path + ["sort_abscissas"])
                                self.source_int_scheme = self.__class__.source_int_scheme(service, version, mode, path + ["source_int_scheme"])
                                self.source_min_dt = self.__class__.source_min_dt(service, version, mode, path + ["source_min_dt"])
                                self.source_ode_err_abs = self.__class__.source_ode_err_abs(service, version, mode, path + ["source_ode_err_abs"])
                                self.source_ode_err_rel = self.__class__.source_ode_err_rel(service, version, mode, path + ["source_ode_err_rel"])
                                self.source_ode_factor = self.__class__.source_ode_factor(service, version, mode, path + ["source_ode_factor"])
                                self.source_ode_factor_max = self.__class__.source_ode_factor_max(service, version, mode, path + ["source_ode_factor_max"])
                                self.source_ode_factor_min = self.__class__.source_ode_factor_min(service, version, mode, path + ["source_ode_factor_min"])
                                self.verbosity_level = self.__class__.verbosity_level(service, version, mode, path + ["verbosity_level"])
                                self.zero_moment_minus = self.__class__.zero_moment_minus(service, version, mode, path + ["zero_moment_minus"])
                                self.zero_moment_plus = self.__class__.zero_moment_plus(service, version, mode, path + ["zero_moment_plus"])
                                self.zero_zeta_minus = self.__class__.zero_zeta_minus(service, version, mode, path + ["zero_zeta_minus"])
                                self.zero_zeta_plus = self.__class__.zero_zeta_plus(service, version, mode, path + ["zero_zeta_plus"])
                                super().__init__(service, version, mode, path)
                            class advection_cfl(TUIMethod):
                                """
                                Select the QBMM advection Courant number.
                                """
                            class advection_int_scheme(TUIMethod):
                                """
                                Select QBMM advection time integration scheme.
                                """
                            class exit_on_non_real(TUIMethod):
                                """
                                Exit on non-realizable moments detection.
                                """
                            class solve_advection(TUIMethod):
                                """
                                Solve the advection part of the QBMM equation?.
                                """
                            class sort_abscissas(TUIMethod):
                                """
                                Sort quadrature points based on abscissas.
                                """
                            class source_int_scheme(TUIMethod):
                                """
                                Select QBMM source time integration scheme.
                                """
                            class source_min_dt(TUIMethod):
                                """
                                Select the minimum acceptable time step for source time integration.
                                """
                            class source_ode_err_abs(TUIMethod):
                                """
                                Select the source time integration absolute error.
                                """
                            class source_ode_err_rel(TUIMethod):
                                """
                                Select the source time integration relative error.
                                """
                            class source_ode_factor(TUIMethod):
                                """
                                Select the source time integration factor for error estimation.
                                """
                            class source_ode_factor_max(TUIMethod):
                                """
                                Select the source time integration maximum factor for error estimation.
                                """
                            class source_ode_factor_min(TUIMethod):
                                """
                                Select the source time integration minimum factor for error estimation.
                                """
                            class verbosity_level(TUIMethod):
                                """
                                Select a verbosity level (0-4) for QBMM.
                                """
                            class zero_moment_minus(TUIMethod):
                                """
                                Select a small negative value above which the moments are considered negligible.
                                """
                            class zero_moment_plus(TUIMethod):
                                """
                                Select a small positive value bellow which the moments are considered negligible.
                                """
                            class zero_zeta_minus(TUIMethod):
                                """
                                Select a small negative value above which the auxiliary quantities are considered negligible.
                                """
                            class zero_zeta_plus(TUIMethod):
                                """
                                Select a small postitive value bellow which the auxiliary quantities are considered negligible.
                                """

                        class qmom(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.inversion_algorithm = self.__class__.inversion_algorithm(service, version, mode, path + ["inversion_algorithm"])
                                self.print_realizable_moment_warning = self.__class__.print_realizable_moment_warning(service, version, mode, path + ["print_realizable_moment_warning"])
                                self.realizable_moments = self.__class__.realizable_moments(service, version, mode, path + ["realizable_moments"])
                                self.retain_qmom_sources_for_low_vof = self.__class__.retain_qmom_sources_for_low_vof(service, version, mode, path + ["retain_qmom_sources_for_low_vof"])
                                super().__init__(service, version, mode, path)
                            class inversion_algorithm(TUIMethod):
                                """
                                Select the inversion algorithm for quadrature-based population balance method.
                                """
                            class print_realizable_moment_warning(TUIMethod):
                                """
                                Print the information for realizable moments in the population balance model.
                                """
                            class realizable_moments(TUIMethod):
                                """
                                Set the population balance model.
                                """
                            class retain_qmom_sources_for_low_vof(TUIMethod):
                                """
                                Retain qmom source calculation for low secondary phase vof.
                                """

                    class phenomena(TUIMenu):
                        """
                        Enters the phenomena menu for population balance.
                        """
                        def __init__(self, service, version, mode, path):
                            self.aggregation = self.__class__.aggregation(service, version, mode, path + ["aggregation"])
                            self.aggregation_factor = self.__class__.aggregation_factor(service, version, mode, path + ["aggregation_factor"])
                            self.breakage = self.__class__.breakage(service, version, mode, path + ["breakage"])
                            self.breakage_aggregation_vof_cutoff = self.__class__.breakage_aggregation_vof_cutoff(service, version, mode, path + ["breakage_aggregation_vof_cutoff"])
                            self.breakage_factor = self.__class__.breakage_factor(service, version, mode, path + ["breakage_factor"])
                            self.growth = self.__class__.growth(service, version, mode, path + ["growth"])
                            self.nucleation = self.__class__.nucleation(service, version, mode, path + ["nucleation"])
                            super().__init__(service, version, mode, path)
                        class aggregation(TUIMethod):
                            """
                            Sets the aggregation kernel.
                            """
                        class aggregation_factor(TUIMethod):
                            """
                            Specifies a factor that controls the intensity of the selected aggregation kernel.
                            """
                        class breakage(TUIMethod):
                            """
                            Set the breakage kernel.
                            """
                        class breakage_aggregation_vof_cutoff(TUIMethod):
                            """
                            Specifies a cutoff limit for the volume fraction values for the breakage and aggregation kernels.
                            """
                        class breakage_factor(TUIMethod):
                            """
                            Specifies a factor that controls the intensity of the selected breakage kernel.
                            """
                        class growth(TUIMethod):
                            """
                            Specifies the growth rate.
                            """
                        class nucleation(TUIMethod):
                            """
                            Specifies the nucleation rate.
                            """

                class sub_models(TUIMenu):
                    """
                    Enter the menu to select sub-models.
                    """
                    def __init__(self, service, version, mode, path):
                        self.boiling_options = self.__class__.boiling_options(service, version, mode, path + ["boiling_options"])
                        self.boiling = self.__class__.boiling(service, version, mode, path + ["boiling"])
                        super().__init__(service, version, mode, path)
                    class boiling(TUIMethod):
                        """
                        Activate boiling model.
                        """

                    class boiling_options(TUIMenu):
                        """
                        Set boiling options.
                        """
                        def __init__(self, service, version, mode, path):
                            self.nlbf_model = self.__class__.nlbf_model(service, version, mode, path + ["nlbf_model"])
                            self.options = self.__class__.options(service, version, mode, path + ["options"])
                            super().__init__(service, version, mode, path)
                        class nlbf_model(TUIMethod):
                            """
                            Set the non-local boundary field correction.
                            """
                        class options(TUIMethod):
                            """
                            Choose the type of boiling model.
                            """

                class wet_steam(TUIMenu):
                    """
                    Enters the wet steam model menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.set = self.__class__.set(service, version, mode, path + ["set"])
                        self.compile_user_defined_wetsteam_functions = self.__class__.compile_user_defined_wetsteam_functions(service, version, mode, path + ["compile_user_defined_wetsteam_functions"])
                        self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                        self.load_unload_user_defined_wetsteam_library = self.__class__.load_unload_user_defined_wetsteam_library(service, version, mode, path + ["load_unload_user_defined_wetsteam_library"])
                        super().__init__(service, version, mode, path)
                    class compile_user_defined_wetsteam_functions(TUIMethod):
                        """
                        Compiles user-defined wet steam library.
                        """
                    class enable(TUIMethod):
                        """
                        Enables/disables the wet steam model.
                        """
                    class load_unload_user_defined_wetsteam_library(TUIMethod):
                        """
                        Loads or unloads user-defined wet steam library.
                        """

                    class set(TUIMenu):
                        """
                        Enters the set menu for setting wet steam model options.
                        """
                        def __init__(self, service, version, mode, path):
                            self.droplet_growth_rate = self.__class__.droplet_growth_rate(service, version, mode, path + ["droplet_growth_rate"])
                            self.max_liquid_mass_fraction = self.__class__.max_liquid_mass_fraction(service, version, mode, path + ["max_liquid_mass_fraction"])
                            self.rgp_tables = self.__class__.rgp_tables(service, version, mode, path + ["rgp_tables"])
                            self.stagnation_conditions = self.__class__.stagnation_conditions(service, version, mode, path + ["stagnation_conditions"])
                            self.virial_equation = self.__class__.virial_equation(service, version, mode, path + ["virial_equation"])
                            self.zonal_phase_change = self.__class__.zonal_phase_change(service, version, mode, path + ["zonal_phase_change"])
                            super().__init__(service, version, mode, path)
                        class droplet_growth_rate(TUIMethod):
                            """
                            S formulation (default) or Hill.
                            """
                        class max_liquid_mass_fraction(TUIMethod):
                            """
                            Sets the maximum limit on the condensed liquid-phase mass-fraction to prevent divergence.
                            """
                        class rgp_tables(TUIMethod):
                            """
                            Sets the RGP (real gas property) table to be used with the Wet Steam model.
                            """
                        class stagnation_conditions(TUIMethod):
                            """
                            Computes stagnation conditions using either gas phase only, or mixture. For details, see .
                            """
                        class virial_equation(TUIMethod):
                            """
                            Sets the equation of state for steam to either Vukalovich formulation (default) or Young formulation.
                            """
                        class zonal_phase_change(TUIMethod):
                            """
                            Select cell zones where phase change process is active.
                            """

            class nox_parameters(TUIMenu):
                """
                Enters the NOx parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self.inlet_diffusion = self.__class__.inlet_diffusion(service, version, mode, path + ["inlet_diffusion"])
                    self.nox_chemistry = self.__class__.nox_chemistry(service, version, mode, path + ["nox_chemistry"])
                    self.nox_expert = self.__class__.nox_expert(service, version, mode, path + ["nox_expert"])
                    self.nox_turbulence_interaction = self.__class__.nox_turbulence_interaction(service, version, mode, path + ["nox_turbulence_interaction"])
                    super().__init__(service, version, mode, path)
                class inlet_diffusion(TUIMethod):
                    """
                    Enables/disables inclusion of diffusion at inlets.
                    """
                class nox_chemistry(TUIMethod):
                    """
                    Selects NOx chemistry model.
                    """
                class nox_expert(TUIMethod):
                    """
                    Selects additional NOx equations.
                    """
                class nox_turbulence_interaction(TUIMethod):
                    """
                    Sets NOx turbulence interaction model.
                    """

            class optics(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.beams = self.__class__.beams(service, version, mode, path + ["beams"])
                    self.statistics = self.__class__.statistics(service, version, mode, path + ["statistics"])
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.index_of_refraction = self.__class__.index_of_refraction(service, version, mode, path + ["index_of_refraction"])
                    self.report = self.__class__.report(service, version, mode, path + ["report"])
                    self.sampling_iterations = self.__class__.sampling_iterations(service, version, mode, path + ["sampling_iterations"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    .
                    """
                class index_of_refraction(TUIMethod):
                    """
                    .
                    """
                class report(TUIMethod):
                    """
                    .
                    """
                class sampling_iterations(TUIMethod):
                    """
                    .
                    """
                class verbosity(TUIMethod):
                    """
                    .
                    """

                class beams(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.add = self.__class__.add(service, version, mode, path + ["add"])
                        self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                        self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                        super().__init__(service, version, mode, path)
                    class add(TUIMethod):
                        """
                        Create a new beams object.
                        """
                    class copy(TUIMethod):
                        """
                        .
                        """
                    class delete(TUIMethod):
                        """
                        .
                        """
                    class edit(TUIMethod):
                        """
                        Edit beams object.
                        """
                    class list(TUIMethod):
                        """
                        .
                        """
                    class list_properties(TUIMethod):
                        """
                        .
                        """
                    class make_a_copy(TUIMethod):
                        """
                        .
                        """
                    class rename(TUIMethod):
                        """
                        Rename beams object.
                        """

                class statistics(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.reset_statistics = self.__class__.reset_statistics(service, version, mode, path + ["reset_statistics"])
                        self.statistics_controls = self.__class__.statistics_controls(service, version, mode, path + ["statistics_controls"])
                        super().__init__(service, version, mode, path)
                    class reset_statistics(TUIMethod):
                        """
                        .
                        """
                    class statistics_controls(TUIMethod):
                        """
                        .
                        """

            class radiation(TUIMenu):
                """
                Enters the radiation models menu.
                """
                def __init__(self, service, version, mode, path):
                    self.dtrm_parameters = self.__class__.dtrm_parameters(service, version, mode, path + ["dtrm_parameters"])
                    self.s2s_parameters = self.__class__.s2s_parameters(service, version, mode, path + ["s2s_parameters"])
                    self.solar_parameters = self.__class__.solar_parameters(service, version, mode, path + ["solar_parameters"])
                    self.apply_full_solar_irradiation = self.__class__.apply_full_solar_irradiation(service, version, mode, path + ["apply_full_solar_irradiation"])
                    self.beta_radiation_features = self.__class__.beta_radiation_features(service, version, mode, path + ["beta_radiation_features"])
                    self.blending_factor = self.__class__.blending_factor(service, version, mode, path + ["blending_factor"])
                    self.discrete_ordinates = self.__class__.discrete_ordinates(service, version, mode, path + ["discrete_ordinates"])
                    self.discrete_transfer = self.__class__.discrete_transfer(service, version, mode, path + ["discrete_transfer"])
                    self.do_acceleration = self.__class__.do_acceleration(service, version, mode, path + ["do_acceleration"])
                    self.do_coupling = self.__class__.do_coupling(service, version, mode, path + ["do_coupling"])
                    self.fast_second_order_discrete_ordinate = self.__class__.fast_second_order_discrete_ordinate(service, version, mode, path + ["fast_second_order_discrete_ordinate"])
                    self.mc_model_parameters = self.__class__.mc_model_parameters(service, version, mode, path + ["mc_model_parameters"])
                    self.mc_under_relaxation = self.__class__.mc_under_relaxation(service, version, mode, path + ["mc_under_relaxation"])
                    self.method_partially_specular_wall = self.__class__.method_partially_specular_wall(service, version, mode, path + ["method_partially_specular_wall"])
                    self.montecarlo = self.__class__.montecarlo(service, version, mode, path + ["montecarlo"])
                    self.non_gray_model_parameters = self.__class__.non_gray_model_parameters(service, version, mode, path + ["non_gray_model_parameters"])
                    self.p1 = self.__class__.p1(service, version, mode, path + ["p1"])
                    self.radiation_iteration_parameters = self.__class__.radiation_iteration_parameters(service, version, mode, path + ["radiation_iteration_parameters"])
                    self.radiation_model_parameters = self.__class__.radiation_model_parameters(service, version, mode, path + ["radiation_model_parameters"])
                    self.rosseland = self.__class__.rosseland(service, version, mode, path + ["rosseland"])
                    self.s2s = self.__class__.s2s(service, version, mode, path + ["s2s"])
                    self.solar = self.__class__.solar(service, version, mode, path + ["solar"])
                    self.solar_calculator = self.__class__.solar_calculator(service, version, mode, path + ["solar_calculator"])
                    self.solar_irradiation = self.__class__.solar_irradiation(service, version, mode, path + ["solar_irradiation"])
                    self.solution_method_for_do_coupling = self.__class__.solution_method_for_do_coupling(service, version, mode, path + ["solution_method_for_do_coupling"])
                    self.target_cells_per_volume_cluster = self.__class__.target_cells_per_volume_cluster(service, version, mode, path + ["target_cells_per_volume_cluster"])
                    self.wsggm_cell_based = self.__class__.wsggm_cell_based(service, version, mode, path + ["wsggm_cell_based"])
                    super().__init__(service, version, mode, path)
                class apply_full_solar_irradiation(TUIMethod):
                    """
                    Enables/disables the application of the complete solar load to the first wavelength 	band only, reverting to the pre-2019 R1 behavior of the 	Solar Load and Discrete Ordinates models.
                    """
                class beta_radiation_features(TUIMethod):
                    """
                    Enable Radiation Models with Non-Iterative Time Advancement (NITA) as Beta features in FL12.0.
                    """
                class blending_factor(TUIMethod):
                    """
                    Sets numeric option for Discrete Ordinate model. Make sure thatSecond Order Upwind is selected for the Discrete Ordinates spatial 	discretization for the blending-factor option to 	appear in the text command list.
                    """
                class discrete_ordinates(TUIMethod):
                    """
                    Enables/disables discrete ordinates radiation model.
                    """
                class discrete_transfer(TUIMethod):
                    """
                    Enables/disables discrete transfer radiation model.
                    """
                class do_acceleration(TUIMethod):
                    """
                    Enables/disables the acceleration of the discrete 	ordinates (DO) radiation model calculations. Note that 	this text command is only available when running on 	Linux in parallel.
                    """
                class do_coupling(TUIMethod):
                    """
                    Enables/disables DO/energy coupling.
                    """
                class fast_second_order_discrete_ordinate(TUIMethod):
                    """
                    Enables/disables the fast-second-order option for Discrete Ordinate Model.
                    """
                class mc_model_parameters(TUIMethod):
                    """
                    Specifies Monte Carlo model parameters. This text command is available only when the 	Monte Carlo model is enabled.
                    """
                class mc_under_relaxation(TUIMethod):
                    """
                    Sets the under-relaxation factor for Monte Carlo radiation sources used in the 	energy equation.
                    """
                class method_partially_specular_wall(TUIMethod):
                    """
                    Sets the method for partially specular wall with discrete ordinate model.
                    """
                class montecarlo(TUIMethod):
                    """
                    Enables/disables the Monte Carlo radiation model.
                    """
                class non_gray_model_parameters(TUIMethod):
                    """
                    Sets parameters for non-gray model.
                    """
                class p1(TUIMethod):
                    """
                    Enables/disables P1 radiation model.
                    """
                class radiation_iteration_parameters(TUIMethod):
                    """
                    Sets iteration parameters for radiation models.
                    """
                class radiation_model_parameters(TUIMethod):
                    """
                    Set parameters for radiation models.
                    """
                class rosseland(TUIMethod):
                    """
                    Enables/disables Rosseland radiation model.
                    """
                class s2s(TUIMethod):
                    """
                    Enables/disables S2S radiation model.
                    """
                class solar(TUIMethod):
                    """
                    Enables/disables solar model.
                    """
                class solar_calculator(TUIMethod):
                    """
                    Calculates sun direction and intensity.
                    """
                class solar_irradiation(TUIMethod):
                    """
                    Enables/disables the solar irradiation model.
                    """
                class solution_method_for_do_coupling(TUIMethod):
                    """
                    Enables/disables the solution method for DO/energy coupling.
                    """
                class target_cells_per_volume_cluster(TUIMethod):
                    """
                    Sets the amount of coarsening of the radiation mesh 	for the Monte Carlo radiation model. A number greater 	than one implies coarsening, whereas equal to one 	implies no coarsening.
                    """
                class wsggm_cell_based(TUIMethod):
                    """
                    Enables/disables WSGGM cell based method. Note that when enabled, the wsggm-cell-based option will 	become available in theAbsorption Coefficient drop-down list in the Create/Edit Materials dialog 	box.
                    """

                class dtrm_parameters(TUIMenu):
                    """
                    Enters the dtrm parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.check_ray_file = self.__class__.check_ray_file(service, version, mode, path + ["check_ray_file"])
                        self.controls = self.__class__.controls(service, version, mode, path + ["controls"])
                        self.make_globs = self.__class__.make_globs(service, version, mode, path + ["make_globs"])
                        self.ray_trace = self.__class__.ray_trace(service, version, mode, path + ["ray_trace"])
                        super().__init__(service, version, mode, path)
                    class check_ray_file(TUIMethod):
                        """
                        Reads DTRM rays file.
                        """
                    class controls(TUIMethod):
                        """
                        Sets dtrm solution controls.
                        """
                    class make_globs(TUIMethod):
                        """
                        Makes globs (coarser mesh) for radiation.
                        """
                    class ray_trace(TUIMethod):
                        """
                        Creates DTRM rays for radiation.
                        """

                class s2s_parameters(TUIMenu):
                    """
                    Enters the S2S parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.compute_clusters_and_vf_accelerated = self.__class__.compute_clusters_and_vf_accelerated(service, version, mode, path + ["compute_clusters_and_vf_accelerated"])
                        self.compute_fpsc_values = self.__class__.compute_fpsc_values(service, version, mode, path + ["compute_fpsc_values"])
                        self.compute_vf_accelerated = self.__class__.compute_vf_accelerated(service, version, mode, path + ["compute_vf_accelerated"])
                        self.compute_vf_only = self.__class__.compute_vf_only(service, version, mode, path + ["compute_vf_only"])
                        self.compute_write_vf = self.__class__.compute_write_vf(service, version, mode, path + ["compute_write_vf"])
                        self.enable_mesh_interface_clustering = self.__class__.enable_mesh_interface_clustering(service, version, mode, path + ["enable_mesh_interface_clustering"])
                        self.non_participating_boundary_zones_temperature = self.__class__.non_participating_boundary_zones_temperature(service, version, mode, path + ["non_participating_boundary_zones_temperature"])
                        self.print_thread_clusters = self.__class__.print_thread_clusters(service, version, mode, path + ["print_thread_clusters"])
                        self.print_zonewise_radiation = self.__class__.print_zonewise_radiation(service, version, mode, path + ["print_zonewise_radiation"])
                        self.read_vf_file = self.__class__.read_vf_file(service, version, mode, path + ["read_vf_file"])
                        self.set_global_faces_per_surface_cluster = self.__class__.set_global_faces_per_surface_cluster(service, version, mode, path + ["set_global_faces_per_surface_cluster"])
                        self.set_vf_parameters = self.__class__.set_vf_parameters(service, version, mode, path + ["set_vf_parameters"])
                        self.split_angle = self.__class__.split_angle(service, version, mode, path + ["split_angle"])
                        self.use_new_cluster_algorithm = self.__class__.use_new_cluster_algorithm(service, version, mode, path + ["use_new_cluster_algorithm"])
                        self.use_old_cluster_algorithm = self.__class__.use_old_cluster_algorithm(service, version, mode, path + ["use_old_cluster_algorithm"])
                        super().__init__(service, version, mode, path)
                    class compute_clusters_and_vf_accelerated(TUIMethod):
                        """
                        .
                        """
                    class compute_fpsc_values(TUIMethod):
                        """
                        Computes only fpsc values based on current settings.
                        """
                    class compute_vf_accelerated(TUIMethod):
                        """
                        .
                        """
                    class compute_vf_only(TUIMethod):
                        """
                        Computes/writes view factors only.
                        """
                    class compute_write_vf(TUIMethod):
                        """
                        Computes/writes surface clusters and view factors for S2S radiation model.
                        """
                    class enable_mesh_interface_clustering(TUIMethod):
                        """
                        Enables surface clusters on mesh interfaces.
                        """
                    class non_participating_boundary_zones_temperature(TUIMethod):
                        """
                        Sets temperature for the non-participating boundary zones.
                        """
                    class print_thread_clusters(TUIMethod):
                        """
                        Prints the following for all boundary threads: thread-id, number of faces, faces per surface cluster, and the number of surface clusters.
                        """
                    class print_zonewise_radiation(TUIMethod):
                        """
                        Prints the zonewise incoming radiation, viewfactors, and average temperature.
                        """
                    class read_vf_file(TUIMethod):
                        """
                        Reads S2S file.
                        """
                    class set_global_faces_per_surface_cluster(TUIMethod):
                        """
                        Sets global value of faces per surface cluster for all boundary zones.
                        """
                    class set_vf_parameters(TUIMethod):
                        """
                        Sets the parameters needed for the viewfactor calculations.
                        """
                    class split_angle(TUIMethod):
                        """
                        Sets split angle for the clustering algorithm.
                        """
                    class use_new_cluster_algorithm(TUIMethod):
                        """
                        Uses the new surface clustering algorithm.
                        """
                    class use_old_cluster_algorithm(TUIMethod):
                        """
                        Uses the old surface clustering algorithm.
                        """

                class solar_parameters(TUIMenu):
                    """
                    Enters the solar parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.autoread_solar_data = self.__class__.autoread_solar_data(service, version, mode, path + ["autoread_solar_data"])
                        self.autosave_solar_data = self.__class__.autosave_solar_data(service, version, mode, path + ["autosave_solar_data"])
                        self.ground_reflectivity = self.__class__.ground_reflectivity(service, version, mode, path + ["ground_reflectivity"])
                        self.illumination_parameters = self.__class__.illumination_parameters(service, version, mode, path + ["illumination_parameters"])
                        self.iteration_parameters = self.__class__.iteration_parameters(service, version, mode, path + ["iteration_parameters"])
                        self.quad_tree_parameters = self.__class__.quad_tree_parameters(service, version, mode, path + ["quad_tree_parameters"])
                        self.scattering_fraction = self.__class__.scattering_fraction(service, version, mode, path + ["scattering_fraction"])
                        self.sol_adjacent_fluidcells = self.__class__.sol_adjacent_fluidcells(service, version, mode, path + ["sol_adjacent_fluidcells"])
                        self.sol_camera_pos = self.__class__.sol_camera_pos(service, version, mode, path + ["sol_camera_pos"])
                        self.sol_on_demand = self.__class__.sol_on_demand(service, version, mode, path + ["sol_on_demand"])
                        self.solar_thread_control = self.__class__.solar_thread_control(service, version, mode, path + ["solar_thread_control"])
                        self.sun_direction_vector = self.__class__.sun_direction_vector(service, version, mode, path + ["sun_direction_vector"])
                        self.use_direction_from_sol_calc = self.__class__.use_direction_from_sol_calc(service, version, mode, path + ["use_direction_from_sol_calc"])
                        super().__init__(service, version, mode, path)
                    class autoread_solar_data(TUIMethod):
                        """
                        Sets autoread solar data parameters.
                        """
                    class autosave_solar_data(TUIMethod):
                        """
                        Sets autosave solar data parameters.
                        """
                    class ground_reflectivity(TUIMethod):
                        """
                        Sets ground reflectivity parameters.
                        """
                    class illumination_parameters(TUIMethod):
                        """
                        Sets illumination parameters.
                        """
                    class iteration_parameters(TUIMethod):
                        """
                        Sets update parameters.
                        """
                    class quad_tree_parameters(TUIMethod):
                        """
                        Sets quad-tree refinement parameters.
                        """
                    class scattering_fraction(TUIMethod):
                        """
                        Sets scattering fraction parameters.
                        """
                    class sol_adjacent_fluidcells(TUIMethod):
                        """
                        Sets solar load on for adjacent fluid cells.
                        """
                    class sol_camera_pos(TUIMethod):
                        """
                        Sets camera position based on sun direction vector.
                        """
                    class sol_on_demand(TUIMethod):
                        """
                        Sets solar load on demand.
                        """
                    class solar_thread_control(TUIMethod):
                        """
                        Sets the number of threads to run the solar flux calculation. This item appears only when running in parallel with nodes located on a separate machine from the one running the host process andSolar Ray Tracing is enabled.
                        """
                    class sun_direction_vector(TUIMethod):
                        """
                        Sets sun direction vector.
                        """
                    class use_direction_from_sol_calc(TUIMethod):
                        """
                        Sets direction computed from solar calculator.
                        """

            class shell_conduction(TUIMenu):
                """
                Enters the shell conduction models menu.
                """
                def __init__(self, service, version, mode, path):
                    self.enhanced_encapsulation = self.__class__.enhanced_encapsulation(service, version, mode, path + ["enhanced_encapsulation"])
                    self.multi_layer_shell = self.__class__.multi_layer_shell(service, version, mode, path + ["multi_layer_shell"])
                    self.read_csv = self.__class__.read_csv(service, version, mode, path + ["read_csv"])
                    self.save_shell_zones = self.__class__.save_shell_zones(service, version, mode, path + ["save_shell_zones"])
                    self.settings = self.__class__.settings(service, version, mode, path + ["settings"])
                    self.write_csv = self.__class__.write_csv(service, version, mode, path + ["write_csv"])
                    super().__init__(service, version, mode, path)
                class enhanced_encapsulation(TUIMethod):
                    """
                    Enables/disables an enhanced routine for the encapsulation of coupled walls during 	mesh partitioning that is enabled by default when shell 	conduction and/or the surface to surface (S2S) radiation 	model is used.
                    """
                class multi_layer_shell(TUIMethod):
                    """
                    Enables/disables the ability to define multi-layer 	shell conduction for walls. Note that the warped-face 	gradient correction (WFGC) is not supported when 	multi-layer shells are disabled.
                    """
                class read_csv(TUIMethod):
                    """
                    Defines the shell conduction settings by reading a CSV file.
                    """
                class save_shell_zones(TUIMethod):
                    """
                    Enables the saving of shell zones to case 	files.
                    """
                class settings(TUIMethod):
                    """
                    Enables shell conduction and defines the settings for any wall or group of walls by 	manually entering the number and properties of the 	layers.
                    """
                class write_csv(TUIMethod):
                    """
                    Writes your saved shell conduction settings to a CSV file.
                    """

            class solver(TUIMenu):
                """
                Enters the menu to select the solver.
                """
                def __init__(self, service, version, mode, path):
                    self.adjust_solver_defaults_based_on_setup = self.__class__.adjust_solver_defaults_based_on_setup(service, version, mode, path + ["adjust_solver_defaults_based_on_setup"])
                    self.density_based_explicit = self.__class__.density_based_explicit(service, version, mode, path + ["density_based_explicit"])
                    self.density_based_implicit = self.__class__.density_based_implicit(service, version, mode, path + ["density_based_implicit"])
                    self.pressure_based = self.__class__.pressure_based(service, version, mode, path + ["pressure_based"])
                    super().__init__(service, version, mode, path)
                class adjust_solver_defaults_based_on_setup(TUIMethod):
                    """
                    .
                    """
                class density_based_explicit(TUIMethod):
                    """
                    Enables/disables the density-based-explicit solver.
                    """
                class density_based_implicit(TUIMethod):
                    """
                    Enables/disables the density-based-implicit solver.
                    """
                class pressure_based(TUIMethod):
                    """
                    Enables/disables the pressure-based solver.
                    """

            class soot_parameters(TUIMenu):
                """
                Enters the soot parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self.inlet_diffusion = self.__class__.inlet_diffusion(service, version, mode, path + ["inlet_diffusion"])
                    self.modify_schmidt_number = self.__class__.modify_schmidt_number(service, version, mode, path + ["modify_schmidt_number"])
                    self.soot_model_parameters = self.__class__.soot_model_parameters(service, version, mode, path + ["soot_model_parameters"])
                    self.soot_model_udfs = self.__class__.soot_model_udfs(service, version, mode, path + ["soot_model_udfs"])
                    self.soot_process_parameters = self.__class__.soot_process_parameters(service, version, mode, path + ["soot_process_parameters"])
                    self.soot_radiation_interaction = self.__class__.soot_radiation_interaction(service, version, mode, path + ["soot_radiation_interaction"])
                    self.soot_turbulence_interaction = self.__class__.soot_turbulence_interaction(service, version, mode, path + ["soot_turbulence_interaction"])
                    super().__init__(service, version, mode, path)
                class inlet_diffusion(TUIMethod):
                    """
                    Enables/disables inclusion of diffusion at inlets.
                    """
                class modify_schmidt_number(TUIMethod):
                    """
                    Changes the turbulent Schmidt number for soot/nuclei equations.
                    """
                class soot_model_parameters(TUIMethod):
                    """
                    Selects soot model parameters.
                    """
                class soot_model_udfs(TUIMethod):
                    """
                    User defined functions for soot model.
                    """
                class soot_process_parameters(TUIMethod):
                    """
                    Selects soot process parameters.
                    """
                class soot_radiation_interaction(TUIMethod):
                    """
                    Enables/disables the soot-radiation interaction model.
                    """
                class soot_turbulence_interaction(TUIMethod):
                    """
                    Sets soot-turbulence interaction model.
                    """

            class species(TUIMenu):
                """
                Enters the species models menu.
                """
                def __init__(self, service, version, mode, path):
                    self.CHEMKIN_CFD_parameters = self.__class__.CHEMKIN_CFD_parameters(service, version, mode, path + ["CHEMKIN_CFD_parameters"])
                    self.CHEMKIN_CFD = self.__class__.CHEMKIN_CFD(service, version, mode, path + ["CHEMKIN_CFD"])
                    self.clear_isat_table = self.__class__.clear_isat_table(service, version, mode, path + ["clear_isat_table"])
                    self.coal_calculator = self.__class__.coal_calculator(service, version, mode, path + ["coal_calculator"])
                    self.combustion_expert = self.__class__.combustion_expert(service, version, mode, path + ["combustion_expert"])
                    self.combustion_numerics = self.__class__.combustion_numerics(service, version, mode, path + ["combustion_numerics"])
                    self.decoupled_detailed_chemistry = self.__class__.decoupled_detailed_chemistry(service, version, mode, path + ["decoupled_detailed_chemistry"])
                    self.diffusion_energy_source = self.__class__.diffusion_energy_source(service, version, mode, path + ["diffusion_energy_source"])
                    self.electro_chemical_surface_reactions = self.__class__.electro_chemical_surface_reactions(service, version, mode, path + ["electro_chemical_surface_reactions"])
                    self.epdf_energy = self.__class__.epdf_energy(service, version, mode, path + ["epdf_energy"])
                    self.flamelet_expert = self.__class__.flamelet_expert(service, version, mode, path + ["flamelet_expert"])
                    self.full_tabulation = self.__class__.full_tabulation(service, version, mode, path + ["full_tabulation"])
                    self.heat_of_surface_reactions = self.__class__.heat_of_surface_reactions(service, version, mode, path + ["heat_of_surface_reactions"])
                    self.ignition_model = self.__class__.ignition_model(service, version, mode, path + ["ignition_model"])
                    self.ignition_model_controls = self.__class__.ignition_model_controls(service, version, mode, path + ["ignition_model_controls"])
                    self.import_flamelet_for_restart = self.__class__.import_flamelet_for_restart(service, version, mode, path + ["import_flamelet_for_restart"])
                    self.inert_transport_controls = self.__class__.inert_transport_controls(service, version, mode, path + ["inert_transport_controls"])
                    self.inert_transport_model = self.__class__.inert_transport_model(service, version, mode, path + ["inert_transport_model"])
                    self.init_unsteady_flamelet_prob = self.__class__.init_unsteady_flamelet_prob(service, version, mode, path + ["init_unsteady_flamelet_prob"])
                    self.inlet_diffusion = self.__class__.inlet_diffusion(service, version, mode, path + ["inlet_diffusion"])
                    self.integration_parameters = self.__class__.integration_parameters(service, version, mode, path + ["integration_parameters"])
                    self.liquid_energy_diffusion = self.__class__.liquid_energy_diffusion(service, version, mode, path + ["liquid_energy_diffusion"])
                    self.liquid_micro_mixing = self.__class__.liquid_micro_mixing(service, version, mode, path + ["liquid_micro_mixing"])
                    self.mass_deposition_source = self.__class__.mass_deposition_source(service, version, mode, path + ["mass_deposition_source"])
                    self.mixing_model = self.__class__.mixing_model(service, version, mode, path + ["mixing_model"])
                    self.multicomponent_diffusion = self.__class__.multicomponent_diffusion(service, version, mode, path + ["multicomponent_diffusion"])
                    self.non_premixed_combustion = self.__class__.non_premixed_combustion(service, version, mode, path + ["non_premixed_combustion"])
                    self.non_premixed_combustion_expert = self.__class__.non_premixed_combustion_expert(service, version, mode, path + ["non_premixed_combustion_expert"])
                    self.non_premixed_combustion_parameters = self.__class__.non_premixed_combustion_parameters(service, version, mode, path + ["non_premixed_combustion_parameters"])
                    self.off = self.__class__.off(service, version, mode, path + ["off"])
                    self.partially_premixed_combustion = self.__class__.partially_premixed_combustion(service, version, mode, path + ["partially_premixed_combustion"])
                    self.partially_premixed_combustion_expert = self.__class__.partially_premixed_combustion_expert(service, version, mode, path + ["partially_premixed_combustion_expert"])
                    self.partially_premixed_combustion_grids = self.__class__.partially_premixed_combustion_grids(service, version, mode, path + ["partially_premixed_combustion_grids"])
                    self.partially_premixed_combustion_parameters = self.__class__.partially_premixed_combustion_parameters(service, version, mode, path + ["partially_premixed_combustion_parameters"])
                    self.partially_premixed_properties = self.__class__.partially_premixed_properties(service, version, mode, path + ["partially_premixed_properties"])
                    self.particle_surface_reactions = self.__class__.particle_surface_reactions(service, version, mode, path + ["particle_surface_reactions"])
                    self.pdf_transport = self.__class__.pdf_transport(service, version, mode, path + ["pdf_transport"])
                    self.pdf_transport_expert = self.__class__.pdf_transport_expert(service, version, mode, path + ["pdf_transport_expert"])
                    self.premixed_combustion = self.__class__.premixed_combustion(service, version, mode, path + ["premixed_combustion"])
                    self.premixed_model = self.__class__.premixed_model(service, version, mode, path + ["premixed_model"])
                    self.re_calc_par_premix_props = self.__class__.re_calc_par_premix_props(service, version, mode, path + ["re_calc_par_premix_props"])
                    self.reacting_channel_model = self.__class__.reacting_channel_model(service, version, mode, path + ["reacting_channel_model"])
                    self.reacting_channel_model_options = self.__class__.reacting_channel_model_options(service, version, mode, path + ["reacting_channel_model_options"])
                    self.reaction_diffusion_balance = self.__class__.reaction_diffusion_balance(service, version, mode, path + ["reaction_diffusion_balance"])
                    self.reactor_network_model = self.__class__.reactor_network_model(service, version, mode, path + ["reactor_network_model"])
                    self.relax_to_equil = self.__class__.relax_to_equil(service, version, mode, path + ["relax_to_equil"])
                    self.save_gradients = self.__class__.save_gradients(service, version, mode, path + ["save_gradients"])
                    self.set_multi_regime_fgm = self.__class__.set_multi_regime_fgm(service, version, mode, path + ["set_multi_regime_fgm"])
                    self.set_premixed_combustion = self.__class__.set_premixed_combustion(service, version, mode, path + ["set_premixed_combustion"])
                    self.set_turb_chem_interaction = self.__class__.set_turb_chem_interaction(service, version, mode, path + ["set_turb_chem_interaction"])
                    self.spark_model = self.__class__.spark_model(service, version, mode, path + ["spark_model"])
                    self.species_migration = self.__class__.species_migration(service, version, mode, path + ["species_migration"])
                    self.species_transport = self.__class__.species_transport(service, version, mode, path + ["species_transport"])
                    self.species_transport_expert = self.__class__.species_transport_expert(service, version, mode, path + ["species_transport_expert"])
                    self.stiff_chemistry = self.__class__.stiff_chemistry(service, version, mode, path + ["stiff_chemistry"])
                    self.surf_reaction_aggressiveness_factor = self.__class__.surf_reaction_aggressiveness_factor(service, version, mode, path + ["surf_reaction_aggressiveness_factor"])
                    self.surf_reaction_netm_params = self.__class__.surf_reaction_netm_params(service, version, mode, path + ["surf_reaction_netm_params"])
                    self.thermal_diffusion = self.__class__.thermal_diffusion(service, version, mode, path + ["thermal_diffusion"])
                    self.thickened_flame_model = self.__class__.thickened_flame_model(service, version, mode, path + ["thickened_flame_model"])
                    self.volumetric_reactions = self.__class__.volumetric_reactions(service, version, mode, path + ["volumetric_reactions"])
                    self.wall_surface_reactions = self.__class__.wall_surface_reactions(service, version, mode, path + ["wall_surface_reactions"])
                    self.water_corrosion_pre = self.__class__.water_corrosion_pre(service, version, mode, path + ["water_corrosion_pre"])
                    super().__init__(service, version, mode, path)
                class CHEMKIN_CFD(TUIMethod):
                    """
                    Enables/disables the Ansys CHEMKIN-CFD solver.
                    """
                class clear_isat_table(TUIMethod):
                    """
                    Clears ISAT table.
                    """
                class coal_calculator(TUIMethod):
                    """
                    Sets up coal modeling inputs.
                    """
                class combustion_expert(TUIMethod):
                    """
                    Enables import of the CHEMKIN mechanism transport 	data. When this option is enabled, you will be prompted 	for importing CHEMKIN transport property database when 	setting your combustion case.
                    """
                class combustion_numerics(TUIMethod):
                    """
                    Applies optimal solver settings automatically to provide a faster solution time. 	This command is available only for transient 	non-premixed and partially premixed combustion 	models.
                    """
                class decoupled_detailed_chemistry(TUIMethod):
                    """
                    Enables/disables the Decoupled Detailed Chemistry model.
                    """
                class diffusion_energy_source(TUIMethod):
                    """
                    Enables/disables diffusion energy source.
                    """
                class electro_chemical_surface_reactions(TUIMethod):
                    """
                    Enables/disables electrochemical surface reactions.
                    """
                class epdf_energy(TUIMethod):
                    """
                    Enables/disables EPDF energy option.
                    """
                class flamelet_expert(TUIMethod):
                    """
                    Sets flamelet expert parameters.
                    """
                class full_tabulation(TUIMethod):
                    """
                    Enables/disables building of a full 2-mixture fraction table.
                    """
                class heat_of_surface_reactions(TUIMethod):
                    """
                    Enables/disables heat of surface reactions.
                    """
                class ignition_model(TUIMethod):
                    """
                    Enables/disables the ignition model.
                    """
                class ignition_model_controls(TUIMethod):
                    """
                    Sets ignition model parameters.
                    """
                class import_flamelet_for_restart(TUIMethod):
                    """
                    Imports Flamelet File for Restart.
                    """
                class inert_transport_controls(TUIMethod):
                    """
                    Sets inert transport model parameters.
                    """
                class inert_transport_model(TUIMethod):
                    """
                    Enables/disables the inert transport model.
                    """
                class init_unsteady_flamelet_prob(TUIMethod):
                    """
                    Initializes Unsteady Flamelet Probability.
                    """
                class inlet_diffusion(TUIMethod):
                    """
                    Enables/disables inclusion of diffusion at inlets.
                    """
                class integration_parameters(TUIMethod):
                    """
                    Sets chemistry ODE integrator parameters. Enables/disables stiff chemistry 	acceleration methods and set their parameters.
                    """
                class liquid_energy_diffusion(TUIMethod):
                    """
                    .
                    """
                class liquid_micro_mixing(TUIMethod):
                    """
                    Enables/disables liquid micro mixing.
                    """
                class mass_deposition_source(TUIMethod):
                    """
                    Enables/disables mass deposition source due to surface reactions.
                    """
                class mixing_model(TUIMethod):
                    """
                    Sets PDF Transport mixing model.
                    """
                class multicomponent_diffusion(TUIMethod):
                    """
                    Enables/disables multicomponent diffusion.
                    """
                class non_premixed_combustion(TUIMethod):
                    """
                    Enables/disables non-premixed combustion model.
                    """
                class non_premixed_combustion_expert(TUIMethod):
                    """
                    Sets PDF expert parameters.
                    """
                class non_premixed_combustion_parameters(TUIMethod):
                    """
                    Sets PDF parameters.
                    """
                class off(TUIMethod):
                    """
                    Enables/disables solution of species models.
                    """
                class partially_premixed_combustion(TUIMethod):
                    """
                    Enables/disables partially premixed combustion model.
                    """
                class partially_premixed_combustion_expert(TUIMethod):
                    """
                    Sets PDF expert parameters.
                    """
                class partially_premixed_combustion_grids(TUIMethod):
                    """
                    Sets values for the grid distribution for PDF table or 	flamelet parameter. This text command is available only 	for partially premixed combustion cases with FGM.
                    """
                class partially_premixed_combustion_parameters(TUIMethod):
                    """
                    Sets PDF parameters.
                    """
                class partially_premixed_properties(TUIMethod):
                    """
                    Sets/changes partially-premixed mixture properties. 	This command is only available when partially-premixed-combustion? 	is enabled.
                    """
                class particle_surface_reactions(TUIMethod):
                    """
                    Enables/disables particle surface reactions.
                    """
                class pdf_transport(TUIMethod):
                    """
                    Enables/disables the composition PDF transport combustion model.
                    """
                class pdf_transport_expert(TUIMethod):
                    """
                    Enables/disables PDF Transport expert user.
                    """
                class premixed_combustion(TUIMethod):
                    """
                    Enables/disables premixed combustion model.
                    """
                class premixed_model(TUIMethod):
                    """
                    Sets premixed combustion model.
                    """
                class re_calc_par_premix_props(TUIMethod):
                    """
                    Re-calculate partially-premixed properties.
                    """
                class reacting_channel_model(TUIMethod):
                    """
                    Enables/disables the Reacting Channel Model.
                    """
                class reacting_channel_model_options(TUIMethod):
                    """
                    Sets Reacting Channel Model parameters.
                    """
                class reaction_diffusion_balance(TUIMethod):
                    """
                    Enables/disables reaction diffusion balance at reacting surface for surface 	reactions.
                    """
                class reactor_network_model(TUIMethod):
                    """
                    Enables/disables the Reactor Network Model.
                    """
                class relax_to_equil(TUIMethod):
                    """
                    Enables/disables the Relaxation to Chemical Equilibrium model.
                    """
                class save_gradients(TUIMethod):
                    """
                    Enables/disables storage of species mass fraction gradients.
                    """
                class set_multi_regime_fgm(TUIMethod):
                    """
                    Set-multi-regim-fgm-parameters.
                    """
                class set_premixed_combustion(TUIMethod):
                    """
                    Sets premixed combustion parameters.
                    """
                class set_turb_chem_interaction(TUIMethod):
                    """
                    Sets EDC model constants.
                    """
                class spark_model(TUIMethod):
                    """
                    Switches between the R15 and R14.5 spark models and sets spark model 	parameters.
                    """
                class species_migration(TUIMethod):
                    """
                    Includes species migration in electric field. This command is available only when 	the electrochemical surface reactions are 	enabled.
                    """
                class species_transport(TUIMethod):
                    """
                    Enables/disables the species transport model.
                    """
                class species_transport_expert(TUIMethod):
                    """
                    Sets the convergence acceleration expert parameters. This command is only available 	when the species transport model is enabled.
                    """
                class stiff_chemistry(TUIMethod):
                    """
                    Enables/disables stiff chemistry option.
                    """
                class surf_reaction_aggressiveness_factor(TUIMethod):
                    """
                    Sets the surface reaction aggressiveness factor.
                    """
                class surf_reaction_netm_params(TUIMethod):
                    """
                    Sets the surface reaction parameters for the Non-Equilibrium Thermal Model.
                    """
                class thermal_diffusion(TUIMethod):
                    """
                    Enables/disables thermal diffusion.
                    """
                class thickened_flame_model(TUIMethod):
                    """
                    Enables/disables the Relaxation to Chemical Equilibrium model.
                    """
                class volumetric_reactions(TUIMethod):
                    """
                    Enables/disables volumetric reactions.
                    """
                class wall_surface_reactions(TUIMethod):
                    """
                    Enables/disables wall surface reactions.
                    """
                class water_corrosion_pre(TUIMethod):
                    """
                    Compute water chemistry and set up corrosion material.
                    """

                class CHEMKIN_CFD_parameters(TUIMenu):
                    """
                    Enters the expert CHEMKIN-CFD parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.add_cell_monitor = self.__class__.add_cell_monitor(service, version, mode, path + ["add_cell_monitor"])
                        self.advanced_options = self.__class__.advanced_options(service, version, mode, path + ["advanced_options"])
                        self.basic_options = self.__class__.basic_options(service, version, mode, path + ["basic_options"])
                        self.delete_cell_monitors = self.__class__.delete_cell_monitors(service, version, mode, path + ["delete_cell_monitors"])
                        self.list_cell_monitors = self.__class__.list_cell_monitors(service, version, mode, path + ["list_cell_monitors"])
                        super().__init__(service, version, mode, path)
                    class add_cell_monitor(TUIMethod):
                        """
                        Monitors cell for debug output.
                        """
                    class advanced_options(TUIMethod):
                        """
                        Sets advanced parameter options.
                        """
                    class basic_options(TUIMethod):
                        """
                        Sets basic parameter options.
                        """
                    class delete_cell_monitors(TUIMethod):
                        """
                        Deletes cell monitors.
                        """
                    class list_cell_monitors(TUIMethod):
                        """
                        Lists cell monitors.
                        """

            class structure(TUIMenu):
                """
                Enters the structure model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.controls = self.__class__.controls(service, version, mode, path + ["controls"])
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.linear_elasticity = self.__class__.linear_elasticity(service, version, mode, path + ["linear_elasticity"])
                    self.nonlinear_elasticity = self.__class__.nonlinear_elasticity(service, version, mode, path + ["nonlinear_elasticity"])
                    self.structure_off = self.__class__.structure_off(service, version, mode, path + ["structure_off"])
                    self.thermal_effects = self.__class__.thermal_effects(service, version, mode, path + ["thermal_effects"])
                    super().__init__(service, version, mode, path)
                class linear_elasticity(TUIMethod):
                    """
                    Enables the linear elasticity model.
                    """
                class nonlinear_elasticity(TUIMethod):
                    """
                    Enable the nonlinear elasticity model.
                    """
                class structure_off(TUIMethod):
                    """
                    Disables the structural model.
                    """
                class thermal_effects(TUIMethod):
                    """
                    .
                    """

                class controls(TUIMenu):
                    """
                    Enters the structure controls menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.amg_stabilization = self.__class__.amg_stabilization(service, version, mode, path + ["amg_stabilization"])
                        self.enhanced_strain = self.__class__.enhanced_strain(service, version, mode, path + ["enhanced_strain"])
                        self.max_iter = self.__class__.max_iter(service, version, mode, path + ["max_iter"])
                        self.numerical_damping_factor = self.__class__.numerical_damping_factor(service, version, mode, path + ["numerical_damping_factor"])
                        self.unsteady_damping_rayleigh = self.__class__.unsteady_damping_rayleigh(service, version, mode, path + ["unsteady_damping_rayleigh"])
                        super().__init__(service, version, mode, path)
                    class amg_stabilization(TUIMethod):
                        """
                        Sets the algebraic multigrid (AMG) stabilization method for the structural model calculations.
                        """
                    class enhanced_strain(TUIMethod):
                        """
                        .
                        """
                    class max_iter(TUIMethod):
                        """
                        Sets the maximum number of iterations for the structural model calculations.
                        """
                    class numerical_damping_factor(TUIMethod):
                        """
                        Sets the damping factor for the structural model (that is, the amplitude decay factor  in  in the Theory Guide).
                        """
                    class unsteady_damping_rayleigh(TUIMethod):
                        """
                        .
                        """

                class expert(TUIMenu):
                    """
                    Enters the structure expert menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.explicit_fsi_force = self.__class__.explicit_fsi_force(service, version, mode, path + ["explicit_fsi_force"])
                        self.include_pop_in_fsi_force = self.__class__.include_pop_in_fsi_force(service, version, mode, path + ["include_pop_in_fsi_force"])
                        self.include_viscous_fsi_force = self.__class__.include_viscous_fsi_force(service, version, mode, path + ["include_viscous_fsi_force"])
                        self.starting_t_re_initialization = self.__class__.starting_t_re_initialization(service, version, mode, path + ["starting_t_re_initialization"])
                        self.steady_2way_fsi = self.__class__.steady_2way_fsi(service, version, mode, path + ["steady_2way_fsi"])
                        super().__init__(service, version, mode, path)
                    class explicit_fsi_force(TUIMethod):
                        """
                        Enables/disables an explicit fluid-structure interaction force.
                        """
                    class include_pop_in_fsi_force(TUIMethod):
                        """
                        Enables/disables the inclusion of operating pressure into the fluid-structure interaction force.
                        """
                    class include_viscous_fsi_force(TUIMethod):
                        """
                        Enables/disables the inclusion of a viscous fluid-structure interaction force.
                        """
                    class starting_t_re_initialization(TUIMethod):
                        """
                        .
                        """
                    class steady_2way_fsi(TUIMethod):
                        """
                        .
                        """

            class system_coupling_settings(TUIMenu):
                """
                Enters the system coupling menu.
                """
                def __init__(self, service, version, mode, path):
                    self.htc = self.__class__.htc(service, version, mode, path + ["htc"])
                    self.unsteady_statistics = self.__class__.unsteady_statistics(service, version, mode, path + ["unsteady_statistics"])
                    self.use_face_or_element_based_data_transfer = self.__class__.use_face_or_element_based_data_transfer(service, version, mode, path + ["use_face_or_element_based_data_transfer"])
                    self.user_defined_coupling_variables_via_udm = self.__class__.user_defined_coupling_variables_via_udm(service, version, mode, path + ["user_defined_coupling_variables_via_udm"])
                    super().__init__(service, version, mode, path)
                class use_face_or_element_based_data_transfer(TUIMethod):
                    """
                    Answering yes at the prompt 	enables Fluent to use element data for mapping surface 	conservative quantities such as surface forces and heat 	flows.
                    """
                class user_defined_coupling_variables_via_udm(TUIMethod):
                    """
                    User defined coupling variables via UDM.
                    """

                class htc(TUIMenu):
                    """
                    Enter the heat transfer coeficient menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.htc_calculation_method = self.__class__.htc_calculation_method(service, version, mode, path + ["htc_calculation_method"])
                        super().__init__(service, version, mode, path)

                    class htc_calculation_method(TUIMenu):
                        """
                        Enter the htc calculation menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.use_tref_in_htc_calculation = self.__class__.use_tref_in_htc_calculation(service, version, mode, path + ["use_tref_in_htc_calculation"])
                            self.use_wall_function_based_htc = self.__class__.use_wall_function_based_htc(service, version, mode, path + ["use_wall_function_based_htc"])
                            self.use_yplus_based_htc_calculation = self.__class__.use_yplus_based_htc_calculation(service, version, mode, path + ["use_yplus_based_htc_calculation"])
                            super().__init__(service, version, mode, path)
                        class use_tref_in_htc_calculation(TUIMethod):
                            """
                            Enable/disable tref in htc computation.
                            """
                        class use_wall_function_based_htc(TUIMethod):
                            """
                            Enable/disable wall function based htc computation.
                            """
                        class use_yplus_based_htc_calculation(TUIMethod):
                            """
                            Enable/disable yplus in htc computation.
                            """

                class unsteady_statistics(TUIMenu):
                    """
                    Enter the unsteady statistics menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.sc_enable_sub_stepping_option_per_coupling_step = self.__class__.sc_enable_sub_stepping_option_per_coupling_step(service, version, mode, path + ["sc_enable_sub_stepping_option_per_coupling_step"])
                        super().__init__(service, version, mode, path)
                    class sc_enable_sub_stepping_option_per_coupling_step(TUIMethod):
                        """
                        Enable/disable sub stepping option per coupling step.
                        """

            class two_temperature(TUIMenu):
                """
                Enters the Two-Temperature model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.translational_vibrational_energy_relaxation = self.__class__.translational_vibrational_energy_relaxation(service, version, mode, path + ["translational_vibrational_energy_relaxation"])
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.nasa9_enhancement = self.__class__.nasa9_enhancement(service, version, mode, path + ["nasa9_enhancement"])
                    self.robustness_enhancement = self.__class__.robustness_enhancement(service, version, mode, path + ["robustness_enhancement"])
                    self.set_verbosity = self.__class__.set_verbosity(service, version, mode, path + ["set_verbosity"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enables/disables the Two-Temperature model.
                    """
                class nasa9_enhancement(TUIMethod):
                    """
                    .
                    """
                class robustness_enhancement(TUIMethod):
                    """
                    Enables/disables the robustness enhancement, which is 	on by default.
                    """
                class set_verbosity(TUIMethod):
                    """
                    Specifies the level of detail printed in the console 	about the Two-Temperature model. For a verbosity of one, 	Fluent will print the number of cells that reach the 	temperature limit, have an excessive temperature change, 	or get a negative temperature.
                    """

                class translational_vibrational_energy_relaxation(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                        self.model = self.__class__.model(service, version, mode, path + ["model"])
                        super().__init__(service, version, mode, path)
                    class model(TUIMethod):
                        """
                        .
                        """

                    class expert(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                            self.list_all = self.__class__.list_all(service, version, mode, path + ["list_all"])
                            self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                            self.number_of_objects = self.__class__.number_of_objects(service, version, mode, path + ["number_of_objects"])
                            super().__init__(service, version, mode, path)
                        class edit(TUIMethod):
                            """
                            Edit expert object.
                            """
                        class list_all(TUIMethod):
                            """
                            .
                            """
                        class list_properties(TUIMethod):
                            """
                            .
                            """
                        class number_of_objects(TUIMethod):
                            """
                            Set number of objects for expert.
                            """

            class virtual_blade_model(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.rotor = self.__class__.rotor(service, version, mode, path + ["rotor"])
                    self.apply = self.__class__.apply(service, version, mode, path + ["apply"])
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.mode = self.__class__.mode(service, version, mode, path + ["mode"])
                    super().__init__(service, version, mode, path)
                class apply(TUIMethod):
                    """
                    .
                    """
                class enable(TUIMethod):
                    """
                    .
                    """
                class mode(TUIMethod):
                    """
                    .
                    """

                class rotor(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                        self.new = self.__class__.new(service, version, mode, path + ["new"])
                        self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                        super().__init__(service, version, mode, path)
                    class delete(TUIMethod):
                        """
                        .
                        """
                    class edit(TUIMethod):
                        """
                        Edit rotor object.
                        """
                    class list(TUIMethod):
                        """
                        .
                        """
                    class list_properties(TUIMethod):
                        """
                        .
                        """
                    class make_a_copy(TUIMethod):
                        """
                        .
                        """
                    class new(TUIMethod):
                        """
                        Create a new rotor object.
                        """
                    class rename(TUIMethod):
                        """
                        Rename rotor object.
                        """

            class viscous(TUIMenu):
                """
                Enters the viscous model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.geko_options = self.__class__.geko_options(service, version, mode, path + ["geko_options"])
                    self.les_model_options = self.__class__.les_model_options(service, version, mode, path + ["les_model_options"])
                    self.multiphase_turbulence = self.__class__.multiphase_turbulence(service, version, mode, path + ["multiphase_turbulence"])
                    self.near_wall_treatment = self.__class__.near_wall_treatment(service, version, mode, path + ["near_wall_treatment"])
                    self.transition_model_options = self.__class__.transition_model_options(service, version, mode, path + ["transition_model_options"])
                    self.turbulence_expert = self.__class__.turbulence_expert(service, version, mode, path + ["turbulence_expert"])
                    self.add_intermittency_transition_model = self.__class__.add_intermittency_transition_model(service, version, mode, path + ["add_intermittency_transition_model"])
                    self.add_transition_model = self.__class__.add_transition_model(service, version, mode, path + ["add_transition_model"])
                    self.buoyancy_effects = self.__class__.buoyancy_effects(service, version, mode, path + ["buoyancy_effects"])
                    self.corner_flow_correction = self.__class__.corner_flow_correction(service, version, mode, path + ["corner_flow_correction"])
                    self.corner_flow_correction_ccorner = self.__class__.corner_flow_correction_ccorner(service, version, mode, path + ["corner_flow_correction_ccorner"])
                    self.curvature_correction = self.__class__.curvature_correction(service, version, mode, path + ["curvature_correction"])
                    self.curvature_correction_ccurv = self.__class__.curvature_correction_ccurv(service, version, mode, path + ["curvature_correction_ccurv"])
                    self.des_limiter_option = self.__class__.des_limiter_option(service, version, mode, path + ["des_limiter_option"])
                    self.detached_eddy_simulation = self.__class__.detached_eddy_simulation(service, version, mode, path + ["detached_eddy_simulation"])
                    self.geko = self.__class__.geko(service, version, mode, path + ["geko"])
                    self.inviscid = self.__class__.inviscid(service, version, mode, path + ["inviscid"])
                    self.k_kl_w = self.__class__.k_kl_w(service, version, mode, path + ["k_kl_w"])
                    self.ke1e = self.__class__.ke1e(service, version, mode, path + ["ke1e"])
                    self.ke_easm = self.__class__.ke_easm(service, version, mode, path + ["ke_easm"])
                    self.ke_realizable = self.__class__.ke_realizable(service, version, mode, path + ["ke_realizable"])
                    self.ke_rng = self.__class__.ke_rng(service, version, mode, path + ["ke_rng"])
                    self.ke_standard = self.__class__.ke_standard(service, version, mode, path + ["ke_standard"])
                    self.kw_bsl = self.__class__.kw_bsl(service, version, mode, path + ["kw_bsl"])
                    self.kw_buoyancy_effects = self.__class__.kw_buoyancy_effects(service, version, mode, path + ["kw_buoyancy_effects"])
                    self.kw_easm = self.__class__.kw_easm(service, version, mode, path + ["kw_easm"])
                    self.kw_geko = self.__class__.kw_geko(service, version, mode, path + ["kw_geko"])
                    self.kw_low_re_correction = self.__class__.kw_low_re_correction(service, version, mode, path + ["kw_low_re_correction"])
                    self.kw_shear_correction = self.__class__.kw_shear_correction(service, version, mode, path + ["kw_shear_correction"])
                    self.kw_sst = self.__class__.kw_sst(service, version, mode, path + ["kw_sst"])
                    self.kw_standard = self.__class__.kw_standard(service, version, mode, path + ["kw_standard"])
                    self.kw_wj_bsl_earsm = self.__class__.kw_wj_bsl_earsm(service, version, mode, path + ["kw_wj_bsl_earsm"])
                    self.laminar = self.__class__.laminar(service, version, mode, path + ["laminar"])
                    self.large_eddy_simulation = self.__class__.large_eddy_simulation(service, version, mode, path + ["large_eddy_simulation"])
                    self.les_dynamic_energy_flux = self.__class__.les_dynamic_energy_flux(service, version, mode, path + ["les_dynamic_energy_flux"])
                    self.les_dynamic_scalar_flux = self.__class__.les_dynamic_scalar_flux(service, version, mode, path + ["les_dynamic_scalar_flux"])
                    self.les_subgrid_dynamic_fvar = self.__class__.les_subgrid_dynamic_fvar(service, version, mode, path + ["les_subgrid_dynamic_fvar"])
                    self.les_subgrid_rng = self.__class__.les_subgrid_rng(service, version, mode, path + ["les_subgrid_rng"])
                    self.les_subgrid_sigma = self.__class__.les_subgrid_sigma(service, version, mode, path + ["les_subgrid_sigma"])
                    self.les_subgrid_smagorinsky = self.__class__.les_subgrid_smagorinsky(service, version, mode, path + ["les_subgrid_smagorinsky"])
                    self.les_subgrid_tke = self.__class__.les_subgrid_tke(service, version, mode, path + ["les_subgrid_tke"])
                    self.les_subgrid_vreman = self.__class__.les_subgrid_vreman(service, version, mode, path + ["les_subgrid_vreman"])
                    self.les_subgrid_wale = self.__class__.les_subgrid_wale(service, version, mode, path + ["les_subgrid_wale"])
                    self.les_subgrid_wmles = self.__class__.les_subgrid_wmles(service, version, mode, path + ["les_subgrid_wmles"])
                    self.les_subgrid_wmles_s_minus_omega = self.__class__.les_subgrid_wmles_s_minus_omega(service, version, mode, path + ["les_subgrid_wmles_s_minus_omega"])
                    self.low_pressure_boundary_slip = self.__class__.low_pressure_boundary_slip(service, version, mode, path + ["low_pressure_boundary_slip"])
                    self.mixing_length = self.__class__.mixing_length(service, version, mode, path + ["mixing_length"])
                    self.reynolds_stress_model = self.__class__.reynolds_stress_model(service, version, mode, path + ["reynolds_stress_model"])
                    self.rng_differential_visc = self.__class__.rng_differential_visc(service, version, mode, path + ["rng_differential_visc"])
                    self.rng_swirl_model = self.__class__.rng_swirl_model(service, version, mode, path + ["rng_swirl_model"])
                    self.rsm_bsl_based = self.__class__.rsm_bsl_based(service, version, mode, path + ["rsm_bsl_based"])
                    self.rsm_linear_pressure_strain = self.__class__.rsm_linear_pressure_strain(service, version, mode, path + ["rsm_linear_pressure_strain"])
                    self.rsm_omega_based = self.__class__.rsm_omega_based(service, version, mode, path + ["rsm_omega_based"])
                    self.rsm_or_earsm_geko_option = self.__class__.rsm_or_earsm_geko_option(service, version, mode, path + ["rsm_or_earsm_geko_option"])
                    self.rsm_solve_tke = self.__class__.rsm_solve_tke(service, version, mode, path + ["rsm_solve_tke"])
                    self.rsm_ssg_pressure_strain = self.__class__.rsm_ssg_pressure_strain(service, version, mode, path + ["rsm_ssg_pressure_strain"])
                    self.rsm_wall_echo = self.__class__.rsm_wall_echo(service, version, mode, path + ["rsm_wall_echo"])
                    self.sa_alternate_prod = self.__class__.sa_alternate_prod(service, version, mode, path + ["sa_alternate_prod"])
                    self.sa_damping = self.__class__.sa_damping(service, version, mode, path + ["sa_damping"])
                    self.sa_enhanced_wall_treatment = self.__class__.sa_enhanced_wall_treatment(service, version, mode, path + ["sa_enhanced_wall_treatment"])
                    self.sas = self.__class__.sas(service, version, mode, path + ["sas"])
                    self.spalart_allmaras = self.__class__.spalart_allmaras(service, version, mode, path + ["spalart_allmaras"])
                    self.trans_sst_roughness_correlation = self.__class__.trans_sst_roughness_correlation(service, version, mode, path + ["trans_sst_roughness_correlation"])
                    self.transition_sst = self.__class__.transition_sst(service, version, mode, path + ["transition_sst"])
                    self.turb_buoyancy_effects = self.__class__.turb_buoyancy_effects(service, version, mode, path + ["turb_buoyancy_effects"])
                    self.turb_compressibility = self.__class__.turb_compressibility(service, version, mode, path + ["turb_compressibility"])
                    self.user_defined = self.__class__.user_defined(service, version, mode, path + ["user_defined"])
                    self.user_defined_transition = self.__class__.user_defined_transition(service, version, mode, path + ["user_defined_transition"])
                    self.v2f = self.__class__.v2f(service, version, mode, path + ["v2f"])
                    self.zero_equation_hvac = self.__class__.zero_equation_hvac(service, version, mode, path + ["zero_equation_hvac"])
                    super().__init__(service, version, mode, path)
                class add_intermittency_transition_model(TUIMethod):
                    """
                    Enable/disable the intermittency transition model to account for transitional effects.
                    """
                class add_transition_model(TUIMethod):
                    """
                    Sets Transition model to account for transitional effects. The default is none, however you can 	select gamma-algebraic or gamma-transport-eqn.  After a transition model has been enabled, you have additional options in the 	submenu transition-model-options.
                    """
                class buoyancy_effects(TUIMethod):
                    """
                    Enable/disable effects of buoyancy on turbulence.
                    """
                class corner_flow_correction(TUIMethod):
                    """
                    Enables/disables the corner flow correction.
                    """
                class corner_flow_correction_ccorner(TUIMethod):
                    """
                    Sets the strength of the quadratic term of the corner flow correction. The default 	value is 1. This is available after the corner-flow-correction? 	option is enabled.
                    """
                class curvature_correction(TUIMethod):
                    """
                    Enables/disables the curvature correction.
                    """
                class curvature_correction_ccurv(TUIMethod):
                    """
                    Sets the strength of the curvature correction term. 	The default value is 1. This is available after the curvature-correction? 	option is enabled.
                    """
                class des_limiter_option(TUIMethod):
                    """
                    Selects the DES limiter option (none, F1, F2, Delayed DES, or Improved Delayed 	DES).
                    """
                class detached_eddy_simulation(TUIMethod):
                    """
                    Enables/disables detached eddy simulation.
                    """
                class geko(TUIMethod):
                    """
                    Enable/disable the GEKO model.
                    """
                class inviscid(TUIMethod):
                    """
                    Enables/disables inviscid flow model.
                    """
                class k_kl_w(TUIMethod):
                    """
                    Enables/disables the k-kl-  turbulence model.
                    """
                class ke1e(TUIMethod):
                    """
                    Enable/disable the KE1E turbulence model.
                    """
                class ke_easm(TUIMethod):
                    """
                    Enables/disables the EASM -  turbulence model.
                    """
                class ke_realizable(TUIMethod):
                    """
                    Enables/disables the realizable -  turbulence model.
                    """
                class ke_rng(TUIMethod):
                    """
                    Enables/disables the RNG -  turbulence model.
                    """
                class ke_standard(TUIMethod):
                    """
                    Enables/disables the standard -  turbulence model.
                    """
                class kw_bsl(TUIMethod):
                    """
                    Enables/disables the baseline (BSL) -  turbulence model.
                    """
                class kw_buoyancy_effects(TUIMethod):
                    """
                    Enable/disable effects of buoyancy on k-omega turbulence model.
                    """
                class kw_easm(TUIMethod):
                    """
                    Enables/disables the EASM -  turbulence model.
                    """
                class kw_geko(TUIMethod):
                    """
                    Enables/disables the generalized -  (GEKO) turbulence model.
                    """
                class kw_low_re_correction(TUIMethod):
                    """
                    Enables/disables the -  low Re option.
                    """
                class kw_shear_correction(TUIMethod):
                    """
                    Enables/disables the -  shear-flow correction option. This 	text command is only available for the standard  -  model and the stress-omega RSM 	model.
                    """
                class kw_sst(TUIMethod):
                    """
                    Enables/disables the SST -  turbulence model.
                    """
                class kw_standard(TUIMethod):
                    """
                    Enables/disables the standard -  turbulence model.
                    """
                class kw_wj_bsl_earsm(TUIMethod):
                    """
                    Enable/disable the EASM k-omega turbulence model.
                    """
                class laminar(TUIMethod):
                    """
                    Enables/disables laminar flow model.
                    """
                class large_eddy_simulation(TUIMethod):
                    """
                    Enables/disables large eddy simulation.
                    """
                class les_dynamic_energy_flux(TUIMethod):
                    """
                    Enables/disables the dynamic sub-grid scale turbulent Prandtl Number.
                    """
                class les_dynamic_scalar_flux(TUIMethod):
                    """
                    Enables/disables the dynamic sub-grid scale turbulent Schmidt Number.
                    """
                class les_subgrid_dynamic_fvar(TUIMethod):
                    """
                    Enables/disables the dynamic subgrid-scale mixture fraction variance model.
                    """
                class les_subgrid_rng(TUIMethod):
                    """
                    Enable/disable the RNG subgrid-scale model.
                    """
                class les_subgrid_sigma(TUIMethod):
                    """
                    Enable/disable the Sigma subgrid-scale model.
                    """
                class les_subgrid_smagorinsky(TUIMethod):
                    """
                    Enables/disables the Smagorinsky-Lilly subgrid-scale model.
                    """
                class les_subgrid_tke(TUIMethod):
                    """
                    Enables/disables kinetic energy transport subgrid-scale model.
                    """
                class les_subgrid_vreman(TUIMethod):
                    """
                    Enable/disable the Vreman subgrid-scale model.
                    """
                class les_subgrid_wale(TUIMethod):
                    """
                    Enables/disables WALE subgrid-scale model.
                    """
                class les_subgrid_wmles(TUIMethod):
                    """
                    Enables/disables the WMLES subgrid-scale model.
                    """
                class les_subgrid_wmles_s_minus_omega(TUIMethod):
                    """
                    Enables/disables the WMLES -  subgrid-scale model.
                    """
                class low_pressure_boundary_slip(TUIMethod):
                    """
                    Enables/disables the slip boundary formulation for 	low-pressure gas systems.
                    """
                class mixing_length(TUIMethod):
                    """
                    Enables/disables mixing-length (algebraic) turbulence model.
                    """
                class reynolds_stress_model(TUIMethod):
                    """
                    Enables/disables the Reynolds-stress turbulence model.
                    """
                class rng_differential_visc(TUIMethod):
                    """
                    Enables/disables the differential-viscosity model.
                    """
                class rng_swirl_model(TUIMethod):
                    """
                    Enables/disables swirl corrections for rng-model.
                    """
                class rsm_bsl_based(TUIMethod):
                    """
                    Enables/disables the stress-BSL Reynolds stress model.
                    """
                class rsm_linear_pressure_strain(TUIMethod):
                    """
                    Enables/disables the linear pressure-strain model in RSM.
                    """
                class rsm_omega_based(TUIMethod):
                    """
                    Enables/disables the stress-omega Reynolds stress model.
                    """
                class rsm_or_earsm_geko_option(TUIMethod):
                    """
                    Enables/disables the RSM version of the GEKO model.
                    """
                class rsm_solve_tke(TUIMethod):
                    """
                    Enables/disables the solution of T.K.E. in RSM model.
                    """
                class rsm_ssg_pressure_strain(TUIMethod):
                    """
                    Enables/disables quadratic pressure-strain model in RSM.
                    """
                class rsm_wall_echo(TUIMethod):
                    """
                    Enables/disables wall-echo effects in RSM model.
                    """
                class sa_alternate_prod(TUIMethod):
                    """
                    Enables/disables strain/vorticity production in Spalart-Allmaras model.
                    """
                class sa_damping(TUIMethod):
                    """
                    Enables/disables full low-Reynolds number form of Spalart-Allmaras model. This option is only available if your response wasno to sa-enhanced-wall-treatment?.
                    """
                class sa_enhanced_wall_treatment(TUIMethod):
                    """
                    Enables/disables the enhanced wall treatment for the Spalart-Allmaras model. If 	disabled, no smooth blending between the viscous 	sublayer and the log-law formulation is employed, as was 	done in versions previous to Fluent 14.
                    """
                class sas(TUIMethod):
                    """
                    Enables/disables Scale-Adaptive Simulation (SAS) in combination with the SST  -  turbulence model.
                    """
                class spalart_allmaras(TUIMethod):
                    """
                    Enables/disables Spalart-Allmaras turbulence model.
                    """
                class trans_sst_roughness_correlation(TUIMethod):
                    """
                    Enables/disables the Transition-SST roughness correlation option.
                    """
                class transition_sst(TUIMethod):
                    """
                    Enables/disables the transition SST turbulence model.
                    """
                class turb_buoyancy_effects(TUIMethod):
                    """
                    Enables/disables effects of buoyancy on 	turbulence.
                    """
                class turb_compressibility(TUIMethod):
                    """
                    Enables/disables the compressibility correction option.
                    """
                class user_defined(TUIMethod):
                    """
                    Selects user-defined functions to define the turbulent viscosity and the turbulent 	Prandtl and Schmidt numbers.
                    """
                class user_defined_transition(TUIMethod):
                    """
                    Sets user-defined transition correlations.
                    """
                class v2f(TUIMethod):
                    """
                    Enables/disables V2F turbulence model.
                    """
                class zero_equation_hvac(TUIMethod):
                    """
                    Enables/disables zero-equation HVAC turbulence model.
                    """

                class geko_options(TUIMenu):
                    """
                    Enters the GEKO model menu..
                    """
                    def __init__(self, service, version, mode, path):
                        self.blending_function = self.__class__.blending_function(service, version, mode, path + ["blending_function"])
                        self.cbf_lam = self.__class__.cbf_lam(service, version, mode, path + ["cbf_lam"])
                        self.cbf_tur = self.__class__.cbf_tur(service, version, mode, path + ["cbf_tur"])
                        self.cjet = self.__class__.cjet(service, version, mode, path + ["cjet"])
                        self.cjet_aux = self.__class__.cjet_aux(service, version, mode, path + ["cjet_aux"])
                        self.cmix = self.__class__.cmix(service, version, mode, path + ["cmix"])
                        self.cnw = self.__class__.cnw(service, version, mode, path + ["cnw"])
                        self.cnw_sub = self.__class__.cnw_sub(service, version, mode, path + ["cnw_sub"])
                        self.creal = self.__class__.creal(service, version, mode, path + ["creal"])
                        self.csep = self.__class__.csep(service, version, mode, path + ["csep"])
                        self.geko_defaults = self.__class__.geko_defaults(service, version, mode, path + ["geko_defaults"])
                        self.wall_distance_free = self.__class__.wall_distance_free(service, version, mode, path + ["wall_distance_free"])
                        super().__init__(service, version, mode, path)
                    class blending_function(TUIMethod):
                        """
                        Sets the blending function, which deactivatescmix and cjet inside boundary layers.
                        """
                    class cbf_lam(TUIMethod):
                        """
                        Setscbf_lam, a part of the blending function and shields the laminar boundary layer.
                        """
                    class cbf_tur(TUIMethod):
                        """
                        Setscbf_tur, a factor for the main blending factor, controlling the thickness of the layer near walls.
                        """
                    class cjet(TUIMethod):
                        """
                        Setscjet, the parameter to optimize free shear layer mixing (optimize free jets independent of mixing layer).
                        """
                    class cjet_aux(TUIMethod):
                        """
                        Setscjet_aux, which allows fine-tuning of the parameter to optimize free jets.
                        """
                    class cmix(TUIMethod):
                        """
                        Setscmix, the parameter to optimize strength of mixing in free shear flows.
                        """
                    class cnw(TUIMethod):
                        """
                        Setscnw, the parameter to optimize flow in non-equilibrium near wall regions.
                        """
                    class cnw_sub(TUIMethod):
                        """
                        Setscnw_sub, which allows the adjustment of log-layer and cf.
                        """
                    class creal(TUIMethod):
                        """
                        Setscreal, a realizability limiter that ensures positive normal stresses in the entire domain.
                        """
                    class csep(TUIMethod):
                        """
                        Setscsep, the parameter to optimize flow separation from smooth surfaces.
                        """
                    class geko_defaults(TUIMethod):
                        """
                        Restores the defaults of all GEKO parameters.
                        """
                    class wall_distance_free(TUIMethod):
                        """
                        Enables/disables the wall distance free version of the GEKO model.
                        """

                class les_model_options(TUIMenu):
                    """
                    Enter the LES model options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.csigma = self.__class__.csigma(service, version, mode, path + ["csigma"])
                        self.cvreman = self.__class__.cvreman(service, version, mode, path + ["cvreman"])
                        self.cw1 = self.__class__.cw1(service, version, mode, path + ["cw1"])
                        self.cw2 = self.__class__.cw2(service, version, mode, path + ["cw2"])
                        self.near_wall_rans_layer = self.__class__.near_wall_rans_layer(service, version, mode, path + ["near_wall_rans_layer"])
                        super().__init__(service, version, mode, path)
                    class csigma(TUIMethod):
                        """
                        .
                        """
                    class cvreman(TUIMethod):
                        """
                        .
                        """
                    class cw1(TUIMethod):
                        """
                        .
                        """
                    class cw2(TUIMethod):
                        """
                        .
                        """
                    class near_wall_rans_layer(TUIMethod):
                        """
                        .
                        """

                class multiphase_turbulence(TUIMenu):
                    """
                    Enters the multiphase turbulence menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.multiphase_options = self.__class__.multiphase_options(service, version, mode, path + ["multiphase_options"])
                        self.rsm_multiphase_models = self.__class__.rsm_multiphase_models(service, version, mode, path + ["rsm_multiphase_models"])
                        self.subgrid_turbulence_contribution_aiad = self.__class__.subgrid_turbulence_contribution_aiad(service, version, mode, path + ["subgrid_turbulence_contribution_aiad"])
                        self.turbulence_multiphase_models = self.__class__.turbulence_multiphase_models(service, version, mode, path + ["turbulence_multiphase_models"])
                        super().__init__(service, version, mode, path)
                    class multiphase_options(TUIMethod):
                        """
                        Enables/disables multiphase options.
                        """
                    class rsm_multiphase_models(TUIMethod):
                        """
                        Selects Reynolds Stress multiphase model.
                        """
                    class subgrid_turbulence_contribution_aiad(TUIMethod):
                        """
                        .
                        """
                    class turbulence_multiphase_models(TUIMethod):
                        """
                        Selects -  multiphase model.
                        """

                class near_wall_treatment(TUIMenu):
                    """
                    Enters the near wall treatment menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enhanced_wall_treatment = self.__class__.enhanced_wall_treatment(service, version, mode, path + ["enhanced_wall_treatment"])
                        self.harmonic_blend_rplus_wf = self.__class__.harmonic_blend_rplus_wf(service, version, mode, path + ["harmonic_blend_rplus_wf"])
                        self.menter_lechner = self.__class__.menter_lechner(service, version, mode, path + ["menter_lechner"])
                        self.non_equilibrium_wall_fn = self.__class__.non_equilibrium_wall_fn(service, version, mode, path + ["non_equilibrium_wall_fn"])
                        self.scalable_wall_functions = self.__class__.scalable_wall_functions(service, version, mode, path + ["scalable_wall_functions"])
                        self.user_defined_wall_functions = self.__class__.user_defined_wall_functions(service, version, mode, path + ["user_defined_wall_functions"])
                        self.wall_omega_treatment = self.__class__.wall_omega_treatment(service, version, mode, path + ["wall_omega_treatment"])
                        self.werner_wengle_wall_fn = self.__class__.werner_wengle_wall_fn(service, version, mode, path + ["werner_wengle_wall_fn"])
                        self.wf_pressure_gradient_effects = self.__class__.wf_pressure_gradient_effects(service, version, mode, path + ["wf_pressure_gradient_effects"])
                        self.wf_thermal_effects = self.__class__.wf_thermal_effects(service, version, mode, path + ["wf_thermal_effects"])
                        super().__init__(service, version, mode, path)
                    class enhanced_wall_treatment(TUIMethod):
                        """
                        Enables/disables enhanced wall functions.
                        """
                    class harmonic_blend_rplus_wf(TUIMethod):
                        """
                        Enable/disable harmonic blended wall functions based on r-plus.
                        """
                    class menter_lechner(TUIMethod):
                        """
                        Enables/disables the Menter-Lechner near-wall treatment.
                        """
                    class non_equilibrium_wall_fn(TUIMethod):
                        """
                        Enables/disables non-equilibrium wall functions.
                        """
                    class scalable_wall_functions(TUIMethod):
                        """
                        Enables/disables scalable wall functions.
                        """
                    class user_defined_wall_functions(TUIMethod):
                        """
                        Enables/disables user-defined wall functions.
                        """
                    class wall_omega_treatment(TUIMethod):
                        """
                        .
                        """
                    class werner_wengle_wall_fn(TUIMethod):
                        """
                        Enables/disables Werner-Wengle wall functions.
                        """
                    class wf_pressure_gradient_effects(TUIMethod):
                        """
                        Enables/disables wall function pressure- gradient effects.
                        """
                    class wf_thermal_effects(TUIMethod):
                        """
                        Enables/disables wall function thermal effects.
                        """

                class transition_model_options(TUIMenu):
                    """
                    Enters the transition model options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.capg_hightu = self.__class__.capg_hightu(service, version, mode, path + ["capg_hightu"])
                        self.capg_lowtu = self.__class__.capg_lowtu(service, version, mode, path + ["capg_lowtu"])
                        self.cbubble_c1 = self.__class__.cbubble_c1(service, version, mode, path + ["cbubble_c1"])
                        self.cbubble_c2 = self.__class__.cbubble_c2(service, version, mode, path + ["cbubble_c2"])
                        self.cfpg_hightu = self.__class__.cfpg_hightu(service, version, mode, path + ["cfpg_hightu"])
                        self.cfpg_lowtu = self.__class__.cfpg_lowtu(service, version, mode, path + ["cfpg_lowtu"])
                        self.clambda_scale = self.__class__.clambda_scale(service, version, mode, path + ["clambda_scale"])
                        self.critical_reynolds_number_correlation = self.__class__.critical_reynolds_number_correlation(service, version, mode, path + ["critical_reynolds_number_correlation"])
                        self.crossflow_transition = self.__class__.crossflow_transition(service, version, mode, path + ["crossflow_transition"])
                        self.ctu_hightu = self.__class__.ctu_hightu(service, version, mode, path + ["ctu_hightu"])
                        self.ctu_lowtu = self.__class__.ctu_lowtu(service, version, mode, path + ["ctu_lowtu"])
                        self.rec_c1 = self.__class__.rec_c1(service, version, mode, path + ["rec_c1"])
                        self.rec_c2 = self.__class__.rec_c2(service, version, mode, path + ["rec_c2"])
                        self.rec_max = self.__class__.rec_max(service, version, mode, path + ["rec_max"])
                        self.rv1_switch = self.__class__.rv1_switch(service, version, mode, path + ["rv1_switch"])
                        super().__init__(service, version, mode, path)
                    class capg_hightu(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient CAPG_HIGHTU.
                        """
                    class capg_lowtu(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient CAPG_LOWTU.
                        """
                    class cbubble_c1(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient CBUBBLE_C1.
                        """
                    class cbubble_c2(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient CBUBBLE_C2.
                        """
                    class cfpg_hightu(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient CFPG_HIGHTU.
                        """
                    class cfpg_lowtu(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient CFPG_LOWTU.
                        """
                    class clambda_scale(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient CLAMBDA_SCALE.
                        """
                    class critical_reynolds_number_correlation(TUIMethod):
                        """
                        Sets the critical Reynolds number correlation.
                        """
                    class crossflow_transition(TUIMethod):
                        """
                        Enables/disables the effects of crossflow instability.
                        """
                    class ctu_hightu(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient CTU_HIGHTU.
                        """
                    class ctu_lowtu(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient CTU_LOWTU.
                        """
                    class rec_c1(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient REC_C1.
                        """
                    class rec_c2(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient REC_C2.
                        """
                    class rec_max(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient REC_MAX.
                        """
                    class rv1_switch(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient RV1_SWITCH.
                        """

                class turbulence_expert(TUIMenu):
                    """
                    Enters the turbulence expert menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.curvature_correction_coefficient = self.__class__.curvature_correction_coefficient(service, version, mode, path + ["curvature_correction_coefficient"])
                        self.kato_launder_model = self.__class__.kato_launder_model(service, version, mode, path + ["kato_launder_model"])
                        self.kw_add_des = self.__class__.kw_add_des(service, version, mode, path + ["kw_add_des"])
                        self.kw_add_sas = self.__class__.kw_add_sas(service, version, mode, path + ["kw_add_sas"])
                        self.kw_vorticity_based_production = self.__class__.kw_vorticity_based_production(service, version, mode, path + ["kw_vorticity_based_production"])
                        self.low_re_ke = self.__class__.low_re_ke(service, version, mode, path + ["low_re_ke"])
                        self.low_re_ke_index = self.__class__.low_re_ke_index(service, version, mode, path + ["low_re_ke_index"])
                        self.non_newtonian_modification = self.__class__.non_newtonian_modification(service, version, mode, path + ["non_newtonian_modification"])
                        self.production_limiter = self.__class__.production_limiter(service, version, mode, path + ["production_limiter"])
                        self.restore_sst_v61 = self.__class__.restore_sst_v61(service, version, mode, path + ["restore_sst_v61"])
                        self.rke_cmu_rotation_term = self.__class__.rke_cmu_rotation_term(service, version, mode, path + ["rke_cmu_rotation_term"])
                        self.sbes_les_subgrid_dynamic_fvar = self.__class__.sbes_les_subgrid_dynamic_fvar(service, version, mode, path + ["sbes_les_subgrid_dynamic_fvar"])
                        self.sbes_sdes_hybrid_model = self.__class__.sbes_sdes_hybrid_model(service, version, mode, path + ["sbes_sdes_hybrid_model"])
                        self.sbes_sgs_option = self.__class__.sbes_sgs_option(service, version, mode, path + ["sbes_sgs_option"])
                        self.sbes_update_interval_k_omega = self.__class__.sbes_update_interval_k_omega(service, version, mode, path + ["sbes_update_interval_k_omega"])
                        self.thermal_p_function = self.__class__.thermal_p_function(service, version, mode, path + ["thermal_p_function"])
                        self.turb_add_sbes_sdes = self.__class__.turb_add_sbes_sdes(service, version, mode, path + ["turb_add_sbes_sdes"])
                        self.turb_non_newtonian = self.__class__.turb_non_newtonian(service, version, mode, path + ["turb_non_newtonian"])
                        self.turb_pk_compressible = self.__class__.turb_pk_compressible(service, version, mode, path + ["turb_pk_compressible"])
                        self.turbulence_damping = self.__class__.turbulence_damping(service, version, mode, path + ["turbulence_damping"])
                        super().__init__(service, version, mode, path)
                    class curvature_correction_coefficient(TUIMethod):
                        """
                        Set the strength of the curvature correction term. The default value is 1.
                        """
                    class kato_launder_model(TUIMethod):
                        """
                        Enables/disables Kato-Launder modification.
                        """
                    class kw_add_des(TUIMethod):
                        """
                        Enables/disables Detached Eddy Simulation (DES) in combination with the currently selected BSL -  model or transition SST model. This text command is only available for transient cases.
                        """
                    class kw_add_sas(TUIMethod):
                        """
                        Enables/disables Scale-Adaptive Simulation (SAS) in combination with the currently selected -based URANS turbulence model. This text command is only available for transient cases.
                        """
                    class kw_vorticity_based_production(TUIMethod):
                        """
                        Enables/disables vorticity-based production.
                        """
                    class low_re_ke(TUIMethod):
                        """
                        Enables/disables the low-Re -  turbulence model.
                        """
                    class low_re_ke_index(TUIMethod):
                        """
                        Specifies which low-Reynolds-number -  model is to be used. Six models are available:
                        Index
                        Model
                        0
                        Abid
                        1
                        Lam-Bremhorst
                        2
                        Launder-Sharma
                        3
                        Yang-Shih
                        4
                        Abe-Kondoh-Nagano
                        5
                        Chang-Hsieh-Chen
                        Contact your Ansys, Inc. technical support engineer for more details.
                        """
                    class non_newtonian_modification(TUIMethod):
                        """
                        Enables/disables non-Newtonian modification for Lam-Bremhorst model.
                        """
                    class production_limiter(TUIMethod):
                        """
                        Enables/disables Production Limiter modification.
                        """
                    class restore_sst_v61(TUIMethod):
                        """
                        Enables/disables SST formulation of v6.1.
                        """
                    class rke_cmu_rotation_term(TUIMethod):
                        """
                        Modifies the  definition for the realizable  -  model.
                        """
                    class sbes_les_subgrid_dynamic_fvar(TUIMethod):
                        """
                        .
                        """
                    class sbes_sdes_hybrid_model(TUIMethod):
                        """
                        Selects the hybrid model, to specify whether you want to apply the Shielded Detached Eddy Simulation (SDES) model, Stress-Blended Eddy Simulation (SBES), or SBES with a user-defined function.
                        """
                    class sbes_sgs_option(TUIMethod):
                        """
                        Selects the subgrid-scale model for the LES portion of your Stress-Blended Eddy Simulation (SBES).
                        """
                    class sbes_update_interval_k_omega(TUIMethod):
                        """
                        Sets the number of time steps between updates of the k- part of the SBES model.
                        """
                    class thermal_p_function(TUIMethod):
                        """
                        Enables/disables Jayatilleke P function.
                        """
                    class turb_add_sbes_sdes(TUIMethod):
                        """
                        Enables/disables the Stress-Blended Eddy Simulation (SBES) model or Shielded Detached Eddy Simulation (SDES) model.
                        """
                    class turb_non_newtonian(TUIMethod):
                        """
                        Enables/disables turbulence for non-Newtonian fluids.
                        """
                    class turb_pk_compressible(TUIMethod):
                        """
                        Enables/disables turbulent production due to compressible divergence.
                        """
                    class turbulence_damping(TUIMethod):
                        """
                        Enables/disables turbulence damping and sets turbulence damping parameters.
                        """

        class motion_definitions(TUIMenu):
            """
            Manage motion definitions.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Add a new object.
                """
            class delete(TUIMethod):
                """
                Delete an object.
                """
            class edit(TUIMethod):
                """
                Edit an object.
                """
            class list(TUIMethod):
                """
                List objects.
                """
            class list_properties(TUIMethod):
                """
                List properties of an object.
                """

        class named_expressions(TUIMenu):
            """
            Enters the named expressions menu.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.compute = self.__class__.compute(service, version, mode, path + ["compute"])
                self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.export_to_tsv = self.__class__.export_to_tsv(service, version, mode, path + ["export_to_tsv"])
                self.import_from_tsv = self.__class__.import_from_tsv(service, version, mode, path + ["import_from_tsv"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Creates a new named expression.
                """
            class compute(TUIMethod):
                """
                Computes and prints the value of an expression. This is only available for expressions that evaluate to a single value.
                """
            class copy(TUIMethod):
                """
                Allows you to copy an existing named expression.
                """
            class delete(TUIMethod):
                """
                Allows you to delete a named expression, as long as it is not in use.
                """
            class edit(TUIMethod):
                """
                Allows you to edit the definition of a named expression.
                """
            class export_to_tsv(TUIMethod):
                """
                Export one or more named expressions to a file in TSV format.
                """
            class import_from_tsv(TUIMethod):
                """
                Import one or more named expressions saved in TSV format.
                """
            class list(TUIMethod):
                """
                Lists all of the currently defined named expressions.
                """
            class list_properties(TUIMethod):
                """
                Lists the definition of a named expression.
                """

        class operating_conditions(TUIMenu):
            """
            Enters the define operating conditions menu.
            """
            def __init__(self, service, version, mode, path):
                self.operating_density = self.__class__.operating_density(service, version, mode, path + ["operating_density"])
                self.gravity = self.__class__.gravity(service, version, mode, path + ["gravity"])
                self.gravity_mrf_behavior = self.__class__.gravity_mrf_behavior(service, version, mode, path + ["gravity_mrf_behavior"])
                self.operating_pressure = self.__class__.operating_pressure(service, version, mode, path + ["operating_pressure"])
                self.operating_temperature = self.__class__.operating_temperature(service, version, mode, path + ["operating_temperature"])
                self.reference_pressure_location = self.__class__.reference_pressure_location(service, version, mode, path + ["reference_pressure_location"])
                self.reference_pressure_method = self.__class__.reference_pressure_method(service, version, mode, path + ["reference_pressure_method"])
                self.set_state = self.__class__.set_state(service, version, mode, path + ["set_state"])
                self.use_inlet_temperature_for_operating_density = self.__class__.use_inlet_temperature_for_operating_density(service, version, mode, path + ["use_inlet_temperature_for_operating_density"])
                self.used_ref_pressure_location = self.__class__.used_ref_pressure_location(service, version, mode, path + ["used_ref_pressure_location"])
                super().__init__(service, version, mode, path)
            class operating_density(TUIMethod):
                """
                Multiphase flow Operating Density menu.
                """
            class gravity(TUIMethod):
                """
                Sets gravitational acceleration.
                """
            class gravity_mrf_behavior(TUIMethod):
                """
                .
                """
            class operating_pressure(TUIMethod):
                """
                Sets the operating pressure.
                """
            class operating_temperature(TUIMethod):
                """
                Sets the operating temperature for Boussinesq.
                """
            class reference_pressure_location(TUIMethod):
                """
                Sets a location that determines the reference pressure cell or cells (depending on the selected reference pressure method). The pressure value in such cells can be used to adjust the gauge pressure field after each iteration to keep it from floating.
                """
            class reference_pressure_method(TUIMethod):
                """
                Specifies the method used for adjusting the gauge pressure field after each iteration to keep it from floating: the method can assume that all of the cell zones are connected by internal boundary zones (such as interior zones), or can account for connected and disconnected cell zones. Such adjustment is only allowed for incompressible flows, and will be limited partially or entirely by the presence of a pressure boundary.
                """
            class set_state(TUIMethod):
                """
                Selects state for real gas EOS subcritical condition.
                """
            class use_inlet_temperature_for_operating_density(TUIMethod):
                """
                Uses inlet temperature to calculate operating density.
                """
            class used_ref_pressure_location(TUIMethod):
                """
                Prints the coordinates of the reference pressure cell or cells (depending on the selected reference pressure method). The pressure value in such cells can be used to adjust the gauge pressure field after each iteration to keep it from floating.
                """

        class overset_interfaces(TUIMenu):
            """
            Enters the overset interfaces menu.
            """
            def __init__(self, service, version, mode, path):
                self.adapt = self.__class__.adapt(service, version, mode, path + ["adapt"])
                self.cut_control = self.__class__.cut_control(service, version, mode, path + ["cut_control"])
                self.options = self.__class__.options(service, version, mode, path + ["options"])
                self.check = self.__class__.check(service, version, mode, path + ["check"])
                self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                self.clear_all = self.__class__.clear_all(service, version, mode, path + ["clear_all"])
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                self.debug_hole_cut = self.__class__.debug_hole_cut(service, version, mode, path + ["debug_hole_cut"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                self.display_cells = self.__class__.display_cells(service, version, mode, path + ["display_cells"])
                self.fill_dci = self.__class__.fill_dci(service, version, mode, path + ["fill_dci"])
                self.find_all_bounding_cells = self.__class__.find_all_bounding_cells(service, version, mode, path + ["find_all_bounding_cells"])
                self.find_bounding_cell = self.__class__.find_bounding_cell(service, version, mode, path + ["find_bounding_cell"])
                self.free_dci = self.__class__.free_dci(service, version, mode, path + ["free_dci"])
                self.grid_priorities = self.__class__.grid_priorities(service, version, mode, path + ["grid_priorities"])
                self.intersect = self.__class__.intersect(service, version, mode, path + ["intersect"])
                self.intersect_all = self.__class__.intersect_all(service, version, mode, path + ["intersect_all"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.mark_cell_change = self.__class__.mark_cell_change(service, version, mode, path + ["mark_cell_change"])
                self.mark_cells = self.__class__.mark_cells(service, version, mode, path + ["mark_cells"])
                self.read_dci_from_case = self.__class__.read_dci_from_case(service, version, mode, path + ["read_dci_from_case"])
                self.set_mark_bounds = self.__class__.set_mark_bounds(service, version, mode, path + ["set_mark_bounds"])
                self.update_from_dci = self.__class__.update_from_dci(service, version, mode, path + ["update_from_dci"])
                self.write_cell_types = self.__class__.write_cell_types(service, version, mode, path + ["write_cell_types"])
                self.write_dci = self.__class__.write_dci(service, version, mode, path + ["write_dci"])
                self.write_dci_to_case = self.__class__.write_dci_to_case(service, version, mode, path + ["write_dci_to_case"])
                super().__init__(service, version, mode, path)
            class check(TUIMethod):
                """
                Checks the integrity of the overset interfaces. Reports orphan cells and errors in the domain connectivity.
                """
            class clear(TUIMethod):
                """
                Clears the domain connectivity of an overset interface. This text command is only available when define/overset-interfaces/options/expert? is set to yes.
                """
            class clear_all(TUIMethod):
                """
                Clears the domain connectivity of all overset interfaces. This text command is only available when define/overset-interfaces/options/expert? is set to yes.
                """
            class create(TUIMethod):
                """
                Creates an overset interface.
                """
            class debug_hole_cut(TUIMethod):
                """
                Debugging tool to troubleshoot hole cutting of overset interfaces. This text command is only available when define/overset-interfaces/options/expert? is set to yes.
                """
            class delete(TUIMethod):
                """
                Deletes an overset interface.
                """
            class delete_all(TUIMethod):
                """
                Deletes all overset interfaces in the domain.
                """
            class display_cells(TUIMethod):
                """
                Displays the overset cells marked using the text command define/overset-interfaces/mark-cells.
                """
            class fill_dci(TUIMethod):
                """
                Fill overset domain connectivity information (DCI).
                """
            class find_all_bounding_cells(TUIMethod):
                """
                Find bounding cells for all cell centroids.
                """
            class find_bounding_cell(TUIMethod):
                """
                Find bounding cell for given cell or search point.
                """
            class free_dci(TUIMethod):
                """
                Free overset domain connectivity information (DCI).
                """
            class grid_priorities(TUIMethod):
                """
                Allows you to specify grid priorities on background and component meshes, used in the overlap minimization of an overset interface.
                """
            class intersect(TUIMethod):
                """
                Executes the hole cutting of an overset interface and establishes the domain connectivity. This text command is only available when define/overset-interfaces/options/expert? is set to yes.
                """
            class intersect_all(TUIMethod):
                """
                Executes hole cutting for all overset interfaces in the domain. This text command is only available when define/overset-interfaces/options/expert? is set to yes.
                """
            class list(TUIMethod):
                """
                Lists information about the overset interfaces. The output depends on the overset verbosity setting.
                """
            class mark_cell_change(TUIMethod):
                """
                Marks cells that have undergone a specified overset cell type change (from solve,receptor, or dead to any other type) in the last time step. Adaption registers are automatically filled based on these markings. This text command is only available for unsteady simulations and if define/overset-interfaces/options/expert? is set to yes.
                """
            class mark_cells(TUIMethod):
                """
                Marks the specified overset cells (solve, receptor, donor, orphan, or dead) and fills registers based on the markings. Display the marked cells via the text command define/overset-interfaces/display-cells.
                """
            class read_dci_from_case(TUIMethod):
                """
                Read domain connectivity information (DCI) from case file.
                """
            class set_mark_bounds(TUIMethod):
                """
                Allows you to set bounds so that any marking of cells is performed within a spherical region based on a specified origin and radius. This can be useful when diagnosing a local problem on a large mesh. This text command is only available if define/overset-interfaces/options/expert? is set to yes. After defining the bounds, you can then mark the cells using the define/overset-interfaces/mark-cell-change or define/overset-interfaces/mark-cells text command. To disable the bounds, enter a radius of 0.
                """
            class update_from_dci(TUIMethod):
                """
                Update all overset intrfaces from stored domain connectivity information (DCI).
                """
            class write_cell_types(TUIMethod):
                """
                Write overset cell types into file.
                """
            class write_dci(TUIMethod):
                """
                Save domain connectivity information (DCI) to a text file.
                """
            class write_dci_to_case(TUIMethod):
                """
                Save domain connectivity information (DCI) to case file.
                """

            class adapt(TUIMenu):
                """
                Enters the overset adaption menu.
                """
                def __init__(self, service, version, mode, path):
                    self.set = self.__class__.set(service, version, mode, path + ["set"])
                    self.adapt_mesh = self.__class__.adapt_mesh(service, version, mode, path + ["adapt_mesh"])
                    self.mark_adaption = self.__class__.mark_adaption(service, version, mode, path + ["mark_adaption"])
                    super().__init__(service, version, mode, path)
                class adapt_mesh(TUIMethod):
                    """
                    Marks and adapts the mesh to improve your overset 	mesh.
                    """
                class mark_adaption(TUIMethod):
                    """
                    Marks cells to identify those that can be adapted in 	order to improve your overset mesh.
                    """

                class set(TUIMenu):
                    """
                    Enters the overset adaption set menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.adaption_sweeps = self.__class__.adaption_sweeps(service, version, mode, path + ["adaption_sweeps"])
                        self.automatic = self.__class__.automatic(service, version, mode, path + ["automatic"])
                        self.buffer_layers = self.__class__.buffer_layers(service, version, mode, path + ["buffer_layers"])
                        self.gap_resolution = self.__class__.gap_resolution(service, version, mode, path + ["gap_resolution"])
                        self.length_ratio_max = self.__class__.length_ratio_max(service, version, mode, path + ["length_ratio_max"])
                        self.mark_coarsening = self.__class__.mark_coarsening(service, version, mode, path + ["mark_coarsening"])
                        self.mark_fixed_orphans = self.__class__.mark_fixed_orphans(service, version, mode, path + ["mark_fixed_orphans"])
                        self.mark_gaps = self.__class__.mark_gaps(service, version, mode, path + ["mark_gaps"])
                        self.mark_orphans = self.__class__.mark_orphans(service, version, mode, path + ["mark_orphans"])
                        self.mark_size = self.__class__.mark_size(service, version, mode, path + ["mark_size"])
                        self.maximum_refinement_level = self.__class__.maximum_refinement_level(service, version, mode, path + ["maximum_refinement_level"])
                        self.prismatic = self.__class__.prismatic(service, version, mode, path + ["prismatic"])
                        super().__init__(service, version, mode, path)
                    class adaption_sweeps(TUIMethod):
                        """
                        Sets the number of rounds of adaption applied during each adaption cycle.
                        """
                    class automatic(TUIMethod):
                        """
                        Enable the option to automatically adapt overset meshes during solution update.
                        """
                    class buffer_layers(TUIMethod):
                        """
                        Sets the number of cell layers marked in addition to the cells marked for orphan adaption.
                        """
                    class gap_resolution(TUIMethod):
                        """
                        Set the target (minimum) gap resolution used when marking cells for gap adaption.
                        """
                    class length_ratio_max(TUIMethod):
                        """
                        Sets the length scale ratio threshold used to determine which cells are marked for adaption based on donor-receptor cell size differences.
                        """
                    class mark_coarsening(TUIMethod):
                        """
                        Enables/disables the option to coarsen the mesh if mesh refinement is no longer needed. This option is enabled by default.
                        """
                    class mark_fixed_orphans(TUIMethod):
                        """
                        Enables/disables the option to also adapt based on cells that are not actual orphans because they were fixed by accepting neighbor donors. This option is only applied if define/overset-interfaces/adapt/set/mark-orphans? is enabled.
                        """
                    class mark_gaps(TUIMethod):
                        """
                        Enable the option to adapt underresolved gaps.
                        """
                    class mark_orphans(TUIMethod):
                        """
                        Enables/disables the option to adapt for orphan reduction.
                        """
                    class mark_size(TUIMethod):
                        """
                        Enables/disables the option to adapt based on donor-receptor cell size differences.
                        """
                    class maximum_refinement_level(TUIMethod):
                        """
                        Sets the maximum level of refinement during overset adaption, in conjunction with the value set using the mesh/adapt/set/maximum-refinement-level text command (the larger of the two values is used).
                        """
                    class prismatic(TUIMethod):
                        """
                        Enable the option to use anisotropic adaption in prismatic cells.
                        """

            class cut_control(TUIMenu):
                """
                Enters the overset hole cut control menu.
                """
                def __init__(self, service, version, mode, path):
                    self.cut_seeds = self.__class__.cut_seeds(service, version, mode, path + ["cut_seeds"])
                    self.add = self.__class__.add(service, version, mode, path + ["add"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    super().__init__(service, version, mode, path)
                class add(TUIMethod):
                    """
                    Adds a hole cut control, so that a boundary zone does 	not cut specified cell zones.
                    """
                class delete(TUIMethod):
                    """
                    Deletes the hole cut control for a boundary 	zone.
                    """
                class delete_all(TUIMethod):
                    """
                    Deletes the hole cut controls for all boundary 	zones.
                    """
                class list(TUIMethod):
                    """
                    Lists the defined hole cut controls.
                    """

                class cut_seeds(TUIMenu):
                    """
                    Enters the overset hole cut seeds menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.add = self.__class__.add(service, version, mode, path + ["add"])
                        self.cut_seeds_for_all_component_zones = self.__class__.cut_seeds_for_all_component_zones(service, version, mode, path + ["cut_seeds_for_all_component_zones"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        super().__init__(service, version, mode, path)
                    class add(TUIMethod):
                        """
                        Add a hole cut seed.
                        """
                    class cut_seeds_for_all_component_zones(TUIMethod):
                        """
                        Specifies whether all component zones get cut seeds, which cut pilot holes into the overlapping meshes that will then be enlarged during overlap minimization.
                        """
                    class delete(TUIMethod):
                        """
                        Delete a hole cut seed.
                        """
                    class delete_all(TUIMethod):
                        """
                        Delete all hole cut seeds.
                        """
                    class list(TUIMethod):
                        """
                        List the defined hole cut seeds.
                        """

            class options(TUIMenu):
                """
                Enters the overset interface options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.auto_create = self.__class__.auto_create(service, version, mode, path + ["auto_create"])
                    self.dead_cell_update = self.__class__.dead_cell_update(service, version, mode, path + ["dead_cell_update"])
                    self.donor_priority_method = self.__class__.donor_priority_method(service, version, mode, path + ["donor_priority_method"])
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.mesh_interfaces = self.__class__.mesh_interfaces(service, version, mode, path + ["mesh_interfaces"])
                    self.minimize_overlap = self.__class__.minimize_overlap(service, version, mode, path + ["minimize_overlap"])
                    self.modified_donor_search = self.__class__.modified_donor_search(service, version, mode, path + ["modified_donor_search"])
                    self.modified_hole_cutting = self.__class__.modified_hole_cutting(service, version, mode, path + ["modified_hole_cutting"])
                    self.node_connected_donors = self.__class__.node_connected_donors(service, version, mode, path + ["node_connected_donors"])
                    self.overlap_boundaries = self.__class__.overlap_boundaries(service, version, mode, path + ["overlap_boundaries"])
                    self.parallel = self.__class__.parallel(service, version, mode, path + ["parallel"])
                    self.partial_cut_faces = self.__class__.partial_cut_faces(service, version, mode, path + ["partial_cut_faces"])
                    self.render_receptor_cells = self.__class__.render_receptor_cells(service, version, mode, path + ["render_receptor_cells"])
                    self.solve_island_removal = self.__class__.solve_island_removal(service, version, mode, path + ["solve_island_removal"])
                    self.transient_caching = self.__class__.transient_caching(service, version, mode, path + ["transient_caching"])
                    self.update_before_case_write = self.__class__.update_before_case_write(service, version, mode, path + ["update_before_case_write"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    super().__init__(service, version, mode, path)
                class auto_create(TUIMethod):
                    """
                    Enables the automatic creation of a default overset interface during 	initialization or mesh motion update.
                    """
                class dead_cell_update(TUIMethod):
                    """
                    Enables/disables the updating of dead cells during the solution process, which may 	be helpful for some moving and dynamic mesh simulations 	(though at the cost of solver performance). You can 	enter the number of layers of dead cells adjacent to the 	receptor cells that you want updated, or enter -1 to request that all dead 	cells are updated. This text command is only available 	for transient simulations when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                class donor_priority_method(TUIMethod):
                    """
                    Allows you to specify whether the cell donor priority used in the overlap 	minimization of an overset interface is inversely proportional to either the 	cell size or the distance to the nearest boundary.
                    """
                class expert(TUIMethod):
                    """
                    Enables / disables overset-related expert tools.
                    """
                class mesh_interfaces(TUIMethod):
                    """
                    Allows the inclusion of non-conformal mesh interfaces 	inside overset cell zones, as long as the mesh 	interfaces do not spatially overlap with the cells where 	the overset interfaces lie.
                    """
                class minimize_overlap(TUIMethod):
                    """
                    Allows you to disable overlap minimization during hole cutting.
                    """
                class modified_donor_search(TUIMethod):
                    """
                    Enables / disables modified donor search parameters. When enabled, these parameters result in 	a more extended donor search, which can be helpful for 	meshes with orphans. This text command is only available 	when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                class modified_hole_cutting(TUIMethod):
                    """
                    Enables / disables modified hole cutting parameters. When enabled, the parameters used can 	help avoid dead cell zones that result from a hole 	cutting failure. This text command is only available 	when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                class node_connected_donors(TUIMethod):
                    """
                    Allows you to switch between face or node connected donor cells. This text command is only 	available when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                class overlap_boundaries(TUIMethod):
                    """
                    Allows you to disable the detection of overlapping boundaries during hole cutting, 	in order to reduce the computational expense for cases 	that do not include such boundaries. When enabled, this 	text command also allows you to specify which boundary 	zones should be considered when detecting overlapping 	boundaries; this can be helpful when the default hole 	cutting process fails.
                    """
                class parallel(TUIMethod):
                    """
                    Allows you to select the algorithm used for overset parallel processing. You can 	select from the default cell exchange model or the local 	cell zone replication model; the cell exchange model 	should require less memory and may result in faster 	calculations.
                    """
                class partial_cut_faces(TUIMethod):
                    """
                    Enables/disables enhanced hole cutting, where partially overlapping cut faces are 	decomposed into overlapping and non-overlapping 	fractions, and only the non-overlapping fractions 	participate in the hole cutting. This can help avoid the 	situation where a region or cell zone is erroneously 	identified as dead because of leakage during flood 	filling, even though it has overlapping boundaries that 	match well. When this text command is disabled, the 	partially overlapping faces are entirely protected from 	cutting.
                    """
                class render_receptor_cells(TUIMethod):
                    """
                    Allows you to enable visualization of receptor cells in contour and mesh 	displays.
                    """
                class solve_island_removal(TUIMethod):
                    """
                    Sets the method used to control the removal of isolated patches of solve cells. This text 	command is only available when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                class transient_caching(TUIMethod):
                    """
                    Sets the options to control caching of entities in transient overset simulations. This text 	command is only available when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                class update_before_case_write(TUIMethod):
                    """
                    Enables/disables the updating of the overset interfaces before writing a case file in the 	Common Fluids Format (CFF). This text command is only 	available when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                class verbosity(TUIMethod):
                    """
                    Specifies the level of detail printed in the console about overset 	interfaces.
                    """

        class parameters(TUIMenu):
            """
            Enters the parameters menu.
            """
            def __init__(self, service, version, mode, path):
                self.input_parameters = self.__class__.input_parameters(service, version, mode, path + ["input_parameters"])
                self.list_parameters = self.__class__.list_parameters(service, version, mode, path + ["list_parameters"])
                self.output_parameters = self.__class__.output_parameters(service, version, mode, path + ["output_parameters"])
                self.enable_in_TUI = self.__class__.enable_in_TUI(service, version, mode, path + ["enable_in_TUI"])
                super().__init__(service, version, mode, path)
            class enable_in_TUI(TUIMethod):
                """
                Enables/disables parameters in the text user interface.
                """

            class input_parameters(TUIMenu):
                """
                Enters the input-parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self.advance = self.__class__.advance(service, version, mode, path + ["advance"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    super().__init__(service, version, mode, path)
                class delete(TUIMethod):
                    """
                    Deletes an input parameter.
                    """
                class edit(TUIMethod):
                    """
                    Edits an input parameter.
                    """

                class advance(TUIMenu):
                    """
                    Define custom variable to use input parameter.
                    """
                    def __init__(self, service, version, mode, path):
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.use_in = self.__class__.use_in(service, version, mode, path + ["use_in"])
                        super().__init__(service, version, mode, path)
                    class delete(TUIMethod):
                        """
                        Delete selected custom-input-parameters.
                        """
                    class list(TUIMethod):
                        """
                        List of custom-input-parameters.
                        """
                    class use_in(TUIMethod):
                        """
                        Use input parameter in solver-udf or in scheme-procedure.
                        """

            class list_parameters(TUIMenu):
                """
                Enter list-param menu.
                """
                def __init__(self, service, version, mode, path):
                    self.input_parameters = self.__class__.input_parameters(service, version, mode, path + ["input_parameters"])
                    self.output_parameters = self.__class__.output_parameters(service, version, mode, path + ["output_parameters"])
                    super().__init__(service, version, mode, path)
                class input_parameters(TUIMethod):
                    """
                    .
                    """
                class output_parameters(TUIMethod):
                    """
                    .
                    """

            class output_parameters(TUIMenu):
                """
                Enters the output-parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.print_all_to_console = self.__class__.print_all_to_console(service, version, mode, path + ["print_all_to_console"])
                    self.print_to_console = self.__class__.print_to_console(service, version, mode, path + ["print_to_console"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    self.write_all_to_file = self.__class__.write_all_to_file(service, version, mode, path + ["write_all_to_file"])
                    self.write_to_file = self.__class__.write_to_file(service, version, mode, path + ["write_to_file"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Creates an output parameter.
                    """
                class delete(TUIMethod):
                    """
                    Deletes an output parameter.
                    """
                class edit(TUIMethod):
                    """
                    Edits an output parameter.
                    """
                class print_all_to_console(TUIMethod):
                    """
                    Displays all parameter values in the console.
                    """
                class print_to_console(TUIMethod):
                    """
                    Displays parameter value in the console.
                    """
                class rename(TUIMethod):
                    """
                    Renames an output parameter.
                    """
                class write_all_to_file(TUIMethod):
                    """
                    Writes all parameter values to file.
                    """
                class write_to_file(TUIMethod):
                    """
                    Writes parameter value to file.
                    """

        class periodic_conditions(TUIMenu):
            """
            Enters the periodic conditions menu.
            """
            def __init__(self, service, version, mode, path):
                self.massflow_rate_specification = self.__class__.massflow_rate_specification(service, version, mode, path + ["massflow_rate_specification"])
                self.pressure_gradient_specification = self.__class__.pressure_gradient_specification(service, version, mode, path + ["pressure_gradient_specification"])
                super().__init__(service, version, mode, path)
            class massflow_rate_specification(TUIMethod):
                """
                Enables/disables specification of mass flow rate at the periodic boundary.
                """
            class pressure_gradient_specification(TUIMethod):
                """
                Enables/disables specification of pressure gradient at the periodic boundary.
                """

        class phases(TUIMenu):
            """
            Enters the phases menu.
            """
            def __init__(self, service, version, mode, path):
                self.iac_expert = self.__class__.iac_expert(service, version, mode, path + ["iac_expert"])
                self.set_domain_properties = self.__class__.set_domain_properties(service, version, mode, path + ["set_domain_properties"])
                self.interaction_domain = self.__class__.interaction_domain(service, version, mode, path + ["interaction_domain"])
                self.phase_domain = self.__class__.phase_domain(service, version, mode, path + ["phase_domain"])
                super().__init__(service, version, mode, path)
            class interaction_domain(TUIMethod):
                """
                Enter the menu to set interaction domain properties.
                """
            class phase_domain(TUIMethod):
                """
                Enter the menu to set phase domain properties.
                """

            class iac_expert(TUIMenu):
                """
                Enters the IAC expert setting menu.
                """
                def __init__(self, service, version, mode, path):
                    self.hibiki_ishii_model = self.__class__.hibiki_ishii_model(service, version, mode, path + ["hibiki_ishii_model"])
                    self.iac_pseudo_time_step = self.__class__.iac_pseudo_time_step(service, version, mode, path + ["iac_pseudo_time_step"])
                    self.ishii_kim_model = self.__class__.ishii_kim_model(service, version, mode, path + ["ishii_kim_model"])
                    self.yao_morel_model = self.__class__.yao_morel_model(service, version, mode, path + ["yao_morel_model"])
                    super().__init__(service, version, mode, path)
                class hibiki_ishii_model(TUIMethod):
                    """
                    Sets Hibiki-Ishii model coefficients.
                    """
                class iac_pseudo_time_step(TUIMethod):
                    """
                    Set iac pseudo-time.
                    """
                class ishii_kim_model(TUIMethod):
                    """
                    Sets Ishii-Kim model coefficients.
                    """
                class yao_morel_model(TUIMethod):
                    """
                    Sets Yao-Morel model coefficients.
                    """

            class set_domain_properties(TUIMenu):
                """
                Enters the menu to set phase domain properties.
                """
                def __init__(self, service, version, mode, path):
                    self.interaction_domain = self.__class__.interaction_domain(service, version, mode, path + ["interaction_domain"])
                    self.change_phases_names = self.__class__.change_phases_names(service, version, mode, path + ["change_phases_names"])
                    self.phase_domains = self.__class__.phase_domains(service, version, mode, path + ["phase_domains"])
                    super().__init__(service, version, mode, path)
                class change_phases_names(TUIMethod):
                    """
                    Allows you to change the names of all the phases in your simulation.
                    """
                class phase_domains(TUIMethod):
                    """
                    Enters the menu to select a specific phase.
                    """

                class interaction_domain(TUIMenu):
                    """
                    Enters the menu to set the interaction domain 	properties.
                    """
                    def __init__(self, service, version, mode, path):
                        self.forces = self.__class__.forces(service, version, mode, path + ["forces"])
                        self.heat_mass_reactions = self.__class__.heat_mass_reactions(service, version, mode, path + ["heat_mass_reactions"])
                        self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                        self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                        self.numerics = self.__class__.numerics(service, version, mode, path + ["numerics"])
                        super().__init__(service, version, mode, path)

                    class forces(TUIMenu):
                        """
                        Enters the menu to set interfacial forces models.
                        """
                        def __init__(self, service, version, mode, path):
                            self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                            self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                            self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                            self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                            self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                            self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                            self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                            self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                            self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                            self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                            self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                            self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                            self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                            self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                            self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                            self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                            super().__init__(service, version, mode, path)
                        class drag(TUIMethod):
                            """
                            Specifies the drag function, drag modification, and drag factor for each pair of phases. This command is available only with the Eulerian and Mixture multiphase models.
                            """
                        class heat_coeff(TUIMethod):
                            """
                            Specify the heat transfer coefficient function between each pair of phases.
                            """
                        class interfacial_area(TUIMethod):
                            """
                            Set the interfacial area parameters for each pair of phases.
                            """
                        class mass_transfer(TUIMethod):
                            """
                            Specify the mass transfer mechanisms.
                            """
                        class model_transition(TUIMethod):
                            """
                            Set the model transition mechanism.
                            """
                        class reactions(TUIMethod):
                            """
                            Define multiple heterogeneous reactions and stoichiometry.
                            """
                        class restitution(TUIMethod):
                            """
                            Specifies the restitution coefficient for collisions between each pair of granular phases, and for collisions between particles of the same granular phase. This command is available only for multiphase flows with two or more granular phases.
                            """
                        class slip_velocity(TUIMethod):
                            """
                            Specifies the slip velocity function for each secondary phase with respect to the primary phase. This command is available only for the Mixture multiphase model.
                            """
                        class turbulence_interaction(TUIMethod):
                            """
                            Specifies the turbulence interaction model for each primary-secondary phase pair. This command is available only with the Eulerian multiphase model.
                            """
                        class turbulent_dispersion(TUIMethod):
                            """
                            Specifies the turbulent dispersion model for each primary-secondary phase pair. This command is available only with the Eulerian multiphase model.
                            """
                        class wall_lubrication(TUIMethod):
                            """
                            Specifies the wall lubrication model for each primary-secondary phase pair. This command is available only with the Eulerian multiphase model.
                            """

                        class cavitation(TUIMenu):
                            """
                            Enter the menu to set cavitation models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_discretization(TUIMenu):
                            """
                            Enter the menu to set interphase discretization models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_viscous_dissipation(TUIMenu):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class lift(TUIMenu):
                            """
                            Enters the menu to set the lift force. This item is available only with the Eulerian multiphase model.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                Specifies the lift function for each pair of phases.
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Enables/disables the Shaver-Podowski lift correction.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class surface_tension(TUIMenu):
                            """
                            Enters the menu to set surface tension models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enables/disables the treatment of the contact angle specification at the porous jump boundary. This command is available only for the VOF multiphase model with the continuum surface stress model option and when sfc-modeling? is enabled.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Selects the surface tension model. You can choose between the continuum surface force and continuum surface stress methods. This item is available only when sfc-modeling? is enabled.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Allows you to include the effects of surface tension along the fluid-fluid interface. This option is only available for the VOF and Eulerian multiphase models.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specifies the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enables/disables the specification for a wall adhesion angle. This item is available only whensfc-modeling? is enabled.
                                """

                        class virtual_mass(TUIMenu):
                            """
                            Enters the menu to set virtual mass models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Allows you to include the virtual mass force effect that occurs when a secondary phase accelerates relative to the primary phase. This command is available only with the Eulerian multiphase model.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specifies the virtual mass coefficient for each pair of phases. This option is available only ifvirtual-mass? is enabled.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enables/disables the implicit method for the virtual mass force. This option can improve convergence in some cases. This option is available only if virtual-mass? is enabled.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Specifies what form of the implicit method to use (default, option-2, or option-3). default models the entire virtual mass force while option-2 and option-3 model truncated expressions which may further improve convergence. This option is available only if vmass-implicit? is enabled.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                    class heat_mass_reactions(TUIMenu):
                        """
                        Enters the menu to set heat, mass-transfer, and reaction models.
                        """
                        def __init__(self, service, version, mode, path):
                            self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                            self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                            self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                            self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                            self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                            self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                            self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                            self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                            self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                            self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                            self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                            self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                            self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                            self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                            self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                            self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                            super().__init__(service, version, mode, path)
                        class drag(TUIMethod):
                            """
                            Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                            """
                        class heat_coeff(TUIMethod):
                            """
                            Species the heat transfer coefficient function between each pair of phases (constant-htc, nusselt-number, ranz-marshall, hughmark, tomiyama, fixed-to-sat-temp, two-resistance, or user-defined). This command is enable only with the Eulerian multiphase model.
                            """
                        class interfacial_area(TUIMethod):
                            """
                            Set the interfacial area parameters for each pair of phases.
                            """
                        class mass_transfer(TUIMethod):
                            """
                            Specify the mass transfer mechanisms.
                            """
                        class model_transition(TUIMethod):
                            """
                            Set the model transition mechanism.
                            """
                        class reactions(TUIMethod):
                            """
                            Allows you to define multiple heterogeneous reactions and stoichiometry. This option is available only with the species model.
                            """
                        class restitution(TUIMethod):
                            """
                            Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                            """
                        class slip_velocity(TUIMethod):
                            """
                            Specify the slip velocity function for each secondary phase with respect to the primary phase.
                            """
                        class turbulence_interaction(TUIMethod):
                            """
                            Specify the turbulence interaction model for each primary-secondary phase pair.
                            """
                        class turbulent_dispersion(TUIMethod):
                            """
                            Specify the turbulent dispersion model for each primary-secondary phase pair.
                            """
                        class wall_lubrication(TUIMethod):
                            """
                            Specify the wall lubrication model for each primary-secondary phase pair.
                            """

                        class cavitation(TUIMenu):
                            """
                            Enters the menu to set cavitation models. This option is available only for the Mixture multiphase model with the Singhal-et-al cavitation model enabled via solve/set/advanced/singhal-et-al-cavitation-model.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Sets the vaporization pressure, surface tension coefficient, and non-condensable gas mass fraction. This command is available only when cavitation? is enabled.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_discretization(TUIMenu):
                            """
                            Enter the menu to set interphase discretization models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_viscous_dissipation(TUIMenu):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class lift(TUIMenu):
                            """
                            Enter the menu to set lift models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class surface_tension(TUIMenu):
                            """
                            Enter the menu to set surface tension models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class virtual_mass(TUIMenu):
                            """
                            Enter the menu to set virtual mass models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                    class interfacial_area(TUIMenu):
                        """
                        Enters the menu to set interfacial area models. This menu is available only for the Mixture and Eulerian multiphase models.
                        """
                        def __init__(self, service, version, mode, path):
                            self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                            self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                            self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                            self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                            self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                            self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                            self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                            self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                            self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                            self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                            self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                            self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                            self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                            self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                            self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                            self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                            super().__init__(service, version, mode, path)
                        class drag(TUIMethod):
                            """
                            Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                            """
                        class heat_coeff(TUIMethod):
                            """
                            Specify the heat transfer coefficient function between each pair of phases.
                            """
                        class interfacial_area(TUIMethod):
                            """
                            Specifies the interfacial area model for each pair of phases.
                            """
                        class mass_transfer(TUIMethod):
                            """
                            Specify the mass transfer mechanisms.
                            """
                        class model_transition(TUIMethod):
                            """
                            Set the model transition mechanism.
                            """
                        class reactions(TUIMethod):
                            """
                            Define multiple heterogeneous reactions and stoichiometry.
                            """
                        class restitution(TUIMethod):
                            """
                            Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                            """
                        class slip_velocity(TUIMethod):
                            """
                            Specify the slip velocity function for each secondary phase with respect to the primary phase.
                            """
                        class turbulence_interaction(TUIMethod):
                            """
                            Specify the turbulence interaction model for each primary-secondary phase pair.
                            """
                        class turbulent_dispersion(TUIMethod):
                            """
                            Specify the turbulent dispersion model for each primary-secondary phase pair.
                            """
                        class wall_lubrication(TUIMethod):
                            """
                            Specify the wall lubrication model for each primary-secondary phase pair.
                            """

                        class cavitation(TUIMenu):
                            """
                            Enter the menu to set cavitation models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_discretization(TUIMenu):
                            """
                            Enter the menu to set interphase discretization models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_viscous_dissipation(TUIMenu):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class lift(TUIMenu):
                            """
                            Enter the menu to set lift models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class surface_tension(TUIMenu):
                            """
                            Enter the menu to set surface tension models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class virtual_mass(TUIMenu):
                            """
                            Enter the menu to set virtual mass models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                    class model_transition(TUIMenu):
                        """
                        Enters the menu to set model transition mechanisms.
                        """
                        def __init__(self, service, version, mode, path):
                            self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                            self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                            self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                            self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                            self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                            self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                            self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                            self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                            self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                            self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                            self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                            self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                            self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                            self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                            self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                            self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                            super().__init__(service, version, mode, path)
                        class drag(TUIMethod):
                            """
                            Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                            """
                        class heat_coeff(TUIMethod):
                            """
                            Specify the heat transfer coefficient function between each pair of phases.
                            """
                        class interfacial_area(TUIMethod):
                            """
                            Set the interfacial area parameters for each pair of phases.
                            """
                        class mass_transfer(TUIMethod):
                            """
                            Specify the mass transfer mechanisms.
                            """
                        class model_transition(TUIMethod):
                            """
                            Sets the VOF-to-DPM model transition mechanism.
                            """
                        class reactions(TUIMethod):
                            """
                            Define multiple heterogeneous reactions and stoichiometry.
                            """
                        class restitution(TUIMethod):
                            """
                            Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                            """
                        class slip_velocity(TUIMethod):
                            """
                            Specify the slip velocity function for each secondary phase with respect to the primary phase.
                            """
                        class turbulence_interaction(TUIMethod):
                            """
                            Specify the turbulence interaction model for each primary-secondary phase pair.
                            """
                        class turbulent_dispersion(TUIMethod):
                            """
                            Specify the turbulent dispersion model for each primary-secondary phase pair.
                            """
                        class wall_lubrication(TUIMethod):
                            """
                            Specify the wall lubrication model for each primary-secondary phase pair.
                            """

                        class cavitation(TUIMenu):
                            """
                            Enter the menu to set cavitation models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_discretization(TUIMenu):
                            """
                            Enter the menu to set interphase discretization models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_viscous_dissipation(TUIMenu):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class lift(TUIMenu):
                            """
                            Enter the menu to set lift models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class surface_tension(TUIMenu):
                            """
                            Enter the menu to set surface tension models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class virtual_mass(TUIMenu):
                            """
                            Enter the menu to set virtual mass models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                    class numerics(TUIMenu):
                        """
                        Enters the menu to set numerics models. This menu is available for multiphase models with the sharp-dispersed and phase localized discretization interface modeling options (set in define/models/multiphase/interface-modeling-options).
                        """
                        def __init__(self, service, version, mode, path):
                            self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                            self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                            self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                            self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                            self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                            self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                            self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                            self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                            self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                            self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                            self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                            self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                            self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                            self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                            self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                            self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                            super().__init__(service, version, mode, path)
                        class drag(TUIMethod):
                            """
                            Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                            """
                        class heat_coeff(TUIMethod):
                            """
                            Specify the heat transfer coefficient function between each pair of phases.
                            """
                        class interfacial_area(TUIMethod):
                            """
                            Set the interfacial area parameters for each pair of phases.
                            """
                        class mass_transfer(TUIMethod):
                            """
                            Specify the mass transfer mechanisms.
                            """
                        class model_transition(TUIMethod):
                            """
                            Set the model transition mechanism.
                            """
                        class reactions(TUIMethod):
                            """
                            Define multiple heterogeneous reactions and stoichiometry.
                            """
                        class restitution(TUIMethod):
                            """
                            Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                            """
                        class slip_velocity(TUIMethod):
                            """
                            Specify the slip velocity function for each secondary phase with respect to the primary phase.
                            """
                        class turbulence_interaction(TUIMethod):
                            """
                            Specify the turbulence interaction model for each primary-secondary phase pair.
                            """
                        class turbulent_dispersion(TUIMethod):
                            """
                            Specify the turbulent dispersion model for each primary-secondary phase pair.
                            """
                        class wall_lubrication(TUIMethod):
                            """
                            Specify the wall lubrication model for each primary-secondary phase pair.
                            """

                        class cavitation(TUIMenu):
                            """
                            Enter the menu to set cavitation models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_discretization(TUIMenu):
                            """
                            Enters the menu to set interphase discretization models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enables/disables phase localized compressive scheme.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specifies the slope limiter to set a specific discretization scheme for each phase pair. A value of 0 corresponds to first order upwind, a value of 1 corresponds to second order upwind, a value of 2 applies the compressive scheme, and a value between 0 and 2 corresponds to a blended scheme. This option is available only wheninterphase-discr? is enabled.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_viscous_dissipation(TUIMenu):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class lift(TUIMenu):
                            """
                            Enter the menu to set lift models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class surface_tension(TUIMenu):
                            """
                            Enter the menu to set surface tension models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class virtual_mass(TUIMenu):
                            """
                            Enter the menu to set virtual mass models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

        class profiles(TUIMenu):
            """
            Enters the boundary profiles menu.
            """
            def __init__(self, service, version, mode, path):
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                self.display_profile_point_cloud_data = self.__class__.display_profile_point_cloud_data(service, version, mode, path + ["display_profile_point_cloud_data"])
                self.display_profile_surface = self.__class__.display_profile_surface(service, version, mode, path + ["display_profile_surface"])
                self.interpolation_method = self.__class__.interpolation_method(service, version, mode, path + ["interpolation_method"])
                self.link_profile_to_reference_frame = self.__class__.link_profile_to_reference_frame(service, version, mode, path + ["link_profile_to_reference_frame"])
                self.list_profile_fields = self.__class__.list_profile_fields(service, version, mode, path + ["list_profile_fields"])
                self.list_profile_parameters = self.__class__.list_profile_parameters(service, version, mode, path + ["list_profile_parameters"])
                self.list_profiles = self.__class__.list_profiles(service, version, mode, path + ["list_profiles"])
                self.morphing = self.__class__.morphing(service, version, mode, path + ["morphing"])
                self.orient_profile = self.__class__.orient_profile(service, version, mode, path + ["orient_profile"])
                self.overlay_profile_point_cloud_data = self.__class__.overlay_profile_point_cloud_data(service, version, mode, path + ["overlay_profile_point_cloud_data"])
                self.overlay_profile_surface = self.__class__.overlay_profile_surface(service, version, mode, path + ["overlay_profile_surface"])
                self.replicate_profile = self.__class__.replicate_profile(service, version, mode, path + ["replicate_profile"])
                self.set_preference_profile_point_cloud_data = self.__class__.set_preference_profile_point_cloud_data(service, version, mode, path + ["set_preference_profile_point_cloud_data"])
                self.update_interval = self.__class__.update_interval(service, version, mode, path + ["update_interval"])
                super().__init__(service, version, mode, path)
            class delete(TUIMethod):
                """
                Deletes a profile.
                """
            class delete_all(TUIMethod):
                """
                Deletes all boundary-profiles.
                """
            class display_profile_point_cloud_data(TUIMethod):
                """
                Display Profile Point Cloud Data.
                """
            class display_profile_surface(TUIMethod):
                """
                Display the profile as a surface (this option is only available if the specified profile contains node-connectivity data).
                """
            class interpolation_method(TUIMethod):
                """
                Chooses the method for interpolation of profiles.
                """
            class link_profile_to_reference_frame(TUIMethod):
                """
                Attaches a profile to a reference frame so that the profile will rotate according to the reference frame.
                """
            class list_profile_fields(TUIMethod):
                """
                Lists the fields of a particular profile.
                """
            class list_profile_parameters(TUIMethod):
                """
                List the parameters of a particular profile.
                """
            class list_profiles(TUIMethod):
                """
                Lists all profiles.
                """
            class morphing(TUIMethod):
                """
                Enables/disables profile morphing options in Orient Profile panel.
                """
            class orient_profile(TUIMethod):
                """
                Re-orient an existing profile.
                """
            class overlay_profile_point_cloud_data(TUIMethod):
                """
                Overlay Profile Point Cloud Data.
                """
            class overlay_profile_surface(TUIMethod):
                """
                Overlay Profile Surface.
                """
            class replicate_profile(TUIMethod):
                """
                Replicate Profile.
                """
            class set_preference_profile_point_cloud_data(TUIMethod):
                """
                Set Preference Profile Point Cloud Data e.g., Point marker symbol,size,color.
                """
            class update_interval(TUIMethod):
                """
                Sets interval between updates of dynamic profiles.
                """

        class reference_frames(TUIMenu):
            """
            Enters the reference frames menu.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                self.display_edit = self.__class__.display_edit(service, version, mode, path + ["display_edit"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.hide = self.__class__.hide(service, version, mode, path + ["hide"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Creates a new reference frame.
                """
            class delete(TUIMethod):
                """
                Deletes the reference frame you specify.
                """
            class display(TUIMethod):
                """
                Displays the reference frame you specify.
                """
            class display_edit(TUIMethod):
                """
                Display and edit reference frame from graphics.
                """
            class edit(TUIMethod):
                """
                Allows you to edit a reference frame.
                """
            class hide(TUIMethod):
                """
                Removes the specified reference frame from the graphics window.
                """
            class list(TUIMethod):
                """
                Lists all of the reference frames.
                """
            class list_properties(TUIMethod):
                """
                Lists the properties of the reference frame you specify.
                """

        class solution_strategy(TUIMenu):
            """
            Enters the automatic initialization and case modification strategy menu.
            """
            def __init__(self, service, version, mode, path):
                self.automatic_case_modification = self.__class__.automatic_case_modification(service, version, mode, path + ["automatic_case_modification"])
                self.add_edit_modification = self.__class__.add_edit_modification(service, version, mode, path + ["add_edit_modification"])
                self.automatic_initialization = self.__class__.automatic_initialization(service, version, mode, path + ["automatic_initialization"])
                self.continue_strategy_execution = self.__class__.continue_strategy_execution(service, version, mode, path + ["continue_strategy_execution"])
                self.copy_modification = self.__class__.copy_modification(service, version, mode, path + ["copy_modification"])
                self.delete_modification = self.__class__.delete_modification(service, version, mode, path + ["delete_modification"])
                self.disable_modification = self.__class__.disable_modification(service, version, mode, path + ["disable_modification"])
                self.enable_modification = self.__class__.enable_modification(service, version, mode, path + ["enable_modification"])
                self.enable_strategy = self.__class__.enable_strategy(service, version, mode, path + ["enable_strategy"])
                self.execute_strategy = self.__class__.execute_strategy(service, version, mode, path + ["execute_strategy"])
                self.export_modifications = self.__class__.export_modifications(service, version, mode, path + ["export_modifications"])
                self.import_modifications = self.__class__.import_modifications(service, version, mode, path + ["import_modifications"])
                super().__init__(service, version, mode, path)
            class add_edit_modification(TUIMethod):
                """
                Define a single case modification.
                """
            class automatic_initialization(TUIMethod):
                """
                Defines how the case is to be automatically initialized.
                """
            class continue_strategy_execution(TUIMethod):
                """
                Continues execution of the currently defined automatic initialization and case modification strategy.
                """
            class copy_modification(TUIMethod):
                """
                .
                """
            class delete_modification(TUIMethod):
                """
                .
                """
            class disable_modification(TUIMethod):
                """
                .
                """
            class enable_modification(TUIMethod):
                """
                .
                """
            class enable_strategy(TUIMethod):
                """
                Enables/disables automatic initialization and case modification.
                """
            class execute_strategy(TUIMethod):
                """
                Executes the currently defined automatic initialization and case modification strategy.
                """
            class export_modifications(TUIMethod):
                """
                .
                """
            class import_modifications(TUIMethod):
                """
                .
                """

            class automatic_case_modification(TUIMenu):
                """
                Enters the automatic case modification menu.
                """
                def __init__(self, service, version, mode, path):
                    self.before_init_modification = self.__class__.before_init_modification(service, version, mode, path + ["before_init_modification"])
                    self.modifications = self.__class__.modifications(service, version, mode, path + ["modifications"])
                    self.original_settings = self.__class__.original_settings(service, version, mode, path + ["original_settings"])
                    super().__init__(service, version, mode, path)
                class before_init_modification(TUIMethod):
                    """
                    Specifies modification to be performed before initialization.
                    """
                class modifications(TUIMethod):
                    """
                    Specifies modifications to be performed during solution.
                    """
                class original_settings(TUIMethod):
                    """
                    Specifies modification to be performed after initialization to restore to original 	settings.
                    """

        class spectral(TUIMenu):
            """
            Enter the Spectral menu.
            """
            def __init__(self, service, version, mode, path):
                self.calculate_fourier_coefficients = self.__class__.calculate_fourier_coefficients(service, version, mode, path + ["calculate_fourier_coefficients"])
                self.calculate_harmonic_exports = self.__class__.calculate_harmonic_exports(service, version, mode, path + ["calculate_harmonic_exports"])
                self.delete_fourier_coefficients = self.__class__.delete_fourier_coefficients(service, version, mode, path + ["delete_fourier_coefficients"])
                self.delete_harmonic_exports = self.__class__.delete_harmonic_exports(service, version, mode, path + ["delete_harmonic_exports"])
                super().__init__(service, version, mode, path)
            class calculate_fourier_coefficients(TUIMethod):
                """
                Calculates Fourier coefficient data.
                """
            class calculate_harmonic_exports(TUIMethod):
                """
                Calculates Harmonic Export data.
                """
            class delete_fourier_coefficients(TUIMethod):
                """
                Deletes Fourier coefficient data.
                """
            class delete_harmonic_exports(TUIMethod):
                """
                Deletes Harmonic Export data.
                """

        class turbo_model(TUIMenu):
            """
            Enters the turbo menu.
            """
            def __init__(self, service, version, mode, path):
                self.blade_flutter_harmonics = self.__class__.blade_flutter_harmonics(service, version, mode, path + ["blade_flutter_harmonics"])
                self.general_turbo_interface_settings = self.__class__.general_turbo_interface_settings(service, version, mode, path + ["general_turbo_interface_settings"])
                self.legacy_models = self.__class__.legacy_models(service, version, mode, path + ["legacy_models"])
                self.turbo_topology = self.__class__.turbo_topology(service, version, mode, path + ["turbo_topology"])
                self.append_graphics_spectral_content = self.__class__.append_graphics_spectral_content(service, version, mode, path + ["append_graphics_spectral_content"])
                self.append_phaselag_spectral_content = self.__class__.append_phaselag_spectral_content(service, version, mode, path + ["append_phaselag_spectral_content"])
                self.blade_flutter_row = self.__class__.blade_flutter_row(service, version, mode, path + ["blade_flutter_row"])
                self.create_graphics_spectral_content = self.__class__.create_graphics_spectral_content(service, version, mode, path + ["create_graphics_spectral_content"])
                self.create_phaselag_spectral_content = self.__class__.create_phaselag_spectral_content(service, version, mode, path + ["create_phaselag_spectral_content"])
                self.create_turbomachine_description = self.__class__.create_turbomachine_description(service, version, mode, path + ["create_turbomachine_description"])
                self.delete_graphics_spectral_content = self.__class__.delete_graphics_spectral_content(service, version, mode, path + ["delete_graphics_spectral_content"])
                self.delete_phaselag_spectral_content = self.__class__.delete_phaselag_spectral_content(service, version, mode, path + ["delete_phaselag_spectral_content"])
                self.delete_turbomachine_description = self.__class__.delete_turbomachine_description(service, version, mode, path + ["delete_turbomachine_description"])
                self.enable_turbo_model = self.__class__.enable_turbo_model(service, version, mode, path + ["enable_turbo_model"])
                self.export_boundary_mesh = self.__class__.export_boundary_mesh(service, version, mode, path + ["export_boundary_mesh"])
                self.graphics_extra_settings = self.__class__.graphics_extra_settings(service, version, mode, path + ["graphics_extra_settings"])
                self.list_graphics_spectral_content = self.__class__.list_graphics_spectral_content(service, version, mode, path + ["list_graphics_spectral_content"])
                self.list_phaselag_state = self.__class__.list_phaselag_state(service, version, mode, path + ["list_phaselag_state"])
                self.list_turbomachine_description = self.__class__.list_turbomachine_description(service, version, mode, path + ["list_turbomachine_description"])
                self.make_phaselag_from_boundaries = self.__class__.make_phaselag_from_boundaries(service, version, mode, path + ["make_phaselag_from_boundaries"])
                self.make_phaselag_from_periodic = self.__class__.make_phaselag_from_periodic(service, version, mode, path + ["make_phaselag_from_periodic"])
                self.phaselag_extra_settings = self.__class__.phaselag_extra_settings(service, version, mode, path + ["phaselag_extra_settings"])
                self.separate_nonoverlapping_interface_boundary = self.__class__.separate_nonoverlapping_interface_boundary(service, version, mode, path + ["separate_nonoverlapping_interface_boundary"])
                self.turbo_create = self.__class__.turbo_create(service, version, mode, path + ["turbo_create"])
                self.turbo_interface_check = self.__class__.turbo_interface_check(service, version, mode, path + ["turbo_interface_check"])
                super().__init__(service, version, mode, path)
            class append_graphics_spectral_content(TUIMethod):
                """
                Define post-processing related spectral content.
                """
            class append_phaselag_spectral_content(TUIMethod):
                """
                Define phaselag related spectral content.
                """
            class blade_flutter_row(TUIMethod):
                """
                Define the periodic displacement row.
                """
            class create_graphics_spectral_content(TUIMethod):
                """
                Define post-processing related spectral content.
                """
            class create_phaselag_spectral_content(TUIMethod):
                """
                Define phaselag related spectral content.
                """
            class create_turbomachine_description(TUIMethod):
                """
                Define turbomachine description.
                """
            class delete_graphics_spectral_content(TUIMethod):
                """
                Delete post-processing related spectral content.
                """
            class delete_phaselag_spectral_content(TUIMethod):
                """
                Delete phaselag related spectral content.
                """
            class delete_turbomachine_description(TUIMethod):
                """
                Delete turbomachine description.
                """
            class enable_turbo_model(TUIMethod):
                """
                Enables/disables turbo model menu.
                """
            class export_boundary_mesh(TUIMethod):
                """
                Export boundary mesh file.
                """
            class graphics_extra_settings(TUIMethod):
                """
                Define phaselag related extra settings.
                """
            class list_graphics_spectral_content(TUIMethod):
                """
                List post-processing related spectral content.
                """
            class list_phaselag_state(TUIMethod):
                """
                List all phaselag related case settings.
                """
            class list_turbomachine_description(TUIMethod):
                """
                List turbomachine description.
                """
            class make_phaselag_from_boundaries(TUIMethod):
                """
                Make interface zones phase lagged.
                """
            class make_phaselag_from_periodic(TUIMethod):
                """
                Convert periodic interface to phase lagged.
                """
            class phaselag_extra_settings(TUIMethod):
                """
                Define phaselag related extra settings.
                """
            class separate_nonoverlapping_interface_boundary(TUIMethod):
                """
                Split a general turbo interface non-overlapping zone.
                """
            class turbo_create(TUIMethod):
                """
                Creates a general turbo interface.
                """
            class turbo_interface_check(TUIMethod):
                """
                Check General Turbo Interface and Phase-lag.
                """

            class blade_flutter_harmonics(TUIMenu):
                """
                Enters the blade flutter harmonics options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.enable_harmonic_exports = self.__class__.enable_harmonic_exports(service, version, mode, path + ["enable_harmonic_exports"])
                    self.write_aerodamping_vs_nodal_diameter = self.__class__.write_aerodamping_vs_nodal_diameter(service, version, mode, path + ["write_aerodamping_vs_nodal_diameter"])
                    self.write_harmonic_exports = self.__class__.write_harmonic_exports(service, version, mode, path + ["write_harmonic_exports"])
                    super().__init__(service, version, mode, path)
                class enable_harmonic_exports(TUIMethod):
                    """
                    Calculates/Deletes flutter harmonic export data.
                    """
                class write_aerodamping_vs_nodal_diameter(TUIMethod):
                    """
                    Reads report definition file and Writes influence coefficient aerodynamic damping values vs nodal diameter.
                    """
                class write_harmonic_exports(TUIMethod):
                    """
                    Writes harmonic export data.
                    """

            class general_turbo_interface_settings(TUIMenu):
                """
                Enters the General Turbo Interface options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.mixing_plane_model_settings = self.__class__.mixing_plane_model_settings(service, version, mode, path + ["mixing_plane_model_settings"])
                    super().__init__(service, version, mode, path)

                class expert(TUIMenu):
                    """
                    Set the expert parameters for turbo interfaces.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enforce_flux_scaling = self.__class__.enforce_flux_scaling(service, version, mode, path + ["enforce_flux_scaling"])
                        self.list_settings = self.__class__.list_settings(service, version, mode, path + ["list_settings"])
                        super().__init__(service, version, mode, path)
                    class enforce_flux_scaling(TUIMethod):
                        """
                        Enforce flux scaling ON/OFF at the turbo interfaces.
                        """
                    class list_settings(TUIMethod):
                        """
                        List the flux scale settings at the turbo interfaces.
                        """

                class mixing_plane_model_settings(TUIMenu):
                    """
                    Defines settings for the mixing plane model.
                    """
                    def __init__(self, service, version, mode, path):
                        self.number_of_bands = self.__class__.number_of_bands(service, version, mode, path + ["number_of_bands"])
                        self.averaging_method = self.__class__.averaging_method(service, version, mode, path + ["averaging_method"])
                        self.bands_type = self.__class__.bands_type(service, version, mode, path + ["bands_type"])
                        self.list_mixing_planes = self.__class__.list_mixing_planes(service, version, mode, path + ["list_mixing_planes"])
                        self.mixing_set_constraint = self.__class__.mixing_set_constraint(service, version, mode, path + ["mixing_set_constraint"])
                        super().__init__(service, version, mode, path)
                    class averaging_method(TUIMethod):
                        """
                        Set the averaging method for the mixing.
                        """
                    class bands_type(TUIMethod):
                        """
                        Specifies the averaging bands for mixing as fixed or variable width.
                        """
                    class list_mixing_planes(TUIMethod):
                        """
                        List the settings of mixing planes in the case.
                        """
                    class mixing_set_constraint(TUIMethod):
                        """
                        To set the mixing of primitive or total variable approach.
                        """

                    class number_of_bands(TUIMenu):
                        """
                        Sets the number of bands to be used for mixing.
                        """
                        def __init__(self, service, version, mode, path):
                            self.set_all_interfaces = self.__class__.set_all_interfaces(service, version, mode, path + ["set_all_interfaces"])
                            self.set_specific_interface = self.__class__.set_specific_interface(service, version, mode, path + ["set_specific_interface"])
                            super().__init__(service, version, mode, path)
                        class set_all_interfaces(TUIMethod):
                            """
                            Set number of band to be used for mixing.
                            """
                        class set_specific_interface(TUIMethod):
                            """
                            Set number of band to be used for mixing.
                            """

            class legacy_models(TUIMenu):
                """
                Enter Legacy Turbo Model Menu.
                """
                def __init__(self, service, version, mode, path):
                    self.legacy_mixing_plane = self.__class__.legacy_mixing_plane(service, version, mode, path + ["legacy_mixing_plane"])
                    super().__init__(service, version, mode, path)

                class legacy_mixing_plane(TUIMenu):
                    """
                    Enter the legacy mixing planes menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.set = self.__class__.set(service, version, mode, path + ["set"])
                        self.create = self.__class__.create(service, version, mode, path + ["create"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.mixing_plane_gui = self.__class__.mixing_plane_gui(service, version, mode, path + ["mixing_plane_gui"])
                        super().__init__(service, version, mode, path)
                    class create(TUIMethod):
                        """
                        Create a mixing plane.
                        """
                    class delete(TUIMethod):
                        """
                        Delete a mixing plane.
                        """
                    class list(TUIMethod):
                        """
                        List defined mixing plane(s).
                        """
                    class mixing_plane_gui(TUIMethod):
                        """
                        GUI for setting up legacy mixing plane model.
                        """

                    class set(TUIMenu):
                        """
                        Enter the mixing plane set menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.conserve_swirl = self.__class__.conserve_swirl(service, version, mode, path + ["conserve_swirl"])
                            self.conserve_total_enthalpy = self.__class__.conserve_total_enthalpy(service, version, mode, path + ["conserve_total_enthalpy"])
                            self.averaging_method = self.__class__.averaging_method(service, version, mode, path + ["averaging_method"])
                            self.fix_pressure_level = self.__class__.fix_pressure_level(service, version, mode, path + ["fix_pressure_level"])
                            self.under_relaxation = self.__class__.under_relaxation(service, version, mode, path + ["under_relaxation"])
                            super().__init__(service, version, mode, path)
                        class averaging_method(TUIMethod):
                            """
                            Set mixing plane profile averaging method.
                            """
                        class fix_pressure_level(TUIMethod):
                            """
                            Set fix pressure level using define/reference-pressure-location.
                            """
                        class under_relaxation(TUIMethod):
                            """
                            Set mixing plane under-relaxation factor.
                            """

                        class conserve_swirl(TUIMenu):
                            """
                            Enter the mixing plane conserve-swirl menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                                self.report_swirl_integration = self.__class__.report_swirl_integration(service, version, mode, path + ["report_swirl_integration"])
                                self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                                super().__init__(service, version, mode, path)
                            class enable(TUIMethod):
                                """
                                Enable/disable swirl conservation in mixing plane.
                                """
                            class report_swirl_integration(TUIMethod):
                                """
                                Report swirl integration (torque) on inflow and outflow zones.
                                """
                            class verbosity(TUIMethod):
                                """
                                Enable/disable verbosity in swirl conservation calculations.
                                """

                        class conserve_total_enthalpy(TUIMenu):
                            """
                            Enter the menu to set total enthalpy conservation in mixing plane menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                                self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                                super().__init__(service, version, mode, path)
                            class enable(TUIMethod):
                                """
                                Enable/disable total enthalpy conservation in mixing plane.
                                """
                            class verbosity(TUIMethod):
                                """
                                Enable/disable verbosity in total-enthalpy conservation calculations.
                                """

            class turbo_topology(TUIMenu):
                """
                Enters the turbo topology menu.
                """
                def __init__(self, service, version, mode, path):
                    self.define_topology = self.__class__.define_topology(service, version, mode, path + ["define_topology"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.mesh_method = self.__class__.mesh_method(service, version, mode, path + ["mesh_method"])
                    self.projection_method = self.__class__.projection_method(service, version, mode, path + ["projection_method"])
                    self.search_method = self.__class__.search_method(service, version, mode, path + ["search_method"])
                    super().__init__(service, version, mode, path)
                class define_topology(TUIMethod):
                    """
                    Defines a turbo topology.
                    """
                class delete(TUIMethod):
                    """
                    Deletes a previously created turbo topology.
                    """
                class mesh_method(TUIMethod):
                    """
                    Sets turbo structured mesh generation method.
                    """
                class projection_method(TUIMethod):
                    """
                    Sets 2D projection method.
                    """
                class search_method(TUIMethod):
                    """
                    Sets search method for a topology.
                    """

        class user_defined(TUIMenu):
            """
            Enters the user-defined functions and scalars menu.
            """
            def __init__(self, service, version, mode, path):
                self.real_gas_models = self.__class__.real_gas_models(service, version, mode, path + ["real_gas_models"])
                self.auto_compile_compiled_udfs = self.__class__.auto_compile_compiled_udfs(service, version, mode, path + ["auto_compile_compiled_udfs"])
                self.compile_customized_addon_module = self.__class__.compile_customized_addon_module(service, version, mode, path + ["compile_customized_addon_module"])
                self.compiled_functions = self.__class__.compiled_functions(service, version, mode, path + ["compiled_functions"])
                self.enable_udf_on_gpu = self.__class__.enable_udf_on_gpu(service, version, mode, path + ["enable_udf_on_gpu"])
                self.execute_on_demand = self.__class__.execute_on_demand(service, version, mode, path + ["execute_on_demand"])
                self.fan_model = self.__class__.fan_model(service, version, mode, path + ["fan_model"])
                self.function_hooks = self.__class__.function_hooks(service, version, mode, path + ["function_hooks"])
                self.interpreted_functions = self.__class__.interpreted_functions(service, version, mode, path + ["interpreted_functions"])
                self.one_D_coupling = self.__class__.one_D_coupling(service, version, mode, path + ["one_D_coupling"])
                self.use_built_in_compiler = self.__class__.use_built_in_compiler(service, version, mode, path + ["use_built_in_compiler"])
                self.use_contributed_cpp = self.__class__.use_contributed_cpp(service, version, mode, path + ["use_contributed_cpp"])
                self.use_zone_based_udm = self.__class__.use_zone_based_udm(service, version, mode, path + ["use_zone_based_udm"])
                self.user_defined_memory = self.__class__.user_defined_memory(service, version, mode, path + ["user_defined_memory"])
                self.user_defined_node_memory = self.__class__.user_defined_node_memory(service, version, mode, path + ["user_defined_node_memory"])
                self.user_defined_scalars = self.__class__.user_defined_scalars(service, version, mode, path + ["user_defined_scalars"])
                super().__init__(service, version, mode, path)
            class auto_compile_compiled_udfs(TUIMethod):
                """
                For this Fluent session, specify whether to allow auto-compilation of compiled UDF when a case file (or settings file) is read.
                """
            class compile_customized_addon_module(TUIMethod):
                """
                Compile customized addon module?.
                """
            class compiled_functions(TUIMethod):
                """
                Opens user-defined function library.
                """
            class enable_udf_on_gpu(TUIMethod):
                """
                Compile UDFs with OpenCL support.
                """
            class execute_on_demand(TUIMethod):
                """
                Executes UDFs on demand.
                """
            class fan_model(TUIMethod):
                """
                Configures user-defined fan model.
                """
            class function_hooks(TUIMethod):
                """
                Hooks up user-defined functions.
                """
            class interpreted_functions(TUIMethod):
                """
                Loads interpreted user-defined functions.
                """
            class one_D_coupling(TUIMethod):
                """
                Load 1D library.
                """
            class use_built_in_compiler(TUIMethod):
                """
                Enables/disables the use of a built-in compiler (Clang) when the define/user-defined/compiled-functions text command is used. This text command / compiler is available for Windows only, and is provided as part of the ANSYS Fluent installation. It is recommended that you enable this text command when the compiler you installed on your machine is an older version that is no longer supported. Note that the built-in compiler is used automatically if Fluent determines that you have not installed Microsoft Visual Studio or Clang on your computer, whether this text command is enabled or not.
                """
            class use_contributed_cpp(TUIMethod):
                """
                Enable/disable use of cpp from the Fluent.Inc/contrib directory.
                """
            class use_zone_based_udm(TUIMethod):
                """
                Zone based user-defined memory.
                """
            class user_defined_memory(TUIMethod):
                """
                Allocates user-defined memory.
                """
            class user_defined_node_memory(TUIMethod):
                """
                Allocate user-defined node memory.
                """
            class user_defined_scalars(TUIMethod):
                """
                Defines user-defined scalars.
                """

            class real_gas_models(TUIMenu):
                """
                Enters the real-gas menu to enable/configure real gas model.
                """
                def __init__(self, service, version, mode, path):
                    self.nist_multispecies_real_gas_model = self.__class__.nist_multispecies_real_gas_model(service, version, mode, path + ["nist_multispecies_real_gas_model"])
                    self.nist_real_gas_model = self.__class__.nist_real_gas_model(service, version, mode, path + ["nist_real_gas_model"])
                    self.nist_settings = self.__class__.nist_settings(service, version, mode, path + ["nist_settings"])
                    self.set_state = self.__class__.set_state(service, version, mode, path + ["set_state"])
                    self.user_defined_multispecies_real_gas_model = self.__class__.user_defined_multispecies_real_gas_model(service, version, mode, path + ["user_defined_multispecies_real_gas_model"])
                    self.user_defined_real_gas_model = self.__class__.user_defined_real_gas_model(service, version, mode, path + ["user_defined_real_gas_model"])
                    super().__init__(service, version, mode, path)
                class nist_multispecies_real_gas_model(TUIMethod):
                    """
                    Loads the NIST real-gas library.
                    """
                class nist_real_gas_model(TUIMethod):
                    """
                    Loads the NIST real-gas library.
                    """
                class nist_settings(TUIMethod):
                    """
                    Specifies the name and the location for the REFPROP library and fluid files.
                    """
                class set_state(TUIMethod):
                    """
                    Selects the state for NIST real gas model.
                    """
                class user_defined_multispecies_real_gas_model(TUIMethod):
                    """
                    Loads a user-defined multispecies real-gas library.
                    """
                class user_defined_real_gas_model(TUIMethod):
                    """
                    Loads the user-defined real-gas library.
                    """

        class virtual_boundary(TUIMenu):
            """
            Manage Virtual Boundaries.
            """
            def __init__(self, service, version, mode, path):
                self.boundary_interface = self.__class__.boundary_interface(service, version, mode, path + ["boundary_interface"])
                self.hole_geometry = self.__class__.hole_geometry(service, version, mode, path + ["hole_geometry"])
                super().__init__(service, version, mode, path)
            class boundary_interface(TUIMethod):
                """
                Create a Boundary Interface.
                """
            class hole_geometry(TUIMethod):
                """
                Create a Hole Geometry template.
                """

    class display(TUIMenu):
        """
        Enter the display menu.
        """
        def __init__(self, service, version, mode, path):
            self.define = self.__class__.define(service, version, mode, path + ["define"])
            self.display_states = self.__class__.display_states(service, version, mode, path + ["display_states"])
            self.embedded_windows = self.__class__.embedded_windows(service, version, mode, path + ["embedded_windows"])
            self.flamelet_data = self.__class__.flamelet_data(service, version, mode, path + ["flamelet_data"])
            self.objects = self.__class__.objects(service, version, mode, path + ["objects"])
            self.particle_tracks = self.__class__.particle_tracks(service, version, mode, path + ["particle_tracks"])
            self.path_lines = self.__class__.path_lines(service, version, mode, path + ["path_lines"])
            self.pdf_data = self.__class__.pdf_data(service, version, mode, path + ["pdf_data"])
            self.raytracer = self.__class__.raytracer(service, version, mode, path + ["raytracer"])
            self.set = self.__class__.set(service, version, mode, path + ["set"])
            self.surface = self.__class__.surface(service, version, mode, path + ["surface"])
            self.update_scene = self.__class__.update_scene(service, version, mode, path + ["update_scene"])
            self.view_sync = self.__class__.view_sync(service, version, mode, path + ["view_sync"])
            self.views = self.__class__.views(service, version, mode, path + ["views"])
            self.add_custom_vector = self.__class__.add_custom_vector(service, version, mode, path + ["add_custom_vector"])
            self.annotate = self.__class__.annotate(service, version, mode, path + ["annotate"])
            self.clear_annotations = self.__class__.clear_annotations(service, version, mode, path + ["clear_annotations"])
            self.close_window = self.__class__.close_window(service, version, mode, path + ["close_window"])
            self.close_window_by_name = self.__class__.close_window_by_name(service, version, mode, path + ["close_window_by_name"])
            self.contour = self.__class__.contour(service, version, mode, path + ["contour"])
            self.display_custom_vector = self.__class__.display_custom_vector(service, version, mode, path + ["display_custom_vector"])
            self.graphics_window_layout = self.__class__.graphics_window_layout(service, version, mode, path + ["graphics_window_layout"])
            self.grid = self.__class__.grid(service, version, mode, path + ["grid"])
            self.grid_outline = self.__class__.grid_outline(service, version, mode, path + ["grid_outline"])
            self.hsf_file = self.__class__.hsf_file(service, version, mode, path + ["hsf_file"])
            self.mesh = self.__class__.mesh(service, version, mode, path + ["mesh"])
            self.mesh_outline = self.__class__.mesh_outline(service, version, mode, path + ["mesh_outline"])
            self.mesh_partition_boundary = self.__class__.mesh_partition_boundary(service, version, mode, path + ["mesh_partition_boundary"])
            self.multigrid_coarsening = self.__class__.multigrid_coarsening(service, version, mode, path + ["multigrid_coarsening"])
            self.open_window = self.__class__.open_window(service, version, mode, path + ["open_window"])
            self.profile = self.__class__.profile(service, version, mode, path + ["profile"])
            self.re_render = self.__class__.re_render(service, version, mode, path + ["re_render"])
            self.re_scale = self.__class__.re_scale(service, version, mode, path + ["re_scale"])
            self.reacting_channel_curves = self.__class__.reacting_channel_curves(service, version, mode, path + ["reacting_channel_curves"])
            self.save_picture = self.__class__.save_picture(service, version, mode, path + ["save_picture"])
            self.set_list_tree_separator = self.__class__.set_list_tree_separator(service, version, mode, path + ["set_list_tree_separator"])
            self.set_window = self.__class__.set_window(service, version, mode, path + ["set_window"])
            self.set_window_by_name = self.__class__.set_window_by_name(service, version, mode, path + ["set_window_by_name"])
            self.surface_cells = self.__class__.surface_cells(service, version, mode, path + ["surface_cells"])
            self.surface_mesh = self.__class__.surface_mesh(service, version, mode, path + ["surface_mesh"])
            self.switch_to_post_processing_volume = self.__class__.switch_to_post_processing_volume(service, version, mode, path + ["switch_to_post_processing_volume"])
            self.switch_to_primary_volume = self.__class__.switch_to_primary_volume(service, version, mode, path + ["switch_to_primary_volume"])
            self.transient_post_processing = self.__class__.transient_post_processing(service, version, mode, path + ["transient_post_processing"])
            self.update_layout = self.__class__.update_layout(service, version, mode, path + ["update_layout"])
            self.vector = self.__class__.vector(service, version, mode, path + ["vector"])
            self.velocity_vector = self.__class__.velocity_vector(service, version, mode, path + ["velocity_vector"])
            self.zone_mesh = self.__class__.zone_mesh(service, version, mode, path + ["zone_mesh"])
            super().__init__(service, version, mode, path)
        class add_custom_vector(TUIMethod):
            """
            Adds new custom vector definition.
            """
        class annotate(TUIMethod):
            """
            Add a text annotation string to the active graphics window.
            """
        class clear_annotations(TUIMethod):
            """
            Removes all annotations and attachment lines from the active graphics window.
            """
        class close_window(TUIMethod):
            """
            Close a "user" graphics window. User windows are specified by number (1-50), with the associated number corresponding to the order, left-to-right, that the windows were created in.
            """
        class close_window_by_name(TUIMethod):
            """
            Close a reserved graphics window (windows used for residuals, report plots, and animation definitions).
            """
        class contour(TUIMethod):
            """
            Prompts for a scalar field and minimum and maximum values, and then displays a contour plot.
            """
        class display_custom_vector(TUIMethod):
            """
            Displays custom vector.
            """
        class graphics_window_layout(TUIMethod):
            """
            Arranges the graphics window layout.
            """
        class grid(TUIMethod):
            """
            Display the mesh.
            """
        class grid_outline(TUIMethod):
            """
            Display the mesh boundaries.
            """
        class hsf_file(TUIMethod):
            """
            Loads an HSF file for viewing.
            """
        class mesh(TUIMethod):
            """
            Displays the entire mesh. For 3D, you will be asked to confirm that you really want to draw the entire mesh (not just themesh-outline).
            """
        class mesh_outline(TUIMethod):
            """
            Displays the mesh boundaries.
            """
        class mesh_partition_boundary(TUIMethod):
            """
            Displays mesh partition boundaries.
            """
        class multigrid_coarsening(TUIMethod):
            """
            Displays a coarse mesh level from the last multigrid coarsening.
            """
        class open_window(TUIMethod):
            """
            Opens a graphics window.
            """
        class profile(TUIMethod):
            """
            Displays profiles of a flow variable.
            """
        class re_render(TUIMethod):
            """
            Re-renders the last contour, profile, or vector plot with updated surfaces, meshed, lights, colormap, rendering options, and so on, without recalculating the contour data.
            """
        class re_scale(TUIMethod):
            """
            Re-renders the last contour, profile, or vector plot with updated scale, surfaces, meshes, lights, colormap, rendering options, and so on, but without recalculating the field data.
            """
        class reacting_channel_curves(TUIMethod):
            """
            Plots the reacting channel variables.
            """
        class save_picture(TUIMethod):
            """
            Generate a "hardcopy" of the active window.
            """
        class set_list_tree_separator(TUIMethod):
            """
            Set the separator character for list tree.
            """
        class set_window(TUIMethod):
            """
            Sets a "user" graphics window to be the active window. User windows are specified by number (1-50), with the associated number corresponding to the order, left-to-right, that the windows were created in.
            """
        class set_window_by_name(TUIMethod):
            """
            Sets the specified graphics window as active. The graphics windows specified using this command are "reserved" windows, that is, residual monitors, report plots, and animation definitions. The name will match the name you provided when creating the object (report plots and animation definitions).
            """
        class surface_cells(TUIMethod):
            """
            Draws the cells on the specified surfaces. You can include a wildcard (\\*) within the surface names.
            """
        class surface_mesh(TUIMethod):
            """
            Draws the mesh defined by the specified surfaces. You can include a wildcard (\\*) within the surface names.
            """
        class switch_to_post_processing_volume(TUIMethod):
            """
            Switch to post processing volume.
            """
        class switch_to_primary_volume(TUIMethod):
            """
            Switch to primary volume.
            """
        class transient_post_processing(TUIMethod):
            """
            Enter transient postprocessing menu.
            """
        class update_layout(TUIMethod):
            """
            Update the fluent layout.
            """
        class vector(TUIMethod):
            """
            Displays vectors of a space vector variable.
            """
        class velocity_vector(TUIMethod):
            """
            Prompts for a scalar field by which to color the vectors, the minimum and maximum values, and the scale factor, and then draws the velocity vectors.
            """
        class zone_mesh(TUIMethod):
            """
            Draws the mesh defined by specified face zones. Zone names can be indicated using wildcards (\\*).
            """

        class define(TUIMenu):
            """
            Enter Display define menu.
            """
            def __init__(self, service, version, mode, path):
                self.material = self.__class__.material(service, version, mode, path + ["material"])
                super().__init__(service, version, mode, path)

            class material(TUIMenu):
                """
                Add, Edit, Remove materials in case file.
                """
                def __init__(self, service, version, mode, path):
                    self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.new = self.__class__.new(service, version, mode, path + ["new"])
                    super().__init__(service, version, mode, path)
                class copy(TUIMethod):
                    """
                    Copy to new material.
                    """
                class delete(TUIMethod):
                    """
                    Remove  material.
                    """
                class edit(TUIMethod):
                    """
                    Edit material.
                    """
                class new(TUIMethod):
                    """
                    Create new material.
                    """

        class display_states(TUIMenu):
            """
            Enter the display state manipulation menu.
            """
            def __init__(self, service, version, mode, path):
                self.apply = self.__class__.apply(service, version, mode, path + ["apply"])
                self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.read = self.__class__.read(service, version, mode, path + ["read"])
                self.use_active = self.__class__.use_active(service, version, mode, path + ["use_active"])
                self.write = self.__class__.write(service, version, mode, path + ["write"])
                super().__init__(service, version, mode, path)
            class apply(TUIMethod):
                """
                Apply a display state to the active window.
                """
            class copy(TUIMethod):
                """
                Create a new display state with settings copied from an existing display state.
                """
            class create(TUIMethod):
                """
                Create a new display state.
                """
            class delete(TUIMethod):
                """
                Delete a display state.
                """
            class edit(TUIMethod):
                """
                Edit a particular display state setting.
                """
            class list(TUIMethod):
                """
                Print the names of the available display states to the console.
                """
            class read(TUIMethod):
                """
                Read display states from a file.
                """
            class use_active(TUIMethod):
                """
                Update an existing display state's settings to match those of the active graphics window.
                """
            class write(TUIMethod):
                """
                Write display states to a file.
                """

        class embedded_windows(TUIMenu):
            """
            Enter the embedded window menu.
            """
            def __init__(self, service, version, mode, path):
                self.close = self.__class__.close(service, version, mode, path + ["close"])
                self.close_all = self.__class__.close_all(service, version, mode, path + ["close_all"])
                self.embed_in = self.__class__.embed_in(service, version, mode, path + ["embed_in"])
                self.move_out = self.__class__.move_out(service, version, mode, path + ["move_out"])
                self.move_out_all = self.__class__.move_out_all(service, version, mode, path + ["move_out_all"])
                self.update_dimensions = self.__class__.update_dimensions(service, version, mode, path + ["update_dimensions"])
                super().__init__(service, version, mode, path)
            class close(TUIMethod):
                """
                Close an embedded window.
                """
            class close_all(TUIMethod):
                """
                Close all the embedded windows within the specified parent window.
                """
            class embed_in(TUIMethod):
                """
                Specify a window to embed and a parent window to receive the embedded window.
                """
            class move_out(TUIMethod):
                """
                Move an embedded window out of the parent window, returning the embedded window to a non-embedded state.
                """
            class move_out_all(TUIMethod):
                """
                Move all the embedded windows out of the specified parent window.
                """
            class update_dimensions(TUIMethod):
                """
                Update the embedded windows dimensions.
                """

        class flamelet_data(TUIMenu):
            """
            Displays flamelet data.
            """
            def __init__(self, service, version, mode, path):
                self.carpet_plot = self.__class__.carpet_plot(service, version, mode, path + ["carpet_plot"])
                self.draw_number_box = self.__class__.draw_number_box(service, version, mode, path + ["draw_number_box"])
                self.plot_1d_slice = self.__class__.plot_1d_slice(service, version, mode, path + ["plot_1d_slice"])
                self.write_to_file = self.__class__.write_to_file(service, version, mode, path + ["write_to_file"])
                super().__init__(service, version, mode, path)
            class carpet_plot(TUIMethod):
                """
                Enables/disables display of carpet plot of a property.
                """
            class draw_number_box(TUIMethod):
                """
                Enables/disables display of the numbers box.
                """
            class plot_1d_slice(TUIMethod):
                """
                Enables/disables plot of the 1D-slice.
                """
            class write_to_file(TUIMethod):
                """
                Enables/disables writing the 1D-slice to file instead of plot.
                """

        class objects(TUIMenu):
            """
            Enter to add, edit, delete or display graphics objects.
            """
            def __init__(self, service, version, mode, path):
                self.add_to_graphics = self.__class__.add_to_graphics(service, version, mode, path + ["add_to_graphics"])
                self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                super().__init__(service, version, mode, path)
            class add_to_graphics(TUIMethod):
                """
                Add graphics object to existing graphics.
                """
            class copy(TUIMethod):
                """
                Copy graphics object.
                """
            class create(TUIMethod):
                """
                Create new graphics object.
                """
            class delete(TUIMethod):
                """
                Delete graphics object.
                """
            class display(TUIMethod):
                """
                Display graphics object.
                """
            class edit(TUIMethod):
                """
                Edit graphics object.
                """

        class particle_tracks(TUIMenu):
            """
            Enters the particle tracks menu.
            """
            def __init__(self, service, version, mode, path):
                self.particle_tracks = self.__class__.particle_tracks(service, version, mode, path + ["particle_tracks"])
                self.plot_write_xy_plot = self.__class__.plot_write_xy_plot(service, version, mode, path + ["plot_write_xy_plot"])
                super().__init__(service, version, mode, path)
            class particle_tracks(TUIMethod):
                """
                Calculates and displays particle tracks from defined injections.
                """
            class plot_write_xy_plot(TUIMethod):
                """
                Plots or writes an XY plot of particle tracks.
                """

        class path_lines(TUIMenu):
            """
            Enters the pathlines menu.
            """
            def __init__(self, service, version, mode, path):
                self.path_lines = self.__class__.path_lines(service, version, mode, path + ["path_lines"])
                self.plot_write_xy_plot = self.__class__.plot_write_xy_plot(service, version, mode, path + ["plot_write_xy_plot"])
                self.write_to_files = self.__class__.write_to_files(service, version, mode, path + ["write_to_files"])
                super().__init__(service, version, mode, path)
            class path_lines(TUIMethod):
                """
                Displays pathlines from a surface.
                """
            class plot_write_xy_plot(TUIMethod):
                """
                Plots or writes an XY plot of pathlines.
                """
            class write_to_files(TUIMethod):
                """
                Writes pathlines to a file.
                """

        class pdf_data(TUIMenu):
            """
            Enters the PDF data menu.
            """
            def __init__(self, service, version, mode, path):
                self.carpet_plot = self.__class__.carpet_plot(service, version, mode, path + ["carpet_plot"])
                self.draw_number_box = self.__class__.draw_number_box(service, version, mode, path + ["draw_number_box"])
                self.plot_1d_slice = self.__class__.plot_1d_slice(service, version, mode, path + ["plot_1d_slice"])
                self.write_to_file = self.__class__.write_to_file(service, version, mode, path + ["write_to_file"])
                super().__init__(service, version, mode, path)
            class carpet_plot(TUIMethod):
                """
                Enables/disables the display of a carpet plot of a property.
                """
            class draw_number_box(TUIMethod):
                """
                Enables/disables the display of the numbers box.
                """
            class plot_1d_slice(TUIMethod):
                """
                Enables/disables a plot of the 1D-slice.
                """
            class write_to_file(TUIMethod):
                """
                Enables/disables writing the 1D-slice to file instead of plot.
                """

        class raytracer(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.background = self.__class__.background(service, version, mode, path + ["background"])
                self.rendering = self.__class__.rendering(service, version, mode, path + ["rendering"])
                self.display_live_preview = self.__class__.display_live_preview(service, version, mode, path + ["display_live_preview"])
                super().__init__(service, version, mode, path)
            class display_live_preview(TUIMethod):
                """
                .
                """

            class background(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.backplate_color = self.__class__.backplate_color(service, version, mode, path + ["backplate_color"])
                    self.backplate_image = self.__class__.backplate_image(service, version, mode, path + ["backplate_image"])
                    self.env_color = self.__class__.env_color(service, version, mode, path + ["env_color"])
                    self.env_intensity = self.__class__.env_intensity(service, version, mode, path + ["env_intensity"])
                    self.env_light_dirvec = self.__class__.env_light_dirvec(service, version, mode, path + ["env_light_dirvec"])
                    self.env_light_upvec = self.__class__.env_light_upvec(service, version, mode, path + ["env_light_upvec"])
                    self.environment_image = self.__class__.environment_image(service, version, mode, path + ["environment_image"])
                    self.hide_environment_keep_effects = self.__class__.hide_environment_keep_effects(service, version, mode, path + ["hide_environment_keep_effects"])
                    self.horizontal = self.__class__.horizontal(service, version, mode, path + ["horizontal"])
                    self.show_backplate = self.__class__.show_backplate(service, version, mode, path + ["show_backplate"])
                    self.spin = self.__class__.spin(service, version, mode, path + ["spin"])
                    self.vertical = self.__class__.vertical(service, version, mode, path + ["vertical"])
                    self.view_zoom = self.__class__.view_zoom(service, version, mode, path + ["view_zoom"])
                    super().__init__(service, version, mode, path)
                class backplate_color(TUIMethod):
                    """
                    .
                    """
                class backplate_image(TUIMethod):
                    """
                    .
                    """
                class env_color(TUIMethod):
                    """
                    .
                    """
                class env_intensity(TUIMethod):
                    """
                    .
                    """
                class env_light_dirvec(TUIMethod):
                    """
                    .
                    """
                class env_light_upvec(TUIMethod):
                    """
                    .
                    """
                class environment_image(TUIMethod):
                    """
                    .
                    """
                class hide_environment_keep_effects(TUIMethod):
                    """
                    .
                    """
                class horizontal(TUIMethod):
                    """
                    .
                    """
                class show_backplate(TUIMethod):
                    """
                    .
                    """
                class spin(TUIMethod):
                    """
                    .
                    """
                class vertical(TUIMethod):
                    """
                    .
                    """
                class view_zoom(TUIMethod):
                    """
                    .
                    """

            class rendering(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.denoiser = self.__class__.denoiser(service, version, mode, path + ["denoiser"])
                    self.max_rendering_timeout = self.__class__.max_rendering_timeout(service, version, mode, path + ["max_rendering_timeout"])
                    self.quality = self.__class__.quality(service, version, mode, path + ["quality"])
                    self.thread_count = self.__class__.thread_count(service, version, mode, path + ["thread_count"])
                    super().__init__(service, version, mode, path)
                class denoiser(TUIMethod):
                    """
                    .
                    """
                class max_rendering_timeout(TUIMethod):
                    """
                    .
                    """
                class quality(TUIMethod):
                    """
                    .
                    """
                class thread_count(TUIMethod):
                    """
                    .
                    """

        class set(TUIMenu):
            """
            Enter the set menu to set display parameters.
            """
            def __init__(self, service, version, mode, path):
                self.colors = self.__class__.colors(service, version, mode, path + ["colors"])
                self.contours = self.__class__.contours(service, version, mode, path + ["contours"])
                self.lights = self.__class__.lights(service, version, mode, path + ["lights"])
                self.particle_tracks = self.__class__.particle_tracks(service, version, mode, path + ["particle_tracks"])
                self.path_lines = self.__class__.path_lines(service, version, mode, path + ["path_lines"])
                self.picture = self.__class__.picture(service, version, mode, path + ["picture"])
                self.rendering_options = self.__class__.rendering_options(service, version, mode, path + ["rendering_options"])
                self.titles = self.__class__.titles(service, version, mode, path + ["titles"])
                self.velocity_vectors = self.__class__.velocity_vectors(service, version, mode, path + ["velocity_vectors"])
                self.windows = self.__class__.windows(service, version, mode, path + ["windows"])
                self.color_map = self.__class__.color_map(service, version, mode, path + ["color_map"])
                self.duplicate_node_display = self.__class__.duplicate_node_display(service, version, mode, path + ["duplicate_node_display"])
                self.element_shrink = self.__class__.element_shrink(service, version, mode, path + ["element_shrink"])
                self.filled_grid = self.__class__.filled_grid(service, version, mode, path + ["filled_grid"])
                self.filled_mesh = self.__class__.filled_mesh(service, version, mode, path + ["filled_mesh"])
                self.grid_level = self.__class__.grid_level(service, version, mode, path + ["grid_level"])
                self.grid_partitions = self.__class__.grid_partitions(service, version, mode, path + ["grid_partitions"])
                self.grid_surfaces = self.__class__.grid_surfaces(service, version, mode, path + ["grid_surfaces"])
                self.grid_zones = self.__class__.grid_zones(service, version, mode, path + ["grid_zones"])
                self.line_weight = self.__class__.line_weight(service, version, mode, path + ["line_weight"])
                self.marker_size = self.__class__.marker_size(service, version, mode, path + ["marker_size"])
                self.marker_symbol = self.__class__.marker_symbol(service, version, mode, path + ["marker_symbol"])
                self.mesh_display_configuration = self.__class__.mesh_display_configuration(service, version, mode, path + ["mesh_display_configuration"])
                self.mesh_level = self.__class__.mesh_level(service, version, mode, path + ["mesh_level"])
                self.mesh_partitions = self.__class__.mesh_partitions(service, version, mode, path + ["mesh_partitions"])
                self.mesh_surfaces = self.__class__.mesh_surfaces(service, version, mode, path + ["mesh_surfaces"])
                self.mesh_zones = self.__class__.mesh_zones(service, version, mode, path + ["mesh_zones"])
                self.mirror_zones = self.__class__.mirror_zones(service, version, mode, path + ["mirror_zones"])
                self.n_stream_func = self.__class__.n_stream_func(service, version, mode, path + ["n_stream_func"])
                self.nodewt_based_interp = self.__class__.nodewt_based_interp(service, version, mode, path + ["nodewt_based_interp"])
                self.overlays = self.__class__.overlays(service, version, mode, path + ["overlays"])
                self.periodic_instancing = self.__class__.periodic_instancing(service, version, mode, path + ["periodic_instancing"])
                self.periodic_repeats = self.__class__.periodic_repeats(service, version, mode, path + ["periodic_repeats"])
                self.proximity_zones = self.__class__.proximity_zones(service, version, mode, path + ["proximity_zones"])
                self.render_mesh = self.__class__.render_mesh(service, version, mode, path + ["render_mesh"])
                self.reset_graphics = self.__class__.reset_graphics(service, version, mode, path + ["reset_graphics"])
                self.zero_angle_dir = self.__class__.zero_angle_dir(service, version, mode, path + ["zero_angle_dir"])
                super().__init__(service, version, mode, path)
            class color_map(TUIMethod):
                """
                Enters the color map menu, which contains names of predefined and user-defined (in the Colormap Editor panel) colormaps that can be selected. It prompts you for the name of the colormap to be used.
                """
            class duplicate_node_display(TUIMethod):
                """
                Set flag to remove duplicate nodes in mesh display.
                """
            class element_shrink(TUIMethod):
                """
                Sets shrinkage of both faces and cells. A value of zero indicates no shrinkage, while a value of one will shrink each face or cell to a point.
                """
            class filled_grid(TUIMethod):
                """
                Enable/disable the filled mesh option.
                """
            class filled_mesh(TUIMethod):
                """
                Determines whether the meshes are drawn as wireframe or solid.
                """
            class grid_level(TUIMethod):
                """
                Set coarse mesh level to be drawn.
                """
            class grid_partitions(TUIMethod):
                """
                Enable/disable drawing of the mesh partition boundaries.
                """
            class grid_surfaces(TUIMethod):
                """
                Set surface IDs to be drawn as mesh.
                """
            class grid_zones(TUIMethod):
                """
                Set zone IDs to be drawn as mesh.
                """
            class line_weight(TUIMethod):
                """
                Set the line-weight factor for the window.
                """
            class marker_size(TUIMethod):
                """
                Sets the size of markers used to represent points.
                """
            class marker_symbol(TUIMethod):
                """
                Sets the type of markers used to represent points.
                """
            class mesh_display_configuration(TUIMethod):
                """
                Changes the default mesh display. If set tomeshing, it draws the mesh on edges and faces of the outline surfaces, colored by their zone ID with lighting enabled. If set tosolution, it draws the mesh on edges and faces of the outline surfaces, colored by their zone type with lighting enabled. If set to post-processing, it draws the object outline with lighting disabled. If set toclassic, it draws the mesh on all edges of the outline surfaces.  This only applies for 3D cases.
                """
            class mesh_level(TUIMethod):
                """
                Sets coarse mesh level to be drawn.
                """
            class mesh_partitions(TUIMethod):
                """
                Enables/disables option to draw mesh partition boundaries.
                """
            class mesh_surfaces(TUIMethod):
                """
                Sets surface IDs to be drawn as meshes. You can include a wildcard  (\\*) within the surface names.
                """
            class mesh_zones(TUIMethod):
                """
                Sets zone IDs to be drawn as meshes.
                """
            class mirror_zones(TUIMethod):
                """
                Sets the zones about which the domain is mirrored (symmetry planes).
                """
            class n_stream_func(TUIMethod):
                """
                Sets number of iterations used in computing stream function.
                """
            class nodewt_based_interp(TUIMethod):
                """
                Disables/enables the use of node weights for node-based gradients in postprocessing.
                """
            class overlays(TUIMethod):
                """
                Enable/disable overlays.
                """
            class periodic_instancing(TUIMethod):
                """
                Sets the number of periodic repetitions.
                """
            class periodic_repeats(TUIMethod):
                """
                Sets the number of periodic repetitions.
                """
            class proximity_zones(TUIMethod):
                """
                Sets zones to be used for boundary cell distance and boundary proximity.
                """
            class render_mesh(TUIMethod):
                """
                Enables/disables rendering the mesh on top of contours, vectors, and so on.
                """
            class reset_graphics(TUIMethod):
                """
                Reset the graphics system.
                """
            class zero_angle_dir(TUIMethod):
                """
                Sets the vector having zero angular coordinates.
                """

            class colors(TUIMenu):
                """
                Enter the color options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.by_surface = self.__class__.by_surface(service, version, mode, path + ["by_surface"])
                    self.by_type = self.__class__.by_type(service, version, mode, path + ["by_type"])
                    self.automatic_skip = self.__class__.automatic_skip(service, version, mode, path + ["automatic_skip"])
                    self.axis_faces = self.__class__.axis_faces(service, version, mode, path + ["axis_faces"])
                    self.background = self.__class__.background(service, version, mode, path + ["background"])
                    self.color_by_type = self.__class__.color_by_type(service, version, mode, path + ["color_by_type"])
                    self.far_field_faces = self.__class__.far_field_faces(service, version, mode, path + ["far_field_faces"])
                    self.foreground = self.__class__.foreground(service, version, mode, path + ["foreground"])
                    self.free_surface_faces = self.__class__.free_surface_faces(service, version, mode, path + ["free_surface_faces"])
                    self.graphics_color_theme = self.__class__.graphics_color_theme(service, version, mode, path + ["graphics_color_theme"])
                    self.grid_inlet = self.__class__.grid_inlet(service, version, mode, path + ["grid_inlet"])
                    self.grid_interior = self.__class__.grid_interior(service, version, mode, path + ["grid_interior"])
                    self.highlight_color = self.__class__.highlight_color(service, version, mode, path + ["highlight_color"])
                    self.inlet_faces = self.__class__.inlet_faces(service, version, mode, path + ["inlet_faces"])
                    self.interface_faces = self.__class__.interface_faces(service, version, mode, path + ["interface_faces"])
                    self.interior_faces = self.__class__.interior_faces(service, version, mode, path + ["interior_faces"])
                    self.internal_faces = self.__class__.internal_faces(service, version, mode, path + ["internal_faces"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.outlet_faces = self.__class__.outlet_faces(service, version, mode, path + ["outlet_faces"])
                    self.overset_faces = self.__class__.overset_faces(service, version, mode, path + ["overset_faces"])
                    self.periodic_faces = self.__class__.periodic_faces(service, version, mode, path + ["periodic_faces"])
                    self.rans_les_interface_faces = self.__class__.rans_les_interface_faces(service, version, mode, path + ["rans_les_interface_faces"])
                    self.reset_colors = self.__class__.reset_colors(service, version, mode, path + ["reset_colors"])
                    self.reset_user_colors = self.__class__.reset_user_colors(service, version, mode, path + ["reset_user_colors"])
                    self.show_user_colors = self.__class__.show_user_colors(service, version, mode, path + ["show_user_colors"])
                    self.skip_label = self.__class__.skip_label(service, version, mode, path + ["skip_label"])
                    self.surface = self.__class__.surface(service, version, mode, path + ["surface"])
                    self.symmetry_faces = self.__class__.symmetry_faces(service, version, mode, path + ["symmetry_faces"])
                    self.traction_faces = self.__class__.traction_faces(service, version, mode, path + ["traction_faces"])
                    self.user_color = self.__class__.user_color(service, version, mode, path + ["user_color"])
                    self.wall_faces = self.__class__.wall_faces(service, version, mode, path + ["wall_faces"])
                    super().__init__(service, version, mode, path)
                class automatic_skip(TUIMethod):
                    """
                    Determine whether to skip labels in the colopmap scale automatically.
                    """
                class axis_faces(TUIMethod):
                    """
                    Set the color of axisymmetric faces.
                    """
                class background(TUIMethod):
                    """
                    Set the background (window) color.
                    """
                class color_by_type(TUIMethod):
                    """
                    Determine whether to color meshes by type or by surface (ID).
                    """
                class far_field_faces(TUIMethod):
                    """
                    Set the color of far field faces.
                    """
                class foreground(TUIMethod):
                    """
                    Set the foreground (text and window frame) color.
                    """
                class free_surface_faces(TUIMethod):
                    """
                    Set the color of free-surface faces.
                    """
                class graphics_color_theme(TUIMethod):
                    """
                    Enter the graphics color theme menu.
                    """
                class grid_inlet(TUIMethod):
                    """
                    Set the color of inlet faces.
                    """
                class grid_interior(TUIMethod):
                    """
                    Set the color of interior faces.
                    """
                class highlight_color(TUIMethod):
                    """
                    Set highlight color.
                    """
                class inlet_faces(TUIMethod):
                    """
                    Set the color of inlet faces.
                    """
                class interface_faces(TUIMethod):
                    """
                    Set the color of mesh Interfaces.
                    """
                class interior_faces(TUIMethod):
                    """
                    Set the color of interior faces.
                    """
                class internal_faces(TUIMethod):
                    """
                    Set the color of internal interface faces.
                    """
                class list(TUIMethod):
                    """
                    List available colors.
                    """
                class outlet_faces(TUIMethod):
                    """
                    Set the color of outlet faces.
                    """
                class overset_faces(TUIMethod):
                    """
                    Set the color of overset faces.
                    """
                class periodic_faces(TUIMethod):
                    """
                    Set the color of periodic faces.
                    """
                class rans_les_interface_faces(TUIMethod):
                    """
                    Set the color of RANS/LES interface faces.
                    """
                class reset_colors(TUIMethod):
                    """
                    Reset individual mesh surface colors to the defaults.
                    """
                class reset_user_colors(TUIMethod):
                    """
                    Reset all user colors.
                    """
                class show_user_colors(TUIMethod):
                    """
                    List currently defined user colors.
                    """
                class skip_label(TUIMethod):
                    """
                    Set the number of labels to be skipped in the colopmap scale.
                    """
                class surface(TUIMethod):
                    """
                    Set the color of surfaces.
                    """
                class symmetry_faces(TUIMethod):
                    """
                    Set the color of symmetric faces.
                    """
                class traction_faces(TUIMethod):
                    """
                    Set the color of traction faces.
                    """
                class user_color(TUIMethod):
                    """
                    Explicitly set color of display zone.
                    """
                class wall_faces(TUIMethod):
                    """
                    Set the color of wall faces.
                    """

                class by_surface(TUIMenu):
                    """
                    Enter the surface(s) color and material assignment menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.list_surfaces_by_color = self.__class__.list_surfaces_by_color(service, version, mode, path + ["list_surfaces_by_color"])
                        self.list_surfaces_by_material = self.__class__.list_surfaces_by_material(service, version, mode, path + ["list_surfaces_by_material"])
                        self.reset = self.__class__.reset(service, version, mode, path + ["reset"])
                        self.surfaces = self.__class__.surfaces(service, version, mode, path + ["surfaces"])
                        self.use_inherent_material_color = self.__class__.use_inherent_material_color(service, version, mode, path + ["use_inherent_material_color"])
                        super().__init__(service, version, mode, path)
                    class list_surfaces_by_color(TUIMethod):
                        """
                        To list the surfaces by its color.
                        """
                    class list_surfaces_by_material(TUIMethod):
                        """
                        To list the surfaces by its material.
                        """
                    class reset(TUIMethod):
                        """
                        To reset colors and/or materials to the defaults.
                        """
                    class surfaces(TUIMethod):
                        """
                        Select the surface(s) to specify colors and/or materials.
                        """
                    class use_inherent_material_color(TUIMethod):
                        """
                        Use inherent material color for surfaces.
                        """

                class by_type(TUIMenu):
                    """
                    Enter the zone type color and material assignment menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.type_name = self.__class__.type_name(service, version, mode, path + ["type_name"])
                        self.only_list_case_boundaries = self.__class__.only_list_case_boundaries(service, version, mode, path + ["only_list_case_boundaries"])
                        self.reset = self.__class__.reset(service, version, mode, path + ["reset"])
                        self.use_inherent_material_color = self.__class__.use_inherent_material_color(service, version, mode, path + ["use_inherent_material_color"])
                        super().__init__(service, version, mode, path)
                    class only_list_case_boundaries(TUIMethod):
                        """
                        Only list the boundary types that are assigned in this case.
                        """
                    class reset(TUIMethod):
                        """
                        To reset colors and/or materials to the defaults.
                        """
                    class use_inherent_material_color(TUIMethod):
                        """
                        Use inherent material color for boundary zones.
                        """

                    class type_name(TUIMenu):
                        """
                        Select the boundary type to specify colors and/or materials.
                        """
                        def __init__(self, service, version, mode, path):
                            self.axis = self.__class__.axis(service, version, mode, path + ["axis"])
                            self.far_field = self.__class__.far_field(service, version, mode, path + ["far_field"])
                            self.free_surface = self.__class__.free_surface(service, version, mode, path + ["free_surface"])
                            self.inlet = self.__class__.inlet(service, version, mode, path + ["inlet"])
                            self.interface = self.__class__.interface(service, version, mode, path + ["interface"])
                            self.interior = self.__class__.interior(service, version, mode, path + ["interior"])
                            self.internal = self.__class__.internal(service, version, mode, path + ["internal"])
                            self.outlet = self.__class__.outlet(service, version, mode, path + ["outlet"])
                            self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                            self.periodic = self.__class__.periodic(service, version, mode, path + ["periodic"])
                            self.rans_les_interface = self.__class__.rans_les_interface(service, version, mode, path + ["rans_les_interface"])
                            self.surface = self.__class__.surface(service, version, mode, path + ["surface"])
                            self.symmetry = self.__class__.symmetry(service, version, mode, path + ["symmetry"])
                            self.traction = self.__class__.traction(service, version, mode, path + ["traction"])
                            self.wall = self.__class__.wall(service, version, mode, path + ["wall"])
                            super().__init__(service, version, mode, path)

                        class axis(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class far_field(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class free_surface(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class inlet(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class interface(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class interior(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class internal(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class outlet(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class overset(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class periodic(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class rans_les_interface(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class surface(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class symmetry(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class traction(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class wall(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

            class contours(TUIMenu):
                """
                Enters the contour options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.auto_range = self.__class__.auto_range(service, version, mode, path + ["auto_range"])
                    self.clip_to_range = self.__class__.clip_to_range(service, version, mode, path + ["clip_to_range"])
                    self.coloring = self.__class__.coloring(service, version, mode, path + ["coloring"])
                    self.filled_contours = self.__class__.filled_contours(service, version, mode, path + ["filled_contours"])
                    self.global_range = self.__class__.global_range(service, version, mode, path + ["global_range"])
                    self.line_contours = self.__class__.line_contours(service, version, mode, path + ["line_contours"])
                    self.log_scale = self.__class__.log_scale(service, version, mode, path + ["log_scale"])
                    self.n_contour = self.__class__.n_contour(service, version, mode, path + ["n_contour"])
                    self.node_values = self.__class__.node_values(service, version, mode, path + ["node_values"])
                    self.render_mesh = self.__class__.render_mesh(service, version, mode, path + ["render_mesh"])
                    self.surfaces = self.__class__.surfaces(service, version, mode, path + ["surfaces"])
                    super().__init__(service, version, mode, path)
                class auto_range(TUIMethod):
                    """
                    Enables/disables auto-computation of the contour range.
                    """
                class clip_to_range(TUIMethod):
                    """
                    Turns the clip to range option for filled contours on/off.
                    """
                class coloring(TUIMethod):
                    """
                    Specifies whether contours are displayed in bands or with smooth transitions. Note that you can only display smooth contours if node-values are enabled.
                    """
                class filled_contours(TUIMethod):
                    """
                    Turns the filled contours option on/off (deselects line-contours?).
                    """
                class global_range(TUIMethod):
                    """
                    Turns the global range for contours on/off.
                    """
                class line_contours(TUIMethod):
                    """
                    Turns the line contours option on/off (deselects filled-contours?).
                    """
                class log_scale(TUIMethod):
                    """
                    Specifies a decimal or logarithmic color scale for contours.
                    """
                class n_contour(TUIMethod):
                    """
                    Sets the number of contour levels.
                    """
                class node_values(TUIMethod):
                    """
                    Sets the option to use scalar field at nodes when computing the contours.
                    """
                class render_mesh(TUIMethod):
                    """
                    Determines whether or not to render the mesh on top of contours, vectors, and so on.
                    """
                class surfaces(TUIMethod):
                    """
                    Sets the surfaces on which contours are drawn. You can include a wildcard (\\*) within the surface names.
                    """

            class lights(TUIMenu):
                """
                Enter the lights menu.
                """
                def __init__(self, service, version, mode, path):
                    self.headlight_on = self.__class__.headlight_on(service, version, mode, path + ["headlight_on"])
                    self.lighting_interpolation = self.__class__.lighting_interpolation(service, version, mode, path + ["lighting_interpolation"])
                    self.lights_on = self.__class__.lights_on(service, version, mode, path + ["lights_on"])
                    self.set_ambient_color = self.__class__.set_ambient_color(service, version, mode, path + ["set_ambient_color"])
                    self.set_light = self.__class__.set_light(service, version, mode, path + ["set_light"])
                    super().__init__(service, version, mode, path)
                class headlight_on(TUIMethod):
                    """
                    Turn the light that moves with the camera on or off.
                    """
                class lighting_interpolation(TUIMethod):
                    """
                    Set lighting interpolation method.
                    """
                class lights_on(TUIMethod):
                    """
                    Turn all active lighting on/off.
                    """
                class set_ambient_color(TUIMethod):
                    """
                    Set the ambient light color for the scene.
                    """
                class set_light(TUIMethod):
                    """
                    Add or modify a directional, colored light.
                    """

            class particle_tracks(TUIMenu):
                """
                Enters the particle-tracks menu to set parameters for display of particle tracks.
                """
                def __init__(self, service, version, mode, path):
                    self.filter_settings = self.__class__.filter_settings(service, version, mode, path + ["filter_settings"])
                    self.sphere_settings = self.__class__.sphere_settings(service, version, mode, path + ["sphere_settings"])
                    self.vector_settings = self.__class__.vector_settings(service, version, mode, path + ["vector_settings"])
                    self.arrow_scale = self.__class__.arrow_scale(service, version, mode, path + ["arrow_scale"])
                    self.arrow_space = self.__class__.arrow_space(service, version, mode, path + ["arrow_space"])
                    self.coarsen_factor = self.__class__.coarsen_factor(service, version, mode, path + ["coarsen_factor"])
                    self.display = self.__class__.display(service, version, mode, path + ["display"])
                    self.history_filename = self.__class__.history_filename(service, version, mode, path + ["history_filename"])
                    self.line_width = self.__class__.line_width(service, version, mode, path + ["line_width"])
                    self.marker_size = self.__class__.marker_size(service, version, mode, path + ["marker_size"])
                    self.particle_skip = self.__class__.particle_skip(service, version, mode, path + ["particle_skip"])
                    self.radius = self.__class__.radius(service, version, mode, path + ["radius"])
                    self.report_default_variables = self.__class__.report_default_variables(service, version, mode, path + ["report_default_variables"])
                    self.report_to = self.__class__.report_to(service, version, mode, path + ["report_to"])
                    self.report_type = self.__class__.report_type(service, version, mode, path + ["report_type"])
                    self.report_variables = self.__class__.report_variables(service, version, mode, path + ["report_variables"])
                    self.sphere_attrib = self.__class__.sphere_attrib(service, version, mode, path + ["sphere_attrib"])
                    self.style = self.__class__.style(service, version, mode, path + ["style"])
                    self.track_single_particle_stream = self.__class__.track_single_particle_stream(service, version, mode, path + ["track_single_particle_stream"])
                    self.twist_factor = self.__class__.twist_factor(service, version, mode, path + ["twist_factor"])
                    super().__init__(service, version, mode, path)
                class arrow_scale(TUIMethod):
                    """
                    Sets the scale factor for arrows drawn on particle tracks.
                    """
                class arrow_space(TUIMethod):
                    """
                    Sets the spacing factor for arrows drawn on particle tracks.
                    """
                class coarsen_factor(TUIMethod):
                    """
                    Sets the coarsening factor for particle tracks.
                    """
                class display(TUIMethod):
                    """
                    Determines whether particle tracks shall be displayed or only tracked.
                    """
                class history_filename(TUIMethod):
                    """
                    Specifies the name of the particle history file.
                    """
                class line_width(TUIMethod):
                    """
                    Sets the width for particle track.
                    """
                class marker_size(TUIMethod):
                    """
                    Sets the size of markers used to represent particle tracks.
                    """
                class particle_skip(TUIMethod):
                    """
                    Specifies how many particle tracks should be displayed.
                    """
                class radius(TUIMethod):
                    """
                    Sets the radius for particle track (ribbon/cylinder only) cross-section.
                    """
                class report_default_variables(TUIMethod):
                    """
                    Sets the report variables to default.
                    """
                class report_to(TUIMethod):
                    """
                    Specifies the destination for the report (console, file, none).
                    """
                class report_type(TUIMethod):
                    """
                    Sets the report type for particle tracks.
                    """
                class report_variables(TUIMethod):
                    """
                    Sets the report variables.
                    """
                class sphere_attrib(TUIMethod):
                    """
                    Specifies the size and number of slices to be used in drawing spheres.
                    """
                class style(TUIMethod):
                    """
                    Sets the display style for particle track (line/ribbon/cylinder/sphere).
                    """
                class track_single_particle_stream(TUIMethod):
                    """
                    Specifies the stream ID to be tracked.
                    """
                class twist_factor(TUIMethod):
                    """
                    Sets the scale factor for twisting (ribbons only).
                    """

                class filter_settings(TUIMenu):
                    """
                    Set filter for particle display.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enable_filtering = self.__class__.enable_filtering(service, version, mode, path + ["enable_filtering"])
                        self.filter_variable = self.__class__.filter_variable(service, version, mode, path + ["filter_variable"])
                        self.inside = self.__class__.inside(service, version, mode, path + ["inside"])
                        self.maximum = self.__class__.maximum(service, version, mode, path + ["maximum"])
                        self.minimum = self.__class__.minimum(service, version, mode, path + ["minimum"])
                        super().__init__(service, version, mode, path)
                    class enable_filtering(TUIMethod):
                        """
                        Specifies whether particle display is filtered.
                        """
                    class filter_variable(TUIMethod):
                        """
                        Selects a variable used for filtering of particles.
                        """
                    class inside(TUIMethod):
                        """
                        Specifies whether filter variable must be inside min/max to be displayed (else outside min/max).
                        """
                    class maximum(TUIMethod):
                        """
                        Specifies the upper bound for the filter variable.
                        """
                    class minimum(TUIMethod):
                        """
                        Specifies the lower bound for the filter variable.
                        """

                class sphere_settings(TUIMenu):
                    """
                    Provide sphere specific input.
                    """
                    def __init__(self, service, version, mode, path):
                        self.auto_range = self.__class__.auto_range(service, version, mode, path + ["auto_range"])
                        self.diameter = self.__class__.diameter(service, version, mode, path + ["diameter"])
                        self.maximum = self.__class__.maximum(service, version, mode, path + ["maximum"])
                        self.minimum = self.__class__.minimum(service, version, mode, path + ["minimum"])
                        self.scale_factor = self.__class__.scale_factor(service, version, mode, path + ["scale_factor"])
                        self.size_variable = self.__class__.size_variable(service, version, mode, path + ["size_variable"])
                        self.smooth_parameter = self.__class__.smooth_parameter(service, version, mode, path + ["smooth_parameter"])
                        self.vary_diameter = self.__class__.vary_diameter(service, version, mode, path + ["vary_diameter"])
                        super().__init__(service, version, mode, path)
                    class auto_range(TUIMethod):
                        """
                        Specifies whether displayed spheres should include auto range of variable to size spheres.
                        """
                    class diameter(TUIMethod):
                        """
                        Diameter of the spheres whenvary-diameter is disabled.
                        """
                    class maximum(TUIMethod):
                        """
                        Sets the maximum value of the sphere to be displayed.
                        """
                    class minimum(TUIMethod):
                        """
                        Sets the minimum value of the sphere to be displayed.
                        """
                    class scale_factor(TUIMethod):
                        """
                        Specifies a scale factor to enlarge/reduce the size of spheres.
                        """
                    class size_variable(TUIMethod):
                        """
                        Selects a particle variable to size the spheres.
                        """
                    class smooth_parameter(TUIMethod):
                        """
                        Specifies number of slices to be used in drawing spheres.
                        """
                    class vary_diameter(TUIMethod):
                        """
                        Specifies whether the spheres can vary with another variable.
                        """

                class vector_settings(TUIMenu):
                    """
                    Set vector specific input.
                    """
                    def __init__(self, service, version, mode, path):
                        self.color_variable = self.__class__.color_variable(service, version, mode, path + ["color_variable"])
                        self.constant_color = self.__class__.constant_color(service, version, mode, path + ["constant_color"])
                        self.length_to_head_ratio = self.__class__.length_to_head_ratio(service, version, mode, path + ["length_to_head_ratio"])
                        self.length_variable = self.__class__.length_variable(service, version, mode, path + ["length_variable"])
                        self.scale_factor = self.__class__.scale_factor(service, version, mode, path + ["scale_factor"])
                        self.style = self.__class__.style(service, version, mode, path + ["style"])
                        self.vector_length = self.__class__.vector_length(service, version, mode, path + ["vector_length"])
                        self.vector_length_variable = self.__class__.vector_length_variable(service, version, mode, path + ["vector_length_variable"])
                        self.vector_variable = self.__class__.vector_variable(service, version, mode, path + ["vector_variable"])
                        super().__init__(service, version, mode, path)
                    class color_variable(TUIMethod):
                        """
                        Specifies whether the vectors should be colored by variable specified in /display/particle-track/particle-track (if false use a constant color).
                        """
                    class constant_color(TUIMethod):
                        """
                        Specifies a constant color for the vectors.
                        """
                    class length_to_head_ratio(TUIMethod):
                        """
                        Specifies ratio of length to head for vectors and length to diameter for cylinders.
                        """
                    class length_variable(TUIMethod):
                        """
                        Specifies whether the displayed vectors have length varying with another variable.
                        """
                    class scale_factor(TUIMethod):
                        """
                        Specifies a scale factor to enlarge/reduce the length of vectors.
                        """
                    class style(TUIMethod):
                        """
                        Enables and sets the display style for particle vectors (none/vector/centered-vector/centered-cylinder).
                        """
                    class vector_length(TUIMethod):
                        """
                        Specifies the length of constant vectors.
                        """
                    class vector_length_variable(TUIMethod):
                        """
                        Selects a particle variable to specify the length of vectors.
                        """
                    class vector_variable(TUIMethod):
                        """
                        Selects a particle vector function to specify vector direction.
                        """

            class path_lines(TUIMenu):
                """
                Sets parameters for display of pathlines.
                """
                def __init__(self, service, version, mode, path):
                    self.arrow_scale = self.__class__.arrow_scale(service, version, mode, path + ["arrow_scale"])
                    self.arrow_space = self.__class__.arrow_space(service, version, mode, path + ["arrow_space"])
                    self.display_steps = self.__class__.display_steps(service, version, mode, path + ["display_steps"])
                    self.error_control = self.__class__.error_control(service, version, mode, path + ["error_control"])
                    self.line_width = self.__class__.line_width(service, version, mode, path + ["line_width"])
                    self.marker_size = self.__class__.marker_size(service, version, mode, path + ["marker_size"])
                    self.maximum_error = self.__class__.maximum_error(service, version, mode, path + ["maximum_error"])
                    self.maximum_steps = self.__class__.maximum_steps(service, version, mode, path + ["maximum_steps"])
                    self.radius = self.__class__.radius(service, version, mode, path + ["radius"])
                    self.relative_pathlines = self.__class__.relative_pathlines(service, version, mode, path + ["relative_pathlines"])
                    self.reverse = self.__class__.reverse(service, version, mode, path + ["reverse"])
                    self.sphere_attrib = self.__class__.sphere_attrib(service, version, mode, path + ["sphere_attrib"])
                    self.step_size = self.__class__.step_size(service, version, mode, path + ["step_size"])
                    self.style = self.__class__.style(service, version, mode, path + ["style"])
                    self.track_in_phase = self.__class__.track_in_phase(service, version, mode, path + ["track_in_phase"])
                    self.twist_factor = self.__class__.twist_factor(service, version, mode, path + ["twist_factor"])
                    super().__init__(service, version, mode, path)
                class arrow_scale(TUIMethod):
                    """
                    Sets the scale factor for arrows drawn on pathlines.
                    """
                class arrow_space(TUIMethod):
                    """
                    Sets the spacing factor for arrows drawn on pathlines.
                    """
                class display_steps(TUIMethod):
                    """
                    Sets the display stepping for pathlines.
                    """
                class error_control(TUIMethod):
                    """
                    Sets error control during pathline computation.
                    """
                class line_width(TUIMethod):
                    """
                    Sets the width for pathlines.
                    """
                class marker_size(TUIMethod):
                    """
                    Sets the marker size for particle drawing.
                    """
                class maximum_error(TUIMethod):
                    """
                    Sets the maximum error allowed while computing the pathlines.
                    """
                class maximum_steps(TUIMethod):
                    """
                    Sets the maximum number of steps to take for pathlines.
                    """
                class radius(TUIMethod):
                    """
                    Sets the radius for pathline (ribbons/cylinder only) cross-section.
                    """
                class relative_pathlines(TUIMethod):
                    """
                    Enables/disables the tracking of pathlines in a relative coordinate system.
                    """
                class reverse(TUIMethod):
                    """
                    Sets direction of path tracking.
                    """
                class sphere_attrib(TUIMethod):
                    """
                    Specifies the size and number of slices to be used in drawing spheres.
                    """
                class step_size(TUIMethod):
                    """
                    Sets the step length between particle positions for pathlines.
                    """
                class style(TUIMethod):
                    """
                    Selects the pathline style (line, point, ribbon, triangle, cylinder).
                    """
                class track_in_phase(TUIMethod):
                    """
                    Selects the phase in which particle pathlines will be computed (Multiphase Eulerian Model only).
                    """
                class twist_factor(TUIMethod):
                    """
                    Sets the scale factor for twisting (ribbons only).
                    """

            class picture(TUIMenu):
                """
                Enter the hardcopy/save-picture options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.color_mode = self.__class__.color_mode(service, version, mode, path + ["color_mode"])
                    self.driver = self.__class__.driver(service, version, mode, path + ["driver"])
                    self.dpi = self.__class__.dpi(service, version, mode, path + ["dpi"])
                    self.invert_background = self.__class__.invert_background(service, version, mode, path + ["invert_background"])
                    self.jpeg_hardcopy_quality = self.__class__.jpeg_hardcopy_quality(service, version, mode, path + ["jpeg_hardcopy_quality"])
                    self.landscape = self.__class__.landscape(service, version, mode, path + ["landscape"])
                    self.preview = self.__class__.preview(service, version, mode, path + ["preview"])
                    self.raytracer_image = self.__class__.raytracer_image(service, version, mode, path + ["raytracer_image"])
                    self.set_standard_resolution = self.__class__.set_standard_resolution(service, version, mode, path + ["set_standard_resolution"])
                    self.use_window_resolution = self.__class__.use_window_resolution(service, version, mode, path + ["use_window_resolution"])
                    self.x_resolution = self.__class__.x_resolution(service, version, mode, path + ["x_resolution"])
                    self.y_resolution = self.__class__.y_resolution(service, version, mode, path + ["y_resolution"])
                    super().__init__(service, version, mode, path)
                class dpi(TUIMethod):
                    """
                    Set the DPI for EPS and Postscript files, specifies the resolution in dots per inch (DPI) instead of setting the width and height.
                    """
                class invert_background(TUIMethod):
                    """
                    Use a white background when the picture is saved.
                    """
                class jpeg_hardcopy_quality(TUIMethod):
                    """
                    To set jpeg hardcopy quality.
                    """
                class landscape(TUIMethod):
                    """
                    Plot hardcopies in landscape or portrait orientation.
                    """
                class preview(TUIMethod):
                    """
                    Display a preview image of a hardcopy.
                    """
                class raytracer_image(TUIMethod):
                    """
                    Enable raytracering rendering.
                    """
                class set_standard_resolution(TUIMethod):
                    """
                    Select from pre-defined resolution list.
                    """
                class use_window_resolution(TUIMethod):
                    """
                    Use the currently active window's resolution for hardcopy (ignores the x-resolution and y-resolution in this case).
                    """
                class x_resolution(TUIMethod):
                    """
                    Set the width of raster-formatted images in pixels (0 implies current window size).
                    """
                class y_resolution(TUIMethod):
                    """
                    Set the height of raster-formatted images in pixels (0 implies current window size).
                    """

                class color_mode(TUIMenu):
                    """
                    Enter the hardcopy color mode menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.color = self.__class__.color(service, version, mode, path + ["color"])
                        self.gray_scale = self.__class__.gray_scale(service, version, mode, path + ["gray_scale"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.mono_chrome = self.__class__.mono_chrome(service, version, mode, path + ["mono_chrome"])
                        super().__init__(service, version, mode, path)
                    class color(TUIMethod):
                        """
                        Plot hardcopies in color.
                        """
                    class gray_scale(TUIMethod):
                        """
                        Convert color to grayscale for hardcopy.
                        """
                    class list(TUIMethod):
                        """
                        Display the current hardcopy color mode.
                        """
                    class mono_chrome(TUIMethod):
                        """
                        Convert color to monochrome (black and white) for hardcopy.
                        """

                class driver(TUIMenu):
                    """
                    Enter the set hardcopy driver menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.post_format = self.__class__.post_format(service, version, mode, path + ["post_format"])
                        self.avz = self.__class__.avz(service, version, mode, path + ["avz"])
                        self.dump_window = self.__class__.dump_window(service, version, mode, path + ["dump_window"])
                        self.eps = self.__class__.eps(service, version, mode, path + ["eps"])
                        self.glb = self.__class__.glb(service, version, mode, path + ["glb"])
                        self.hsf = self.__class__.hsf(service, version, mode, path + ["hsf"])
                        self.jpeg = self.__class__.jpeg(service, version, mode, path + ["jpeg"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.options = self.__class__.options(service, version, mode, path + ["options"])
                        self.png = self.__class__.png(service, version, mode, path + ["png"])
                        self.post_script = self.__class__.post_script(service, version, mode, path + ["post_script"])
                        self.ppm = self.__class__.ppm(service, version, mode, path + ["ppm"])
                        self.tiff = self.__class__.tiff(service, version, mode, path + ["tiff"])
                        self.vrml = self.__class__.vrml(service, version, mode, path + ["vrml"])
                        super().__init__(service, version, mode, path)
                    class avz(TUIMethod):
                        """
                        Use AVZ output for hardcopies.
                        """
                    class dump_window(TUIMethod):
                        """
                        Set the command used to dump the graphics window to a file.
                        """
                    class eps(TUIMethod):
                        """
                        Produce encapsulated PostScript (EPS) output for hardcopies.
                        """
                    class glb(TUIMethod):
                        """
                        Use GLB output for hardcopies.
                        """
                    class hsf(TUIMethod):
                        """
                        Use HSF output for hardcopies.
                        """
                    class jpeg(TUIMethod):
                        """
                        Produce JPEG output for hardcopies.
                        """
                    class list(TUIMethod):
                        """
                        List the current hardcopy driver.
                        """
                    class options(TUIMethod):
                        """
                        Set the hardcopy options. Available options are:
                        "no gamma correction", disables gamma correction of colors,
                        "physical size = (width,height)", where width and height
                        are the actual measurements of the printable area of the page
                        in centimeters.
                        "subscreen = (left,right,bottom,top)", where left,right,
                        bottom, and top are numbers in [-1,1] describing a subwindow on
                        the page in which to place the hardcopy.
                        The options may be combined by separating them with commas.
                        """
                    class png(TUIMethod):
                        """
                        Use PNG output for hardcopies.
                        """
                    class post_script(TUIMethod):
                        """
                        Produce PostScript output for hardcopies.
                        """
                    class ppm(TUIMethod):
                        """
                        Produce PPM output for hardcopies.
                        """
                    class tiff(TUIMethod):
                        """
                        Use TIFF output for hardcopies.
                        """
                    class vrml(TUIMethod):
                        """
                        Use VRML output for hardcopies.
                        """

                    class post_format(TUIMenu):
                        """
                        Enter the PostScript driver format menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.fast_raster = self.__class__.fast_raster(service, version, mode, path + ["fast_raster"])
                            self.raster = self.__class__.raster(service, version, mode, path + ["raster"])
                            self.rle_raster = self.__class__.rle_raster(service, version, mode, path + ["rle_raster"])
                            self.vector = self.__class__.vector(service, version, mode, path + ["vector"])
                            super().__init__(service, version, mode, path)
                        class fast_raster(TUIMethod):
                            """
                            Use the new raster format.
                            """
                        class raster(TUIMethod):
                            """
                            Use the original raster format.
                            """
                        class rle_raster(TUIMethod):
                            """
                            Use the run-length encoded raster format.
                            """
                        class vector(TUIMethod):
                            """
                            Use vector format.
                            """

            class rendering_options(TUIMenu):
                """
                Enter the rendering options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.animation_option = self.__class__.animation_option(service, version, mode, path + ["animation_option"])
                    self.auto_spin = self.__class__.auto_spin(service, version, mode, path + ["auto_spin"])
                    self.color_map_alignment = self.__class__.color_map_alignment(service, version, mode, path + ["color_map_alignment"])
                    self.device_info = self.__class__.device_info(service, version, mode, path + ["device_info"])
                    self.double_buffering = self.__class__.double_buffering(service, version, mode, path + ["double_buffering"])
                    self.driver = self.__class__.driver(service, version, mode, path + ["driver"])
                    self.face_displacement = self.__class__.face_displacement(service, version, mode, path + ["face_displacement"])
                    self.front_faces_transparent = self.__class__.front_faces_transparent(service, version, mode, path + ["front_faces_transparent"])
                    self.help_text_color = self.__class__.help_text_color(service, version, mode, path + ["help_text_color"])
                    self.hidden_line_method = self.__class__.hidden_line_method(service, version, mode, path + ["hidden_line_method"])
                    self.hidden_lines = self.__class__.hidden_lines(service, version, mode, path + ["hidden_lines"])
                    self.hidden_surface_method = self.__class__.hidden_surface_method(service, version, mode, path + ["hidden_surface_method"])
                    self.hidden_surfaces = self.__class__.hidden_surfaces(service, version, mode, path + ["hidden_surfaces"])
                    self.set_rendering_options = self.__class__.set_rendering_options(service, version, mode, path + ["set_rendering_options"])
                    self.show_colormap = self.__class__.show_colormap(service, version, mode, path + ["show_colormap"])
                    self.surface_edge_visibility = self.__class__.surface_edge_visibility(service, version, mode, path + ["surface_edge_visibility"])
                    super().__init__(service, version, mode, path)
                class animation_option(TUIMethod):
                    """
                    Using Wireframe / All option during animation.
                    """
                class auto_spin(TUIMethod):
                    """
                    Enable/disable mouse view rotations to continue to spin the display after the button is released.
                    """
                class color_map_alignment(TUIMethod):
                    """
                    Set the color bar alignment.
                    """
                class device_info(TUIMethod):
                    """
                    List information for the graphics device.
                    """
                class double_buffering(TUIMethod):
                    """
                    Enable/disable double-buffering.
                    """
                class driver(TUIMethod):
                    """
                    Change the current graphics driver.
                    """
                class face_displacement(TUIMethod):
                    """
                    Set face displacement value in Z-buffer units along the Camera Z-axis.
                    """
                class front_faces_transparent(TUIMethod):
                    """
                    Make the front faces transparent.
                    """
                class help_text_color(TUIMethod):
                    """
                    Set the color of screen help text.
                    """
                class hidden_line_method(TUIMethod):
                    """
                    Specify the method to perform hidden line rendering.
                    """
                class hidden_lines(TUIMethod):
                    """
                    Enable/disable hidden line removal.
                    """
                class hidden_surface_method(TUIMethod):
                    """
                    Specify the method to perform hidden line and hidden surface rendering.
                    """
                class hidden_surfaces(TUIMethod):
                    """
                    Enable/disable hidden surface removal.
                    """
                class set_rendering_options(TUIMethod):
                    """
                    Set the rendering options.
                    """
                class show_colormap(TUIMethod):
                    """
                    Enable/Disable colormap.
                    """
                class surface_edge_visibility(TUIMethod):
                    """
                    Set edge visibility flags for surfaces.
                    """

            class titles(TUIMenu):
                """
                Set problem title.
                """
                def __init__(self, service, version, mode, path):
                    self.left_bottom = self.__class__.left_bottom(service, version, mode, path + ["left_bottom"])
                    self.left_top = self.__class__.left_top(service, version, mode, path + ["left_top"])
                    self.right_bottom = self.__class__.right_bottom(service, version, mode, path + ["right_bottom"])
                    self.right_middle = self.__class__.right_middle(service, version, mode, path + ["right_middle"])
                    self.right_top = self.__class__.right_top(service, version, mode, path + ["right_top"])
                    super().__init__(service, version, mode, path)
                class left_bottom(TUIMethod):
                    """
                    Set the title text for left bottom in title segment.
                    """
                class left_top(TUIMethod):
                    """
                    Set the title text for left top in title segment.
                    """
                class right_bottom(TUIMethod):
                    """
                    Set the title text for right bottom in title segment.
                    """
                class right_middle(TUIMethod):
                    """
                    Set the title text for right middle in title segment.
                    """
                class right_top(TUIMethod):
                    """
                    Set the title text for right top in title segment.
                    """

            class velocity_vectors(TUIMenu):
                """
                Enters the menu to set parameters for display of velocity vectors.
                """
                def __init__(self, service, version, mode, path):
                    self.auto_scale = self.__class__.auto_scale(service, version, mode, path + ["auto_scale"])
                    self.color = self.__class__.color(service, version, mode, path + ["color"])
                    self.color_levels = self.__class__.color_levels(service, version, mode, path + ["color_levels"])
                    self.component_x = self.__class__.component_x(service, version, mode, path + ["component_x"])
                    self.component_y = self.__class__.component_y(service, version, mode, path + ["component_y"])
                    self.component_z = self.__class__.component_z(service, version, mode, path + ["component_z"])
                    self.constant_length = self.__class__.constant_length(service, version, mode, path + ["constant_length"])
                    self.global_range = self.__class__.global_range(service, version, mode, path + ["global_range"])
                    self.in_plane = self.__class__.in_plane(service, version, mode, path + ["in_plane"])
                    self.log_scale = self.__class__.log_scale(service, version, mode, path + ["log_scale"])
                    self.node_values = self.__class__.node_values(service, version, mode, path + ["node_values"])
                    self.relative = self.__class__.relative(service, version, mode, path + ["relative"])
                    self.render_mesh = self.__class__.render_mesh(service, version, mode, path + ["render_mesh"])
                    self.scale = self.__class__.scale(service, version, mode, path + ["scale"])
                    self.scale_head = self.__class__.scale_head(service, version, mode, path + ["scale_head"])
                    self.style = self.__class__.style(service, version, mode, path + ["style"])
                    self.surfaces = self.__class__.surfaces(service, version, mode, path + ["surfaces"])
                    super().__init__(service, version, mode, path)
                class auto_scale(TUIMethod):
                    """
                    Auto-scales all vectors so that vector overlap is minimal.
                    """
                class color(TUIMethod):
                    """
                    Sets the color of all velocity vectors to the color specified. The color scale is ignored. This is useful when overlaying a vector plot over a contour plot.
                    """
                class color_levels(TUIMethod):
                    """
                    Sets the number of colors used from the colormap.
                    """
                class component_x(TUIMethod):
                    """
                    Sets the option to use only the  component of the velocity vectors during display.
                    """
                class component_y(TUIMethod):
                    """
                    Sets the option to use only the  component of the velocity vectors during display.
                    """
                class component_z(TUIMethod):
                    """
                    Sets the option to use only the  component of the velocity vectors during display.
                    """
                class constant_length(TUIMethod):
                    """
                    Sets the option to draw velocity vectors of constant length. This shows only the direction of the velocity vectors.
                    """
                class global_range(TUIMethod):
                    """
                    Turns global range for vectors on/off.
                    """
                class in_plane(TUIMethod):
                    """
                    Toggles the display of velocity vector components in the plane of the surface selected for display.
                    """
                class log_scale(TUIMethod):
                    """
                    Toggles whether color scale is logarithmic or linear.
                    """
                class node_values(TUIMethod):
                    """
                    Enables/disables the plotting of node values. Cell values will be plotted if "no".
                    """
                class relative(TUIMethod):
                    """
                    Toggles the display of relative velocity vectors.
                    """
                class render_mesh(TUIMethod):
                    """
                    Enables/disables rendering the mesh on top of contours, vectors, and so on.
                    """
                class scale(TUIMethod):
                    """
                    Sets the value by which the vector length will be scaled.
                    """
                class scale_head(TUIMethod):
                    """
                    Sets the value by which the vector head will be scaled.
                    """
                class style(TUIMethod):
                    """
                    Specifies the vector style that will be used when the vectors are displayed. You can choose from:3d arrow,3d arrowhead, cone,filled-arrow, arrow,harpoon, or headless.
                    """
                class surfaces(TUIMethod):
                    """
                    Sets surfaces on which vectors are drawn. You can include a wildcard (\\*) within the surface names.
                    """

            class windows(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                    self.main = self.__class__.main(service, version, mode, path + ["main"])
                    self.scale = self.__class__.scale(service, version, mode, path + ["scale"])
                    self.text = self.__class__.text(service, version, mode, path + ["text"])
                    self.video = self.__class__.video(service, version, mode, path + ["video"])
                    self.xy = self.__class__.xy(service, version, mode, path + ["xy"])
                    self.aspect_ratio = self.__class__.aspect_ratio(service, version, mode, path + ["aspect_ratio"])
                    self.close_window = self.__class__.close_window(service, version, mode, path + ["close_window"])
                    self.close_window_by_name = self.__class__.close_window_by_name(service, version, mode, path + ["close_window_by_name"])
                    self.logo = self.__class__.logo(service, version, mode, path + ["logo"])
                    self.logo_color = self.__class__.logo_color(service, version, mode, path + ["logo_color"])
                    self.open_window = self.__class__.open_window(service, version, mode, path + ["open_window"])
                    self.ruler = self.__class__.ruler(service, version, mode, path + ["ruler"])
                    self.set_window = self.__class__.set_window(service, version, mode, path + ["set_window"])
                    self.set_window_by_name = self.__class__.set_window_by_name(service, version, mode, path + ["set_window_by_name"])
                    super().__init__(service, version, mode, path)
                class aspect_ratio(TUIMethod):
                    """
                    Sets the aspect ratio of the active window.
                    """
                class close_window(TUIMethod):
                    """
                    .
                    """
                class close_window_by_name(TUIMethod):
                    """
                    .
                    """
                class logo(TUIMethod):
                    """
                    .
                    """
                class logo_color(TUIMethod):
                    """
                    .
                    """
                class open_window(TUIMethod):
                    """
                    .
                    """
                class ruler(TUIMethod):
                    """
                    Turns the ruler on/off. Note that if you are running Fluent in 3D, then the view must be set toorthographic.
                    """
                class set_window(TUIMethod):
                    """
                    .
                    """
                class set_window_by_name(TUIMethod):
                    """
                    .
                    """

                class axes(TUIMenu):
                    """
                    Enters the axes window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                        self.left = self.__class__.left(service, version, mode, path + ["left"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.top = self.__class__.top(service, version, mode, path + ["top"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        super().__init__(service, version, mode, path)
                    class border(TUIMethod):
                        """
                        Sets whether or not to draw a border around the axes window.
                        """
                    class bottom(TUIMethod):
                        """
                        Sets the bottom boundary of the axes window.
                        """
                    class clear(TUIMethod):
                        """
                        Sets the transparency of the axes window.
                        """
                    class left(TUIMethod):
                        """
                        Sets the left boundary of the axes window.
                        """
                    class right(TUIMethod):
                        """
                        Sets the right boundary of the axes window.
                        """
                    class top(TUIMethod):
                        """
                        Sets the top boundary of the axes window.
                        """
                    class visible(TUIMethod):
                        """
                        Controls the visibility of the axes window.
                        """

                class main(TUIMenu):
                    """
                    Enters the main view window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.left = self.__class__.left(service, version, mode, path + ["left"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.top = self.__class__.top(service, version, mode, path + ["top"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        super().__init__(service, version, mode, path)
                    class border(TUIMethod):
                        """
                        Sets whether or not to draw a border around the main viewing window.
                        """
                    class bottom(TUIMethod):
                        """
                        Sets the bottom boundary of the main viewing window.
                        """
                    class left(TUIMethod):
                        """
                        Sets the left boundary of the main viewing window.
                        """
                    class right(TUIMethod):
                        """
                        Sets the right boundary of the main viewing window.
                        """
                    class top(TUIMethod):
                        """
                        Sets the top boundary of the main viewing window.
                        """
                    class visible(TUIMethod):
                        """
                        Controls the visibility of the main viewing window.
                        """

                class scale(TUIMenu):
                    """
                    Enters the color scale window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                        self.font_size = self.__class__.font_size(service, version, mode, path + ["font_size"])
                        self.format = self.__class__.format(service, version, mode, path + ["format"])
                        self.left = self.__class__.left(service, version, mode, path + ["left"])
                        self.margin = self.__class__.margin(service, version, mode, path + ["margin"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.top = self.__class__.top(service, version, mode, path + ["top"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        super().__init__(service, version, mode, path)
                    class border(TUIMethod):
                        """
                        Sets whether or not to draw a border around the color scale window.
                        """
                    class bottom(TUIMethod):
                        """
                        Sets the bottom boundary of the color scale window.
                        """
                    class clear(TUIMethod):
                        """
                        Sets the transparency of the color scale window.
                        """
                    class font_size(TUIMethod):
                        """
                        Sets the font size of the color scale window.
                        """
                    class format(TUIMethod):
                        """
                        Sets the number format of the color scale window (for example, percentage0.2e).
                        """
                    class left(TUIMethod):
                        """
                        Sets the left boundary of the color scale window.
                        """
                    class margin(TUIMethod):
                        """
                        Sets the margin of the color scale window.
                        """
                    class right(TUIMethod):
                        """
                        Sets the right boundary of the color scale window.
                        """
                    class top(TUIMethod):
                        """
                        Sets the top boundary of the color scale window.
                        """
                    class visible(TUIMethod):
                        """
                        Controls the visibility of the color scale window.
                        """

                class text(TUIMenu):
                    """
                    Enters the text window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.alignment = self.__class__.alignment(service, version, mode, path + ["alignment"])
                        self.application = self.__class__.application(service, version, mode, path + ["application"])
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                        self.company = self.__class__.company(service, version, mode, path + ["company"])
                        self.date = self.__class__.date(service, version, mode, path + ["date"])
                        self.left = self.__class__.left(service, version, mode, path + ["left"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.top = self.__class__.top(service, version, mode, path + ["top"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        super().__init__(service, version, mode, path)
                    class alignment(TUIMethod):
                        """
                        .
                        """
                    class application(TUIMethod):
                        """
                        Shows or hides the application name in the picture.
                        """
                    class border(TUIMethod):
                        """
                        Sets whether or not to draw a border around the text window.
                        """
                    class bottom(TUIMethod):
                        """
                        Sets the bottom boundary of the text window.
                        """
                    class clear(TUIMethod):
                        """
                        Enables/disables the transparency of the text window.
                        """
                    class company(TUIMethod):
                        """
                        Shows or hides the company name in the picture.
                        """
                    class date(TUIMethod):
                        """
                        Shows or hides the date in the picture.
                        """
                    class left(TUIMethod):
                        """
                        Sets the left boundary of the text window.
                        """
                    class right(TUIMethod):
                        """
                        Sets the right boundary of the text window.
                        """
                    class top(TUIMethod):
                        """
                        Sets the top boundary of the text window.
                        """
                    class visible(TUIMethod):
                        """
                        Controls the visibility of the text window.
                        """

                class video(TUIMenu):
                    """
                    Contains options for modifying a video. This menu is not relevant for the meshing mode.
                    """
                    def __init__(self, service, version, mode, path):
                        self.background = self.__class__.background(service, version, mode, path + ["background"])
                        self.color_filter = self.__class__.color_filter(service, version, mode, path + ["color_filter"])
                        self.foreground = self.__class__.foreground(service, version, mode, path + ["foreground"])
                        self.on = self.__class__.on(service, version, mode, path + ["on"])
                        self.pixel_size = self.__class__.pixel_size(service, version, mode, path + ["pixel_size"])
                        super().__init__(service, version, mode, path)
                    class background(TUIMethod):
                        """
                        Sets the background color of the graphics window. The color is specified as a string of three comma-separated numbers between 0 and 1, representing red, green, and blue. For example, to change the background from black (default) to gray, you would enter ".5,.5,.5" after selecting the background command.
                        """
                    class color_filter(TUIMethod):
                        """
                        Sets the video color filter. For example, to change the color filter from its default setting  to PAL video with a saturation of 80percentage and a brightness of 90percentage, you would  enter "video=pal,sat=.8,gain=.9" after selecting the color-filter command.
                        """
                    class foreground(TUIMethod):
                        """
                        Sets the foreground (text) color of the graphics window. The color is specified as a string of three comma-separated numbers between 0 and 1, representing red, green, and blue. For example, to change the foreground from white (default) to gray, you would enter ".5,.5,.5" after selecting the foreground command.
                        """
                    class on(TUIMethod):
                        """
                        Enables or disables the video picture settings.
                        """
                    class pixel_size(TUIMethod):
                        """
                        Sets the window size in pixels.
                        """

                class xy(TUIMenu):
                    """
                    Enters the XY plot window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.left = self.__class__.left(service, version, mode, path + ["left"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.top = self.__class__.top(service, version, mode, path + ["top"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        super().__init__(service, version, mode, path)
                    class border(TUIMethod):
                        """
                        Sets whether or not to draw a border around the XY plot window.
                        """
                    class bottom(TUIMethod):
                        """
                        Sets the bottom boundary of the XY plot window.
                        """
                    class left(TUIMethod):
                        """
                        Sets the left boundary of the XY plot window.
                        """
                    class right(TUIMethod):
                        """
                        Sets the right boundary of the XY plot window.
                        """
                    class top(TUIMethod):
                        """
                        Sets the top boundary of the XY plot window.
                        """
                    class visible(TUIMethod):
                        """
                        Controls the visibility of the XY plot window.
                        """

        class surface(TUIMenu):
            """
            Enters the data surface-manipulation menu. For a description of the items in this menu, see surface/.
            """
            def __init__(self, service, version, mode, path):
                self.post_processing_volume = self.__class__.post_processing_volume(service, version, mode, path + ["post_processing_volume"])
                self.query = self.__class__.query(service, version, mode, path + ["query"])
                self.circle_slice = self.__class__.circle_slice(service, version, mode, path + ["circle_slice"])
                self.closest_point_search = self.__class__.closest_point_search(service, version, mode, path + ["closest_point_search"])
                self.cone_slice = self.__class__.cone_slice(service, version, mode, path + ["cone_slice"])
                self.create_imprint_surface = self.__class__.create_imprint_surface(service, version, mode, path + ["create_imprint_surface"])
                self.delete_surface = self.__class__.delete_surface(service, version, mode, path + ["delete_surface"])
                self.edit_surface = self.__class__.edit_surface(service, version, mode, path + ["edit_surface"])
                self.ellipsoid_slice = self.__class__.ellipsoid_slice(service, version, mode, path + ["ellipsoid_slice"])
                self.expression_volume = self.__class__.expression_volume(service, version, mode, path + ["expression_volume"])
                self.group_surfaces = self.__class__.group_surfaces(service, version, mode, path + ["group_surfaces"])
                self.imprint_surface = self.__class__.imprint_surface(service, version, mode, path + ["imprint_surface"])
                self.iso_clip = self.__class__.iso_clip(service, version, mode, path + ["iso_clip"])
                self.iso_clip_multiple = self.__class__.iso_clip_multiple(service, version, mode, path + ["iso_clip_multiple"])
                self.iso_surface = self.__class__.iso_surface(service, version, mode, path + ["iso_surface"])
                self.line_slice = self.__class__.line_slice(service, version, mode, path + ["line_slice"])
                self.line_surface = self.__class__.line_surface(service, version, mode, path + ["line_surface"])
                self.list_surfaces = self.__class__.list_surfaces(service, version, mode, path + ["list_surfaces"])
                self.mouse_line = self.__class__.mouse_line(service, version, mode, path + ["mouse_line"])
                self.mouse_plane = self.__class__.mouse_plane(service, version, mode, path + ["mouse_plane"])
                self.mouse_rake = self.__class__.mouse_rake(service, version, mode, path + ["mouse_rake"])
                self.multiple_iso_surfaces = self.__class__.multiple_iso_surfaces(service, version, mode, path + ["multiple_iso_surfaces"])
                self.multiple_plane_surfaces = self.__class__.multiple_plane_surfaces(service, version, mode, path + ["multiple_plane_surfaces"])
                self.multiple_zone_surfaces = self.__class__.multiple_zone_surfaces(service, version, mode, path + ["multiple_zone_surfaces"])
                self.partition_surface = self.__class__.partition_surface(service, version, mode, path + ["partition_surface"])
                self.plane = self.__class__.plane(service, version, mode, path + ["plane"])
                self.plane_bounded = self.__class__.plane_bounded(service, version, mode, path + ["plane_bounded"])
                self.plane_point_n_normal = self.__class__.plane_point_n_normal(service, version, mode, path + ["plane_point_n_normal"])
                self.plane_slice = self.__class__.plane_slice(service, version, mode, path + ["plane_slice"])
                self.plane_surf_aligned = self.__class__.plane_surf_aligned(service, version, mode, path + ["plane_surf_aligned"])
                self.plane_surface = self.__class__.plane_surface(service, version, mode, path + ["plane_surface"])
                self.plane_view_plane_align = self.__class__.plane_view_plane_align(service, version, mode, path + ["plane_view_plane_align"])
                self.point_array = self.__class__.point_array(service, version, mode, path + ["point_array"])
                self.point_surface = self.__class__.point_surface(service, version, mode, path + ["point_surface"])
                self.quadric_slice = self.__class__.quadric_slice(service, version, mode, path + ["quadric_slice"])
                self.rake_surface = self.__class__.rake_surface(service, version, mode, path + ["rake_surface"])
                self.rename_surface = self.__class__.rename_surface(service, version, mode, path + ["rename_surface"])
                self.rendering_priority = self.__class__.rendering_priority(service, version, mode, path + ["rendering_priority"])
                self.reset_zone_surfaces = self.__class__.reset_zone_surfaces(service, version, mode, path + ["reset_zone_surfaces"])
                self.sphere_slice = self.__class__.sphere_slice(service, version, mode, path + ["sphere_slice"])
                self.structural_point_surface = self.__class__.structural_point_surface(service, version, mode, path + ["structural_point_surface"])
                self.surface_cells = self.__class__.surface_cells(service, version, mode, path + ["surface_cells"])
                self.transform_surface = self.__class__.transform_surface(service, version, mode, path + ["transform_surface"])
                self.ungroup_surface = self.__class__.ungroup_surface(service, version, mode, path + ["ungroup_surface"])
                self.zone_surface = self.__class__.zone_surface(service, version, mode, path + ["zone_surface"])
                super().__init__(service, version, mode, path)
            class circle_slice(TUIMethod):
                """
                Extract a circular slice.
                """
            class closest_point_search(TUIMethod):
                """
                Enable the point surface algorithm to look for the nearest point instead of reporting a creation failure.
                """
            class cone_slice(TUIMethod):
                """
                Extract a cone slice.
                """
            class create_imprint_surface(TUIMethod):
                """
                Imprint surface.
                """
            class delete_surface(TUIMethod):
                """
                Remove a defined data surface.
                """
            class edit_surface(TUIMethod):
                """
                Edit a defined data surface.
                """
            class ellipsoid_slice(TUIMethod):
                """
                Extract a ellipsoid slice.
                """
            class expression_volume(TUIMethod):
                """
                Create volume with boolean expression.
                """
            class group_surfaces(TUIMethod):
                """
                Group a set of surfaces.
                """
            class imprint_surface(TUIMethod):
                """
                Imprint surface.
                """
            class iso_clip(TUIMethod):
                """
                Clip a data surface (surface, curve, or point) between two iso-values.
                """
            class iso_clip_multiple(TUIMethod):
                """
                Clip a data surface (surface, curve, or point) between two iso-values.
                """
            class iso_surface(TUIMethod):
                """
                Extract an iso-surface (surface, curve, or point) from the curent data field.
                """
            class line_slice(TUIMethod):
                """
                Extract a linear slice.
                """
            class line_surface(TUIMethod):
                """
                Define a "line" surface by specifying the two endpoint coordinates.
                """
            class list_surfaces(TUIMethod):
                """
                List the number of facets in the defined surfaces.
                """
            class mouse_line(TUIMethod):
                """
                Define a line surface using the mouse to select two points.
                """
            class mouse_plane(TUIMethod):
                """
                Define a plane surface using the mouse to select three points.
                """
            class mouse_rake(TUIMethod):
                """
                Define a "rake" surface using the mouse to select the end points.
                """
            class multiple_iso_surfaces(TUIMethod):
                """
                Create multiple iso-surfaces from the data field at specified spacing.
                """
            class multiple_plane_surfaces(TUIMethod):
                """
                Create multiple plane surfaces at specified spacing.
                """
            class multiple_zone_surfaces(TUIMethod):
                """
                Create multiple data surfaces at a time.
                """
            class partition_surface(TUIMethod):
                """
                Define a data surface on mesh faces on the partition boundary.
                """
            class plane(TUIMethod):
                """
                Create a plane given 3 points bounded by the domain.
                """
            class plane_bounded(TUIMethod):
                """
                Create a bounded surface.
                """
            class plane_point_n_normal(TUIMethod):
                """
                Create a plane from a point and normal.
                """
            class plane_slice(TUIMethod):
                """
                Extract a planar slice.
                """
            class plane_surf_aligned(TUIMethod):
                """
                Create a plane aligned to a surface.
                """
            class plane_surface(TUIMethod):
                """
                Create a plane from a coordinate plane, point and normal, or three points.
                """
            class plane_view_plane_align(TUIMethod):
                """
                Create a plane aligned to a view-plane.
                """
            class point_array(TUIMethod):
                """
                Extract a rectangular array of data points.
                """
            class point_surface(TUIMethod):
                """
                Define a "point" surface by specifying the coordinates.
                """
            class quadric_slice(TUIMethod):
                """
                Extract a quadric slice.
                """
            class rake_surface(TUIMethod):
                """
                Define a "rake" surface by specifying the end points.
                """
            class rename_surface(TUIMethod):
                """
                Rename a defined data surface.
                """
            class rendering_priority(TUIMethod):
                """
                Define Priority for given surface id.
                """
            class reset_zone_surfaces(TUIMethod):
                """
                .
                """
            class sphere_slice(TUIMethod):
                """
                Extract a spherical slice.
                """
            class structural_point_surface(TUIMethod):
                """
                Define a "structural point" surface by specifying the coordinates.
                """
            class surface_cells(TUIMethod):
                """
                Extract all cells intersected by a data surface.
                """
            class transform_surface(TUIMethod):
                """
                Transform surface.
                """
            class ungroup_surface(TUIMethod):
                """
                Ungroup the surface(if grouped).
                """
            class zone_surface(TUIMethod):
                """
                Define a data surface on a mesh zone.
                """

            class post_processing_volume(TUIMenu):
                """
                Enter post-processing volume menu.
                """
                def __init__(self, service, version, mode, path):
                    self.create_from_file = self.__class__.create_from_file(service, version, mode, path + ["create_from_file"])
                    self.create_octree = self.__class__.create_octree(service, version, mode, path + ["create_octree"])
                    super().__init__(service, version, mode, path)
                class create_from_file(TUIMethod):
                    """
                    Read post-processing mesh from file.
                    """
                class create_octree(TUIMethod):
                    """
                    Create post-processing octree mesh based on current case.
                    """

            class query(TUIMenu):
                """
                Enter surface query menu.
                """
                def __init__(self, service, version, mode, path):
                    self.delete_query = self.__class__.delete_query(service, version, mode, path + ["delete_query"])
                    self.list_named_selection = self.__class__.list_named_selection(service, version, mode, path + ["list_named_selection"])
                    self.list_queries = self.__class__.list_queries(service, version, mode, path + ["list_queries"])
                    self.list_surfaces = self.__class__.list_surfaces(service, version, mode, path + ["list_surfaces"])
                    self.named_surface_list = self.__class__.named_surface_list(service, version, mode, path + ["named_surface_list"])
                    super().__init__(service, version, mode, path)
                class delete_query(TUIMethod):
                    """
                    Delete saved query.
                    """
                class list_named_selection(TUIMethod):
                    """
                    List named selection of surface type.
                    """
                class list_queries(TUIMethod):
                    """
                    List all saved queries.
                    """
                class list_surfaces(TUIMethod):
                    """
                    List surfaces.
                    """
                class named_surface_list(TUIMethod):
                    """
                    Create named list of surfaces.
                    """

        class update_scene(TUIMenu):
            """
            Enter the scene options menu.
            """
            def __init__(self, service, version, mode, path):
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                self.draw_frame = self.__class__.draw_frame(service, version, mode, path + ["draw_frame"])
                self.iso_sweep = self.__class__.iso_sweep(service, version, mode, path + ["iso_sweep"])
                self.overlays = self.__class__.overlays(service, version, mode, path + ["overlays"])
                self.pathline = self.__class__.pathline(service, version, mode, path + ["pathline"])
                self.select_geometry = self.__class__.select_geometry(service, version, mode, path + ["select_geometry"])
                self.set_frame = self.__class__.set_frame(service, version, mode, path + ["set_frame"])
                self.time = self.__class__.time(service, version, mode, path + ["time"])
                self.transform = self.__class__.transform(service, version, mode, path + ["transform"])
                super().__init__(service, version, mode, path)
            class delete(TUIMethod):
                """
                Delete selected geometries.
                """
            class display(TUIMethod):
                """
                Display selected geometries.
                """
            class draw_frame(TUIMethod):
                """
                Enable/disable drawing of the bounding frame.
                """
            class iso_sweep(TUIMethod):
                """
                Change iso-sweep values.
                """
            class overlays(TUIMethod):
                """
                Enable/disable the overlays option.
                """
            class pathline(TUIMethod):
                """
                Change pathline attributes.
                """
            class select_geometry(TUIMethod):
                """
                Select geometry to be updated.
                """
            class set_frame(TUIMethod):
                """
                Change frame options.
                """
            class time(TUIMethod):
                """
                Change time-step value.
                """
            class transform(TUIMethod):
                """
                Apply transformation matrix on selected geometries.
                """

        class view_sync(TUIMenu):
            """
            Synchronize window views.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.add_all = self.__class__.add_all(service, version, mode, path + ["add_all"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.remove = self.__class__.remove(service, version, mode, path + ["remove"])
                self.remove_all = self.__class__.remove_all(service, version, mode, path + ["remove_all"])
                self.start = self.__class__.start(service, version, mode, path + ["start"])
                self.stop = self.__class__.stop(service, version, mode, path + ["stop"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Add list of window ids for synchronization.
                """
            class add_all(TUIMethod):
                """
                Synchronize all windows.
                """
            class list(TUIMethod):
                """
                Print window ids of open windows.
                """
            class remove(TUIMethod):
                """
                Remove list of window ids from synchronization.
                """
            class remove_all(TUIMethod):
                """
                Unsynchronize all windows.
                """
            class start(TUIMethod):
                """
                Start view synchronization.
                """
            class stop(TUIMethod):
                """
                Stop view synchronization.
                """

        class views(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.camera = self.__class__.camera(service, version, mode, path + ["camera"])
                self.display_states = self.__class__.display_states(service, version, mode, path + ["display_states"])
                self.rendering_options = self.__class__.rendering_options(service, version, mode, path + ["rendering_options"])
                self.auto_scale = self.__class__.auto_scale(service, version, mode, path + ["auto_scale"])
                self.default_view = self.__class__.default_view(service, version, mode, path + ["default_view"])
                self.delete_view = self.__class__.delete_view(service, version, mode, path + ["delete_view"])
                self.last_view = self.__class__.last_view(service, version, mode, path + ["last_view"])
                self.list_views = self.__class__.list_views(service, version, mode, path + ["list_views"])
                self.next_view = self.__class__.next_view(service, version, mode, path + ["next_view"])
                self.read_views = self.__class__.read_views(service, version, mode, path + ["read_views"])
                self.restore_view = self.__class__.restore_view(service, version, mode, path + ["restore_view"])
                self.save_view = self.__class__.save_view(service, version, mode, path + ["save_view"])
                self.write_views = self.__class__.write_views(service, version, mode, path + ["write_views"])
                super().__init__(service, version, mode, path)
            class auto_scale(TUIMethod):
                """
                Scales and centers the current scene without changing its orientation.
                """
            class default_view(TUIMethod):
                """
                Resets the view to front and center.
                """
            class delete_view(TUIMethod):
                """
                Deletes a particular view from the list of stored views.
                """
            class last_view(TUIMethod):
                """
                Returns to the camera position before the last manipulation.
                """
            class list_views(TUIMethod):
                """
                Lists all predefined and saved views.
                """
            class next_view(TUIMethod):
                """
                .
                """
            class read_views(TUIMethod):
                """
                Reads views from an external view file.
                """
            class restore_view(TUIMethod):
                """
                Sets the current view to one of the stored views.
                """
            class save_view(TUIMethod):
                """
                Saves the currently displayed view into the list of stored views.
                """
            class write_views(TUIMethod):
                """
                Writes views to an external view file.
                """

            class camera(TUIMenu):
                """
                Contains commands to set the camera options.
                """
                def __init__(self, service, version, mode, path):
                    self.dolly_camera = self.__class__.dolly_camera(service, version, mode, path + ["dolly_camera"])
                    self.field = self.__class__.field(service, version, mode, path + ["field"])
                    self.orbit_camera = self.__class__.orbit_camera(service, version, mode, path + ["orbit_camera"])
                    self.pan_camera = self.__class__.pan_camera(service, version, mode, path + ["pan_camera"])
                    self.position = self.__class__.position(service, version, mode, path + ["position"])
                    self.projection = self.__class__.projection(service, version, mode, path + ["projection"])
                    self.roll_camera = self.__class__.roll_camera(service, version, mode, path + ["roll_camera"])
                    self.target = self.__class__.target(service, version, mode, path + ["target"])
                    self.up_vector = self.__class__.up_vector(service, version, mode, path + ["up_vector"])
                    self.zoom_camera = self.__class__.zoom_camera(service, version, mode, path + ["zoom_camera"])
                    super().__init__(service, version, mode, path)
                class dolly_camera(TUIMethod):
                    """
                    Enables you to move the camera left, right, up, down, in, and out.
                    """
                class field(TUIMethod):
                    """
                    Enables you to set the field of view (width and height) of the scene.
                    """
                class orbit_camera(TUIMethod):
                    """
                    Enables you to move the camera around the target. Gives the effect of circling around the target.
                    """
                class pan_camera(TUIMethod):
                    """
                    Gives you the effect of sweeping the camera across the scene. The camera remains at its position but its target changes.
                    """
                class position(TUIMethod):
                    """
                    Sets the camera position.
                    """
                class projection(TUIMethod):
                    """
                    Lets you switch between perspective and orthographic views.
                    """
                class roll_camera(TUIMethod):
                    """
                    Lets you adjust the camera up-vector.
                    """
                class target(TUIMethod):
                    """
                    Sets the point the camera will look at.
                    """
                class up_vector(TUIMethod):
                    """
                    Sets the camera up-vector.
                    """
                class zoom_camera(TUIMethod):
                    """
                    Adjusts the cameras field of view. This operation is similar to dollying the camera in or out of the scene. Dollying causes objects in front to move past you. Zooming changes the perspective effect in the scene (and can be disconcerting).
                    """

            class display_states(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.new = self.__class__.new(service, version, mode, path + ["new"])
                    self.read = self.__class__.read(service, version, mode, path + ["read"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    self.restore_state = self.__class__.restore_state(service, version, mode, path + ["restore_state"])
                    self.use_active = self.__class__.use_active(service, version, mode, path + ["use_active"])
                    self.write = self.__class__.write(service, version, mode, path + ["write"])
                    super().__init__(service, version, mode, path)
                class copy(TUIMethod):
                    """
                    .
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit display-states object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class new(TUIMethod):
                    """
                    Create a new display-states object.
                    """
                class read(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename display-states object.
                    """
                class restore_state(TUIMethod):
                    """
                    .
                    """
                class use_active(TUIMethod):
                    """
                    .
                    """
                class write(TUIMethod):
                    """
                    .
                    """

            class rendering_options(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.animation_option = self.__class__.animation_option(service, version, mode, path + ["animation_option"])
                    self.auto_spin = self.__class__.auto_spin(service, version, mode, path + ["auto_spin"])
                    self.color_map_alignment = self.__class__.color_map_alignment(service, version, mode, path + ["color_map_alignment"])
                    self.device_info = self.__class__.device_info(service, version, mode, path + ["device_info"])
                    self.double_buffering = self.__class__.double_buffering(service, version, mode, path + ["double_buffering"])
                    self.driver = self.__class__.driver(service, version, mode, path + ["driver"])
                    self.face_displacement = self.__class__.face_displacement(service, version, mode, path + ["face_displacement"])
                    self.front_faces_transparent = self.__class__.front_faces_transparent(service, version, mode, path + ["front_faces_transparent"])
                    self.hidden_surface_method = self.__class__.hidden_surface_method(service, version, mode, path + ["hidden_surface_method"])
                    self.hidden_surfaces = self.__class__.hidden_surfaces(service, version, mode, path + ["hidden_surfaces"])
                    self.set_rendering_options = self.__class__.set_rendering_options(service, version, mode, path + ["set_rendering_options"])
                    self.show_colormap = self.__class__.show_colormap(service, version, mode, path + ["show_colormap"])
                    super().__init__(service, version, mode, path)
                class animation_option(TUIMethod):
                    """
                    .
                    """
                class auto_spin(TUIMethod):
                    """
                    .
                    """
                class color_map_alignment(TUIMethod):
                    """
                    .
                    """
                class device_info(TUIMethod):
                    """
                    .
                    """
                class double_buffering(TUIMethod):
                    """
                    .
                    """
                class driver(TUIMethod):
                    """
                    .
                    """
                class face_displacement(TUIMethod):
                    """
                    .
                    """
                class front_faces_transparent(TUIMethod):
                    """
                    .
                    """
                class hidden_surface_method(TUIMethod):
                    """
                    .
                    """
                class hidden_surfaces(TUIMethod):
                    """
                    .
                    """
                class set_rendering_options(TUIMethod):
                    """
                    .
                    """
                class show_colormap(TUIMethod):
                    """
                    .
                    """

    class file(TUIMenu):
        """
        Enter the file menu.
        """
        def __init__(self, service, version, mode, path):
            self.auto_save = self.__class__.auto_save(service, version, mode, path + ["auto_save"])
            self.cffio_options = self.__class__.cffio_options(service, version, mode, path + ["cffio_options"])
            self.em_mapping = self.__class__.em_mapping(service, version, mode, path + ["em_mapping"])
            self.export = self.__class__.export(service, version, mode, path + ["export"])
            self.fsi = self.__class__.fsi(service, version, mode, path + ["fsi"])
            self.import_ = self.__class__.import_(service, version, mode, path + ["import_"])
            self.interpolate = self.__class__.interpolate(service, version, mode, path + ["interpolate"])
            self.parametric_project = self.__class__.parametric_project(service, version, mode, path + ["parametric_project"])
            self.project_beta = self.__class__.project_beta(service, version, mode, path + ["project_beta"])
            self.solution_files = self.__class__.solution_files(service, version, mode, path + ["solution_files"])
            self.table_manager = self.__class__.table_manager(service, version, mode, path + ["table_manager"])
            self.transient_export = self.__class__.transient_export(service, version, mode, path + ["transient_export"])
            self.async_optimize = self.__class__.async_optimize(service, version, mode, path + ["async_optimize"])
            self.binary_legacy_files = self.__class__.binary_legacy_files(service, version, mode, path + ["binary_legacy_files"])
            self.cff_files = self.__class__.cff_files(service, version, mode, path + ["cff_files"])
            self.close_without_save = self.__class__.close_without_save(service, version, mode, path + ["close_without_save"])
            self.confirm_overwrite = self.__class__.confirm_overwrite(service, version, mode, path + ["confirm_overwrite"])
            self.convert_hanging_nodes_during_read = self.__class__.convert_hanging_nodes_during_read(service, version, mode, path + ["convert_hanging_nodes_during_read"])
            self.data_file_options = self.__class__.data_file_options(service, version, mode, path + ["data_file_options"])
            self.define_macro = self.__class__.define_macro(service, version, mode, path + ["define_macro"])
            self.execute_macro = self.__class__.execute_macro(service, version, mode, path + ["execute_macro"])
            self.export_to_cfd_post = self.__class__.export_to_cfd_post(service, version, mode, path + ["export_to_cfd_post"])
            self.load_act_tool = self.__class__.load_act_tool(service, version, mode, path + ["load_act_tool"])
            self.read_case = self.__class__.read_case(service, version, mode, path + ["read_case"])
            self.read_case_data = self.__class__.read_case_data(service, version, mode, path + ["read_case_data"])
            self.read_case_info = self.__class__.read_case_info(service, version, mode, path + ["read_case_info"])
            self.read_case_settings = self.__class__.read_case_settings(service, version, mode, path + ["read_case_settings"])
            self.read_data = self.__class__.read_data(service, version, mode, path + ["read_data"])
            self.read_field_functions = self.__class__.read_field_functions(service, version, mode, path + ["read_field_functions"])
            self.read_gpu_restart = self.__class__.read_gpu_restart(service, version, mode, path + ["read_gpu_restart"])
            self.read_injections = self.__class__.read_injections(service, version, mode, path + ["read_injections"])
            self.read_isat_table = self.__class__.read_isat_table(service, version, mode, path + ["read_isat_table"])
            self.read_journal = self.__class__.read_journal(service, version, mode, path + ["read_journal"])
            self.read_macros = self.__class__.read_macros(service, version, mode, path + ["read_macros"])
            self.read_pdf = self.__class__.read_pdf(service, version, mode, path + ["read_pdf"])
            self.read_profile = self.__class__.read_profile(service, version, mode, path + ["read_profile"])
            self.read_rays = self.__class__.read_rays(service, version, mode, path + ["read_rays"])
            self.read_settings = self.__class__.read_settings(service, version, mode, path + ["read_settings"])
            self.read_surface_clusters = self.__class__.read_surface_clusters(service, version, mode, path + ["read_surface_clusters"])
            self.read_transient_table = self.__class__.read_transient_table(service, version, mode, path + ["read_transient_table"])
            self.read_viewfactors = self.__class__.read_viewfactors(service, version, mode, path + ["read_viewfactors"])
            self.reload_setup = self.__class__.reload_setup(service, version, mode, path + ["reload_setup"])
            self.replace_mesh = self.__class__.replace_mesh(service, version, mode, path + ["replace_mesh"])
            self.set_batch_options = self.__class__.set_batch_options(service, version, mode, path + ["set_batch_options"])
            self.set_error_on_invalid_command = self.__class__.set_error_on_invalid_command(service, version, mode, path + ["set_error_on_invalid_command"])
            self.set_idle_timeout = self.__class__.set_idle_timeout(service, version, mode, path + ["set_idle_timeout"])
            self.set_maximum_simultaneous_files = self.__class__.set_maximum_simultaneous_files(service, version, mode, path + ["set_maximum_simultaneous_files"])
            self.set_target_reference_frame_for_write_profiles = self.__class__.set_target_reference_frame_for_write_profiles(service, version, mode, path + ["set_target_reference_frame_for_write_profiles"])
            self.set_tui_version = self.__class__.set_tui_version(service, version, mode, path + ["set_tui_version"])
            self.show_configuration = self.__class__.show_configuration(service, version, mode, path + ["show_configuration"])
            self.single_precision_coordinates = self.__class__.single_precision_coordinates(service, version, mode, path + ["single_precision_coordinates"])
            self.start_journal = self.__class__.start_journal(service, version, mode, path + ["start_journal"])
            self.start_transcript = self.__class__.start_transcript(service, version, mode, path + ["start_transcript"])
            self.stop_journal = self.__class__.stop_journal(service, version, mode, path + ["stop_journal"])
            self.stop_macro = self.__class__.stop_macro(service, version, mode, path + ["stop_macro"])
            self.stop_transcript = self.__class__.stop_transcript(service, version, mode, path + ["stop_transcript"])
            self.sync_workbench = self.__class__.sync_workbench(service, version, mode, path + ["sync_workbench"])
            self.write_boundary_mesh = self.__class__.write_boundary_mesh(service, version, mode, path + ["write_boundary_mesh"])
            self.write_case = self.__class__.write_case(service, version, mode, path + ["write_case"])
            self.write_case_data = self.__class__.write_case_data(service, version, mode, path + ["write_case_data"])
            self.write_circumferential_averaged_profile = self.__class__.write_circumferential_averaged_profile(service, version, mode, path + ["write_circumferential_averaged_profile"])
            self.write_cleanup_script = self.__class__.write_cleanup_script(service, version, mode, path + ["write_cleanup_script"])
            self.write_currently_defined_profiles = self.__class__.write_currently_defined_profiles(service, version, mode, path + ["write_currently_defined_profiles"])
            self.write_data = self.__class__.write_data(service, version, mode, path + ["write_data"])
            self.write_fan_profile = self.__class__.write_fan_profile(service, version, mode, path + ["write_fan_profile"])
            self.write_field_functions = self.__class__.write_field_functions(service, version, mode, path + ["write_field_functions"])
            self.write_flamelet = self.__class__.write_flamelet(service, version, mode, path + ["write_flamelet"])
            self.write_gpu_restart = self.__class__.write_gpu_restart(service, version, mode, path + ["write_gpu_restart"])
            self.write_injections = self.__class__.write_injections(service, version, mode, path + ["write_injections"])
            self.write_isat_table = self.__class__.write_isat_table(service, version, mode, path + ["write_isat_table"])
            self.write_macros = self.__class__.write_macros(service, version, mode, path + ["write_macros"])
            self.write_merge_profiles = self.__class__.write_merge_profiles(service, version, mode, path + ["write_merge_profiles"])
            self.write_pdat = self.__class__.write_pdat(service, version, mode, path + ["write_pdat"])
            self.write_pdf = self.__class__.write_pdf(service, version, mode, path + ["write_pdf"])
            self.write_profile = self.__class__.write_profile(service, version, mode, path + ["write_profile"])
            self.write_selected_defined_profiles = self.__class__.write_selected_defined_profiles(service, version, mode, path + ["write_selected_defined_profiles"])
            self.write_settings = self.__class__.write_settings(service, version, mode, path + ["write_settings"])
            super().__init__(service, version, mode, path)
        class async_optimize(TUIMethod):
            """
            Chooses whether to optimize file I/O using scratch disks and asynchronous operations.
            """
        class binary_legacy_files(TUIMethod):
            """
            .
            """
        class cff_files(TUIMethod):
            """
            .
            """
        class close_without_save(TUIMethod):
            """
            Exits ANSYS Fluent without saving data in Workbench. This command is only available when running ANSYS Fluent in Workbench.
            """
        class confirm_overwrite(TUIMethod):
            """
            .
            """
        class convert_hanging_nodes_during_read(TUIMethod):
            """
            .
            """
        class data_file_options(TUIMethod):
            """
            Sets derived quantities to be written in data file.
            """
        class define_macro(TUIMethod):
            """
            Saves input to a named macro.
            """
        class execute_macro(TUIMethod):
            """
            Runs a previously defined macro.
            """
        class export_to_cfd_post(TUIMethod):
            """
            Exports data files that are compatible with CFD-Post and EnSight (that is, .cdat and .cst files) and opens CFD-Post, if desired.
            """
        class load_act_tool(TUIMethod):
            """
            Load ACT Start Page.
            """
        class read_case(TUIMethod):
            """
            Read a case file.
            """
        class read_case_data(TUIMethod):
            """
            Reads a case and a data file.
            """
        class read_case_info(TUIMethod):
            """
            Read basic case info.
            """
        class read_case_settings(TUIMethod):
            """
            Read a case file while skipping mesh elements.
            """
        class read_data(TUIMethod):
            """
            Reads a data file.
            """
        class read_field_functions(TUIMethod):
            """
            Reads custom field function definitions from a file.
            """
        class read_gpu_restart(TUIMethod):
            """
            Read gpuapp restart case and data files.
            """
        class read_injections(TUIMethod):
            """
            Reads all DPM injections from a file.
            """
        class read_isat_table(TUIMethod):
            """
            Reads ISAT Table.
            """
        class read_journal(TUIMethod):
            """
            Read a journal file.
            """
        class read_macros(TUIMethod):
            """
            Reads macro definitions from a file.
            """
        class read_pdf(TUIMethod):
            """
            Reads a PDF file.
            """
        class read_profile(TUIMethod):
            """
            Reads boundary profile data.
            """
        class read_rays(TUIMethod):
            """
            Reads a ray file.
            """
        class read_settings(TUIMethod):
            """
            Reads and sets boundary conditions from a specified file.
            """
        class read_surface_clusters(TUIMethod):
            """
            Reads surface clusters from a file.
            """
        class read_transient_table(TUIMethod):
            """
            Reads table of transient boundary profile data.
            """
        class read_viewfactors(TUIMethod):
            """
            Reads view factors from a file.
            """
        class reload_setup(TUIMethod):
            """
            Discards any changes in the current ANSYS Fluent in Workbench session and removes any corresponding data from the Solution cell. This command is only available when running ANSYS Fluent in Workbench.
            """
        class replace_mesh(TUIMethod):
            """
            Replaces the mesh with a new one while preserving settings.
            """
        class set_batch_options(TUIMethod):
            """
            Sets the batch options.
            """
        class set_error_on_invalid_command(TUIMethod):
            """
            Set whether to abort journal replay on invalid command.
            """
        class set_idle_timeout(TUIMethod):
            """
            Set the idle timeout.
            """
        class set_maximum_simultaneous_files(TUIMethod):
            """
            Specify the maximum number of files, such as report files and profiles, that may be open or written simultaneously. If the number of working files exceeds this limit, files may not be written or Fluent may close unexpectedly.
            """
        class set_target_reference_frame_for_write_profiles(TUIMethod):
            """
            Set reference frame options, which will be used for position transformation during writing of profiles.
            """
        class set_tui_version(TUIMethod):
            """
            Set the version of the TUI commands.
            """
        class show_configuration(TUIMethod):
            """
            .
            """
        class single_precision_coordinates(TUIMethod):
            """
            Specifies whether the nodal coordinates should be written in single precision (rather than the default double precision). This text command is only available in the single-precision version of ANSYS Fluent.
            """
        class start_journal(TUIMethod):
            """
            .
            """
        class start_transcript(TUIMethod):
            """
            .
            """
        class stop_journal(TUIMethod):
            """
            .
            """
        class stop_macro(TUIMethod):
            """
            Stops recording input to a macro.
            """
        class stop_transcript(TUIMethod):
            """
            .
            """
        class sync_workbench(TUIMethod):
            """
            Directly updates Workbench with the most recent Fluent changes. This command is only available when running ANSYS Fluent in Workbench.
            """
        class write_boundary_mesh(TUIMethod):
            """
            Writes the boundary mesh to a file.
            """
        class write_case(TUIMethod):
            """
            Write a case file.
            """
        class write_case_data(TUIMethod):
            """
            Writes a case and a data file.
            """
        class write_circumferential_averaged_profile(TUIMethod):
            """
            Write surface data as a boundary profile file. To use \\*.csv format specify filename with .csv suffix.
            """
        class write_cleanup_script(TUIMethod):
            """
            Writes the cleanup-script-file for ANSYS Fluent.
            """
        class write_currently_defined_profiles(TUIMethod):
            """
            Write currently defined profiles. To use \\*.csv format specify filename with .csv suffix.
            """
        class write_data(TUIMethod):
            """
            Writes a data file.
            """
        class write_fan_profile(TUIMethod):
            """
            Computes radial profiles for a fan zone and writes them to a profile file.
            """
        class write_field_functions(TUIMethod):
            """
            Writes the currently defined custom field functions to a file.
            """
        class write_flamelet(TUIMethod):
            """
            Writes a flamelet file.
            """
        class write_gpu_restart(TUIMethod):
            """
            Write gpuapp restart case and data files.
            """
        class write_injections(TUIMethod):
            """
            Writes out selected DPM injections to a file.
            """
        class write_isat_table(TUIMethod):
            """
            Writes ISAT Table.
            """
        class write_macros(TUIMethod):
            """
            Writes the currently defined macros to a file.
            """
        class write_merge_profiles(TUIMethod):
            """
            Writes a .csv file with the selected surfaces consolidated into one set of data points.
            """
        class write_pdat(TUIMethod):
            """
            Enables / disables the attempt to save .pdat files. Note that this text command is no longer supported.
            """
        class write_pdf(TUIMethod):
            """
            Writes a pdf file.
            """
        class write_profile(TUIMethod):
            """
            Writes surface data as a boundary profile file.
            """
        class write_selected_defined_profiles(TUIMethod):
            """
            Set profile names, only these profile names which will be used during writing of \\*.csv profiles.
            """
        class write_settings(TUIMethod):
            """
            Writes out current boundary conditions in use.
            """

        class auto_save(TUIMenu):
            """
            Enters the auto save menu.
            """
            def __init__(self, service, version, mode, path):
                self.append_file_name_with = self.__class__.append_file_name_with(service, version, mode, path + ["append_file_name_with"])
                self.case_frequency = self.__class__.case_frequency(service, version, mode, path + ["case_frequency"])
                self.data_frequency = self.__class__.data_frequency(service, version, mode, path + ["data_frequency"])
                self.max_files = self.__class__.max_files(service, version, mode, path + ["max_files"])
                self.retain_most_recent_files = self.__class__.retain_most_recent_files(service, version, mode, path + ["retain_most_recent_files"])
                self.root_name = self.__class__.root_name(service, version, mode, path + ["root_name"])
                self.save_data_file_every = self.__class__.save_data_file_every(service, version, mode, path + ["save_data_file_every"])
                super().__init__(service, version, mode, path)
            class append_file_name_with(TUIMethod):
                """
                Sets the suffix for auto-saved files. The file name can be appended by flow-time, time-step value, or by user-specified flags in file name.
                """
            class case_frequency(TUIMethod):
                """
                Specifies the frequency (in iterations, time steps, or flow time) with which case files are saved.
                """
            class data_frequency(TUIMethod):
                """
                Specifies the frequency (in iterations, time steps, or flow time) with which data files are saved.
                """
            class max_files(TUIMethod):
                """
                Sets the maximum number of files. Once the maximum is reached, files will be erased as new files are written.
                """
            class retain_most_recent_files(TUIMethod):
                """
                Sets autosave to retain the 5 most recent files.
                """
            class root_name(TUIMethod):
                """
                Specifies the root name for the files that are saved.
                """
            class save_data_file_every(TUIMethod):
                """
                Specifies the type and frequency of the data file to be saved.
                """

        class cffio_options(TUIMenu):
            """
            Enters the cffio options menu, which provides options for the I/O of case and data files in the Common Fluids Format (CFF).
            """
            def __init__(self, service, version, mode, path):
                self.compression_level = self.__class__.compression_level(service, version, mode, path + ["compression_level"])
                self.io_mode = self.__class__.io_mode(service, version, mode, path + ["io_mode"])
                self.single_precision_data = self.__class__.single_precision_data(service, version, mode, path + ["single_precision_data"])
                super().__init__(service, version, mode, path)
            class compression_level(TUIMethod):
                """
                Sets the compression level for CFF files. The compression level can be set between 0 and 9 with 0 being least compression (fastest) and 9 being highest compression (slowest).
                """
            class io_mode(TUIMethod):
                """
                Sets the I/O mode for writing CFF files.
                1. HOST: I/O is done serially by the host process.
                2. NODE0: I/O is done serially by the node 0 process.
                3. PARALLEL INDEPENDENT: I/O is done in parallel using the independent mode of MPI I/O.
                4. PARALLEL COLLECTIVE: I/O is done in parallel using the collective mode of MPI I/O.
                """
            class single_precision_data(TUIMethod):
                """
                Specifies whether the double-precision solver saves single-precision data when writing CFF data files, in order to reduce the size of the files.
                """

        class em_mapping(TUIMenu):
            """
            Enters the electromagnetic loss mapping menu.
            """
            def __init__(self, service, version, mode, path):
                self.maintain_loss_on_initialization = self.__class__.maintain_loss_on_initialization(service, version, mode, path + ["maintain_loss_on_initialization"])
                self.remove_loss_only = self.__class__.remove_loss_only(service, version, mode, path + ["remove_loss_only"])
                self.surface_energy_source = self.__class__.surface_energy_source(service, version, mode, path + ["surface_energy_source"])
                self.volumetric_energy_source = self.__class__.volumetric_energy_source(service, version, mode, path + ["volumetric_energy_source"])
                super().__init__(service, version, mode, path)
            class maintain_loss_on_initialization(TUIMethod):
                """
                Maintains the loss data provided by Maxwell even if solution is initialized.
                """
            class remove_loss_only(TUIMethod):
                """
                Removes the loss data provided by Maxwell and keeps all other solution data.
                """
            class surface_energy_source(TUIMethod):
                """
                Loss data provided by Ansoft will be assigned to Fluent for selected wall zones.
                """
            class volumetric_energy_source(TUIMethod):
                """
                Loss data provided by Ansoft will be assigned to Fluent for selected cell zones.
                """

        class export(TUIMenu):
            """
            Enter the export menu.
            """
            def __init__(self, service, version, mode, path):
                self.settings = self.__class__.settings(service, version, mode, path + ["settings"])
                self.system_coupling_definition_file_settings = self.__class__.system_coupling_definition_file_settings(service, version, mode, path + ["system_coupling_definition_file_settings"])
                self.abaqus = self.__class__.abaqus(service, version, mode, path + ["abaqus"])
                self.ascii = self.__class__.ascii(service, version, mode, path + ["ascii"])
                self.avs = self.__class__.avs(service, version, mode, path + ["avs"])
                self.cdat_for_cfd_post__and__ensight = self.__class__.cdat_for_cfd_post__and__ensight(service, version, mode, path + ["cdat_for_cfd_post__and__ensight"])
                self.cgns = self.__class__.cgns(service, version, mode, path + ["cgns"])
                self.common_fluids_format_post = self.__class__.common_fluids_format_post(service, version, mode, path + ["common_fluids_format_post"])
                self.custom_heat_flux = self.__class__.custom_heat_flux(service, version, mode, path + ["custom_heat_flux"])
                self.dx = self.__class__.dx(service, version, mode, path + ["dx"])
                self.ensight = self.__class__.ensight(service, version, mode, path + ["ensight"])
                self.ensight_dvs = self.__class__.ensight_dvs(service, version, mode, path + ["ensight_dvs"])
                self.ensight_dvs_surfaces = self.__class__.ensight_dvs_surfaces(service, version, mode, path + ["ensight_dvs_surfaces"])
                self.ensight_dvs_volume = self.__class__.ensight_dvs_volume(service, version, mode, path + ["ensight_dvs_volume"])
                self.ensight_gold = self.__class__.ensight_gold(service, version, mode, path + ["ensight_gold"])
                self.ensight_gold_parallel_surfaces = self.__class__.ensight_gold_parallel_surfaces(service, version, mode, path + ["ensight_gold_parallel_surfaces"])
                self.ensight_gold_parallel_volume = self.__class__.ensight_gold_parallel_volume(service, version, mode, path + ["ensight_gold_parallel_volume"])
                self.fast_mesh = self.__class__.fast_mesh(service, version, mode, path + ["fast_mesh"])
                self.fast_scalar = self.__class__.fast_scalar(service, version, mode, path + ["fast_scalar"])
                self.fast_solution = self.__class__.fast_solution(service, version, mode, path + ["fast_solution"])
                self.fast_velocity = self.__class__.fast_velocity(service, version, mode, path + ["fast_velocity"])
                self.fieldview = self.__class__.fieldview(service, version, mode, path + ["fieldview"])
                self.fieldview_data = self.__class__.fieldview_data(service, version, mode, path + ["fieldview_data"])
                self.fieldview_unstruct = self.__class__.fieldview_unstruct(service, version, mode, path + ["fieldview_unstruct"])
                self.fieldview_unstruct_data = self.__class__.fieldview_unstruct_data(service, version, mode, path + ["fieldview_unstruct_data"])
                self.fieldview_unstruct_mesh = self.__class__.fieldview_unstruct_mesh(service, version, mode, path + ["fieldview_unstruct_mesh"])
                self.fieldview_unstruct_surfaces = self.__class__.fieldview_unstruct_surfaces(service, version, mode, path + ["fieldview_unstruct_surfaces"])
                self.gambit = self.__class__.gambit(service, version, mode, path + ["gambit"])
                self.icemcfd_for_icepak = self.__class__.icemcfd_for_icepak(service, version, mode, path + ["icemcfd_for_icepak"])
                self.ideas = self.__class__.ideas(service, version, mode, path + ["ideas"])
                self.mechanical_apdl = self.__class__.mechanical_apdl(service, version, mode, path + ["mechanical_apdl"])
                self.mechanical_apdl_input = self.__class__.mechanical_apdl_input(service, version, mode, path + ["mechanical_apdl_input"])
                self.nastran = self.__class__.nastran(service, version, mode, path + ["nastran"])
                self.particle_history_data = self.__class__.particle_history_data(service, version, mode, path + ["particle_history_data"])
                self.patran_neutral = self.__class__.patran_neutral(service, version, mode, path + ["patran_neutral"])
                self.patran_nodal = self.__class__.patran_nodal(service, version, mode, path + ["patran_nodal"])
                self.taitherm = self.__class__.taitherm(service, version, mode, path + ["taitherm"])
                self.tecplot = self.__class__.tecplot(service, version, mode, path + ["tecplot"])
                super().__init__(service, version, mode, path)
            class abaqus(TUIMethod):
                """
                Writes an ABAQUS file.
                """
            class ascii(TUIMethod):
                """
                Writes an ASCII file.
                """
            class avs(TUIMethod):
                """
                Writes an AVS UCD file.
                """
            class cdat_for_cfd_post__and__ensight(TUIMethod):
                """
                Write a CDAT for CFD-Post & EnSight file.
                """
            class cgns(TUIMethod):
                """
                Write a CGNS file.
                """
            class common_fluids_format_post(TUIMethod):
                """
                Writes common fluids format files (.cas.post and .dat.post) for mesh and data, respectively. These files are saved in the hierarchical data format.
                """
            class custom_heat_flux(TUIMethod):
                """
                Writes a generic file for heat transfer.
                """
            class dx(TUIMethod):
                """
                Writes an IBM Data Explorer format file.
                """
            class ensight(TUIMethod):
                """
                Writes EnSight geometry, velocity, and scalar files.
                """
            class ensight_dvs(TUIMethod):
                """
                Write post-processing data (geometry, velocity and scalars) for cell and face zones using EnSight Dynamic Visualization Store Interface.
                """
            class ensight_dvs_surfaces(TUIMethod):
                """
                Write post-processing data (geometry, velocity and scalars) for surfaces using EnSight Dynamic Visualization Store Interface.
                """
            class ensight_dvs_volume(TUIMethod):
                """
                Write post-processing data (geometry, velocity and scalars) for cell zones and boundaries attached to them using EnSight Dynamic Visualization Store Interface.
                """
            class ensight_gold(TUIMethod):
                """
                Writes EnSight Gold geometry, velocity, and scalar files.
                """
            class ensight_gold_parallel_surfaces(TUIMethod):
                """
                Writes EnSight Gold geometry, velocity, and scalar files for surfaces in a parallel format suitable for ANSYS Ensight Enterprise.
                """
            class ensight_gold_parallel_volume(TUIMethod):
                """
                Writes EnSight Gold geometry, velocity, and scalar files for cell zones in a parallel format suitable for ANSYS Ensight Enterprise.
                """
            class fast_mesh(TUIMethod):
                """
                Writes FAST/Plot3D unstructured mesh file.
                """
            class fast_scalar(TUIMethod):
                """
                Writes FAST/Plot3D unstructured scalar function file.
                """
            class fast_solution(TUIMethod):
                """
                Writes FAST/Plot3D unstructured solution file.
                """
            class fast_velocity(TUIMethod):
                """
                Writes FAST/Plot3D unstructured vector function file.
                """
            class fieldview(TUIMethod):
                """
                Writes FIELDVIEW case and data files.
                """
            class fieldview_data(TUIMethod):
                """
                Writes FIELDVIEW case and data files.
                """
            class fieldview_unstruct(TUIMethod):
                """
                Writes FIELDVIEW unstructured combined file.
                """
            class fieldview_unstruct_data(TUIMethod):
                """
                Writes FIELDVIEW unstructured results-only file.
                """
            class fieldview_unstruct_mesh(TUIMethod):
                """
                Writes FIELDVIEW unstructured mesh-only file.
                """
            class fieldview_unstruct_surfaces(TUIMethod):
                """
                Writes FIELDVIEW unstructured file for surfaces. You are prompted to select either [1], [2] or [3] to write either mesh-only, results-only, or combined for surfaces (respectively).
                """
            class gambit(TUIMethod):
                """
                Writes GAMBIT neutral file.
                """
            class icemcfd_for_icepak(TUIMethod):
                """
                Writes a binary ICEM CFD domain file.
                """
            class ideas(TUIMethod):
                """
                Writes an I-deas universal file.
                """
            class mechanical_apdl(TUIMethod):
                """
                .
                """
            class mechanical_apdl_input(TUIMethod):
                """
                Writes a Mechanical APDL Input file.
                """
            class nastran(TUIMethod):
                """
                Write a NASTRAN file.
                """
            class particle_history_data(TUIMethod):
                """
                Exports particle-history data.
                """
            class patran_neutral(TUIMethod):
                """
                Writes a PATRAN neutral file.
                """
            class patran_nodal(TUIMethod):
                """
                Writes a PATRAN nodal results file.
                """
            class taitherm(TUIMethod):
                """
                Exports TAITherm file.
                """
            class tecplot(TUIMethod):
                """
                Writes a Tecplot+3DV format file.
                """

            class settings(TUIMenu):
                """
                Enter the export settings menu.
                """
                def __init__(self, service, version, mode, path):
                    self.cgns_default_cellsize_changes = self.__class__.cgns_default_cellsize_changes(service, version, mode, path + ["cgns_default_cellsize_changes"])
                    self.cgns_enhance_poly_export_performance = self.__class__.cgns_enhance_poly_export_performance(service, version, mode, path + ["cgns_enhance_poly_export_performance"])
                    self.cgns_merge_ngons_to_single_ngon = self.__class__.cgns_merge_ngons_to_single_ngon(service, version, mode, path + ["cgns_merge_ngons_to_single_ngon"])
                    self.cgns_mesh_type = self.__class__.cgns_mesh_type(service, version, mode, path + ["cgns_mesh_type"])
                    self.cgns_polyhedral_cpu_threads = self.__class__.cgns_polyhedral_cpu_threads(service, version, mode, path + ["cgns_polyhedral_cpu_threads"])
                    self.set_cgns_export_filetype = self.__class__.set_cgns_export_filetype(service, version, mode, path + ["set_cgns_export_filetype"])
                    super().__init__(service, version, mode, path)
                class cgns_default_cellsize_changes(TUIMethod):
                    """
                    .
                    """
                class cgns_enhance_poly_export_performance(TUIMethod):
                    """
                    .
                    """
                class cgns_merge_ngons_to_single_ngon(TUIMethod):
                    """
                    .
                    """
                class cgns_mesh_type(TUIMethod):
                    """
                    Set CGNS NGON mode.
                    """
                class cgns_polyhedral_cpu_threads(TUIMethod):
                    """
                    .
                    """
                class set_cgns_export_filetype(TUIMethod):
                    """
                    .
                    """

            class system_coupling_definition_file_settings(TUIMenu):
                """
                Enters the system coupling file (.scp) menu.
                """
                def __init__(self, service, version, mode, path):
                    self.enable_auto_creation_of_scp_file = self.__class__.enable_auto_creation_of_scp_file(service, version, mode, path + ["enable_auto_creation_of_scp_file"])
                    self.write_sc_file = self.__class__.write_sc_file(service, version, mode, path + ["write_sc_file"])
                    super().__init__(service, version, mode, path)
                class enable_auto_creation_of_scp_file(TUIMethod):
                    """
                    .
                    """
                class write_sc_file(TUIMethod):
                    """
                    .
                    """

        class fsi(TUIMenu):
            """
            Enters the fluid-structure interaction menu.
            """
            def __init__(self, service, version, mode, path):
                self.conserve_force = self.__class__.conserve_force(service, version, mode, path + ["conserve_force"])
                self.display_fsi_mesh = self.__class__.display_fsi_mesh(service, version, mode, path + ["display_fsi_mesh"])
                self.read_fsi_mesh = self.__class__.read_fsi_mesh(service, version, mode, path + ["read_fsi_mesh"])
                self.write_fsi_mesh = self.__class__.write_fsi_mesh(service, version, mode, path + ["write_fsi_mesh"])
                super().__init__(service, version, mode, path)
            class conserve_force(TUIMethod):
                """
                Conserve the forces for linear line, tri and tet elements.
                """
            class display_fsi_mesh(TUIMethod):
                """
                Displays the mesh for a fluid-structure interaction.
                """
            class read_fsi_mesh(TUIMethod):
                """
                Reads an FEM mesh for one-way data mapping from ANSYS Fluent.
                """
            class write_fsi_mesh(TUIMethod):
                """
                Writes a fluid-structure interaction mesh file.
                """

        class import_(TUIMenu):
            """
            Enter the import menu.
            """
            def __init__(self, service, version, mode, path):
                self.abaqus = self.__class__.abaqus(service, version, mode, path + ["abaqus"])
                self.cfx = self.__class__.cfx(service, version, mode, path + ["cfx"])
                self.cgns = self.__class__.cgns(service, version, mode, path + ["cgns"])
                self.fmu_file = self.__class__.fmu_file(service, version, mode, path + ["fmu_file"])
                self.lstc = self.__class__.lstc(service, version, mode, path + ["lstc"])
                self.mechanical_apdl = self.__class__.mechanical_apdl(service, version, mode, path + ["mechanical_apdl"])
                self.nastran = self.__class__.nastran(service, version, mode, path + ["nastran"])
                self.partition = self.__class__.partition(service, version, mode, path + ["partition"])
                self.patran = self.__class__.patran(service, version, mode, path + ["patran"])
                self.plot3d = self.__class__.plot3d(service, version, mode, path + ["plot3d"])
                self.tecplot = self.__class__.tecplot(service, version, mode, path + ["tecplot"])
                self.chemkin_mechanism = self.__class__.chemkin_mechanism(service, version, mode, path + ["chemkin_mechanism"])
                self.chemkin_report_each_line = self.__class__.chemkin_report_each_line(service, version, mode, path + ["chemkin_report_each_line"])
                self.ensight = self.__class__.ensight(service, version, mode, path + ["ensight"])
                self.fidap = self.__class__.fidap(service, version, mode, path + ["fidap"])
                self.flamelet = self.__class__.flamelet(service, version, mode, path + ["flamelet"])
                self.fluent4_case = self.__class__.fluent4_case(service, version, mode, path + ["fluent4_case"])
                self.gambit = self.__class__.gambit(service, version, mode, path + ["gambit"])
                self.hypermesh = self.__class__.hypermesh(service, version, mode, path + ["hypermesh"])
                self.ideas_universal = self.__class__.ideas_universal(service, version, mode, path + ["ideas_universal"])
                self.marc_post = self.__class__.marc_post(service, version, mode, path + ["marc_post"])
                self.prebfc_structured = self.__class__.prebfc_structured(service, version, mode, path + ["prebfc_structured"])
                self.ptc_mechanica = self.__class__.ptc_mechanica(service, version, mode, path + ["ptc_mechanica"])
                super().__init__(service, version, mode, path)
            class chemkin_mechanism(TUIMethod):
                """
                Read a CHEMKIN mechanism file.
                """
            class chemkin_report_each_line(TUIMethod):
                """
                Enable/disable reporting after reading each line.
                """
            class ensight(TUIMethod):
                """
                Read an Ensight file as a case file.
                """
            class fidap(TUIMethod):
                """
                Read a FIDAP neutral file as a case file.
                """
            class flamelet(TUIMethod):
                """
                Import a flamelet file.
                """
            class fluent4_case(TUIMethod):
                """
                Read a formatted Fluent 4 case file.
                """
            class gambit(TUIMethod):
                """
                Read a GAMBIT neutral file as a case file.
                """
            class hypermesh(TUIMethod):
                """
                Read a HYPERMESH file as a case file.
                """
            class ideas_universal(TUIMethod):
                """
                Read an IDEAS Universal file as a case file.
                """
            class marc_post(TUIMethod):
                """
                Read a MARC POST file as a case file.
                """
            class prebfc_structured(TUIMethod):
                """
                Read a formatted preBFC structured mesh (grid) file.
                """
            class ptc_mechanica(TUIMethod):
                """
                Read a PTC Mechanica file as a case file.
                """

            class abaqus(TUIMenu):
                """
                Enter the Abaqus menu.
                """
                def __init__(self, service, version, mode, path):
                    self.fil = self.__class__.fil(service, version, mode, path + ["fil"])
                    self.input = self.__class__.input(service, version, mode, path + ["input"])
                    self.odb = self.__class__.odb(service, version, mode, path + ["odb"])
                    super().__init__(service, version, mode, path)
                class fil(TUIMethod):
                    """
                    Read an Abaqus .fil result file as a case file.
                    """
                class input(TUIMethod):
                    """
                    Read an Abaqus Input file as a case file.
                    """
                class odb(TUIMethod):
                    """
                    Read an Abaqus odb file as a case file.
                    """

            class cfx(TUIMenu):
                """
                Enter the CFX menu.
                """
                def __init__(self, service, version, mode, path):
                    self.definition = self.__class__.definition(service, version, mode, path + ["definition"])
                    self.result = self.__class__.result(service, version, mode, path + ["result"])
                    super().__init__(service, version, mode, path)
                class definition(TUIMethod):
                    """
                    Read a CFX definition file as a case file.
                    """
                class result(TUIMethod):
                    """
                    Read a CFX result file as a case file.
                    """

            class cgns(TUIMenu):
                """
                Enter the CGNS menu.
                """
                def __init__(self, service, version, mode, path):
                    self.data = self.__class__.data(service, version, mode, path + ["data"])
                    self.mesh = self.__class__.mesh(service, version, mode, path + ["mesh"])
                    self.mesh_data = self.__class__.mesh_data(service, version, mode, path + ["mesh_data"])
                    super().__init__(service, version, mode, path)
                class data(TUIMethod):
                    """
                    Read data from CGNS file.
                    """
                class mesh(TUIMethod):
                    """
                    Read a CGNS file as a case file.
                    """
                class mesh_data(TUIMethod):
                    """
                    Read a CGNS file as a case file.
                    """

            class fmu_file(TUIMenu):
                """
                Read a FMU file.
                """
                def __init__(self, service, version, mode, path):
                    self.define_fmu = self.__class__.define_fmu(service, version, mode, path + ["define_fmu"])
                    self.import_fmu = self.__class__.import_fmu(service, version, mode, path + ["import_fmu"])
                    self.select_fmu_local = self.__class__.select_fmu_local(service, version, mode, path + ["select_fmu_local"])
                    self.set_fmu_parameter = self.__class__.set_fmu_parameter(service, version, mode, path + ["set_fmu_parameter"])
                    super().__init__(service, version, mode, path)
                class define_fmu(TUIMethod):
                    """
                    Link the FMU variables with Fluent parameters.
                    """
                class import_fmu(TUIMethod):
                    """
                    .
                    """
                class select_fmu_local(TUIMethod):
                    """
                    Select the FMU local variables to monitor.
                    """
                class set_fmu_parameter(TUIMethod):
                    """
                    Change the values of FMU parameter variables.
                    """

            class lstc(TUIMenu):
                """
                Enter the LSTC menu.
                """
                def __init__(self, service, version, mode, path):
                    self.input = self.__class__.input(service, version, mode, path + ["input"])
                    self.state = self.__class__.state(service, version, mode, path + ["state"])
                    super().__init__(service, version, mode, path)
                class input(TUIMethod):
                    """
                    Read an LSTC input file as a case file.
                    """
                class state(TUIMethod):
                    """
                    Read an LSTC result file as a case file.
                    """

            class mechanical_apdl(TUIMenu):
                """
                Enter the Mechanical APDL menu.
                """
                def __init__(self, service, version, mode, path):
                    self.input = self.__class__.input(service, version, mode, path + ["input"])
                    self.result = self.__class__.result(service, version, mode, path + ["result"])
                    super().__init__(service, version, mode, path)
                class input(TUIMethod):
                    """
                    Read an Mechanical APDL file as a case file.
                    """
                class result(TUIMethod):
                    """
                    Read an Mechanical APDL result file as a case file.
                    """

            class nastran(TUIMenu):
                """
                Enter the NASTRAN menu.
                """
                def __init__(self, service, version, mode, path):
                    self.bulkdata = self.__class__.bulkdata(service, version, mode, path + ["bulkdata"])
                    self.output2 = self.__class__.output2(service, version, mode, path + ["output2"])
                    super().__init__(service, version, mode, path)
                class bulkdata(TUIMethod):
                    """
                    Read a NASTRAN file as a case file.
                    """
                class output2(TUIMethod):
                    """
                    Read a NASTRAN op2 file as a case file.
                    """

            class partition(TUIMenu):
                """
                Enter the partition menu.
                """
                def __init__(self, service, version, mode, path):
                    self.metis = self.__class__.metis(service, version, mode, path + ["metis"])
                    self.metis_zone = self.__class__.metis_zone(service, version, mode, path + ["metis_zone"])
                    super().__init__(service, version, mode, path)
                class metis(TUIMethod):
                    """
                    Read and partition a Fluent 5 case file.
                    """
                class metis_zone(TUIMethod):
                    """
                    Read and partition a Fluent 5 case file.
                    """

            class patran(TUIMenu):
                """
                Enter the PATRAN menu.
                """
                def __init__(self, service, version, mode, path):
                    self.neutral = self.__class__.neutral(service, version, mode, path + ["neutral"])
                    super().__init__(service, version, mode, path)
                class neutral(TUIMethod):
                    """
                    Read a PATRAN Neutral file (zones defined by named components) as a case file.
                    """

            class plot3d(TUIMenu):
                """
                Enter the PLOT3D menu.
                """
                def __init__(self, service, version, mode, path):
                    self.mesh = self.__class__.mesh(service, version, mode, path + ["mesh"])
                    super().__init__(service, version, mode, path)
                class mesh(TUIMethod):
                    """
                    Read a PLOT3D file as a case file.
                    """

            class tecplot(TUIMenu):
                """
                Enter the Tecplot menu.
                """
                def __init__(self, service, version, mode, path):
                    self.mesh = self.__class__.mesh(service, version, mode, path + ["mesh"])
                    super().__init__(service, version, mode, path)
                class mesh(TUIMethod):
                    """
                    Read a Tecplot binary file as a case file.
                    """

        class interpolate(TUIMenu):
            """
            Interpolates data to/from another grid.
            """
            def __init__(self, service, version, mode, path):
                self.read_data = self.__class__.read_data(service, version, mode, path + ["read_data"])
                self.write_data = self.__class__.write_data(service, version, mode, path + ["write_data"])
                self.zone_selection = self.__class__.zone_selection(service, version, mode, path + ["zone_selection"])
                super().__init__(service, version, mode, path)
            class read_data(TUIMethod):
                """
                Reads and interpolates data.
                """
            class write_data(TUIMethod):
                """
                Writes data for interpolation.
                """
            class zone_selection(TUIMethod):
                """
                Defines a list of cell zone IDs. If specified, interpolation data will be read/written for these cell zones only.
                """

        class parametric_project(TUIMenu):
            """
            Enter to open, save, archive parametric project.
            """
            def __init__(self, service, version, mode, path):
                self.archive = self.__class__.archive(service, version, mode, path + ["archive"])
                self.open = self.__class__.open(service, version, mode, path + ["open"])
                self.save = self.__class__.save(service, version, mode, path + ["save"])
                self.save_a_copy = self.__class__.save_a_copy(service, version, mode, path + ["save_a_copy"])
                self.save_as = self.__class__.save_as(service, version, mode, path + ["save_as"])
                super().__init__(service, version, mode, path)
            class archive(TUIMethod):
                """
                Archive Project.
                """
            class open(TUIMethod):
                """
                Open project.
                """
            class save(TUIMethod):
                """
                Save Project.
                """
            class save_a_copy(TUIMethod):
                """
                Save a Copy.
                """
            class save_as(TUIMethod):
                """
                Save As Project.
                """

        class project_beta(TUIMenu):
            """
            Enter to create new project, open project, save and archive project.
            """
            def __init__(self, service, version, mode, path):
                self.archive = self.__class__.archive(service, version, mode, path + ["archive"])
                self.new = self.__class__.new(service, version, mode, path + ["new"])
                self.open = self.__class__.open(service, version, mode, path + ["open"])
                self.save = self.__class__.save(service, version, mode, path + ["save"])
                self.save_as = self.__class__.save_as(service, version, mode, path + ["save_as"])
                self.save_as_copy = self.__class__.save_as_copy(service, version, mode, path + ["save_as_copy"])
                super().__init__(service, version, mode, path)
            class archive(TUIMethod):
                """
                Archive Project.
                """
            class new(TUIMethod):
                """
                Create New Project.
                """
            class open(TUIMethod):
                """
                Open project.
                """
            class save(TUIMethod):
                """
                Save Project.
                """
            class save_as(TUIMethod):
                """
                Save As Project.
                """
            class save_as_copy(TUIMethod):
                """
                Save As Copy.
                """

        class solution_files(TUIMenu):
            """
            Enters the solution files menu.
            """
            def __init__(self, service, version, mode, path):
                self.delete_solution = self.__class__.delete_solution(service, version, mode, path + ["delete_solution"])
                self.load_solution = self.__class__.load_solution(service, version, mode, path + ["load_solution"])
                self.print_solution_files = self.__class__.print_solution_files(service, version, mode, path + ["print_solution_files"])
                super().__init__(service, version, mode, path)
            class delete_solution(TUIMethod):
                """
                Deletes solution files.
                """
            class load_solution(TUIMethod):
                """
                Loads a solution file.
                """
            class print_solution_files(TUIMethod):
                """
                Prints a list of available solution files.
                """

        class table_manager(TUIMenu):
            """
            Enters the table file manager menu.
            """
            def __init__(self, service, version, mode, path):
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.list_matrix_data = self.__class__.list_matrix_data(service, version, mode, path + ["list_matrix_data"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                self.list_tables = self.__class__.list_tables(service, version, mode, path + ["list_tables"])
                self.read_matrix_data_file = self.__class__.read_matrix_data_file(service, version, mode, path + ["read_matrix_data_file"])
                self.read_rgp_file = self.__class__.read_rgp_file(service, version, mode, path + ["read_rgp_file"])
                self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                self.store_in_case_file = self.__class__.store_in_case_file(service, version, mode, path + ["store_in_case_file"])
                super().__init__(service, version, mode, path)
            class delete(TUIMethod):
                """
                Deletes a table from local storage.
                """
            class list_matrix_data(TUIMethod):
                """
                Lists the data of a matrix type locally-stored table.
                """
            class list_properties(TUIMethod):
                """
                Lists the properties of a locally-stored table.
                """
            class list_tables(TUIMethod):
                """
                Lists all locally-stored tables.
                """
            class read_matrix_data_file(TUIMethod):
                """
                Imports a matrix type table from a file into local storage.
                """
            class read_rgp_file(TUIMethod):
                """
                Imports a set of Real Gas Property (RGP) tables from a file into local storage.
                """
            class rename(TUIMethod):
                """
                Renames a locally-stored table.
                """
            class store_in_case_file(TUIMethod):
                """
                Sets the persistence mode for RGP tables (embedded in case file or rely on external file).
                """

        class transient_export(TUIMenu):
            """
            Enter the export menu.
            """
            def __init__(self, service, version, mode, path):
                self.settings = self.__class__.settings(service, version, mode, path + ["settings"])
                self.abaqus = self.__class__.abaqus(service, version, mode, path + ["abaqus"])
                self.ascii = self.__class__.ascii(service, version, mode, path + ["ascii"])
                self.avs = self.__class__.avs(service, version, mode, path + ["avs"])
                self.cdat_for_cfd_post__and__ensight = self.__class__.cdat_for_cfd_post__and__ensight(service, version, mode, path + ["cdat_for_cfd_post__and__ensight"])
                self.cgns = self.__class__.cgns(service, version, mode, path + ["cgns"])
                self.common_fluids_format_post = self.__class__.common_fluids_format_post(service, version, mode, path + ["common_fluids_format_post"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.dx = self.__class__.dx(service, version, mode, path + ["dx"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.ensight_dvs = self.__class__.ensight_dvs(service, version, mode, path + ["ensight_dvs"])
                self.ensight_dvs_surfaces = self.__class__.ensight_dvs_surfaces(service, version, mode, path + ["ensight_dvs_surfaces"])
                self.ensight_dvs_volume = self.__class__.ensight_dvs_volume(service, version, mode, path + ["ensight_dvs_volume"])
                self.ensight_gold_from_existing_files = self.__class__.ensight_gold_from_existing_files(service, version, mode, path + ["ensight_gold_from_existing_files"])
                self.ensight_gold_parallel_surfaces = self.__class__.ensight_gold_parallel_surfaces(service, version, mode, path + ["ensight_gold_parallel_surfaces"])
                self.ensight_gold_parallel_volume = self.__class__.ensight_gold_parallel_volume(service, version, mode, path + ["ensight_gold_parallel_volume"])
                self.ensight_gold_transient = self.__class__.ensight_gold_transient(service, version, mode, path + ["ensight_gold_transient"])
                self.fast = self.__class__.fast(service, version, mode, path + ["fast"])
                self.fast_solution = self.__class__.fast_solution(service, version, mode, path + ["fast_solution"])
                self.fieldview_unstruct = self.__class__.fieldview_unstruct(service, version, mode, path + ["fieldview_unstruct"])
                self.fieldview_unstruct_data = self.__class__.fieldview_unstruct_data(service, version, mode, path + ["fieldview_unstruct_data"])
                self.fieldview_unstruct_mesh = self.__class__.fieldview_unstruct_mesh(service, version, mode, path + ["fieldview_unstruct_mesh"])
                self.fieldview_unstruct_surfaces = self.__class__.fieldview_unstruct_surfaces(service, version, mode, path + ["fieldview_unstruct_surfaces"])
                self.ideas = self.__class__.ideas(service, version, mode, path + ["ideas"])
                self.mechanical_apdl_input = self.__class__.mechanical_apdl_input(service, version, mode, path + ["mechanical_apdl_input"])
                self.nastran = self.__class__.nastran(service, version, mode, path + ["nastran"])
                self.particle_history_data = self.__class__.particle_history_data(service, version, mode, path + ["particle_history_data"])
                self.patran_neutral = self.__class__.patran_neutral(service, version, mode, path + ["patran_neutral"])
                self.taitherm = self.__class__.taitherm(service, version, mode, path + ["taitherm"])
                self.tecplot = self.__class__.tecplot(service, version, mode, path + ["tecplot"])
                super().__init__(service, version, mode, path)
            class abaqus(TUIMethod):
                """
                Writes an ABAQUS file.
                """
            class ascii(TUIMethod):
                """
                Writes an ASCII file.
                """
            class avs(TUIMethod):
                """
                Writes an AVS UCD file.
                """
            class cdat_for_cfd_post__and__ensight(TUIMethod):
                """
                Write a CDAT for CFD-Post & EnSight file.
                """
            class cgns(TUIMethod):
                """
                Writes a CGNS file.
                """
            class common_fluids_format_post(TUIMethod):
                """
                Write an CFF Post-Only file.
                """
            class delete(TUIMethod):
                """
                Deletes transient exports.
                """
            class dx(TUIMethod):
                """
                Writes an IBM Data Explorer format file.
                """
            class edit(TUIMethod):
                """
                Edits transient exports.
                """
            class ensight_dvs(TUIMethod):
                """
                Write post-processing data (geometry, velocity and scalars) for cell and face zones using EnSight Dynamic Visualization Store Interface.
                """
            class ensight_dvs_surfaces(TUIMethod):
                """
                Write post-processing data (geometry, velocity and scalars) for surfaces using EnSight Dynamic Visualization Store Interface.
                """
            class ensight_dvs_volume(TUIMethod):
                """
                Write post-processing data (geometry, velocity and scalars) for cell zones and boundaries attached to them using EnSight Dynamic Visualization Store Interface.
                """
            class ensight_gold_from_existing_files(TUIMethod):
                """
                Writes EnSight Gold files using ANSYS Fluent case files.
                """
            class ensight_gold_parallel_surfaces(TUIMethod):
                """
                Writes EnSight Gold geometry, velocity, and scalar files for surfaces in a parallel format suitable for ANSYS Ensight Enterprise.
                """
            class ensight_gold_parallel_volume(TUIMethod):
                """
                Writes EnSight Gold geometry, velocity, and scalar files for cell zones in a parallel format suitable for ANSYS Ensight Enterprise.
                """
            class ensight_gold_transient(TUIMethod):
                """
                Writes EnSight Gold geometry, velocity, and scalar files.
                """
            class fast(TUIMethod):
                """
                Writes a FAST/Plot3D unstructured mesh velocity scalar file.
                """
            class fast_solution(TUIMethod):
                """
                Writes a FAST/Plot3D unstructured solution file.
                """
            class fieldview_unstruct(TUIMethod):
                """
                Writes a FIELDVIEW unstructured combined file.
                """
            class fieldview_unstruct_data(TUIMethod):
                """
                Writes a FIELDVIEW unstructured results only file.
                """
            class fieldview_unstruct_mesh(TUIMethod):
                """
                Writes a FIELDVIEW unstructured mesh only file.
                """
            class fieldview_unstruct_surfaces(TUIMethod):
                """
                Writes FIELDVIEW unstructured combined file for surfaces.
                """
            class ideas(TUIMethod):
                """
                Writes an I-deas universal file.
                """
            class mechanical_apdl_input(TUIMethod):
                """
                Writes a Mechanical APDL input file.
                """
            class nastran(TUIMethod):
                """
                Writes a NASTRAN file.
                """
            class particle_history_data(TUIMethod):
                """
                Sets up an automatic particle-history data export.
                """
            class patran_neutral(TUIMethod):
                """
                Writes a PATRAN neutral file.
                """
            class taitherm(TUIMethod):
                """
                Writes a TAITherm file.
                """
            class tecplot(TUIMethod):
                """
                Write a Tecplot+3DV format file.
                """

            class settings(TUIMenu):
                """
                Enters the automatic export settings menu.
                """
                def __init__(self, service, version, mode, path):
                    self.cfd_post_compatible = self.__class__.cfd_post_compatible(service, version, mode, path + ["cfd_post_compatible"])
                    super().__init__(service, version, mode, path)
                class cfd_post_compatible(TUIMethod):
                    """
                    Specifies when case files are written with the .cdat and .cst files exported for Ansys CFD-Post. Note that this setting is ignored if the Write Case File Every Time option is enabled in the Automatic Export dialog box, which is always the case starting in Release 2021 R1.
                    """

    class icing(TUIMenu):
        """
        FENSAP-ICE options.
        """
        def __init__(self, service, version, mode, path):
            self.drop = self.__class__.drop(service, version, mode, path + ["drop"])
            self.file = self.__class__.file(service, version, mode, path + ["file"])
            self.flow = self.__class__.flow(service, version, mode, path + ["flow"])
            self.ice = self.__class__.ice(service, version, mode, path + ["ice"])
            self.multishot = self.__class__.multishot(service, version, mode, path + ["multishot"])
            self.settings = self.__class__.settings(service, version, mode, path + ["settings"])
            super().__init__(service, version, mode, path)
        class drop(TUIMethod):
            """
            Droplet impingement menu.
            """
        class file(TUIMethod):
            """
            File menu.
            """
        class flow(TUIMethod):
            """
            Flow solver menu.
            """
        class ice(TUIMethod):
            """
            Ice accretion menu.
            """
        class multishot(TUIMethod):
            """
            Multi-shot accretion menu.
            """
        class settings(TUIMethod):
            """
            Global settings menu.
            """

    class mesh(TUIMenu):
        """
        Enter the mesh menu.
        """
        def __init__(self, service, version, mode, path):
            self.adapt = self.__class__.adapt(service, version, mode, path + ["adapt"])
            self.anisotropic_adaption = self.__class__.anisotropic_adaption(service, version, mode, path + ["anisotropic_adaption"])
            self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
            self.modify_zones = self.__class__.modify_zones(service, version, mode, path + ["modify_zones"])
            self.polyhedra = self.__class__.polyhedra(service, version, mode, path + ["polyhedra"])
            self.reorder = self.__class__.reorder(service, version, mode, path + ["reorder"])
            self.repair_improve = self.__class__.repair_improve(service, version, mode, path + ["repair_improve"])
            self.surface_mesh = self.__class__.surface_mesh(service, version, mode, path + ["surface_mesh"])
            self.adjacency = self.__class__.adjacency(service, version, mode, path + ["adjacency"])
            self.check = self.__class__.check(service, version, mode, path + ["check"])
            self.check_before_solve = self.__class__.check_before_solve(service, version, mode, path + ["check_before_solve"])
            self.check_verbosity = self.__class__.check_verbosity(service, version, mode, path + ["check_verbosity"])
            self.enhanced_orthogonal_quality = self.__class__.enhanced_orthogonal_quality(service, version, mode, path + ["enhanced_orthogonal_quality"])
            self.memory_usage = self.__class__.memory_usage(service, version, mode, path + ["memory_usage"])
            self.mesh_info = self.__class__.mesh_info(service, version, mode, path + ["mesh_info"])
            self.quality = self.__class__.quality(service, version, mode, path + ["quality"])
            self.redistribute_boundary_layer = self.__class__.redistribute_boundary_layer(service, version, mode, path + ["redistribute_boundary_layer"])
            self.replace = self.__class__.replace(service, version, mode, path + ["replace"])
            self.rotate = self.__class__.rotate(service, version, mode, path + ["rotate"])
            self.scale = self.__class__.scale(service, version, mode, path + ["scale"])
            self.show_periodic_shadow_zones = self.__class__.show_periodic_shadow_zones(service, version, mode, path + ["show_periodic_shadow_zones"])
            self.size_info = self.__class__.size_info(service, version, mode, path + ["size_info"])
            self.smooth_mesh = self.__class__.smooth_mesh(service, version, mode, path + ["smooth_mesh"])
            self.swap_mesh_faces = self.__class__.swap_mesh_faces(service, version, mode, path + ["swap_mesh_faces"])
            self.translate = self.__class__.translate(service, version, mode, path + ["translate"])
            self.wall_distance_method = self.__class__.wall_distance_method(service, version, mode, path + ["wall_distance_method"])
            super().__init__(service, version, mode, path)
        class adjacency(TUIMethod):
            """
            Views and renames face zones adjacent to selected cell  zones.
            """
        class check(TUIMethod):
            """
            Performs various mesh consistency checks and displays a report in the console that lists the domain extents, the volume statistics, the face area statistics, and any warnings, as well as details about the various checks and mesh failures (depending on the setting specified for mesh/check-verbosity).
            """
        class check_before_solve(TUIMethod):
            """
            The default value for mesh/check-before-solve is no. If mesh/check-before-solve is set to yes, a mesh check operation will be invoked prior to starting solver. If grid check fails, solver will be interrupted, and relevant information will be printed in the Fluent console.
            """
        class check_verbosity(TUIMethod):
            """
            Sets the level of details that will be added to the mesh check report generated by mesh/check. A value of 0 (the default) notes when checks are being performed, but does not list them individually. A value of 1 lists the individual checks as they are performed. A value of 2 enables the availability of additional mesh field variables, lists the individual checks as they are performed, and provides additional details (for example, the location of the problem, the affected cells).  The check-verbosity text command can also be used to set the level of detail displayed in the mesh quality report generated by mesh/quality. A value of 0 (the default) or 1 lists the minimum orthogonal quality and the maximum aspect ratio. A value of 2 adds information about the zones that contain the cells with the lowest quality, and additional metrics such as the maximum cell squish index and the minimum expansion ratio.
            """
        class enhanced_orthogonal_quality(TUIMethod):
            """
            Enables / disables an enhanced definition when calculating the orthogonal quality. When enabled, the orthogonal quality is defined using a variety quality measures, including: the orthogonality of a face relative to a vector between the face and cell centroids; a metric that detects poor cell shape at a local edge (such as twisting and/or concavity); and the variation of normals between the faces that can be constructed from the cell face. This enhanced definition is optimal for evaluating thin prism cells.
            """
        class memory_usage(TUIMethod):
            """
            Reports solver memory use.
            """
        class mesh_info(TUIMethod):
            """
            Prints zone information size.
            """
        class quality(TUIMethod):
            """
            Displays information about the quality of the mesh in the console, including the minimum orthogonal quality and the maximum aspect ratio. The level of detail displayed depends on the setting specified for mesh/check-verbosity.
            """
        class redistribute_boundary_layer(TUIMethod):
            """
            Redistributes the nodes in a boundary layer zone to achieve a desired growth rate after anisotropic adaption.
            """
        class replace(TUIMethod):
            """
            .
            """
        class rotate(TUIMethod):
            """
            Rotates the mesh.
            """
        class scale(TUIMethod):
            """
            Prompts for the scaling factors in each of the active Cartesian coordinate directions.
            """
        class show_periodic_shadow_zones(TUIMethod):
            """
            .
            """
        class size_info(TUIMethod):
            """
            Prints mesh size.
            """
        class smooth_mesh(TUIMethod):
            """
            Smooths the mesh using quality-based, Laplacian, or skewness methods.
            """
        class swap_mesh_faces(TUIMethod):
            """
            Swaps mesh faces.
            """
        class translate(TUIMethod):
            """
            Prompts for the translation offset in each of the active Cartesian coordinate directions.
            """
        class wall_distance_method(TUIMethod):
            """
            .
            """

        class adapt(TUIMenu):
            """
            Enters the mesh adaption menu.
            """
            def __init__(self, service, version, mode, path):
                self.cell_registers = self.__class__.cell_registers(service, version, mode, path + ["cell_registers"])
                self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
                self.manage_criteria = self.__class__.manage_criteria(service, version, mode, path + ["manage_criteria"])
                self.multi_layer_refinement = self.__class__.multi_layer_refinement(service, version, mode, path + ["multi_layer_refinement"])
                self.profile = self.__class__.profile(service, version, mode, path + ["profile"])
                self.set = self.__class__.set(service, version, mode, path + ["set"])
                self.adapt_mesh = self.__class__.adapt_mesh(service, version, mode, path + ["adapt_mesh"])
                self.anisotropic_adaption = self.__class__.anisotropic_adaption(service, version, mode, path + ["anisotropic_adaption"])
                self.coarsening_criteria = self.__class__.coarsening_criteria(service, version, mode, path + ["coarsening_criteria"])
                self.display_adaption_cells = self.__class__.display_adaption_cells(service, version, mode, path + ["display_adaption_cells"])
                self.free_hierarchy = self.__class__.free_hierarchy(service, version, mode, path + ["free_hierarchy"])
                self.list_adaption_cells = self.__class__.list_adaption_cells(service, version, mode, path + ["list_adaption_cells"])
                self.manual_coarsening_criteria = self.__class__.manual_coarsening_criteria(service, version, mode, path + ["manual_coarsening_criteria"])
                self.manual_refinement_criteria = self.__class__.manual_refinement_criteria(service, version, mode, path + ["manual_refinement_criteria"])
                self.refinement_criteria = self.__class__.refinement_criteria(service, version, mode, path + ["refinement_criteria"])
                super().__init__(service, version, mode, path)
            class adapt_mesh(TUIMethod):
                """
                Performs manual adaption on the mesh according to the methods and settings that you specified.
                """
            class anisotropic_adaption(TUIMethod):
                """
                Applies legacy anisotropic adaption to refine the boundary layers or registers. Cells will be split in the normal direction to the boundary face. Note that this text command is only available for 3D cases that have the adaption method set to hanging node.
                """
            class coarsening_criteria(TUIMethod):
                """
                Allows you to provide an expression for the coarsening criterion.
                """
            class display_adaption_cells(TUIMethod):
                """
                Displays the cells that are marked for adaption in the graphics window.
                """
            class free_hierarchy(TUIMethod):
                """
                Deletes the defined adaption hierarchy.
                """
            class list_adaption_cells(TUIMethod):
                """
                Prints the number of cells marked for refinement, coarsening, and both to the console.
                """
            class manual_coarsening_criteria(TUIMethod):
                """
                .
                """
            class manual_refinement_criteria(TUIMethod):
                """
                .
                """
            class refinement_criteria(TUIMethod):
                """
                Allows you to provide an expression for the refinement criterion.
                """

            class cell_registers(TUIMenu):
                """
                Enters the cell registers menu.
                """
                def __init__(self, service, version, mode, path):
                    self.adapt = self.__class__.adapt(service, version, mode, path + ["adapt"])
                    self.add = self.__class__.add(service, version, mode, path + ["add"])
                    self.apply_poor_mesh_numerics = self.__class__.apply_poor_mesh_numerics(service, version, mode, path + ["apply_poor_mesh_numerics"])
                    self.coarsen = self.__class__.coarsen(service, version, mode, path + ["coarsen"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.display = self.__class__.display(service, version, mode, path + ["display"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.refine = self.__class__.refine(service, version, mode, path + ["refine"])
                    super().__init__(service, version, mode, path)
                class adapt(TUIMethod):
                    """
                    Adapt cell register objects.
                    """
                class add(TUIMethod):
                    """
                    Add a new object.
                    """
                class apply_poor_mesh_numerics(TUIMethod):
                    """
                    Applies poor mesh numerics to the mesh of a cell register.
                    """
                class coarsen(TUIMethod):
                    """
                    Coarsen the mesh based on a cell register.
                    """
                class delete(TUIMethod):
                    """
                    Deletes a cell register.
                    """
                class display(TUIMethod):
                    """
                    Displays a cell register.
                    """
                class edit(TUIMethod):
                    """
                    Edit an object.
                    """
                class list(TUIMethod):
                    """
                    Lists all of the currently defined cell registers.
                    """
                class list_properties(TUIMethod):
                    """
                    Lists the properties of a cell register.
                    """
                class refine(TUIMethod):
                    """
                    Refine the mesh based on a cell register.
                    """

            class geometry(TUIMenu):
                """
                Enters the geometry menu. Note that this text command menu is not available unless the adaption method is set to hanging node.
                """
                def __init__(self, service, version, mode, path):
                    self.manage = self.__class__.manage(service, version, mode, path + ["manage"])
                    self.reconstruct_geometry = self.__class__.reconstruct_geometry(service, version, mode, path + ["reconstruct_geometry"])
                    self.set_geometry_controls = self.__class__.set_geometry_controls(service, version, mode, path + ["set_geometry_controls"])
                    super().__init__(service, version, mode, path)
                class reconstruct_geometry(TUIMethod):
                    """
                    Enables/disables geometry-based adaption.
                    """
                class set_geometry_controls(TUIMethod):
                    """
                    Sets geometry controls for wall zones.
                    """

                class manage(TUIMenu):
                    """
                    Manage geometry-based adaption.
                    """
                    def __init__(self, service, version, mode, path):
                        self.add = self.__class__.add(service, version, mode, path + ["add"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        super().__init__(service, version, mode, path)
                    class add(TUIMethod):
                        """
                        Add a new object.
                        """
                    class delete(TUIMethod):
                        """
                        Delete an object.
                        """
                    class edit(TUIMethod):
                        """
                        Edit an object.
                        """
                    class list(TUIMethod):
                        """
                        List objects.
                        """
                    class list_properties(TUIMethod):
                        """
                        List properties of an object.
                        """

            class manage_criteria(TUIMenu):
                """
                Enters the manage criteria menu, which provides text commands for managing automatic adaption criteria.
                """
                def __init__(self, service, version, mode, path):
                    self.add = self.__class__.add(service, version, mode, path + ["add"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    super().__init__(service, version, mode, path)
                class add(TUIMethod):
                    """
                    Adds a new automatic adaption criterion.
                    """
                class delete(TUIMethod):
                    """
                    Deletes an existing automatic adaption criterion.
                    """
                class edit(TUIMethod):
                    """
                    Edits an existing automatic adaption criterion.
                    """
                class list(TUIMethod):
                    """
                    Lists all the existing automatic adaption criteria.
                    """
                class list_properties(TUIMethod):
                    """
                    Lists the properties of an existing automatic adaption criterion.
                    """

            class multi_layer_refinement(TUIMenu):
                """
                Enter the multiple boundary layer refinement menu.
                """
                def __init__(self, service, version, mode, path):
                    self.boundary_zones = self.__class__.boundary_zones(service, version, mode, path + ["boundary_zones"])
                    self.layer_count = self.__class__.layer_count(service, version, mode, path + ["layer_count"])
                    self.parameters = self.__class__.parameters(service, version, mode, path + ["parameters"])
                    self.refine_mesh = self.__class__.refine_mesh(service, version, mode, path + ["refine_mesh"])
                    super().__init__(service, version, mode, path)
                class boundary_zones(TUIMethod):
                    """
                    Specify boundary zones for refinement.
                    """
                class layer_count(TUIMethod):
                    """
                    Specify the layer count for refinement.
                    """
                class parameters(TUIMethod):
                    """
                    Specify parameters for multiple boundary layer refinement.
                    """
                class refine_mesh(TUIMethod):
                    """
                    Refine the mesh for multiple boundary layers.
                    """

            class profile(TUIMenu):
                """
                Enters the profile menu.
                """
                def __init__(self, service, version, mode, path):
                    self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                    self.disable = self.__class__.disable(service, version, mode, path + ["disable"])
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.print = self.__class__.print(service, version, mode, path + ["print"])
                    super().__init__(service, version, mode, path)
                class clear(TUIMethod):
                    """
                    Clears the adaption profiling counters.
                    """
                class disable(TUIMethod):
                    """
                    Disables adaption profiling.
                    """
                class enable(TUIMethod):
                    """
                    Enables adaption profiling.
                    """
                class print(TUIMethod):
                    """
                    Prints adaption profiling results.
                    """

            class set(TUIMenu):
                """
                Enters the set menu.
                """
                def __init__(self, service, version, mode, path):
                    self.additional_refinement_layers = self.__class__.additional_refinement_layers(service, version, mode, path + ["additional_refinement_layers"])
                    self.cell_zones = self.__class__.cell_zones(service, version, mode, path + ["cell_zones"])
                    self.display_settings = self.__class__.display_settings(service, version, mode, path + ["display_settings"])
                    self.dynamic_adaption = self.__class__.dynamic_adaption(service, version, mode, path + ["dynamic_adaption"])
                    self.dynamic_adaption_frequency = self.__class__.dynamic_adaption_frequency(service, version, mode, path + ["dynamic_adaption_frequency"])
                    self.encapsulate_children = self.__class__.encapsulate_children(service, version, mode, path + ["encapsulate_children"])
                    self.maximum_cell_count = self.__class__.maximum_cell_count(service, version, mode, path + ["maximum_cell_count"])
                    self.maximum_refinement_level = self.__class__.maximum_refinement_level(service, version, mode, path + ["maximum_refinement_level"])
                    self.method = self.__class__.method(service, version, mode, path + ["method"])
                    self.minimum_cell_quality = self.__class__.minimum_cell_quality(service, version, mode, path + ["minimum_cell_quality"])
                    self.minimum_cell_volume = self.__class__.minimum_cell_volume(service, version, mode, path + ["minimum_cell_volume"])
                    self.minimum_edge_length = self.__class__.minimum_edge_length(service, version, mode, path + ["minimum_edge_length"])
                    self.overset_adapt_dead_cells = self.__class__.overset_adapt_dead_cells(service, version, mode, path + ["overset_adapt_dead_cells"])
                    self.prismatic_adaption = self.__class__.prismatic_adaption(service, version, mode, path + ["prismatic_adaption"])
                    self.prismatic_boundary_zones = self.__class__.prismatic_boundary_zones(service, version, mode, path + ["prismatic_boundary_zones"])
                    self.prismatic_split_ratio = self.__class__.prismatic_split_ratio(service, version, mode, path + ["prismatic_split_ratio"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    super().__init__(service, version, mode, path)
                class additional_refinement_layers(TUIMethod):
                    """
                    Allows you to specify additional refinement layers (this is an advanced control).
                    """
                class cell_zones(TUIMethod):
                    """
                    Sets cell zones to be used for marking adaption. An empty list specifies that all zones are considered for adaption.
                    """
                class display_settings(TUIMethod):
                    """
                    Sets the graphics display options for the refinement, coarsening, and common cells.
                    """
                class dynamic_adaption(TUIMethod):
                    """
                    .
                    """
                class dynamic_adaption_frequency(TUIMethod):
                    """
                    .
                    """
                class encapsulate_children(TUIMethod):
                    """
                    .
                    """
                class maximum_cell_count(TUIMethod):
                    """
                    Sets an approximate limit to the total cell count of the mesh during adaption. Fluent uses this value to determine when to stop marking cells for refinement. A value of zero places no limits on the number of cells.
                    """
                class maximum_refinement_level(TUIMethod):
                    """
                    Controls the number of levels of refinement used to split cells during the adaption.
                    """
                class method(TUIMethod):
                    """
                    Sets the adaption method.
                    """
                class minimum_cell_quality(TUIMethod):
                    """
                    Sets the minimum value allowed for the orthogonal quality of cells during adaption. If your solution diverges, you may find that using a higher minimum quality value resolves the issue. This text command is only available with the PUMA 3D adaption method.
                    """
                class minimum_cell_volume(TUIMethod):
                    """
                    Set limit on the minimum volume of cells in the mesh.
                    """
                class minimum_edge_length(TUIMethod):
                    """
                    Sets an approximate limit to the edge length for cells that are considered for refinement. Even if a cell is marked for refinement, it will not be refined if (for 3D) its volume is less than the cube of this field or (for 2D) its area is less than the square of this field. The default value of zero places no limits on the size of cells that are refined.
                    """
                class overset_adapt_dead_cells(TUIMethod):
                    """
                    Enables/disables the adaption of dead cells in overset meshes.
                    """
                class prismatic_adaption(TUIMethod):
                    """
                    .
                    """
                class prismatic_boundary_zones(TUIMethod):
                    """
                    .
                    """
                class prismatic_split_ratio(TUIMethod):
                    """
                    .
                    """
                class verbosity(TUIMethod):
                    """
                    Allows you set how much information about the adaption is printed to the console.
                    """

        class anisotropic_adaption(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.indicator = self.__class__.indicator(service, version, mode, path + ["indicator"])
                self.operations = self.__class__.operations(service, version, mode, path + ["operations"])
                self.target = self.__class__.target(service, version, mode, path + ["target"])
                self.adapt_mesh = self.__class__.adapt_mesh(service, version, mode, path + ["adapt_mesh"])
                self.fixed_zones = self.__class__.fixed_zones(service, version, mode, path + ["fixed_zones"])
                self.iterations = self.__class__.iterations(service, version, mode, path + ["iterations"])
                self.maximum_anisotropic_ratio = self.__class__.maximum_anisotropic_ratio(service, version, mode, path + ["maximum_anisotropic_ratio"])
                self.minimum_cell_quality = self.__class__.minimum_cell_quality(service, version, mode, path + ["minimum_cell_quality"])
                self.minimum_edge_length = self.__class__.minimum_edge_length(service, version, mode, path + ["minimum_edge_length"])
                super().__init__(service, version, mode, path)
            class adapt_mesh(TUIMethod):
                """
                .
                """
            class fixed_zones(TUIMethod):
                """
                .
                """
            class iterations(TUIMethod):
                """
                .
                """
            class maximum_anisotropic_ratio(TUIMethod):
                """
                .
                """
            class minimum_cell_quality(TUIMethod):
                """
                .
                """
            class minimum_edge_length(TUIMethod):
                """
                .
                """

            class indicator(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.indicator_type = self.__class__.indicator_type(service, version, mode, path + ["indicator_type"])
                    self.multi_scalar_fn = self.__class__.multi_scalar_fn(service, version, mode, path + ["multi_scalar_fn"])
                    self.single_scalar_fn = self.__class__.single_scalar_fn(service, version, mode, path + ["single_scalar_fn"])
                    super().__init__(service, version, mode, path)
                class indicator_type(TUIMethod):
                    """
                    .
                    """
                class multi_scalar_fn(TUIMethod):
                    """
                    .
                    """
                class single_scalar_fn(TUIMethod):
                    """
                    .
                    """

            class operations(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.coarsen = self.__class__.coarsen(service, version, mode, path + ["coarsen"])
                    self.move = self.__class__.move(service, version, mode, path + ["move"])
                    self.refine = self.__class__.refine(service, version, mode, path + ["refine"])
                    self.swap = self.__class__.swap(service, version, mode, path + ["swap"])
                    super().__init__(service, version, mode, path)
                class coarsen(TUIMethod):
                    """
                    .
                    """
                class move(TUIMethod):
                    """
                    .
                    """
                class refine(TUIMethod):
                    """
                    .
                    """
                class swap(TUIMethod):
                    """
                    .
                    """

            class target(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.factor_of_cells = self.__class__.factor_of_cells(service, version, mode, path + ["factor_of_cells"])
                    self.number_of_cells = self.__class__.number_of_cells(service, version, mode, path + ["number_of_cells"])
                    self.target_type = self.__class__.target_type(service, version, mode, path + ["target_type"])
                    super().__init__(service, version, mode, path)
                class factor_of_cells(TUIMethod):
                    """
                    .
                    """
                class number_of_cells(TUIMethod):
                    """
                    .
                    """
                class target_type(TUIMethod):
                    """
                    .
                    """

        class geometry(TUIMenu):
            """
            Enter the auxiliary geometry menu.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                self.display_options = self.__class__.display_options(service, version, mode, path + ["display_options"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Add a new object.
                """
            class delete(TUIMethod):
                """
                Delete an object.
                """
            class display(TUIMethod):
                """
                Display geometry.
                """
            class display_options(TUIMethod):
                """
                Display options.
                """
            class edit(TUIMethod):
                """
                Edit an object.
                """
            class list(TUIMethod):
                """
                List objects.
                """
            class list_properties(TUIMethod):
                """
                List properties of an object.
                """

        class modify_zones(TUIMenu):
            """
            Enters the zone modification menu. For a description of the items in this menu, see define/boundary-conditions/modify-zones.
            """
            def __init__(self, service, version, mode, path):
                self.activate_cell_zone = self.__class__.activate_cell_zone(service, version, mode, path + ["activate_cell_zone"])
                self.append_mesh = self.__class__.append_mesh(service, version, mode, path + ["append_mesh"])
                self.append_mesh_data = self.__class__.append_mesh_data(service, version, mode, path + ["append_mesh_data"])
                self.change_zone_state = self.__class__.change_zone_state(service, version, mode, path + ["change_zone_state"])
                self.convert_all_solid_mrf_to_solid_motion = self.__class__.convert_all_solid_mrf_to_solid_motion(service, version, mode, path + ["convert_all_solid_mrf_to_solid_motion"])
                self.copy_mesh_to_mrf_motion = self.__class__.copy_mesh_to_mrf_motion(service, version, mode, path + ["copy_mesh_to_mrf_motion"])
                self.copy_move_cell_zone = self.__class__.copy_move_cell_zone(service, version, mode, path + ["copy_move_cell_zone"])
                self.copy_mrf_to_mesh_motion = self.__class__.copy_mrf_to_mesh_motion(service, version, mode, path + ["copy_mrf_to_mesh_motion"])
                self.create_all_shell_threads = self.__class__.create_all_shell_threads(service, version, mode, path + ["create_all_shell_threads"])
                self.create_periodic_interface = self.__class__.create_periodic_interface(service, version, mode, path + ["create_periodic_interface"])
                self.deactivate_cell_zone = self.__class__.deactivate_cell_zone(service, version, mode, path + ["deactivate_cell_zone"])
                self.delete_all_shells = self.__class__.delete_all_shells(service, version, mode, path + ["delete_all_shells"])
                self.delete_cell_zone = self.__class__.delete_cell_zone(service, version, mode, path + ["delete_cell_zone"])
                self.extrude_face_zone_delta = self.__class__.extrude_face_zone_delta(service, version, mode, path + ["extrude_face_zone_delta"])
                self.extrude_face_zone_para = self.__class__.extrude_face_zone_para(service, version, mode, path + ["extrude_face_zone_para"])
                self.fuse_face_zones = self.__class__.fuse_face_zones(service, version, mode, path + ["fuse_face_zones"])
                self.list_zones = self.__class__.list_zones(service, version, mode, path + ["list_zones"])
                self.make_periodic = self.__class__.make_periodic(service, version, mode, path + ["make_periodic"])
                self.matching_tolerance = self.__class__.matching_tolerance(service, version, mode, path + ["matching_tolerance"])
                self.merge_zones = self.__class__.merge_zones(service, version, mode, path + ["merge_zones"])
                self.mrf_to_sliding_mesh = self.__class__.mrf_to_sliding_mesh(service, version, mode, path + ["mrf_to_sliding_mesh"])
                self.orient_face_zone = self.__class__.orient_face_zone(service, version, mode, path + ["orient_face_zone"])
                self.recreate_all_shells = self.__class__.recreate_all_shells(service, version, mode, path + ["recreate_all_shells"])
                self.replace_zone = self.__class__.replace_zone(service, version, mode, path + ["replace_zone"])
                self.rotate_zone = self.__class__.rotate_zone(service, version, mode, path + ["rotate_zone"])
                self.scale_zone = self.__class__.scale_zone(service, version, mode, path + ["scale_zone"])
                self.sep_cell_zone_mark = self.__class__.sep_cell_zone_mark(service, version, mode, path + ["sep_cell_zone_mark"])
                self.sep_cell_zone_region = self.__class__.sep_cell_zone_region(service, version, mode, path + ["sep_cell_zone_region"])
                self.sep_face_zone_angle = self.__class__.sep_face_zone_angle(service, version, mode, path + ["sep_face_zone_angle"])
                self.sep_face_zone_face = self.__class__.sep_face_zone_face(service, version, mode, path + ["sep_face_zone_face"])
                self.sep_face_zone_mark = self.__class__.sep_face_zone_mark(service, version, mode, path + ["sep_face_zone_mark"])
                self.sep_face_zone_region = self.__class__.sep_face_zone_region(service, version, mode, path + ["sep_face_zone_region"])
                self.slit_face_zone = self.__class__.slit_face_zone(service, version, mode, path + ["slit_face_zone"])
                self.slit_interior_between_diff_solids = self.__class__.slit_interior_between_diff_solids(service, version, mode, path + ["slit_interior_between_diff_solids"])
                self.slit_periodic = self.__class__.slit_periodic(service, version, mode, path + ["slit_periodic"])
                self.translate_zone = self.__class__.translate_zone(service, version, mode, path + ["translate_zone"])
                self.zone_name = self.__class__.zone_name(service, version, mode, path + ["zone_name"])
                self.zone_type = self.__class__.zone_type(service, version, mode, path + ["zone_type"])
                super().__init__(service, version, mode, path)
            class activate_cell_zone(TUIMethod):
                """
                .
                """
            class append_mesh(TUIMethod):
                """
                .
                """
            class append_mesh_data(TUIMethod):
                """
                .
                """
            class change_zone_state(TUIMethod):
                """
                .
                """
            class convert_all_solid_mrf_to_solid_motion(TUIMethod):
                """
                .
                """
            class copy_mesh_to_mrf_motion(TUIMethod):
                """
                Copy motion variable values for origin, axis and velocities from Mesh Motion to Frame Motion.
                """
            class copy_move_cell_zone(TUIMethod):
                """
                .
                """
            class copy_mrf_to_mesh_motion(TUIMethod):
                """
                Copy motion variable values for origin, axis and velocities from Frame Motion to Mesh Motion.
                """
            class create_all_shell_threads(TUIMethod):
                """
                .
                """
            class create_periodic_interface(TUIMethod):
                """
                .
                """
            class deactivate_cell_zone(TUIMethod):
                """
                .
                """
            class delete_all_shells(TUIMethod):
                """
                .
                """
            class delete_cell_zone(TUIMethod):
                """
                .
                """
            class extrude_face_zone_delta(TUIMethod):
                """
                .
                """
            class extrude_face_zone_para(TUIMethod):
                """
                .
                """
            class fuse_face_zones(TUIMethod):
                """
                .
                """
            class list_zones(TUIMethod):
                """
                .
                """
            class make_periodic(TUIMethod):
                """
                Attempt to establish conformal periodic face zone connectivity.
                """
            class matching_tolerance(TUIMethod):
                """
                .
                """
            class merge_zones(TUIMethod):
                """
                .
                """
            class mrf_to_sliding_mesh(TUIMethod):
                """
                .
                """
            class orient_face_zone(TUIMethod):
                """
                .
                """
            class recreate_all_shells(TUIMethod):
                """
                .
                """
            class replace_zone(TUIMethod):
                """
                .
                """
            class rotate_zone(TUIMethod):
                """
                .
                """
            class scale_zone(TUIMethod):
                """
                .
                """
            class sep_cell_zone_mark(TUIMethod):
                """
                .
                """
            class sep_cell_zone_region(TUIMethod):
                """
                .
                """
            class sep_face_zone_angle(TUIMethod):
                """
                .
                """
            class sep_face_zone_face(TUIMethod):
                """
                .
                """
            class sep_face_zone_mark(TUIMethod):
                """
                .
                """
            class sep_face_zone_region(TUIMethod):
                """
                .
                """
            class slit_face_zone(TUIMethod):
                """
                .
                """
            class slit_interior_between_diff_solids(TUIMethod):
                """
                .
                """
            class slit_periodic(TUIMethod):
                """
                .
                """
            class translate_zone(TUIMethod):
                """
                .
                """
            class zone_name(TUIMethod):
                """
                .
                """
            class zone_type(TUIMethod):
                """
                Set a zone's type.
                """

        class polyhedra(TUIMenu):
            """
            Enters the polyhedra menu.
            """
            def __init__(self, service, version, mode, path):
                self.options = self.__class__.options(service, version, mode, path + ["options"])
                self.convert_domain = self.__class__.convert_domain(service, version, mode, path + ["convert_domain"])
                self.convert_hanging_nodes = self.__class__.convert_hanging_nodes(service, version, mode, path + ["convert_hanging_nodes"])
                self.convert_hanging_nodes_zones = self.__class__.convert_hanging_nodes_zones(service, version, mode, path + ["convert_hanging_nodes_zones"])
                self.convert_skewed_cells = self.__class__.convert_skewed_cells(service, version, mode, path + ["convert_skewed_cells"])
                super().__init__(service, version, mode, path)
            class convert_domain(TUIMethod):
                """
                Converts the entire domain to polyhedra cells.
                """
            class convert_hanging_nodes(TUIMethod):
                """
                Converts cells with hanging nodes/edges to polyhedra.
                """
            class convert_hanging_nodes_zones(TUIMethod):
                """
                Convert selected cell zones with hanging nodes and faces to polyhedra.
                The selected cell zones cannot be connected to other zones.
                """
            class convert_skewed_cells(TUIMethod):
                """
                Converts skewed cells to polyhedra.
                """

            class options(TUIMenu):
                """
                Enters the polyhedra options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.migrate_and_reorder = self.__class__.migrate_and_reorder(service, version, mode, path + ["migrate_and_reorder"])
                    self.preserve_boundary_layer = self.__class__.preserve_boundary_layer(service, version, mode, path + ["preserve_boundary_layer"])
                    self.preserve_interior_zones = self.__class__.preserve_interior_zones(service, version, mode, path + ["preserve_interior_zones"])
                    super().__init__(service, version, mode, path)
                class migrate_and_reorder(TUIMethod):
                    """
                    Enables / disables the migration of newly created partitions to the compute-nodes and the reordering of the domain as part of polyhedra conversion. This is disabled by default, because it requires significant additional memory; when disabled, it is recommended that you save the case file after conversion, read it in a new Fluent session (so that the new / stored partitions become active), and then manually reorder using the mesh/reorder/reorder-domain text command. If you want to run the calculation in the current Fluent session you can enable the migrate-and-reorder? text command prior to conversion, but you must ensure that no more than half of the available memory of your system is currently used.
                    """
                class preserve_boundary_layer(TUIMethod):
                    """
                    Specifies whether boundary layer cells will be preserved when the domain is converted to polyhedra. When the value is set to 0 (default) ANSYS Fluent checks for high aspect ratio cells at the boundary layer and if any are found, Fluent asks if you want to preserve the boundary layer. When the value is set to 1, the boundary layer cells are never preserved; when it is set to 2, the boundary layer cells are always preserved (regardless of the aspect ratio of the boundary layer cells).
                    """
                class preserve_interior_zones(TUIMethod):
                    """
                    Enables the preservation of surfaces (that is, manifold zones of type interior) during the conversion of the domain to polyhedra. Note that only those zones with a name that includes the string you specify will be preserved.
                    """

        class reorder(TUIMenu):
            """
            Reorders domain menu.
            """
            def __init__(self, service, version, mode, path):
                self.band_width = self.__class__.band_width(service, version, mode, path + ["band_width"])
                self.reorder_domain = self.__class__.reorder_domain(service, version, mode, path + ["reorder_domain"])
                self.reorder_zones = self.__class__.reorder_zones(service, version, mode, path + ["reorder_zones"])
                super().__init__(service, version, mode, path)
            class band_width(TUIMethod):
                """
                Prints cell bandwidth.
                """
            class reorder_domain(TUIMethod):
                """
                Reorders cells and faces using the reverse Cuthill-McKee algorithm. Note that you must save a new case file (and a data file, if data exists) after reordering with this text command, as well as recreate any ray files and/or surface cluster information.
                """
            class reorder_zones(TUIMethod):
                """
                Reorders zones by partition, type, and ID.
                """

        class repair_improve(TUIMenu):
            """
            Enter the repair and improve quality menu.
            """
            def __init__(self, service, version, mode, path):
                self.allow_repair_at_boundaries = self.__class__.allow_repair_at_boundaries(service, version, mode, path + ["allow_repair_at_boundaries"])
                self.improve_quality = self.__class__.improve_quality(service, version, mode, path + ["improve_quality"])
                self.include_local_polyhedra_conversion_in_repair = self.__class__.include_local_polyhedra_conversion_in_repair(service, version, mode, path + ["include_local_polyhedra_conversion_in_repair"])
                self.repair = self.__class__.repair(service, version, mode, path + ["repair"])
                self.repair_face_handedness = self.__class__.repair_face_handedness(service, version, mode, path + ["repair_face_handedness"])
                self.repair_face_node_order = self.__class__.repair_face_node_order(service, version, mode, path + ["repair_face_node_order"])
                self.repair_periodic = self.__class__.repair_periodic(service, version, mode, path + ["repair_periodic"])
                self.repair_wall_distance = self.__class__.repair_wall_distance(service, version, mode, path + ["repair_wall_distance"])
                self.report_poor_elements = self.__class__.report_poor_elements(service, version, mode, path + ["report_poor_elements"])
                super().__init__(service, version, mode, path)
            class allow_repair_at_boundaries(TUIMethod):
                """
                Allows the adjustment of the positions of nodes on boundaries as part of the mesh repairs performed by the mesh/repair-improve/repair text command.
                """
            class improve_quality(TUIMethod):
                """
                Improves poor quality cells in the mesh, if possible.
                """
            class include_local_polyhedra_conversion_in_repair(TUIMethod):
                """
                Enables/disables the local conversion of degenerate cells into polyhedra based on skewness criteria as part of the mesh repairs performed by the  mesh/repair-improve/repair text command.
                """
            class repair(TUIMethod):
                """
                Repairs mesh problems identified by the mesh check, if possible. The repairs include fixing cells that have the wrong node order, the wrong face handedness, faces that are small or nonexistent, or very poor quality. Only interior nodes are repositioned by default; boundary nodes may be repositioned if the  mesh/repair-improve/allow-repair-at-boundaries text command is enabled. Note that highly skewed cells may be converted into polyhedra, depending on whether the  mesh/repair-improve/include-local-polyhedra-conversion-in-repair text command is enabled.
                """
            class repair_face_handedness(TUIMethod):
                """
                Modifies cell centroids to repair meshes that contain left-handed faces without face node order problems.
                """
            class repair_face_node_order(TUIMethod):
                """
                Modifies face nodes to repair faces with improper face node order and, therefore, eliminates any resulting left-handed faces.
                """
            class repair_periodic(TUIMethod):
                """
                Modifies the mesh to enforce a rotational angle or translational distance for periodic boundaries. For translationally periodic boundaries, the command computes an average translation distance and adjusts the node coordinates on the shadow face zone to match this distance. For rotationally periodic boundaries, the command prompts for an angle and adjusts the node coordinates on the shadow face zone using this angle and the defined rotational axis for the cell zone.
                """
            class repair_wall_distance(TUIMethod):
                """
                Corrects wall distance at very high aspect ratio hexahedral/polyhedral cells.
                """
            class report_poor_elements(TUIMethod):
                """
                Reports invalid and poor quality elements.
                """

        class surface_mesh(TUIMenu):
            """
            Enters the Surface Mesh menu.
            """
            def __init__(self, service, version, mode, path):
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                self.read = self.__class__.read(service, version, mode, path + ["read"])
                super().__init__(service, version, mode, path)
            class delete(TUIMethod):
                """
                Deletes surface mesh.
                """
            class display(TUIMethod):
                """
                Displays surface meshes.
                """
            class read(TUIMethod):
                """
                Reads surface meshes.
                """

    class parallel(TUIMenu):
        """
        Enter the parallel processing menu.
        """
        def __init__(self, service, version, mode, path):
            self.gpgpu = self.__class__.gpgpu(service, version, mode, path + ["gpgpu"])
            self.load_balance = self.__class__.load_balance(service, version, mode, path + ["load_balance"])
            self.multidomain = self.__class__.multidomain(service, version, mode, path + ["multidomain"])
            self.network = self.__class__.network(service, version, mode, path + ["network"])
            self.partition = self.__class__.partition(service, version, mode, path + ["partition"])
            self.set = self.__class__.set(service, version, mode, path + ["set"])
            self.timer = self.__class__.timer(service, version, mode, path + ["timer"])
            self.bandwidth = self.__class__.bandwidth(service, version, mode, path + ["bandwidth"])
            self.check = self.__class__.check(service, version, mode, path + ["check"])
            self.check_verbosity = self.__class__.check_verbosity(service, version, mode, path + ["check_verbosity"])
            self.latency = self.__class__.latency(service, version, mode, path + ["latency"])
            self.show_connectivity = self.__class__.show_connectivity(service, version, mode, path + ["show_connectivity"])
            self.thread_number_control = self.__class__.thread_number_control(service, version, mode, path + ["thread_number_control"])
            super().__init__(service, version, mode, path)
        class bandwidth(TUIMethod):
            """
            Shows network bandwidth.
            """
        class check(TUIMethod):
            """
            Performs checks of various factors that affect parallel performance.
            """
        class check_verbosity(TUIMethod):
            """
            Sets verbosity output of the parallel check. Higher verbosity corresponds to more detailed information.
            """
        class latency(TUIMethod):
            """
            Shows network latency.
            """
        class show_connectivity(TUIMethod):
            """
            Prints the network connectivity for the selected compute node.
            """
        class thread_number_control(TUIMethod):
            """
            .
            """

        class gpgpu(TUIMenu):
            """
            Enters the GPGPU menu.
            """
            def __init__(self, service, version, mode, path):
                self.select = self.__class__.select(service, version, mode, path + ["select"])
                self.show = self.__class__.show(service, version, mode, path + ["show"])
                super().__init__(service, version, mode, path)
            class select(TUIMethod):
                """
                Selects which GPGPUs to use for AMG acceleration.
                """
            class show(TUIMethod):
                """
                Lists the available GPGPUs. GPGPUs selected for use are indicated by the presence of an asterisk (\\*).
                """

        class load_balance(TUIMenu):
            """
            Enters the load balancing parameters menu.
            """
            def __init__(self, service, version, mode, path):
                self.dynamic_mesh = self.__class__.dynamic_mesh(service, version, mode, path + ["dynamic_mesh"])
                self.mesh_adaption = self.__class__.mesh_adaption(service, version, mode, path + ["mesh_adaption"])
                self.physical_models = self.__class__.physical_models(service, version, mode, path + ["physical_models"])
                super().__init__(service, version, mode, path)
            class dynamic_mesh(TUIMethod):
                """
                Uses load balancing for dynamic mesh?.
                """
            class mesh_adaption(TUIMethod):
                """
                Uses load balancing for mesh adaption?.
                """
            class physical_models(TUIMethod):
                """
                Uses physical-models load balancing?.
                """

        class multidomain(TUIMenu):
            """
            Enters the multidomain architecture menu.
            """
            def __init__(self, service, version, mode, path):
                self.conjugate_heat_transfer = self.__class__.conjugate_heat_transfer(service, version, mode, path + ["conjugate_heat_transfer"])
                self.solve = self.__class__.solve(service, version, mode, path + ["solve"])
                super().__init__(service, version, mode, path)

            class conjugate_heat_transfer(TUIMenu):
                """
                Enters the conjugate heat transfer menu.
                """
                def __init__(self, service, version, mode, path):
                    self.set = self.__class__.set(service, version, mode, path + ["set"])
                    self.enabled = self.__class__.enabled(service, version, mode, path + ["enabled"])
                    super().__init__(service, version, mode, path)
                class enabled(TUIMethod):
                    """
                    .
                    """

                class set(TUIMenu):
                    """
                    Enters the set menu for loosely coupled conjugate heat transfer.
                    """
                    def __init__(self, service, version, mode, path):
                        self.helper_session_setup = self.__class__.helper_session_setup(service, version, mode, path + ["helper_session_setup"])
                        self.coupling = self.__class__.coupling(service, version, mode, path + ["coupling"])
                        self.helper_session = self.__class__.helper_session(service, version, mode, path + ["helper_session"])
                        super().__init__(service, version, mode, path)
                    class coupling(TUIMethod):
                        """
                        Specifies when the fluid and solid zone calculations are coupled,  either at a defined time period or number of fluid time steps.
                        """
                    class helper_session(TUIMethod):
                        """
                        .
                        """

                    class helper_session_setup(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.host_name = self.__class__.host_name(service, version, mode, path + ["host_name"])
                            self.process_count = self.__class__.process_count(service, version, mode, path + ["process_count"])
                            super().__init__(service, version, mode, path)
                        class host_name(TUIMethod):
                            """
                            .
                            """
                        class process_count(TUIMethod):
                            """
                            .
                            """

            class solve(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.dual_time_iterate = self.__class__.dual_time_iterate(service, version, mode, path + ["dual_time_iterate"])
                    self.iterate = self.__class__.iterate(service, version, mode, path + ["iterate"])
                    super().__init__(service, version, mode, path)
                class dual_time_iterate(TUIMethod):
                    """
                    .
                    """
                class iterate(TUIMethod):
                    """
                    .
                    """

        class network(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.kill_all_nodes = self.__class__.kill_all_nodes(service, version, mode, path + ["kill_all_nodes"])
                self.kill_node = self.__class__.kill_node(service, version, mode, path + ["kill_node"])
                self.load_hosts = self.__class__.load_hosts(service, version, mode, path + ["load_hosts"])
                self.save_hosts = self.__class__.save_hosts(service, version, mode, path + ["save_hosts"])
                self.shell_script_path = self.__class__.shell_script_path(service, version, mode, path + ["shell_script_path"])
                self.spawn_node = self.__class__.spawn_node(service, version, mode, path + ["spawn_node"])
                super().__init__(service, version, mode, path)
            class kill_all_nodes(TUIMethod):
                """
                .
                """
            class kill_node(TUIMethod):
                """
                .
                """
            class load_hosts(TUIMethod):
                """
                .
                """
            class save_hosts(TUIMethod):
                """
                .
                """
            class shell_script_path(TUIMethod):
                """
                .
                """
            class spawn_node(TUIMethod):
                """
                .
                """

        class partition(TUIMenu):
            """
            Enters the partition domain menu.
            """
            def __init__(self, service, version, mode, path):
                self.automatic = self.__class__.automatic(service, version, mode, path + ["automatic"])
                self.set = self.__class__.set(service, version, mode, path + ["set"])
                self.combine_partition = self.__class__.combine_partition(service, version, mode, path + ["combine_partition"])
                self.merge_clusters = self.__class__.merge_clusters(service, version, mode, path + ["merge_clusters"])
                self.method = self.__class__.method(service, version, mode, path + ["method"])
                self.print_active_partitions = self.__class__.print_active_partitions(service, version, mode, path + ["print_active_partitions"])
                self.print_partitions = self.__class__.print_partitions(service, version, mode, path + ["print_partitions"])
                self.print_stored_partitions = self.__class__.print_stored_partitions(service, version, mode, path + ["print_stored_partitions"])
                self.reorder_partitions = self.__class__.reorder_partitions(service, version, mode, path + ["reorder_partitions"])
                self.reorder_partitions_to_architecture = self.__class__.reorder_partitions_to_architecture(service, version, mode, path + ["reorder_partitions_to_architecture"])
                self.smooth_partition = self.__class__.smooth_partition(service, version, mode, path + ["smooth_partition"])
                self.use_stored_partitions = self.__class__.use_stored_partitions(service, version, mode, path + ["use_stored_partitions"])
                super().__init__(service, version, mode, path)
            class combine_partition(TUIMethod):
                """
                Merges every N partitions.
                """
            class merge_clusters(TUIMethod):
                """
                Calls the optimizer that attempts to decrease the number of interfaces by eliminating orphan cell clusters. (An orphan cluster is a group of connected cells such that each member has at least one face that is part of an interface boundary.).
                """
            class method(TUIMethod):
                """
                Sets the partition method.
                """
            class print_active_partitions(TUIMethod):
                """
                Prints active partition information (parallel solver).
                """
            class print_partitions(TUIMethod):
                """
                .
                """
            class print_stored_partitions(TUIMethod):
                """
                Prints stored partition information (parallel solver).
                """
            class reorder_partitions(TUIMethod):
                """
                Reorders partitions.
                """
            class reorder_partitions_to_architecture(TUIMethod):
                """
                Reorders partitions to architecture.
                """
            class smooth_partition(TUIMethod):
                """
                Calls the optimizer that attempts to minimize the number of interfaces by modifying the partition boundaries to reduce surface area.
                """
            class use_stored_partitions(TUIMethod):
                """
                Uses this partitioning.
                """

            class automatic(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.across_zones = self.__class__.across_zones(service, version, mode, path + ["across_zones"])
                    self.load_vector = self.__class__.load_vector(service, version, mode, path + ["load_vector"])
                    self.method = self.__class__.method(service, version, mode, path + ["method"])
                    self.pre_test = self.__class__.pre_test(service, version, mode, path + ["pre_test"])
                    self.use_case_file_method = self.__class__.use_case_file_method(service, version, mode, path + ["use_case_file_method"])
                    super().__init__(service, version, mode, path)
                class across_zones(TUIMethod):
                    """
                    .
                    """
                class load_vector(TUIMethod):
                    """
                    .
                    """
                class method(TUIMethod):
                    """
                    .
                    """
                class pre_test(TUIMethod):
                    """
                    .
                    """
                class use_case_file_method(TUIMethod):
                    """
                    .
                    """

            class set(TUIMenu):
                """
                Enters the set partition parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self.partition_origin_vector = self.__class__.partition_origin_vector(service, version, mode, path + ["partition_origin_vector"])
                    self.across_zone_boundaries = self.__class__.across_zone_boundaries(service, version, mode, path + ["across_zone_boundaries"])
                    self.across_zones = self.__class__.across_zones(service, version, mode, path + ["across_zones"])
                    self.all_off = self.__class__.all_off(service, version, mode, path + ["all_off"])
                    self.all_on = self.__class__.all_on(service, version, mode, path + ["all_on"])
                    self.cell_function = self.__class__.cell_function(service, version, mode, path + ["cell_function"])
                    self.dpm_load_balancing = self.__class__.dpm_load_balancing(service, version, mode, path + ["dpm_load_balancing"])
                    self.face_area_as_weights = self.__class__.face_area_as_weights(service, version, mode, path + ["face_area_as_weights"])
                    self.fluid_solid_rebalance_after_read_case = self.__class__.fluid_solid_rebalance_after_read_case(service, version, mode, path + ["fluid_solid_rebalance_after_read_case"])
                    self.isat_weight = self.__class__.isat_weight(service, version, mode, path + ["isat_weight"])
                    self.laplace_smoothing = self.__class__.laplace_smoothing(service, version, mode, path + ["laplace_smoothing"])
                    self.layering = self.__class__.layering(service, version, mode, path + ["layering"])
                    self.load_distribution = self.__class__.load_distribution(service, version, mode, path + ["load_distribution"])
                    self.merge = self.__class__.merge(service, version, mode, path + ["merge"])
                    self.model_weighted_partition = self.__class__.model_weighted_partition(service, version, mode, path + ["model_weighted_partition"])
                    self.nfaces_as_weights = self.__class__.nfaces_as_weights(service, version, mode, path + ["nfaces_as_weights"])
                    self.origin = self.__class__.origin(service, version, mode, path + ["origin"])
                    self.particle_weight = self.__class__.particle_weight(service, version, mode, path + ["particle_weight"])
                    self.pre_test = self.__class__.pre_test(service, version, mode, path + ["pre_test"])
                    self.print_verbosity = self.__class__.print_verbosity(service, version, mode, path + ["print_verbosity"])
                    self.smooth = self.__class__.smooth(service, version, mode, path + ["smooth"])
                    self.solid_thread_weight = self.__class__.solid_thread_weight(service, version, mode, path + ["solid_thread_weight"])
                    self.stretched_mesh_enhancement = self.__class__.stretched_mesh_enhancement(service, version, mode, path + ["stretched_mesh_enhancement"])
                    self.vof_free_surface_weight = self.__class__.vof_free_surface_weight(service, version, mode, path + ["vof_free_surface_weight"])
                    super().__init__(service, version, mode, path)
                class across_zone_boundaries(TUIMethod):
                    """
                    .
                    """
                class across_zones(TUIMethod):
                    """
                    Allows partitions to cross zone boundaries (the default). If turned off, it will restrict partitioning to within each cell zone. This is recommended only when cells in different zones require significantly different amounts of computation during the solution phase; for example, if the domain contains both solid and fluid zones.
                    """
                class all_off(TUIMethod):
                    """
                    Disables all optimizations.
                    """
                class all_on(TUIMethod):
                    """
                    Enables all optimizations.
                    """
                class cell_function(TUIMethod):
                    """
                    Sets cell function.
                    """
                class dpm_load_balancing(TUIMethod):
                    """
                    Enables / disables dynamic load balancing for discrete phase model cases that use a second domain for DPM particle tracking (that is, cases for which you have enabled the define/models/dpm/parallel/hybrid-2domain? text command).
                    """
                class face_area_as_weights(TUIMethod):
                    """
                    Uses face area as connection weights.
                    """
                class fluid_solid_rebalance_after_read_case(TUIMethod):
                    """
                    .
                    """
                class isat_weight(TUIMethod):
                    """
                    Sets ISAT weight.
                    """
                class laplace_smoothing(TUIMethod):
                    """
                    .
                    """
                class layering(TUIMethod):
                    """
                    .
                    """
                class load_distribution(TUIMethod):
                    """
                    Sets the number of cells desired for each partition. This is useful, for example, when computing on multiple machines with significantly different performance characteristics. If left unset, each partition will contain an approximately equal number of cells. Normalized relative values may be used for the entries.
                    """
                class merge(TUIMethod):
                    """
                    Toggles the optimizer that attempts to decrease the number of interfaces by eliminating orphan cell clusters.
                    """
                class model_weighted_partition(TUIMethod):
                    """
                    Enables / disables model-weighted partitioning. This option works with the METIS partitioning method, and specifies that Fluent automatically calculates the weighting based on the cell count and the models and attributes specified as weights (using the parallel/partition/set/isat-weight text command, for example).
                    """
                class nfaces_as_weights(TUIMethod):
                    """
                    Uses number of faces as weights.
                    """
                class origin(TUIMethod):
                    """
                    Sets the , , and  coordinate of the origin used by those partitioning functions that require a radial distance. By default, the origin is set to (0, 0, 0).
                    """
                class particle_weight(TUIMethod):
                    """
                    Sets DPM particle weight.
                    """
                class pre_test(TUIMethod):
                    """
                    Enables the operation that determines the best coordinate-splitting direction.
                    """
                class print_verbosity(TUIMethod):
                    """
                    .
                    """
                class smooth(TUIMethod):
                    """
                    Toggles the optimizer that attempts to minimize the number of interfaces by modifying the partition boundaries to reduce surface area.
                    """
                class solid_thread_weight(TUIMethod):
                    """
                    Uses solid thread weights.
                    """
                class stretched_mesh_enhancement(TUIMethod):
                    """
                    .
                    """
                class vof_free_surface_weight(TUIMethod):
                    """
                    Sets VOF free surface weight.
                    """

                class partition_origin_vector(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.number_of_objects = self.__class__.number_of_objects(service, version, mode, path + ["number_of_objects"])
                        super().__init__(service, version, mode, path)
                    class edit(TUIMethod):
                        """
                        Edit partition-origin-vector object.
                        """
                    class list_properties(TUIMethod):
                        """
                        .
                        """
                    class number_of_objects(TUIMethod):
                        """
                        Set number of objects for partition-origin-vector.
                        """

        class set(TUIMenu):
            """
            Enters the set parallel parameters menu.
            """
            def __init__(self, service, version, mode, path):
                self.fast_io = self.__class__.fast_io(service, version, mode, path + ["fast_io"])
                self.partition_mask = self.__class__.partition_mask(service, version, mode, path + ["partition_mask"])
                self.time_out = self.__class__.time_out(service, version, mode, path + ["time_out"])
                self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                super().__init__(service, version, mode, path)
            class fast_io(TUIMethod):
                """
                .
                """
            class partition_mask(TUIMethod):
                """
                Sets partition mask.
                """
            class time_out(TUIMethod):
                """
                Sets spawn time-out in seconds.
                """
            class verbosity(TUIMethod):
                """
                Sets the parallel verbosity.
                """

        class timer(TUIMenu):
            """
            Enters the timer menu.
            """
            def __init__(self, service, version, mode, path):
                self.reset = self.__class__.reset(service, version, mode, path + ["reset"])
                self.usage = self.__class__.usage(service, version, mode, path + ["usage"])
                super().__init__(service, version, mode, path)
            class reset(TUIMethod):
                """
                Adjusts domain timers.
                """
            class usage(TUIMethod):
                """
                Prints performance statistics in the console window.
                """

    class parameters(TUIMenu):
        """
        .
        """
        def __init__(self, service, version, mode, path):
            self.input_parameters = self.__class__.input_parameters(service, version, mode, path + ["input_parameters"])
            self.output_parameters = self.__class__.output_parameters(service, version, mode, path + ["output_parameters"])
            self.enable_in_tui = self.__class__.enable_in_tui(service, version, mode, path + ["enable_in_tui"])
            super().__init__(service, version, mode, path)
        class enable_in_tui(TUIMethod):
            """
            .
            """

        class input_parameters(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.expression = self.__class__.expression(service, version, mode, path + ["expression"])
                self.scheme_proc = self.__class__.scheme_proc(service, version, mode, path + ["scheme_proc"])
                self.udf_side = self.__class__.udf_side(service, version, mode, path + ["udf_side"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                super().__init__(service, version, mode, path)
            class list(TUIMethod):
                """
                .
                """

            class expression(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new expression object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit expression object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename expression object.
                    """

            class scheme_proc(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new scheme-proc object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit scheme-proc object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename scheme-proc object.
                    """

            class udf_side(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new udf-side object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit udf-side object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename udf-side object.
                    """

        class output_parameters(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.report_definitions = self.__class__.report_definitions(service, version, mode, path + ["report_definitions"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.print_all_to_console = self.__class__.print_all_to_console(service, version, mode, path + ["print_all_to_console"])
                self.write_all_to_file = self.__class__.write_all_to_file(service, version, mode, path + ["write_all_to_file"])
                super().__init__(service, version, mode, path)
            class list(TUIMethod):
                """
                .
                """
            class print_all_to_console(TUIMethod):
                """
                .
                """
            class write_all_to_file(TUIMethod):
                """
                .
                """

            class report_definitions(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.print_to_console = self.__class__.print_to_console(service, version, mode, path + ["print_to_console"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    self.write_to_file = self.__class__.write_to_file(service, version, mode, path + ["write_to_file"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new report-definitions object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit report-definitions object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class print_to_console(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename report-definitions object.
                    """
                class write_to_file(TUIMethod):
                    """
                    .
                    """

    class parametric_study(TUIMenu):
        """
        Enter the parametric study menu.
        """
        def __init__(self, service, version, mode, path):
            self.design_points = self.__class__.design_points(service, version, mode, path + ["design_points"])
            self.study = self.__class__.study(service, version, mode, path + ["study"])
            self.update = self.__class__.update(service, version, mode, path + ["update"])
            self.case_settings_changed = self.__class__.case_settings_changed(service, version, mode, path + ["case_settings_changed"])
            self.delete_study = self.__class__.delete_study(service, version, mode, path + ["delete_study"])
            self.duplicate_study = self.__class__.duplicate_study(service, version, mode, path + ["duplicate_study"])
            self.export_design_table = self.__class__.export_design_table(service, version, mode, path + ["export_design_table"])
            self.import_design_table = self.__class__.import_design_table(service, version, mode, path + ["import_design_table"])
            self.initialize = self.__class__.initialize(service, version, mode, path + ["initialize"])
            self.list_studies = self.__class__.list_studies(service, version, mode, path + ["list_studies"])
            self.rename_study = self.__class__.rename_study(service, version, mode, path + ["rename_study"])
            self.set_as_current_study = self.__class__.set_as_current_study(service, version, mode, path + ["set_as_current_study"])
            self.use_base_data = self.__class__.use_base_data(service, version, mode, path + ["use_base_data"])
            super().__init__(service, version, mode, path)
        class case_settings_changed(TUIMethod):
            """
            Check if case settings are changed.
            """
        class delete_study(TUIMethod):
            """
            Delete Study.
            """
        class duplicate_study(TUIMethod):
            """
            Duplicate Parametric Study.
            """
        class export_design_table(TUIMethod):
            """
            Export Design Point Table.
            """
        class import_design_table(TUIMethod):
            """
            Import Design Point Table.
            """
        class initialize(TUIMethod):
            """
            Start Parametric Study.
            """
        class list_studies(TUIMethod):
            """
            List Studies.
            """
        class rename_study(TUIMethod):
            """
            Rename Study.
            """
        class set_as_current_study(TUIMethod):
            """
            Set As Current Study.
            """
        class use_base_data(TUIMethod):
            """
            Use Base Data.
            """

        class design_points(TUIMenu):
            """
            Enter the design points menu.
            """
            def __init__(self, service, version, mode, path):
                self.auto_create = self.__class__.auto_create(service, version, mode, path + ["auto_create"])
                self.concurrent = self.__class__.concurrent(service, version, mode, path + ["concurrent"])
                self.print_to_console = self.__class__.print_to_console(service, version, mode, path + ["print_to_console"])
                self.set = self.__class__.set(service, version, mode, path + ["set"])
                self.table = self.__class__.table(service, version, mode, path + ["table"])
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.clear_data_and_edit_values = self.__class__.clear_data_and_edit_values(service, version, mode, path + ["clear_data_and_edit_values"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.duplicate = self.__class__.duplicate(service, version, mode, path + ["duplicate"])
                self.load_case_data_for_current_dp = self.__class__.load_case_data_for_current_dp(service, version, mode, path + ["load_case_data_for_current_dp"])
                self.save_journals = self.__class__.save_journals(service, version, mode, path + ["save_journals"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Add new design point.
                """
            class clear_data_and_edit_values(TUIMethod):
                """
                Clear Generated Data.
                """
            class delete(TUIMethod):
                """
                Delete Design Point.
                """
            class duplicate(TUIMethod):
                """
                Duplicate Design Point.
                """
            class load_case_data_for_current_dp(TUIMethod):
                """
                Loads relevant case/data file for current design point.
                """
            class save_journals(TUIMethod):
                """
                Save Journals.
                """

            class auto_create(TUIMenu):
                """
                Enter the auto-crate design points menu.
                """
                def __init__(self, service, version, mode, path):
                    self.optimize = self.__class__.optimize(service, version, mode, path + ["optimize"])
                    self.create_design_points = self.__class__.create_design_points(service, version, mode, path + ["create_design_points"])
                    self.export_designs = self.__class__.export_designs(service, version, mode, path + ["export_designs"])
                    self.get_number_of_designs = self.__class__.get_number_of_designs(service, version, mode, path + ["get_number_of_designs"])
                    self.go_to_optislang = self.__class__.go_to_optislang(service, version, mode, path + ["go_to_optislang"])
                    self.list_current_settings = self.__class__.list_current_settings(service, version, mode, path + ["list_current_settings"])
                    self.open_designs_in_optislang_postprocessor = self.__class__.open_designs_in_optislang_postprocessor(service, version, mode, path + ["open_designs_in_optislang_postprocessor"])
                    self.set_parameter_as_active_or_inactive = self.__class__.set_parameter_as_active_or_inactive(service, version, mode, path + ["set_parameter_as_active_or_inactive"])
                    super().__init__(service, version, mode, path)
                class create_design_points(TUIMethod):
                    """
                    Create design points automatically.
                    """
                class export_designs(TUIMethod):
                    """
                    Export designs by writing a JSON file.
                    """
                class get_number_of_designs(TUIMethod):
                    """
                    Get number of designs.
                    """
                class go_to_optislang(TUIMethod):
                    """
                    Open the optiSLang project.
                    """
                class list_current_settings(TUIMethod):
                    """
                    List current settings for auto-create design points.
                    """
                class open_designs_in_optislang_postprocessor(TUIMethod):
                    """
                    Export designs into JSON and open this JSON into optiSLang Postprocessor.
                    """
                class set_parameter_as_active_or_inactive(TUIMethod):
                    """
                    Set the parameter as Active or Inactive.
                    """

                class optimize(TUIMenu):
                    """
                    Enter Optimize menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.print_to_console = self.__class__.print_to_console(service, version, mode, path + ["print_to_console"])
                        self.set = self.__class__.set(service, version, mode, path + ["set"])
                        self.export_omdb_in_optislang_postprocessor = self.__class__.export_omdb_in_optislang_postprocessor(service, version, mode, path + ["export_omdb_in_optislang_postprocessor"])
                        self.export_optimization_results_to_csv = self.__class__.export_optimization_results_to_csv(service, version, mode, path + ["export_optimization_results_to_csv"])
                        self.new_optimization = self.__class__.new_optimization(service, version, mode, path + ["new_optimization"])
                        self.run_optimization = self.__class__.run_optimization(service, version, mode, path + ["run_optimization"])
                        super().__init__(service, version, mode, path)
                    class export_omdb_in_optislang_postprocessor(TUIMethod):
                        """
                        Export OMDB in optiSLang Postprocessor.
                        """
                    class export_optimization_results_to_csv(TUIMethod):
                        """
                        Export optimization results to csv.
                        """
                    class new_optimization(TUIMethod):
                        """
                        Start new optimization.
                        """
                    class run_optimization(TUIMethod):
                        """
                        Run optimization.
                        """

                    class print_to_console(TUIMenu):
                        """
                        Enter print-to-console menu for Optimization.
                        """
                        def __init__(self, service, version, mode, path):
                            self.algorithm_settings = self.__class__.algorithm_settings(service, version, mode, path + ["algorithm_settings"])
                            self.active_and_inactive = self.__class__.active_and_inactive(service, version, mode, path + ["active_and_inactive"])
                            self.algorithm = self.__class__.algorithm(service, version, mode, path + ["algorithm"])
                            self.criteria = self.__class__.criteria(service, version, mode, path + ["criteria"])
                            self.results_csv_path = self.__class__.results_csv_path(service, version, mode, path + ["results_csv_path"])
                            super().__init__(service, version, mode, path)
                        class active_and_inactive(TUIMethod):
                            """
                            Print whether a parameter is active or inactive.
                            """
                        class algorithm(TUIMethod):
                            """
                            Print current algorithm.
                            """
                        class criteria(TUIMethod):
                            """
                            Print criteria.
                            """
                        class results_csv_path(TUIMethod):
                            """
                            Path to write output results.
                            """

                        class algorithm_settings(TUIMenu):
                            """
                            Enter algorithm-properties menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.consider_failed_designs = self.__class__.consider_failed_designs(service, version, mode, path + ["consider_failed_designs"])
                                self.imp_of_criteria = self.__class__.imp_of_criteria(service, version, mode, path + ["imp_of_criteria"])
                                self.imp_of_local_cop = self.__class__.imp_of_local_cop(service, version, mode, path + ["imp_of_local_cop"])
                                self.imp_of_sample_density = self.__class__.imp_of_sample_density(service, version, mode, path + ["imp_of_sample_density"])
                                self.iteration_number_of_samples = self.__class__.iteration_number_of_samples(service, version, mode, path + ["iteration_number_of_samples"])
                                self.iteration_sampling_type = self.__class__.iteration_sampling_type(service, version, mode, path + ["iteration_sampling_type"])
                                self.max_iterations = self.__class__.max_iterations(service, version, mode, path + ["max_iterations"])
                                self.max_number_of_samples = self.__class__.max_number_of_samples(service, version, mode, path + ["max_number_of_samples"])
                                self.number_of_designs_in_parallel = self.__class__.number_of_designs_in_parallel(service, version, mode, path + ["number_of_designs_in_parallel"])
                                self.number_of_stagnation_iterations = self.__class__.number_of_stagnation_iterations(service, version, mode, path + ["number_of_stagnation_iterations"])
                                self.refinement_number_of_samples = self.__class__.refinement_number_of_samples(service, version, mode, path + ["refinement_number_of_samples"])
                                self.refinement_sampling_type = self.__class__.refinement_sampling_type(service, version, mode, path + ["refinement_sampling_type"])
                                self.refinement_type = self.__class__.refinement_type(service, version, mode, path + ["refinement_type"])
                                self.seed_value = self.__class__.seed_value(service, version, mode, path + ["seed_value"])
                                self.stagnation_iterations = self.__class__.stagnation_iterations(service, version, mode, path + ["stagnation_iterations"])
                                self.target_cop = self.__class__.target_cop(service, version, mode, path + ["target_cop"])
                                self.use_mop = self.__class__.use_mop(service, version, mode, path + ["use_mop"])
                                self.use_start_designs_only = self.__class__.use_start_designs_only(service, version, mode, path + ["use_start_designs_only"])
                                super().__init__(service, version, mode, path)
                            class consider_failed_designs(TUIMethod):
                                """
                                Print value for consider failed designs.
                                """
                            class imp_of_criteria(TUIMethod):
                                """
                                Print value for importance of criteria.
                                """
                            class imp_of_local_cop(TUIMethod):
                                """
                                Print value for importance of local CoP.
                                """
                            class imp_of_sample_density(TUIMethod):
                                """
                                Set value for importance of weight density.
                                """
                            class iteration_number_of_samples(TUIMethod):
                                """
                                Print iteration number of samples.
                                """
                            class iteration_sampling_type(TUIMethod):
                                """
                                Print iteration sampling type.
                                """
                            class max_iterations(TUIMethod):
                                """
                                Print value for maximum iterations.
                                """
                            class max_number_of_samples(TUIMethod):
                                """
                                Print maximum number of samples.
                                """
                            class number_of_designs_in_parallel(TUIMethod):
                                """
                                Print value of Number of designs in parallel.
                                """
                            class number_of_stagnation_iterations(TUIMethod):
                                """
                                Print value of Number of stagnation evaluations.
                                """
                            class refinement_number_of_samples(TUIMethod):
                                """
                                Set refinement number of samples.
                                """
                            class refinement_sampling_type(TUIMethod):
                                """
                                Print refinement sampling type.
                                """
                            class refinement_type(TUIMethod):
                                """
                                Print refinement type.
                                """
                            class seed_value(TUIMethod):
                                """
                                Print Seed Value.
                                """
                            class stagnation_iterations(TUIMethod):
                                """
                                Print value for stagnation iterations.
                                """
                            class target_cop(TUIMethod):
                                """
                                Print value for target CoP.
                                """
                            class use_mop(TUIMethod):
                                """
                                Print the value for Use MOP.
                                """
                            class use_start_designs_only(TUIMethod):
                                """
                                Print value for use start designs only.
                                """

                    class set(TUIMenu):
                        """
                        Enter Set menu for Optimization.
                        """
                        def __init__(self, service, version, mode, path):
                            self.algorithm_settings = self.__class__.algorithm_settings(service, version, mode, path + ["algorithm_settings"])
                            self.algorithm = self.__class__.algorithm(service, version, mode, path + ["algorithm"])
                            self.configure_algorithm_settings = self.__class__.configure_algorithm_settings(service, version, mode, path + ["configure_algorithm_settings"])
                            self.criteria = self.__class__.criteria(service, version, mode, path + ["criteria"])
                            self.lower_and_upper_bounds = self.__class__.lower_and_upper_bounds(service, version, mode, path + ["lower_and_upper_bounds"])
                            self.results_csv_path = self.__class__.results_csv_path(service, version, mode, path + ["results_csv_path"])
                            self.set_parameter_as_active_or_inactive = self.__class__.set_parameter_as_active_or_inactive(service, version, mode, path + ["set_parameter_as_active_or_inactive"])
                            super().__init__(service, version, mode, path)
                        class algorithm(TUIMethod):
                            """
                            Select Optimization Algorithm.
                            """
                        class configure_algorithm_settings(TUIMethod):
                            """
                            Configure the algorithm settings.
                            """
                        class criteria(TUIMethod):
                            """
                            Enter Criteria menu.
                            """
                        class lower_and_upper_bounds(TUIMethod):
                            """
                            Enter Lower and Upper bounds for input parameters.
                            """
                        class results_csv_path(TUIMethod):
                            """
                            Path to write output results.
                            """
                        class set_parameter_as_active_or_inactive(TUIMethod):
                            """
                            Set the parameter as Active or Inactive.
                            """

                        class algorithm_settings(TUIMenu):
                            """
                            Set the algorithm settings.
                            """
                            def __init__(self, service, version, mode, path):
                                self.consider_failed_designs = self.__class__.consider_failed_designs(service, version, mode, path + ["consider_failed_designs"])
                                self.imp_of_criteria = self.__class__.imp_of_criteria(service, version, mode, path + ["imp_of_criteria"])
                                self.imp_of_local_cop = self.__class__.imp_of_local_cop(service, version, mode, path + ["imp_of_local_cop"])
                                self.imp_of_sample_density = self.__class__.imp_of_sample_density(service, version, mode, path + ["imp_of_sample_density"])
                                self.iteration_number_of_samples = self.__class__.iteration_number_of_samples(service, version, mode, path + ["iteration_number_of_samples"])
                                self.iteration_sampling_type = self.__class__.iteration_sampling_type(service, version, mode, path + ["iteration_sampling_type"])
                                self.max_iterations = self.__class__.max_iterations(service, version, mode, path + ["max_iterations"])
                                self.max_number_of_samples = self.__class__.max_number_of_samples(service, version, mode, path + ["max_number_of_samples"])
                                self.number_of_designs_in_parallel = self.__class__.number_of_designs_in_parallel(service, version, mode, path + ["number_of_designs_in_parallel"])
                                self.number_of_stagnation_iterations = self.__class__.number_of_stagnation_iterations(service, version, mode, path + ["number_of_stagnation_iterations"])
                                self.refinement_number_of_samples = self.__class__.refinement_number_of_samples(service, version, mode, path + ["refinement_number_of_samples"])
                                self.refinement_sampling_type = self.__class__.refinement_sampling_type(service, version, mode, path + ["refinement_sampling_type"])
                                self.refinement_type = self.__class__.refinement_type(service, version, mode, path + ["refinement_type"])
                                self.seed_value = self.__class__.seed_value(service, version, mode, path + ["seed_value"])
                                self.stagnation_iterations = self.__class__.stagnation_iterations(service, version, mode, path + ["stagnation_iterations"])
                                self.target_cop = self.__class__.target_cop(service, version, mode, path + ["target_cop"])
                                self.use_mop = self.__class__.use_mop(service, version, mode, path + ["use_mop"])
                                self.use_start_designs_only = self.__class__.use_start_designs_only(service, version, mode, path + ["use_start_designs_only"])
                                super().__init__(service, version, mode, path)
                            class consider_failed_designs(TUIMethod):
                                """
                                Set value for consider failed designs.
                                """
                            class imp_of_criteria(TUIMethod):
                                """
                                Set value for importance of criteria.
                                """
                            class imp_of_local_cop(TUIMethod):
                                """
                                Set value for importance of local CoP.
                                """
                            class imp_of_sample_density(TUIMethod):
                                """
                                Set value for importance of weight density.
                                """
                            class iteration_number_of_samples(TUIMethod):
                                """
                                Set iteration number of samples.
                                """
                            class iteration_sampling_type(TUIMethod):
                                """
                                Set iteration sampling type.
                                """
                            class max_iterations(TUIMethod):
                                """
                                Set value for maximum iterations.
                                """
                            class max_number_of_samples(TUIMethod):
                                """
                                Set maximum number of samples.
                                """
                            class number_of_designs_in_parallel(TUIMethod):
                                """
                                Number of designs in parallel.
                                """
                            class number_of_stagnation_iterations(TUIMethod):
                                """
                                Number of stagnation evaluations.
                                """
                            class refinement_number_of_samples(TUIMethod):
                                """
                                Set refinement number of samples.
                                """
                            class refinement_sampling_type(TUIMethod):
                                """
                                Set refinement sampling type.
                                """
                            class refinement_type(TUIMethod):
                                """
                                Set the Refinement Type.
                                """
                            class seed_value(TUIMethod):
                                """
                                Seed Value.
                                """
                            class stagnation_iterations(TUIMethod):
                                """
                                Set value for stagnation iterations.
                                """
                            class target_cop(TUIMethod):
                                """
                                Set value for target CoP.
                                """
                            class use_mop(TUIMethod):
                                """
                                Set value fir Use MOP.
                                """
                            class use_start_designs_only(TUIMethod):
                                """
                                Set value for use start designs only.
                                """

            class concurrent(TUIMenu):
                """
                Enter the concurrent design points menu.
                """
                def __init__(self, service, version, mode, path):
                    self.abort_all_design_points = self.__class__.abort_all_design_points(service, version, mode, path + ["abort_all_design_points"])
                    self.abort_design_point = self.__class__.abort_design_point(service, version, mode, path + ["abort_design_point"])
                    self.refresh_status = self.__class__.refresh_status(service, version, mode, path + ["refresh_status"])
                    super().__init__(service, version, mode, path)
                class abort_all_design_points(TUIMethod):
                    """
                    Interrupt All Design Points.
                    """
                class abort_design_point(TUIMethod):
                    """
                    Interrupt Design Point.
                    """
                class refresh_status(TUIMethod):
                    """
                    Refresh Status.
                    """

            class print_to_console(TUIMenu):
                """
                Enter the design points print menu.
                """
                def __init__(self, service, version, mode, path):
                    self.capture_simulation_report_data = self.__class__.capture_simulation_report_data(service, version, mode, path + ["capture_simulation_report_data"])
                    self.current_dp = self.__class__.current_dp(service, version, mode, path + ["current_dp"])
                    self.input_parameters_of_dp = self.__class__.input_parameters_of_dp(service, version, mode, path + ["input_parameters_of_dp"])
                    self.output_parameters_of_dp = self.__class__.output_parameters_of_dp(service, version, mode, path + ["output_parameters_of_dp"])
                    self.status_of_all_dps = self.__class__.status_of_all_dps(service, version, mode, path + ["status_of_all_dps"])
                    self.status_of_dp = self.__class__.status_of_dp(service, version, mode, path + ["status_of_dp"])
                    self.write_data = self.__class__.write_data(service, version, mode, path + ["write_data"])
                    super().__init__(service, version, mode, path)
                class capture_simulation_report_data(TUIMethod):
                    """
                    Print Capture Simulation Report Data option for Design Point.
                    """
                class current_dp(TUIMethod):
                    """
                    Print Name of Current Design Point.
                    """
                class input_parameters_of_dp(TUIMethod):
                    """
                    Print Input Parameter Values of Current Design Point.
                    """
                class output_parameters_of_dp(TUIMethod):
                    """
                    Print Output Parameter Values of Design Point.
                    """
                class status_of_all_dps(TUIMethod):
                    """
                    Print Statuses of all Design Points.
                    """
                class status_of_dp(TUIMethod):
                    """
                    Print Status of given DP.
                    """
                class write_data(TUIMethod):
                    """
                    Print WriteData option for Design Point.
                    """

            class set(TUIMenu):
                """
                Enter the design points Set menu.
                """
                def __init__(self, service, version, mode, path):
                    self.capture_simulation_report_data = self.__class__.capture_simulation_report_data(service, version, mode, path + ["capture_simulation_report_data"])
                    self.current_dp = self.__class__.current_dp(service, version, mode, path + ["current_dp"])
                    self.input_parameters_of_dp = self.__class__.input_parameters_of_dp(service, version, mode, path + ["input_parameters_of_dp"])
                    self.write_data = self.__class__.write_data(service, version, mode, path + ["write_data"])
                    super().__init__(service, version, mode, path)
                class capture_simulation_report_data(TUIMethod):
                    """
                    Set Capture Simulation Report Data option for Design Point.
                    """
                class current_dp(TUIMethod):
                    """
                    Set current design point.
                    """
                class input_parameters_of_dp(TUIMethod):
                    """
                    Set Input Parameter Values of Design Point.
                    """
                class write_data(TUIMethod):
                    """
                    Set WriteData option for Design Point.
                    """

            class table(TUIMenu):
                """
                Enter the design point table menu.
                """
                def __init__(self, service, version, mode, path):
                    self.export_design_table = self.__class__.export_design_table(service, version, mode, path + ["export_design_table"])
                    self.import_design_table = self.__class__.import_design_table(service, version, mode, path + ["import_design_table"])
                    super().__init__(service, version, mode, path)
                class export_design_table(TUIMethod):
                    """
                    Export Design Points Table.
                    """
                class import_design_table(TUIMethod):
                    """
                    Import Design Points Table.
                    """

        class study(TUIMenu):
            """
            Enter the study menu.
            """
            def __init__(self, service, version, mode, path):
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.duplicate = self.__class__.duplicate(service, version, mode, path + ["duplicate"])
                self.initialize = self.__class__.initialize(service, version, mode, path + ["initialize"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.read_case_before_each_dp_update = self.__class__.read_case_before_each_dp_update(service, version, mode, path + ["read_case_before_each_dp_update"])
                self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                self.set_as_current = self.__class__.set_as_current(service, version, mode, path + ["set_as_current"])
                self.use_base_data = self.__class__.use_base_data(service, version, mode, path + ["use_base_data"])
                self.use_data_of_previous_dp = self.__class__.use_data_of_previous_dp(service, version, mode, path + ["use_data_of_previous_dp"])
                super().__init__(service, version, mode, path)
            class delete(TUIMethod):
                """
                Delete Study.
                """
            class duplicate(TUIMethod):
                """
                Duplicate Parametric Study.
                """
            class initialize(TUIMethod):
                """
                Start Parametric Study.
                """
            class list(TUIMethod):
                """
                List Studies.
                """
            class read_case_before_each_dp_update(TUIMethod):
                """
                Start Design Point Update from Base case.
                """
            class rename(TUIMethod):
                """
                Rename Study.
                """
            class set_as_current(TUIMethod):
                """
                Set As Current Study.
                """
            class use_base_data(TUIMethod):
                """
                Use Base Data to Initialize a Design Point.
                """
            class use_data_of_previous_dp(TUIMethod):
                """
                Use Data of Previous Updated Design Point.
                """

        class update(TUIMenu):
            """
            Enter the update menu.
            """
            def __init__(self, service, version, mode, path):
                self.concurrent = self.__class__.concurrent(service, version, mode, path + ["concurrent"])
                self.auto_update_mesh_morphs = self.__class__.auto_update_mesh_morphs(service, version, mode, path + ["auto_update_mesh_morphs"])
                self.print_update_method = self.__class__.print_update_method(service, version, mode, path + ["print_update_method"])
                self.set_update_method = self.__class__.set_update_method(service, version, mode, path + ["set_update_method"])
                self.update_all = self.__class__.update_all(service, version, mode, path + ["update_all"])
                self.update_current = self.__class__.update_current(service, version, mode, path + ["update_current"])
                self.update_selected_design_points = self.__class__.update_selected_design_points(service, version, mode, path + ["update_selected_design_points"])
                super().__init__(service, version, mode, path)
            class auto_update_mesh_morphs(TUIMethod):
                """
                Enable Auto Mesh Morphing Update.
                """
            class print_update_method(TUIMethod):
                """
                Print update method.
                """
            class set_update_method(TUIMethod):
                """
                Set update method.
                """
            class update_all(TUIMethod):
                """
                Update All Design Points.
                """
            class update_current(TUIMethod):
                """
                Update Current Design Point.
                """
            class update_selected_design_points(TUIMethod):
                """
                Update Selected Design Points.
                """

            class concurrent(TUIMenu):
                """
                Enter Concurrent Update menu.
                """
                def __init__(self, service, version, mode, path):
                    self.licensing = self.__class__.licensing(service, version, mode, path + ["licensing"])
                    self.print_to_console = self.__class__.print_to_console(service, version, mode, path + ["print_to_console"])
                    self.set = self.__class__.set(service, version, mode, path + ["set"])
                    self.delete_endpoint = self.__class__.delete_endpoint(service, version, mode, path + ["delete_endpoint"])
                    self.register_new_endpoint = self.__class__.register_new_endpoint(service, version, mode, path + ["register_new_endpoint"])
                    super().__init__(service, version, mode, path)
                class delete_endpoint(TUIMethod):
                    """
                    Delete endpoint.
                    """
                class register_new_endpoint(TUIMethod):
                    """
                    Register a new endpoint.
                    """

                class licensing(TUIMenu):
                    """
                    Enter Concurrent Licensing menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.print_to_console = self.__class__.print_to_console(service, version, mode, path + ["print_to_console"])
                        self.set = self.__class__.set(service, version, mode, path + ["set"])
                        super().__init__(service, version, mode, path)

                    class print_to_console(TUIMenu):
                        """
                        Print Concurrent Licensing Settings.
                        """
                        def __init__(self, service, version, mode, path):
                            self.license_type = self.__class__.license_type(service, version, mode, path + ["license_type"])
                            self.optislang_license_count = self.__class__.optislang_license_count(service, version, mode, path + ["optislang_license_count"])
                            self.optislang_license_type = self.__class__.optislang_license_type(service, version, mode, path + ["optislang_license_type"])
                            super().__init__(service, version, mode, path)
                        class license_type(TUIMethod):
                            """
                            License Type.
                            """
                        class optislang_license_count(TUIMethod):
                            """
                            OptiSLang License Count.
                            """
                        class optislang_license_type(TUIMethod):
                            """
                            OptiSLang License Type.
                            """

                    class set(TUIMenu):
                        """
                        Enter Concurrent Licensing Menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.license_type = self.__class__.license_type(service, version, mode, path + ["license_type"])
                            self.optislang_license_count = self.__class__.optislang_license_count(service, version, mode, path + ["optislang_license_count"])
                            self.optislang_license_type = self.__class__.optislang_license_type(service, version, mode, path + ["optislang_license_type"])
                            super().__init__(service, version, mode, path)
                        class license_type(TUIMethod):
                            """
                            License Type.
                            """
                        class optislang_license_count(TUIMethod):
                            """
                            OptiSLang License Count.
                            """
                        class optislang_license_type(TUIMethod):
                            """
                            OptiSLang License Type.
                            """

                class print_to_console(TUIMenu):
                    """
                    Print to console concurrent options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.current_endpoint = self.__class__.current_endpoint(service, version, mode, path + ["current_endpoint"])
                        self.current_queue = self.__class__.current_queue(service, version, mode, path + ["current_queue"])
                        self.number_of_concurrent_dps = self.__class__.number_of_concurrent_dps(service, version, mode, path + ["number_of_concurrent_dps"])
                        self.number_of_cores_per_dp = self.__class__.number_of_cores_per_dp(service, version, mode, path + ["number_of_cores_per_dp"])
                        self.registered_endpoints = self.__class__.registered_endpoints(service, version, mode, path + ["registered_endpoints"])
                        super().__init__(service, version, mode, path)
                    class current_endpoint(TUIMethod):
                        """
                        Get the current endpoint.
                        """
                    class current_queue(TUIMethod):
                        """
                        Get the current queue.
                        """
                    class number_of_concurrent_dps(TUIMethod):
                        """
                        Print Number of Concurrent Design Points.
                        """
                    class number_of_cores_per_dp(TUIMethod):
                        """
                        Get Number of Cores per Design Point.
                        """
                    class registered_endpoints(TUIMethod):
                        """
                        List registered endpoints.
                        """

                class set(TUIMenu):
                    """
                    Set concurrent update options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.current_endpoint = self.__class__.current_endpoint(service, version, mode, path + ["current_endpoint"])
                        self.current_queue = self.__class__.current_queue(service, version, mode, path + ["current_queue"])
                        self.number_of_concurrent_dps = self.__class__.number_of_concurrent_dps(service, version, mode, path + ["number_of_concurrent_dps"])
                        self.number_of_cores_per_dp = self.__class__.number_of_cores_per_dp(service, version, mode, path + ["number_of_cores_per_dp"])
                        super().__init__(service, version, mode, path)
                    class current_endpoint(TUIMethod):
                        """
                        Set the current endpoint.
                        """
                    class current_queue(TUIMethod):
                        """
                        Set the current queue.
                        """
                    class number_of_concurrent_dps(TUIMethod):
                        """
                        Set Number of Concurrent Design Points.
                        """
                    class number_of_cores_per_dp(TUIMethod):
                        """
                        Set Number of Cores per Design Point.
                        """

    class plot(TUIMenu):
        """
        Enter the XY plot menu.
        """
        def __init__(self, service, version, mode, path):
            self.ansys_sound_analysis = self.__class__.ansys_sound_analysis(service, version, mode, path + ["ansys_sound_analysis"])
            self.cumulative_plot = self.__class__.cumulative_plot(service, version, mode, path + ["cumulative_plot"])
            self.datasources = self.__class__.datasources(service, version, mode, path + ["datasources"])
            self.fft_set = self.__class__.fft_set(service, version, mode, path + ["fft_set"])
            self.file_set = self.__class__.file_set(service, version, mode, path + ["file_set"])
            self.flamelet_curves = self.__class__.flamelet_curves(service, version, mode, path + ["flamelet_curves"])
            self.histogram_set = self.__class__.histogram_set(service, version, mode, path + ["histogram_set"])
            self.residuals_set = self.__class__.residuals_set(service, version, mode, path + ["residuals_set"])
            self.solution_set = self.__class__.solution_set(service, version, mode, path + ["solution_set"])
            self.vrx_sound_analysis = self.__class__.vrx_sound_analysis(service, version, mode, path + ["vrx_sound_analysis"])
            self.change_fft_ref_pressure = self.__class__.change_fft_ref_pressure(service, version, mode, path + ["change_fft_ref_pressure"])
            self.circum_avg_axial = self.__class__.circum_avg_axial(service, version, mode, path + ["circum_avg_axial"])
            self.circum_avg_radial = self.__class__.circum_avg_radial(service, version, mode, path + ["circum_avg_radial"])
            self.display_profile_data = self.__class__.display_profile_data(service, version, mode, path + ["display_profile_data"])
            self.fft = self.__class__.fft(service, version, mode, path + ["fft"])
            self.file = self.__class__.file(service, version, mode, path + ["file"])
            self.file_list = self.__class__.file_list(service, version, mode, path + ["file_list"])
            self.histogram = self.__class__.histogram(service, version, mode, path + ["histogram"])
            self.label_alignment = self.__class__.label_alignment(service, version, mode, path + ["label_alignment"])
            self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
            self.plot_direction = self.__class__.plot_direction(service, version, mode, path + ["plot_direction"])
            self.residuals = self.__class__.residuals(service, version, mode, path + ["residuals"])
            self.set_boundary_val_off = self.__class__.set_boundary_val_off(service, version, mode, path + ["set_boundary_val_off"])
            self.solution = self.__class__.solution(service, version, mode, path + ["solution"])
            super().__init__(service, version, mode, path)
        class change_fft_ref_pressure(TUIMethod):
            """
            Changes reference acoustic pressure.
            """
        class circum_avg_axial(TUIMethod):
            """
            Computes iso-axial band surfaces and plots data vs. axial coordinate on them.
            """
        class circum_avg_radial(TUIMethod):
            """
            Computes iso-radial band surfaces and plots data vs. radius on them.
            """
        class display_profile_data(TUIMethod):
            """
            Plots profile data.
            """
        class fft(TUIMethod):
            """
            Plots fast Fourier transform (FFT) of file data. If you respond yes to Acoustic Analysis?, then additional Y axis functions are made available.
            """
        class file(TUIMethod):
            """
            Plots data from an external file.
            """
        class file_list(TUIMethod):
            """
            Plots data from multiple external files.
            """
        class histogram(TUIMethod):
            """
            Plots a histogram of the specified solution variable using the defined range and number of intervals.
            """
        class label_alignment(TUIMethod):
            """
            Set the orientation of XY plot axis labels as either horizontal or axis-aligned.
            """
        class plot(TUIMethod):
            """
            Plots solution on surfaces.
            """
        class plot_direction(TUIMethod):
            """
            Sets plot direction for XY plot.
            """
        class residuals(TUIMethod):
            """
            Contains commands that allow you to select the variables for which you want to display XY plots of residual histories in the active graphics window.
            """
        class set_boundary_val_off(TUIMethod):
            """
            Disables the use of boundary face values when node values are disabled in solution XY plots. This option is disabled by default, that is, boundary face values are used when node values are disabled.
            """
        class solution(TUIMethod):
            """
            Plots solution on surfaces and/or zones. Zone and surface names can be indicated using a  wildcard (\\*).
            """

        class ansys_sound_analysis(TUIMenu):
            """
            Enter the Ansys sound analysis menu.
            """
            def __init__(self, service, version, mode, path):
                self.print_indicators = self.__class__.print_indicators(service, version, mode, path + ["print_indicators"])
                self.write_files = self.__class__.write_files(service, version, mode, path + ["write_files"])
                super().__init__(service, version, mode, path)
            class print_indicators(TUIMethod):
                """
                Read in a pressure signal or spectrum file, then optionally read in a frequency response function (FRF) or transfer function file, before printing the acoustics indicators.
                """
            class write_files(TUIMethod):
                """
                Read in a pressure signal or spectrum file, then optionally read in a frequency response function (FRF) or transfer function file, before writing a WAV, output pressure, and/or acoustic indicators file.
                """

        class cumulative_plot(TUIMenu):
            """
            Plot the development of force, force coefficient, moment, or moment coefficient across the specified wall zones.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                self.curves = self.__class__.curves(service, version, mode, path + ["curves"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
                self.print = self.__class__.print(service, version, mode, path + ["print"])
                self.write = self.__class__.write(service, version, mode, path + ["write"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Create a new cumulative plot.
                """
            class axes(TUIMethod):
                """
                Set axes options of an object.
                """
            class curves(TUIMethod):
                """
                Set curves options of an object.
                """
            class delete(TUIMethod):
                """
                Delete an existing cumulative plot object.
                """
            class edit(TUIMethod):
                """
                Edit an existing cumulative plot object.
                """
            class list(TUIMethod):
                """
                Print the names of the existing cumulative plot objects to the console.
                """
            class list_properties(TUIMethod):
                """
                Print the properties of the specified cumulative plot object to the console.
                """
            class plot(TUIMethod):
                """
                Plot a cumulative plot in the graphics window.
                """
            class print(TUIMethod):
                """
                Print the value of a cumulative plot to the console.
                """
            class write(TUIMethod):
                """
                Write a cumulative plot to a file.
                """

        class datasources(TUIMenu):
            """
            Enters the menu for creating and modifying plots containing multiple data sources.
            """
            def __init__(self, service, version, mode, path):
                self.add_report_plot = self.__class__.add_report_plot(service, version, mode, path + ["add_report_plot"])
                self.add_xy_plot = self.__class__.add_xy_plot(service, version, mode, path + ["add_xy_plot"])
                self.list_curve_information = self.__class__.list_curve_information(service, version, mode, path + ["list_curve_information"])
                self.list_data_sources = self.__class__.list_data_sources(service, version, mode, path + ["list_data_sources"])
                self.list_legend_names = self.__class__.list_legend_names(service, version, mode, path + ["list_legend_names"])
                self.load_file = self.__class__.load_file(service, version, mode, path + ["load_file"])
                self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
                self.properties = self.__class__.properties(service, version, mode, path + ["properties"])
                self.remove_data_source = self.__class__.remove_data_source(service, version, mode, path + ["remove_data_source"])
                self.rename_legend = self.__class__.rename_legend(service, version, mode, path + ["rename_legend"])
                super().__init__(service, version, mode, path)
            class add_report_plot(TUIMethod):
                """
                Specify an existing report plot to include in this plot.
                """
            class add_xy_plot(TUIMethod):
                """
                Specify an existing XY plot to include in this plot.
                """
            class list_curve_information(TUIMethod):
                """
                Prints the names of the variables selected for plotting.
                """
            class list_data_sources(TUIMethod):
                """
                Prints the names of the selected/loaded data sources including the files and in-session plot objects.
                """
            class list_legend_names(TUIMethod):
                """
                Prints the names of the legends to the console.
                """
            class load_file(TUIMethod):
                """
                Specify a file to load for plotting. The file must be located in the working directory.
                """
            class plot(TUIMethod):
                """
                Plots the selected data in the active graphics window.
                """
            class properties(TUIMethod):
                """
                Prints the properties of whichever plot or file included in the multiple data sources plot that you specify.
                """
            class remove_data_source(TUIMethod):
                """
                Removes whichever data source (plot or file) you specify.
                """
            class rename_legend(TUIMethod):
                """
                Allows you to rename legend entries. Note that you must re-plot to see the legend name change.
                """

        class fft_set(TUIMenu):
            """
            Enter the menu to set histogram plot parameters.
            """
            def __init__(self, service, version, mode, path):
                self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                self.curves = self.__class__.curves(service, version, mode, path + ["curves"])
                super().__init__(service, version, mode, path)
            class axes(TUIMethod):
                """
                Set axes options of an object.
                """
            class curves(TUIMethod):
                """
                Set curves options of an object.
                """

        class file_set(TUIMenu):
            """
            Sets file plot parameters.
            """
            def __init__(self, service, version, mode, path):
                self.auto_scale = self.__class__.auto_scale(service, version, mode, path + ["auto_scale"])
                self.background_color = self.__class__.background_color(service, version, mode, path + ["background_color"])
                self.end_plot_to_file = self.__class__.end_plot_to_file(service, version, mode, path + ["end_plot_to_file"])
                self.file_lines = self.__class__.file_lines(service, version, mode, path + ["file_lines"])
                self.file_markers = self.__class__.file_markers(service, version, mode, path + ["file_markers"])
                self.get_residuals_window = self.__class__.get_residuals_window(service, version, mode, path + ["get_residuals_window"])
                self.key = self.__class__.key(service, version, mode, path + ["key"])
                self.labels = self.__class__.labels(service, version, mode, path + ["labels"])
                self.lines = self.__class__.lines(service, version, mode, path + ["lines"])
                self.log = self.__class__.log(service, version, mode, path + ["log"])
                self.markers = self.__class__.markers(service, version, mode, path + ["markers"])
                self.numbers = self.__class__.numbers(service, version, mode, path + ["numbers"])
                self.plot_to_file = self.__class__.plot_to_file(service, version, mode, path + ["plot_to_file"])
                self.rules = self.__class__.rules(service, version, mode, path + ["rules"])
                self.windows = self.__class__.windows(service, version, mode, path + ["windows"])
                self.xy_percent_y = self.__class__.xy_percent_y(service, version, mode, path + ["xy_percent_y"])
                super().__init__(service, version, mode, path)
            class auto_scale(TUIMethod):
                """
                Sets the range for the   and   axes. If auto-scaling is not activated for a particular axis, you are prompted for the minimum and maximum data values.
                """
            class background_color(TUIMethod):
                """
                Sets the color of the field within the abscissa and ordinate axes.
                """
            class end_plot_to_file(TUIMethod):
                """
                End plot to file.
                """
            class file_lines(TUIMethod):
                """
                Sets parameters for plot lines.
                """
            class file_markers(TUIMethod):
                """
                Sets parameters for data markers.
                """
            class get_residuals_window(TUIMethod):
                """
                Get residuals window id.
                """
            class key(TUIMethod):
                """
                Enables/disables display of curve key and sets its window title.
                """
            class labels(TUIMethod):
                """
                Sets labels for plot axes.
                """
            class lines(TUIMethod):
                """
                Sets parameters for plot lines.
                """
            class log(TUIMethod):
                """
                Uses log scales for one or both axes.
                """
            class markers(TUIMethod):
                """
                Sets parameters for data markers.
                """
            class numbers(TUIMethod):
                """
                Sets number formats for axes.
                """
            class plot_to_file(TUIMethod):
                """
                Specifies a file in which to write XY plot data.
                """
            class rules(TUIMethod):
                """
                Sets parameters for display of major and minor rules.
                """
            class windows(TUIMethod):
                """
                XY plot window options. For a description of the items in this menu, see display/set/windows/xy.
                """
            class xy_percent_y(TUIMethod):
                """
                Scale xy plot by percentage of total elements.
                """

        class flamelet_curves(TUIMenu):
            """
            Enters the flamelet curves menu.
            """
            def __init__(self, service, version, mode, path):
                self.plot_curves = self.__class__.plot_curves(service, version, mode, path + ["plot_curves"])
                self.write_to_file = self.__class__.write_to_file(service, version, mode, path + ["write_to_file"])
                super().__init__(service, version, mode, path)
            class plot_curves(TUIMethod):
                """
                Plots of a curve property.
                """
            class write_to_file(TUIMethod):
                """
                Writes curve to a file instead of plot.
                """

        class histogram_set(TUIMenu):
            """
            Sets histogram plot parameters. Sub-menu items are the same as file-set/ above.
            """
            def __init__(self, service, version, mode, path):
                self.auto_scale = self.__class__.auto_scale(service, version, mode, path + ["auto_scale"])
                self.background_color = self.__class__.background_color(service, version, mode, path + ["background_color"])
                self.end_plot_to_file = self.__class__.end_plot_to_file(service, version, mode, path + ["end_plot_to_file"])
                self.file_lines = self.__class__.file_lines(service, version, mode, path + ["file_lines"])
                self.file_markers = self.__class__.file_markers(service, version, mode, path + ["file_markers"])
                self.get_residuals_window = self.__class__.get_residuals_window(service, version, mode, path + ["get_residuals_window"])
                self.key = self.__class__.key(service, version, mode, path + ["key"])
                self.labels = self.__class__.labels(service, version, mode, path + ["labels"])
                self.lines = self.__class__.lines(service, version, mode, path + ["lines"])
                self.log = self.__class__.log(service, version, mode, path + ["log"])
                self.markers = self.__class__.markers(service, version, mode, path + ["markers"])
                self.numbers = self.__class__.numbers(service, version, mode, path + ["numbers"])
                self.plot_to_file = self.__class__.plot_to_file(service, version, mode, path + ["plot_to_file"])
                self.rules = self.__class__.rules(service, version, mode, path + ["rules"])
                self.windows = self.__class__.windows(service, version, mode, path + ["windows"])
                self.xy_percent_y = self.__class__.xy_percent_y(service, version, mode, path + ["xy_percent_y"])
                super().__init__(service, version, mode, path)
            class auto_scale(TUIMethod):
                """
                Automatically compute x/y-axis extents?.
                """
            class background_color(TUIMethod):
                """
                Set the color of the plot background.
                """
            class end_plot_to_file(TUIMethod):
                """
                End plot to file.
                """
            class file_lines(TUIMethod):
                """
                Set parameters for plot lines.
                """
            class file_markers(TUIMethod):
                """
                Set parameters for data markers.
                """
            class get_residuals_window(TUIMethod):
                """
                Get residuals window id.
                """
            class key(TUIMethod):
                """
                Enable/disable display of curve key and set its window title.
                """
            class labels(TUIMethod):
                """
                Set labels for plot axes.
                """
            class lines(TUIMethod):
                """
                Set parameters for plot lines.
                """
            class log(TUIMethod):
                """
                Use log scales for one or both axes?.
                """
            class markers(TUIMethod):
                """
                Set parameters for data markers.
                """
            class numbers(TUIMethod):
                """
                Set number formats for axes.
                """
            class plot_to_file(TUIMethod):
                """
                Specify a file to write an xy plot to.
                """
            class rules(TUIMethod):
                """
                Set parameters for display of major and minor rules.
                """
            class windows(TUIMethod):
                """
                X-Y plot window options.
                """
            class xy_percent_y(TUIMethod):
                """
                Scale xy plot by percentage of total elements.
                """

        class residuals_set(TUIMenu):
            """
            Sets residual plot parameters. Sub-menu items are the same as file-set/ above.
            """
            def __init__(self, service, version, mode, path):
                self.auto_scale = self.__class__.auto_scale(service, version, mode, path + ["auto_scale"])
                self.background_color = self.__class__.background_color(service, version, mode, path + ["background_color"])
                self.end_plot_to_file = self.__class__.end_plot_to_file(service, version, mode, path + ["end_plot_to_file"])
                self.file_lines = self.__class__.file_lines(service, version, mode, path + ["file_lines"])
                self.file_markers = self.__class__.file_markers(service, version, mode, path + ["file_markers"])
                self.get_residuals_window = self.__class__.get_residuals_window(service, version, mode, path + ["get_residuals_window"])
                self.key = self.__class__.key(service, version, mode, path + ["key"])
                self.labels = self.__class__.labels(service, version, mode, path + ["labels"])
                self.lines = self.__class__.lines(service, version, mode, path + ["lines"])
                self.log = self.__class__.log(service, version, mode, path + ["log"])
                self.markers = self.__class__.markers(service, version, mode, path + ["markers"])
                self.numbers = self.__class__.numbers(service, version, mode, path + ["numbers"])
                self.plot_to_file = self.__class__.plot_to_file(service, version, mode, path + ["plot_to_file"])
                self.rules = self.__class__.rules(service, version, mode, path + ["rules"])
                self.windows = self.__class__.windows(service, version, mode, path + ["windows"])
                self.xy_percent_y = self.__class__.xy_percent_y(service, version, mode, path + ["xy_percent_y"])
                super().__init__(service, version, mode, path)
            class auto_scale(TUIMethod):
                """
                Automatically compute x/y-axis extents?.
                """
            class background_color(TUIMethod):
                """
                Set the color of the plot background.
                """
            class end_plot_to_file(TUIMethod):
                """
                End plot to file.
                """
            class file_lines(TUIMethod):
                """
                Set parameters for plot lines.
                """
            class file_markers(TUIMethod):
                """
                Set parameters for data markers.
                """
            class get_residuals_window(TUIMethod):
                """
                Get residuals window id.
                """
            class key(TUIMethod):
                """
                Enable/disable display of curve key and set its window title.
                """
            class labels(TUIMethod):
                """
                Set labels for plot axes.
                """
            class lines(TUIMethod):
                """
                Set parameters for plot lines.
                """
            class log(TUIMethod):
                """
                Use log scales for one or both axes?.
                """
            class markers(TUIMethod):
                """
                Set parameters for data markers.
                """
            class numbers(TUIMethod):
                """
                Set number formats for axes.
                """
            class plot_to_file(TUIMethod):
                """
                Specify a file to write an xy plot to.
                """
            class rules(TUIMethod):
                """
                Set parameters for display of major and minor rules.
                """
            class windows(TUIMethod):
                """
                X-Y plot window options.
                """
            class xy_percent_y(TUIMethod):
                """
                Scale xy plot by percentage of total elements.
                """

        class solution_set(TUIMenu):
            """
            Sets solution plot parameters. Sub-menu items are the same as file-set/ above.
            """
            def __init__(self, service, version, mode, path):
                self.auto_scale = self.__class__.auto_scale(service, version, mode, path + ["auto_scale"])
                self.background_color = self.__class__.background_color(service, version, mode, path + ["background_color"])
                self.end_plot_to_file = self.__class__.end_plot_to_file(service, version, mode, path + ["end_plot_to_file"])
                self.file_lines = self.__class__.file_lines(service, version, mode, path + ["file_lines"])
                self.file_markers = self.__class__.file_markers(service, version, mode, path + ["file_markers"])
                self.get_residuals_window = self.__class__.get_residuals_window(service, version, mode, path + ["get_residuals_window"])
                self.key = self.__class__.key(service, version, mode, path + ["key"])
                self.labels = self.__class__.labels(service, version, mode, path + ["labels"])
                self.lines = self.__class__.lines(service, version, mode, path + ["lines"])
                self.log = self.__class__.log(service, version, mode, path + ["log"])
                self.markers = self.__class__.markers(service, version, mode, path + ["markers"])
                self.numbers = self.__class__.numbers(service, version, mode, path + ["numbers"])
                self.plot_to_file = self.__class__.plot_to_file(service, version, mode, path + ["plot_to_file"])
                self.rules = self.__class__.rules(service, version, mode, path + ["rules"])
                self.windows = self.__class__.windows(service, version, mode, path + ["windows"])
                self.xy_percent_y = self.__class__.xy_percent_y(service, version, mode, path + ["xy_percent_y"])
                super().__init__(service, version, mode, path)
            class auto_scale(TUIMethod):
                """
                Automatically compute x/y-axis extents?.
                """
            class background_color(TUIMethod):
                """
                Set the color of the plot background.
                """
            class end_plot_to_file(TUIMethod):
                """
                End plot to file.
                """
            class file_lines(TUIMethod):
                """
                Set parameters for plot lines.
                """
            class file_markers(TUIMethod):
                """
                Set parameters for data markers.
                """
            class get_residuals_window(TUIMethod):
                """
                Get residuals window id.
                """
            class key(TUIMethod):
                """
                Enable/disable display of curve key and set its window title.
                """
            class labels(TUIMethod):
                """
                Set labels for plot axes.
                """
            class lines(TUIMethod):
                """
                Set parameters for plot lines.
                """
            class log(TUIMethod):
                """
                Use log scales for one or both axes?.
                """
            class markers(TUIMethod):
                """
                Set parameters for data markers.
                """
            class numbers(TUIMethod):
                """
                Set number formats for axes.
                """
            class plot_to_file(TUIMethod):
                """
                Specify a file to write an xy plot to.
                """
            class rules(TUIMethod):
                """
                Set parameters for display of major and minor rules.
                """
            class windows(TUIMethod):
                """
                X-Y plot window options.
                """
            class xy_percent_y(TUIMethod):
                """
                Scale xy plot by percentage of total elements.
                """

        class vrx_sound_analysis(TUIMenu):
            """
            Ansys Sound analysis and specification.
            """
            def __init__(self, service, version, mode, path):
                self.print_indicators = self.__class__.print_indicators(service, version, mode, path + ["print_indicators"])
                self.write_files = self.__class__.write_files(service, version, mode, path + ["write_files"])
                super().__init__(service, version, mode, path)
            class print_indicators(TUIMethod):
                """
                Print Ansys Sound indicators.
                """
            class write_files(TUIMethod):
                """
                Write Ansys Sound out files.
                """

    class preferences(TUIMenu):
        """
        Set preferences.
        """
        def __init__(self, service, version, mode, path):
            self.appearance = self.__class__.appearance(service, version, mode, path + ["appearance"])
            self.general = self.__class__.general(service, version, mode, path + ["general"])
            self.gpuapp = self.__class__.gpuapp(service, version, mode, path + ["gpuapp"])
            self.graphics = self.__class__.graphics(service, version, mode, path + ["graphics"])
            self.mat_pro_app = self.__class__.mat_pro_app(service, version, mode, path + ["mat_pro_app"])
            self.meshing_workflow = self.__class__.meshing_workflow(service, version, mode, path + ["meshing_workflow"])
            self.navigation = self.__class__.navigation(service, version, mode, path + ["navigation"])
            self.parametric_study = self.__class__.parametric_study(service, version, mode, path + ["parametric_study"])
            self.simulation = self.__class__.simulation(service, version, mode, path + ["simulation"])
            self.turbo_workflow = self.__class__.turbo_workflow(service, version, mode, path + ["turbo_workflow"])
            super().__init__(service, version, mode, path)

        class appearance(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.ansys_logo = self.__class__.ansys_logo(service, version, mode, path + ["ansys_logo"])
                self.charts = self.__class__.charts(service, version, mode, path + ["charts"])
                self.selections = self.__class__.selections(service, version, mode, path + ["selections"])
                self.application_font_size = self.__class__.application_font_size(service, version, mode, path + ["application_font_size"])
                self.axis_triad = self.__class__.axis_triad(service, version, mode, path + ["axis_triad"])
                self.color_theme = self.__class__.color_theme(service, version, mode, path + ["color_theme"])
                self.completer = self.__class__.completer(service, version, mode, path + ["completer"])
                self.custom_title_bar = self.__class__.custom_title_bar(service, version, mode, path + ["custom_title_bar"])
                self.default_view = self.__class__.default_view(service, version, mode, path + ["default_view"])
                self.graphics_background_color1 = self.__class__.graphics_background_color1(service, version, mode, path + ["graphics_background_color1"])
                self.graphics_background_color2 = self.__class__.graphics_background_color2(service, version, mode, path + ["graphics_background_color2"])
                self.graphics_background_style = self.__class__.graphics_background_style(service, version, mode, path + ["graphics_background_style"])
                self.graphics_color_theme = self.__class__.graphics_color_theme(service, version, mode, path + ["graphics_color_theme"])
                self.graphics_default_manual_face_color = self.__class__.graphics_default_manual_face_color(service, version, mode, path + ["graphics_default_manual_face_color"])
                self.graphics_default_manual_node_color = self.__class__.graphics_default_manual_node_color(service, version, mode, path + ["graphics_default_manual_node_color"])
                self.graphics_edge_color = self.__class__.graphics_edge_color(service, version, mode, path + ["graphics_edge_color"])
                self.graphics_foreground_color = self.__class__.graphics_foreground_color(service, version, mode, path + ["graphics_foreground_color"])
                self.graphics_partition_boundary_color = self.__class__.graphics_partition_boundary_color(service, version, mode, path + ["graphics_partition_boundary_color"])
                self.graphics_surface_color = self.__class__.graphics_surface_color(service, version, mode, path + ["graphics_surface_color"])
                self.graphics_title_window_framecolor = self.__class__.graphics_title_window_framecolor(service, version, mode, path + ["graphics_title_window_framecolor"])
                self.graphics_view = self.__class__.graphics_view(service, version, mode, path + ["graphics_view"])
                self.graphics_wall_face_color = self.__class__.graphics_wall_face_color(service, version, mode, path + ["graphics_wall_face_color"])
                self.group_by_tree_view = self.__class__.group_by_tree_view(service, version, mode, path + ["group_by_tree_view"])
                self.model_color_scheme = self.__class__.model_color_scheme(service, version, mode, path + ["model_color_scheme"])
                self.number_of_files_recently_used = self.__class__.number_of_files_recently_used(service, version, mode, path + ["number_of_files_recently_used"])
                self.number_of_pastel_colors = self.__class__.number_of_pastel_colors(service, version, mode, path + ["number_of_pastel_colors"])
                self.pastel_color_saturation = self.__class__.pastel_color_saturation(service, version, mode, path + ["pastel_color_saturation"])
                self.pastel_color_value = self.__class__.pastel_color_value(service, version, mode, path + ["pastel_color_value"])
                self.quick_property_view = self.__class__.quick_property_view(service, version, mode, path + ["quick_property_view"])
                self.ruler = self.__class__.ruler(service, version, mode, path + ["ruler"])
                self.show_enabled_models = self.__class__.show_enabled_models(service, version, mode, path + ["show_enabled_models"])
                self.show_interface_children_zone = self.__class__.show_interface_children_zone(service, version, mode, path + ["show_interface_children_zone"])
                self.show_model_edges = self.__class__.show_model_edges(service, version, mode, path + ["show_model_edges"])
                self.solution_mode_edge_color_in_meshing_mode = self.__class__.solution_mode_edge_color_in_meshing_mode(service, version, mode, path + ["solution_mode_edge_color_in_meshing_mode"])
                self.surface_emissivity = self.__class__.surface_emissivity(service, version, mode, path + ["surface_emissivity"])
                self.surface_specularity = self.__class__.surface_specularity(service, version, mode, path + ["surface_specularity"])
                self.surface_specularity_for_contours = self.__class__.surface_specularity_for_contours(service, version, mode, path + ["surface_specularity_for_contours"])
                self.titles = self.__class__.titles(service, version, mode, path + ["titles"])
                self.titles_border_offset = self.__class__.titles_border_offset(service, version, mode, path + ["titles_border_offset"])
                super().__init__(service, version, mode, path)
            class application_font_size(TUIMethod):
                """
                .
                """
            class axis_triad(TUIMethod):
                """
                .
                """
            class color_theme(TUIMethod):
                """
                .
                """
            class completer(TUIMethod):
                """
                .
                """
            class custom_title_bar(TUIMethod):
                """
                .
                """
            class default_view(TUIMethod):
                """
                .
                """
            class graphics_background_color1(TUIMethod):
                """
                .
                """
            class graphics_background_color2(TUIMethod):
                """
                .
                """
            class graphics_background_style(TUIMethod):
                """
                .
                """
            class graphics_color_theme(TUIMethod):
                """
                .
                """
            class graphics_default_manual_face_color(TUIMethod):
                """
                .
                """
            class graphics_default_manual_node_color(TUIMethod):
                """
                .
                """
            class graphics_edge_color(TUIMethod):
                """
                .
                """
            class graphics_foreground_color(TUIMethod):
                """
                .
                """
            class graphics_partition_boundary_color(TUIMethod):
                """
                .
                """
            class graphics_surface_color(TUIMethod):
                """
                .
                """
            class graphics_title_window_framecolor(TUIMethod):
                """
                .
                """
            class graphics_view(TUIMethod):
                """
                .
                """
            class graphics_wall_face_color(TUIMethod):
                """
                .
                """
            class group_by_tree_view(TUIMethod):
                """
                .
                """
            class model_color_scheme(TUIMethod):
                """
                .
                """
            class number_of_files_recently_used(TUIMethod):
                """
                .
                """
            class number_of_pastel_colors(TUIMethod):
                """
                .
                """
            class pastel_color_saturation(TUIMethod):
                """
                .
                """
            class pastel_color_value(TUIMethod):
                """
                .
                """
            class quick_property_view(TUIMethod):
                """
                .
                """
            class ruler(TUIMethod):
                """
                .
                """
            class show_enabled_models(TUIMethod):
                """
                .
                """
            class show_interface_children_zone(TUIMethod):
                """
                .
                """
            class show_model_edges(TUIMethod):
                """
                .
                """
            class solution_mode_edge_color_in_meshing_mode(TUIMethod):
                """
                .
                """
            class surface_emissivity(TUIMethod):
                """
                .
                """
            class surface_specularity(TUIMethod):
                """
                .
                """
            class surface_specularity_for_contours(TUIMethod):
                """
                .
                """
            class titles(TUIMethod):
                """
                .
                """
            class titles_border_offset(TUIMethod):
                """
                .
                """

            class ansys_logo(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.color = self.__class__.color(service, version, mode, path + ["color"])
                    self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                    super().__init__(service, version, mode, path)
                class color(TUIMethod):
                    """
                    .
                    """
                class visible(TUIMethod):
                    """
                    .
                    """

            class charts(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.font = self.__class__.font(service, version, mode, path + ["font"])
                    self.text_color = self.__class__.text_color(service, version, mode, path + ["text_color"])
                    self.curve_colors = self.__class__.curve_colors(service, version, mode, path + ["curve_colors"])
                    self.enable_open_glfor_modern_plots = self.__class__.enable_open_glfor_modern_plots(service, version, mode, path + ["enable_open_glfor_modern_plots"])
                    self.legend_alignment = self.__class__.legend_alignment(service, version, mode, path + ["legend_alignment"])
                    self.legend_visibility = self.__class__.legend_visibility(service, version, mode, path + ["legend_visibility"])
                    self.modern_plots_enabled = self.__class__.modern_plots_enabled(service, version, mode, path + ["modern_plots_enabled"])
                    self.modern_plots_points_threshold = self.__class__.modern_plots_points_threshold(service, version, mode, path + ["modern_plots_points_threshold"])
                    self.plots_behavior = self.__class__.plots_behavior(service, version, mode, path + ["plots_behavior"])
                    self.print_plot_data = self.__class__.print_plot_data(service, version, mode, path + ["print_plot_data"])
                    self.print_residuals_data = self.__class__.print_residuals_data(service, version, mode, path + ["print_residuals_data"])
                    self.threshold = self.__class__.threshold(service, version, mode, path + ["threshold"])
                    self.tooltip_interpolation = self.__class__.tooltip_interpolation(service, version, mode, path + ["tooltip_interpolation"])
                    super().__init__(service, version, mode, path)
                class curve_colors(TUIMethod):
                    """
                    .
                    """
                class enable_open_glfor_modern_plots(TUIMethod):
                    """
                    .
                    """
                class legend_alignment(TUIMethod):
                    """
                    .
                    """
                class legend_visibility(TUIMethod):
                    """
                    .
                    """
                class modern_plots_enabled(TUIMethod):
                    """
                    .
                    """
                class modern_plots_points_threshold(TUIMethod):
                    """
                    .
                    """
                class plots_behavior(TUIMethod):
                    """
                    .
                    """
                class print_plot_data(TUIMethod):
                    """
                    .
                    """
                class print_residuals_data(TUIMethod):
                    """
                    .
                    """
                class threshold(TUIMethod):
                    """
                    .
                    """
                class tooltip_interpolation(TUIMethod):
                    """
                    .
                    """

                class font(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                        self.axes_titles = self.__class__.axes_titles(service, version, mode, path + ["axes_titles"])
                        self.legend = self.__class__.legend(service, version, mode, path + ["legend"])
                        self.title = self.__class__.title(service, version, mode, path + ["title"])
                        super().__init__(service, version, mode, path)
                    class axes(TUIMethod):
                        """
                        .
                        """
                    class axes_titles(TUIMethod):
                        """
                        .
                        """
                    class legend(TUIMethod):
                        """
                        .
                        """
                    class title(TUIMethod):
                        """
                        .
                        """

                class text_color(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                        self.axes_titles = self.__class__.axes_titles(service, version, mode, path + ["axes_titles"])
                        self.legend = self.__class__.legend(service, version, mode, path + ["legend"])
                        self.title = self.__class__.title(service, version, mode, path + ["title"])
                        super().__init__(service, version, mode, path)
                    class axes(TUIMethod):
                        """
                        .
                        """
                    class axes_titles(TUIMethod):
                        """
                        .
                        """
                    class legend(TUIMethod):
                        """
                        .
                        """
                    class title(TUIMethod):
                        """
                        .
                        """

            class selections(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.enable_highlight_edge_transparency = self.__class__.enable_highlight_edge_transparency(service, version, mode, path + ["enable_highlight_edge_transparency"])
                    self.general_displacement = self.__class__.general_displacement(service, version, mode, path + ["general_displacement"])
                    self.highlight_edge_color = self.__class__.highlight_edge_color(service, version, mode, path + ["highlight_edge_color"])
                    self.highlight_edge_weight = self.__class__.highlight_edge_weight(service, version, mode, path + ["highlight_edge_weight"])
                    self.highlight_face_color = self.__class__.highlight_face_color(service, version, mode, path + ["highlight_face_color"])
                    self.highlight_gloss = self.__class__.highlight_gloss(service, version, mode, path + ["highlight_gloss"])
                    self.highlight_specular_component = self.__class__.highlight_specular_component(service, version, mode, path + ["highlight_specular_component"])
                    self.highlight_transparency = self.__class__.highlight_transparency(service, version, mode, path + ["highlight_transparency"])
                    self.mouse_hover_probe_values_enabled = self.__class__.mouse_hover_probe_values_enabled(service, version, mode, path + ["mouse_hover_probe_values_enabled"])
                    self.mouse_over_highlight_enabled = self.__class__.mouse_over_highlight_enabled(service, version, mode, path + ["mouse_over_highlight_enabled"])
                    self.probe_tooltip_hide_delay_timer = self.__class__.probe_tooltip_hide_delay_timer(service, version, mode, path + ["probe_tooltip_hide_delay_timer"])
                    self.probe_tooltip_show_delay_timer = self.__class__.probe_tooltip_show_delay_timer(service, version, mode, path + ["probe_tooltip_show_delay_timer"])
                    super().__init__(service, version, mode, path)
                class enable_highlight_edge_transparency(TUIMethod):
                    """
                    .
                    """
                class general_displacement(TUIMethod):
                    """
                    .
                    """
                class highlight_edge_color(TUIMethod):
                    """
                    .
                    """
                class highlight_edge_weight(TUIMethod):
                    """
                    .
                    """
                class highlight_face_color(TUIMethod):
                    """
                    .
                    """
                class highlight_gloss(TUIMethod):
                    """
                    .
                    """
                class highlight_specular_component(TUIMethod):
                    """
                    .
                    """
                class highlight_transparency(TUIMethod):
                    """
                    .
                    """
                class mouse_hover_probe_values_enabled(TUIMethod):
                    """
                    .
                    """
                class mouse_over_highlight_enabled(TUIMethod):
                    """
                    .
                    """
                class probe_tooltip_hide_delay_timer(TUIMethod):
                    """
                    .
                    """
                class probe_tooltip_show_delay_timer(TUIMethod):
                    """
                    .
                    """

        class general(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.startup_messages = self.__class__.startup_messages(service, version, mode, path + ["startup_messages"])
                self.advanced_partition = self.__class__.advanced_partition(service, version, mode, path + ["advanced_partition"])
                self.automatic_transcript = self.__class__.automatic_transcript(service, version, mode, path + ["automatic_transcript"])
                self.default_ioformat = self.__class__.default_ioformat(service, version, mode, path + ["default_ioformat"])
                self.dock_editor = self.__class__.dock_editor(service, version, mode, path + ["dock_editor"])
                self.flow_model = self.__class__.flow_model(service, version, mode, path + ["flow_model"])
                self.idle_timeout = self.__class__.idle_timeout(service, version, mode, path + ["idle_timeout"])
                self.import_physics_volume_definitions = self.__class__.import_physics_volume_definitions(service, version, mode, path + ["import_physics_volume_definitions"])
                self.initial_physics_volume_definitions = self.__class__.initial_physics_volume_definitions(service, version, mode, path + ["initial_physics_volume_definitions"])
                self.skip_creation_of_groups_pointing_to_single_entity = self.__class__.skip_creation_of_groups_pointing_to_single_entity(service, version, mode, path + ["skip_creation_of_groups_pointing_to_single_entity"])
                self.utlcreate_physics_on_mode_change = self.__class__.utlcreate_physics_on_mode_change(service, version, mode, path + ["utlcreate_physics_on_mode_change"])
                self.utlmode = self.__class__.utlmode(service, version, mode, path + ["utlmode"])
                super().__init__(service, version, mode, path)
            class advanced_partition(TUIMethod):
                """
                .
                """
            class automatic_transcript(TUIMethod):
                """
                .
                """
            class default_ioformat(TUIMethod):
                """
                .
                """
            class dock_editor(TUIMethod):
                """
                .
                """
            class flow_model(TUIMethod):
                """
                .
                """
            class idle_timeout(TUIMethod):
                """
                .
                """
            class import_physics_volume_definitions(TUIMethod):
                """
                .
                """
            class initial_physics_volume_definitions(TUIMethod):
                """
                .
                """
            class skip_creation_of_groups_pointing_to_single_entity(TUIMethod):
                """
                .
                """
            class utlcreate_physics_on_mode_change(TUIMethod):
                """
                .
                """
            class utlmode(TUIMethod):
                """
                .
                """

            class startup_messages(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.color_theme_change_message = self.__class__.color_theme_change_message(service, version, mode, path + ["color_theme_change_message"])
                    self.key_behavioral_changes_message = self.__class__.key_behavioral_changes_message(service, version, mode, path + ["key_behavioral_changes_message"])
                    self.qaservice_message = self.__class__.qaservice_message(service, version, mode, path + ["qaservice_message"])
                    super().__init__(service, version, mode, path)
                class color_theme_change_message(TUIMethod):
                    """
                    .
                    """
                class key_behavioral_changes_message(TUIMethod):
                    """
                    .
                    """
                class qaservice_message(TUIMethod):
                    """
                    .
                    """

        class gpuapp(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.alpha_features = self.__class__.alpha_features(service, version, mode, path + ["alpha_features"])
                super().__init__(service, version, mode, path)
            class alpha_features(TUIMethod):
                """
                .
                """

        class graphics(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.boundary_markers = self.__class__.boundary_markers(service, version, mode, path + ["boundary_markers"])
                self.colormap_settings = self.__class__.colormap_settings(service, version, mode, path + ["colormap_settings"])
                self.embedded_windows = self.__class__.embedded_windows(service, version, mode, path + ["embedded_windows"])
                self.export_video_settings = self.__class__.export_video_settings(service, version, mode, path + ["export_video_settings"])
                self.graphics_effects = self.__class__.graphics_effects(service, version, mode, path + ["graphics_effects"])
                self.hardcopy_settings = self.__class__.hardcopy_settings(service, version, mode, path + ["hardcopy_settings"])
                self.lighting = self.__class__.lighting(service, version, mode, path + ["lighting"])
                self.manage_hoops_memory = self.__class__.manage_hoops_memory(service, version, mode, path + ["manage_hoops_memory"])
                self.material_effects = self.__class__.material_effects(service, version, mode, path + ["material_effects"])
                self.meshing_mode = self.__class__.meshing_mode(service, version, mode, path + ["meshing_mode"])
                self.performance = self.__class__.performance(service, version, mode, path + ["performance"])
                self.transparency = self.__class__.transparency(service, version, mode, path + ["transparency"])
                self.vector_settings = self.__class__.vector_settings(service, version, mode, path + ["vector_settings"])
                self.animation_option = self.__class__.animation_option(service, version, mode, path + ["animation_option"])
                self.backface_cull = self.__class__.backface_cull(service, version, mode, path + ["backface_cull"])
                self.double_buffering = self.__class__.double_buffering(service, version, mode, path + ["double_buffering"])
                self.enable_non_object_based_workflow = self.__class__.enable_non_object_based_workflow(service, version, mode, path + ["enable_non_object_based_workflow"])
                self.event_poll_interval = self.__class__.event_poll_interval(service, version, mode, path + ["event_poll_interval"])
                self.event_poll_timeout = self.__class__.event_poll_timeout(service, version, mode, path + ["event_poll_timeout"])
                self.force_key_frame_animation_markers_to_off = self.__class__.force_key_frame_animation_markers_to_off(service, version, mode, path + ["force_key_frame_animation_markers_to_off"])
                self.graphics_window_line_width = self.__class__.graphics_window_line_width(service, version, mode, path + ["graphics_window_line_width"])
                self.graphics_window_point_symbol = self.__class__.graphics_window_point_symbol(service, version, mode, path + ["graphics_window_point_symbol"])
                self.hidden_surface_removal_method = self.__class__.hidden_surface_removal_method(service, version, mode, path + ["hidden_surface_removal_method"])
                self.higher_resolution_graphics_window_line_width = self.__class__.higher_resolution_graphics_window_line_width(service, version, mode, path + ["higher_resolution_graphics_window_line_width"])
                self.lower_resolution_graphics_window_line_width = self.__class__.lower_resolution_graphics_window_line_width(service, version, mode, path + ["lower_resolution_graphics_window_line_width"])
                self.marker_drawing_mode = self.__class__.marker_drawing_mode(service, version, mode, path + ["marker_drawing_mode"])
                self.max_graphics_text_size = self.__class__.max_graphics_text_size(service, version, mode, path + ["max_graphics_text_size"])
                self.min_graphics_text_size = self.__class__.min_graphics_text_size(service, version, mode, path + ["min_graphics_text_size"])
                self.plot_legend_margin = self.__class__.plot_legend_margin(service, version, mode, path + ["plot_legend_margin"])
                self.point_tool_size = self.__class__.point_tool_size(service, version, mode, path + ["point_tool_size"])
                self.remove_partition_lines = self.__class__.remove_partition_lines(service, version, mode, path + ["remove_partition_lines"])
                self.remove_partition_lines_tolerance = self.__class__.remove_partition_lines_tolerance(service, version, mode, path + ["remove_partition_lines_tolerance"])
                self.rotation_centerpoint_visible = self.__class__.rotation_centerpoint_visible(service, version, mode, path + ["rotation_centerpoint_visible"])
                self.scroll_wheel_event_end_timer = self.__class__.scroll_wheel_event_end_timer(service, version, mode, path + ["scroll_wheel_event_end_timer"])
                self.set_camera_normal_to_surface_increments = self.__class__.set_camera_normal_to_surface_increments(service, version, mode, path + ["set_camera_normal_to_surface_increments"])
                self.show_hidden_lines = self.__class__.show_hidden_lines(service, version, mode, path + ["show_hidden_lines"])
                self.show_hidden_surfaces = self.__class__.show_hidden_surfaces(service, version, mode, path + ["show_hidden_surfaces"])
                self.surface_general_displacement = self.__class__.surface_general_displacement(service, version, mode, path + ["surface_general_displacement"])
                self.switch_to_open_glfor_remote_visualization = self.__class__.switch_to_open_glfor_remote_visualization(service, version, mode, path + ["switch_to_open_glfor_remote_visualization"])
                self.test_use_external_function = self.__class__.test_use_external_function(service, version, mode, path + ["test_use_external_function"])
                self.text_window_line_width = self.__class__.text_window_line_width(service, version, mode, path + ["text_window_line_width"])
                super().__init__(service, version, mode, path)
            class animation_option(TUIMethod):
                """
                .
                """
            class backface_cull(TUIMethod):
                """
                .
                """
            class double_buffering(TUIMethod):
                """
                .
                """
            class enable_non_object_based_workflow(TUIMethod):
                """
                .
                """
            class event_poll_interval(TUIMethod):
                """
                .
                """
            class event_poll_timeout(TUIMethod):
                """
                .
                """
            class force_key_frame_animation_markers_to_off(TUIMethod):
                """
                .
                """
            class graphics_window_line_width(TUIMethod):
                """
                .
                """
            class graphics_window_point_symbol(TUIMethod):
                """
                .
                """
            class hidden_surface_removal_method(TUIMethod):
                """
                .
                """
            class higher_resolution_graphics_window_line_width(TUIMethod):
                """
                .
                """
            class lower_resolution_graphics_window_line_width(TUIMethod):
                """
                .
                """
            class marker_drawing_mode(TUIMethod):
                """
                .
                """
            class max_graphics_text_size(TUIMethod):
                """
                .
                """
            class min_graphics_text_size(TUIMethod):
                """
                .
                """
            class plot_legend_margin(TUIMethod):
                """
                .
                """
            class point_tool_size(TUIMethod):
                """
                .
                """
            class remove_partition_lines(TUIMethod):
                """
                .
                """
            class remove_partition_lines_tolerance(TUIMethod):
                """
                .
                """
            class rotation_centerpoint_visible(TUIMethod):
                """
                .
                """
            class scroll_wheel_event_end_timer(TUIMethod):
                """
                .
                """
            class set_camera_normal_to_surface_increments(TUIMethod):
                """
                .
                """
            class show_hidden_lines(TUIMethod):
                """
                .
                """
            class show_hidden_surfaces(TUIMethod):
                """
                .
                """
            class surface_general_displacement(TUIMethod):
                """
                .
                """
            class switch_to_open_glfor_remote_visualization(TUIMethod):
                """
                .
                """
            class test_use_external_function(TUIMethod):
                """
                .
                """
            class text_window_line_width(TUIMethod):
                """
                .
                """

            class boundary_markers(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.color_option = self.__class__.color_option(service, version, mode, path + ["color_option"])
                    self.enabled = self.__class__.enabled(service, version, mode, path + ["enabled"])
                    self.exclude_from_bounding = self.__class__.exclude_from_bounding(service, version, mode, path + ["exclude_from_bounding"])
                    self.inlet_color = self.__class__.inlet_color(service, version, mode, path + ["inlet_color"])
                    self.marker_fraction = self.__class__.marker_fraction(service, version, mode, path + ["marker_fraction"])
                    self.marker_size_limiting_scale_multiplier = self.__class__.marker_size_limiting_scale_multiplier(service, version, mode, path + ["marker_size_limiting_scale_multiplier"])
                    self.markers_limit = self.__class__.markers_limit(service, version, mode, path + ["markers_limit"])
                    self.outlet_color = self.__class__.outlet_color(service, version, mode, path + ["outlet_color"])
                    self.scale_marker = self.__class__.scale_marker(service, version, mode, path + ["scale_marker"])
                    self.show_inlet_markers = self.__class__.show_inlet_markers(service, version, mode, path + ["show_inlet_markers"])
                    self.show_outlet_markers = self.__class__.show_outlet_markers(service, version, mode, path + ["show_outlet_markers"])
                    super().__init__(service, version, mode, path)
                class color_option(TUIMethod):
                    """
                    .
                    """
                class enabled(TUIMethod):
                    """
                    .
                    """
                class exclude_from_bounding(TUIMethod):
                    """
                    .
                    """
                class inlet_color(TUIMethod):
                    """
                    .
                    """
                class marker_fraction(TUIMethod):
                    """
                    .
                    """
                class marker_size_limiting_scale_multiplier(TUIMethod):
                    """
                    .
                    """
                class markers_limit(TUIMethod):
                    """
                    .
                    """
                class outlet_color(TUIMethod):
                    """
                    .
                    """
                class scale_marker(TUIMethod):
                    """
                    .
                    """
                class show_inlet_markers(TUIMethod):
                    """
                    .
                    """
                class show_outlet_markers(TUIMethod):
                    """
                    .
                    """

            class colormap_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.alignment = self.__class__.alignment(service, version, mode, path + ["alignment"])
                    self.aspect_ratio_when_horizontal = self.__class__.aspect_ratio_when_horizontal(service, version, mode, path + ["aspect_ratio_when_horizontal"])
                    self.aspect_ratio_when_vertical = self.__class__.aspect_ratio_when_vertical(service, version, mode, path + ["aspect_ratio_when_vertical"])
                    self.auto_refit_on_resize = self.__class__.auto_refit_on_resize(service, version, mode, path + ["auto_refit_on_resize"])
                    self.automatic_resize = self.__class__.automatic_resize(service, version, mode, path + ["automatic_resize"])
                    self.border_style = self.__class__.border_style(service, version, mode, path + ["border_style"])
                    self.colormap = self.__class__.colormap(service, version, mode, path + ["colormap"])
                    self.isolines_position_offset = self.__class__.isolines_position_offset(service, version, mode, path + ["isolines_position_offset"])
                    self.labels = self.__class__.labels(service, version, mode, path + ["labels"])
                    self.levels = self.__class__.levels(service, version, mode, path + ["levels"])
                    self.log_scale = self.__class__.log_scale(service, version, mode, path + ["log_scale"])
                    self.major_length_to_screen_ratio_when_horizontal = self.__class__.major_length_to_screen_ratio_when_horizontal(service, version, mode, path + ["major_length_to_screen_ratio_when_horizontal"])
                    self.major_length_to_screen_ratio_when_vertical = self.__class__.major_length_to_screen_ratio_when_vertical(service, version, mode, path + ["major_length_to_screen_ratio_when_vertical"])
                    self.margin_from_edge_to_screen_ratio = self.__class__.margin_from_edge_to_screen_ratio(service, version, mode, path + ["margin_from_edge_to_screen_ratio"])
                    self.max_size_scale_factor = self.__class__.max_size_scale_factor(service, version, mode, path + ["max_size_scale_factor"])
                    self.min_size_scale_factor = self.__class__.min_size_scale_factor(service, version, mode, path + ["min_size_scale_factor"])
                    self.number_format_precision = self.__class__.number_format_precision(service, version, mode, path + ["number_format_precision"])
                    self.number_format_type = self.__class__.number_format_type(service, version, mode, path + ["number_format_type"])
                    self.preserve_aspect_ratio_for_hardcopy = self.__class__.preserve_aspect_ratio_for_hardcopy(service, version, mode, path + ["preserve_aspect_ratio_for_hardcopy"])
                    self.show_colormap = self.__class__.show_colormap(service, version, mode, path + ["show_colormap"])
                    self.skip_value = self.__class__.skip_value(service, version, mode, path + ["skip_value"])
                    self.text_behavior = self.__class__.text_behavior(service, version, mode, path + ["text_behavior"])
                    self.text_font_automatic_horizontal_size = self.__class__.text_font_automatic_horizontal_size(service, version, mode, path + ["text_font_automatic_horizontal_size"])
                    self.text_font_automatic_size = self.__class__.text_font_automatic_size(service, version, mode, path + ["text_font_automatic_size"])
                    self.text_font_automatic_units = self.__class__.text_font_automatic_units(service, version, mode, path + ["text_font_automatic_units"])
                    self.text_font_automatic_vertical_size = self.__class__.text_font_automatic_vertical_size(service, version, mode, path + ["text_font_automatic_vertical_size"])
                    self.text_font_fixed_horizontal_size = self.__class__.text_font_fixed_horizontal_size(service, version, mode, path + ["text_font_fixed_horizontal_size"])
                    self.text_font_fixed_size = self.__class__.text_font_fixed_size(service, version, mode, path + ["text_font_fixed_size"])
                    self.text_font_fixed_units = self.__class__.text_font_fixed_units(service, version, mode, path + ["text_font_fixed_units"])
                    self.text_font_fixed_vertical_size = self.__class__.text_font_fixed_vertical_size(service, version, mode, path + ["text_font_fixed_vertical_size"])
                    self.text_font_name = self.__class__.text_font_name(service, version, mode, path + ["text_font_name"])
                    self.text_truncation_limit_for_horizontal_colormaps = self.__class__.text_truncation_limit_for_horizontal_colormaps(service, version, mode, path + ["text_truncation_limit_for_horizontal_colormaps"])
                    self.text_truncation_limit_for_vertical_colormaps = self.__class__.text_truncation_limit_for_vertical_colormaps(service, version, mode, path + ["text_truncation_limit_for_vertical_colormaps"])
                    self.type = self.__class__.type(service, version, mode, path + ["type"])
                    self.use_no_sub_windows = self.__class__.use_no_sub_windows(service, version, mode, path + ["use_no_sub_windows"])
                    super().__init__(service, version, mode, path)
                class alignment(TUIMethod):
                    """
                    .
                    """
                class aspect_ratio_when_horizontal(TUIMethod):
                    """
                    .
                    """
                class aspect_ratio_when_vertical(TUIMethod):
                    """
                    .
                    """
                class auto_refit_on_resize(TUIMethod):
                    """
                    .
                    """
                class automatic_resize(TUIMethod):
                    """
                    .
                    """
                class border_style(TUIMethod):
                    """
                    .
                    """
                class colormap(TUIMethod):
                    """
                    .
                    """
                class isolines_position_offset(TUIMethod):
                    """
                    .
                    """
                class labels(TUIMethod):
                    """
                    .
                    """
                class levels(TUIMethod):
                    """
                    .
                    """
                class log_scale(TUIMethod):
                    """
                    .
                    """
                class major_length_to_screen_ratio_when_horizontal(TUIMethod):
                    """
                    .
                    """
                class major_length_to_screen_ratio_when_vertical(TUIMethod):
                    """
                    .
                    """
                class margin_from_edge_to_screen_ratio(TUIMethod):
                    """
                    .
                    """
                class max_size_scale_factor(TUIMethod):
                    """
                    .
                    """
                class min_size_scale_factor(TUIMethod):
                    """
                    .
                    """
                class number_format_precision(TUIMethod):
                    """
                    .
                    """
                class number_format_type(TUIMethod):
                    """
                    .
                    """
                class preserve_aspect_ratio_for_hardcopy(TUIMethod):
                    """
                    .
                    """
                class show_colormap(TUIMethod):
                    """
                    .
                    """
                class skip_value(TUIMethod):
                    """
                    .
                    """
                class text_behavior(TUIMethod):
                    """
                    .
                    """
                class text_font_automatic_horizontal_size(TUIMethod):
                    """
                    .
                    """
                class text_font_automatic_size(TUIMethod):
                    """
                    .
                    """
                class text_font_automatic_units(TUIMethod):
                    """
                    .
                    """
                class text_font_automatic_vertical_size(TUIMethod):
                    """
                    .
                    """
                class text_font_fixed_horizontal_size(TUIMethod):
                    """
                    .
                    """
                class text_font_fixed_size(TUIMethod):
                    """
                    .
                    """
                class text_font_fixed_units(TUIMethod):
                    """
                    .
                    """
                class text_font_fixed_vertical_size(TUIMethod):
                    """
                    .
                    """
                class text_font_name(TUIMethod):
                    """
                    .
                    """
                class text_truncation_limit_for_horizontal_colormaps(TUIMethod):
                    """
                    .
                    """
                class text_truncation_limit_for_vertical_colormaps(TUIMethod):
                    """
                    .
                    """
                class type(TUIMethod):
                    """
                    .
                    """
                class use_no_sub_windows(TUIMethod):
                    """
                    .
                    """

            class embedded_windows(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.default_embedded_mesh_windows_view = self.__class__.default_embedded_mesh_windows_view(service, version, mode, path + ["default_embedded_mesh_windows_view"])
                    self.default_embedded_windows_view = self.__class__.default_embedded_windows_view(service, version, mode, path + ["default_embedded_windows_view"])
                    self.save_embedded_window_layout = self.__class__.save_embedded_window_layout(service, version, mode, path + ["save_embedded_window_layout"])
                    self.show_border_for_embedded_window = self.__class__.show_border_for_embedded_window(service, version, mode, path + ["show_border_for_embedded_window"])
                    super().__init__(service, version, mode, path)
                class default_embedded_mesh_windows_view(TUIMethod):
                    """
                    .
                    """
                class default_embedded_windows_view(TUIMethod):
                    """
                    .
                    """
                class save_embedded_window_layout(TUIMethod):
                    """
                    .
                    """
                class show_border_for_embedded_window(TUIMethod):
                    """
                    .
                    """

            class export_video_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.advanced_video_quality_options = self.__class__.advanced_video_quality_options(service, version, mode, path + ["advanced_video_quality_options"])
                    self.video_format = self.__class__.video_format(service, version, mode, path + ["video_format"])
                    self.video_fps = self.__class__.video_fps(service, version, mode, path + ["video_fps"])
                    self.video_quality = self.__class__.video_quality(service, version, mode, path + ["video_quality"])
                    self.video_resoution_x = self.__class__.video_resoution_x(service, version, mode, path + ["video_resoution_x"])
                    self.video_resoution_y = self.__class__.video_resoution_y(service, version, mode, path + ["video_resoution_y"])
                    self.video_scale = self.__class__.video_scale(service, version, mode, path + ["video_scale"])
                    self.video_smooth_scaling = self.__class__.video_smooth_scaling(service, version, mode, path + ["video_smooth_scaling"])
                    self.video_use_frame_resolution = self.__class__.video_use_frame_resolution(service, version, mode, path + ["video_use_frame_resolution"])
                    super().__init__(service, version, mode, path)
                class video_format(TUIMethod):
                    """
                    .
                    """
                class video_fps(TUIMethod):
                    """
                    .
                    """
                class video_quality(TUIMethod):
                    """
                    .
                    """
                class video_resoution_x(TUIMethod):
                    """
                    .
                    """
                class video_resoution_y(TUIMethod):
                    """
                    .
                    """
                class video_scale(TUIMethod):
                    """
                    .
                    """
                class video_smooth_scaling(TUIMethod):
                    """
                    .
                    """
                class video_use_frame_resolution(TUIMethod):
                    """
                    .
                    """

                class advanced_video_quality_options(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.bit_rate_quality = self.__class__.bit_rate_quality(service, version, mode, path + ["bit_rate_quality"])
                        self.bitrate = self.__class__.bitrate(service, version, mode, path + ["bitrate"])
                        self.compression_method = self.__class__.compression_method(service, version, mode, path + ["compression_method"])
                        self.enable_h264 = self.__class__.enable_h264(service, version, mode, path + ["enable_h264"])
                        super().__init__(service, version, mode, path)
                    class bit_rate_quality(TUIMethod):
                        """
                        .
                        """
                    class bitrate(TUIMethod):
                        """
                        .
                        """
                    class compression_method(TUIMethod):
                        """
                        .
                        """
                    class enable_h264(TUIMethod):
                        """
                        .
                        """

            class graphics_effects(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.ambient_occlusion_enabled = self.__class__.ambient_occlusion_enabled(service, version, mode, path + ["ambient_occlusion_enabled"])
                    self.ambient_occlusion_quality = self.__class__.ambient_occlusion_quality(service, version, mode, path + ["ambient_occlusion_quality"])
                    self.ambient_occlusion_strength = self.__class__.ambient_occlusion_strength(service, version, mode, path + ["ambient_occlusion_strength"])
                    self.anti_aliasing = self.__class__.anti_aliasing(service, version, mode, path + ["anti_aliasing"])
                    self.bloom_blur = self.__class__.bloom_blur(service, version, mode, path + ["bloom_blur"])
                    self.bloom_enabled = self.__class__.bloom_enabled(service, version, mode, path + ["bloom_enabled"])
                    self.bloom_strength = self.__class__.bloom_strength(service, version, mode, path + ["bloom_strength"])
                    self.grid_color = self.__class__.grid_color(service, version, mode, path + ["grid_color"])
                    self.grid_plane_count = self.__class__.grid_plane_count(service, version, mode, path + ["grid_plane_count"])
                    self.grid_plane_enabled = self.__class__.grid_plane_enabled(service, version, mode, path + ["grid_plane_enabled"])
                    self.grid_plane_offset = self.__class__.grid_plane_offset(service, version, mode, path + ["grid_plane_offset"])
                    self.grid_plane_size_factor = self.__class__.grid_plane_size_factor(service, version, mode, path + ["grid_plane_size_factor"])
                    self.plane_direction = self.__class__.plane_direction(service, version, mode, path + ["plane_direction"])
                    self.reflections_enabled = self.__class__.reflections_enabled(service, version, mode, path + ["reflections_enabled"])
                    self.shadow_map_enabled = self.__class__.shadow_map_enabled(service, version, mode, path + ["shadow_map_enabled"])
                    self.show_edge_reflections = self.__class__.show_edge_reflections(service, version, mode, path + ["show_edge_reflections"])
                    self.show_marker_reflections = self.__class__.show_marker_reflections(service, version, mode, path + ["show_marker_reflections"])
                    self.simple_shadows_enabled = self.__class__.simple_shadows_enabled(service, version, mode, path + ["simple_shadows_enabled"])
                    self.update_after_mouse_release = self.__class__.update_after_mouse_release(service, version, mode, path + ["update_after_mouse_release"])
                    super().__init__(service, version, mode, path)
                class ambient_occlusion_enabled(TUIMethod):
                    """
                    .
                    """
                class ambient_occlusion_quality(TUIMethod):
                    """
                    .
                    """
                class ambient_occlusion_strength(TUIMethod):
                    """
                    .
                    """
                class anti_aliasing(TUIMethod):
                    """
                    .
                    """
                class bloom_blur(TUIMethod):
                    """
                    .
                    """
                class bloom_enabled(TUIMethod):
                    """
                    .
                    """
                class bloom_strength(TUIMethod):
                    """
                    .
                    """
                class grid_color(TUIMethod):
                    """
                    .
                    """
                class grid_plane_count(TUIMethod):
                    """
                    .
                    """
                class grid_plane_enabled(TUIMethod):
                    """
                    .
                    """
                class grid_plane_offset(TUIMethod):
                    """
                    .
                    """
                class grid_plane_size_factor(TUIMethod):
                    """
                    .
                    """
                class plane_direction(TUIMethod):
                    """
                    .
                    """
                class reflections_enabled(TUIMethod):
                    """
                    .
                    """
                class shadow_map_enabled(TUIMethod):
                    """
                    .
                    """
                class show_edge_reflections(TUIMethod):
                    """
                    .
                    """
                class show_marker_reflections(TUIMethod):
                    """
                    .
                    """
                class simple_shadows_enabled(TUIMethod):
                    """
                    .
                    """
                class update_after_mouse_release(TUIMethod):
                    """
                    .
                    """

            class hardcopy_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.export_edges_for_avz = self.__class__.export_edges_for_avz(service, version, mode, path + ["export_edges_for_avz"])
                    self.hardcopy_driver = self.__class__.hardcopy_driver(service, version, mode, path + ["hardcopy_driver"])
                    self.hardcopy_line_width = self.__class__.hardcopy_line_width(service, version, mode, path + ["hardcopy_line_width"])
                    self.hardware_image_accel = self.__class__.hardware_image_accel(service, version, mode, path + ["hardware_image_accel"])
                    self.post_script_permission_override = self.__class__.post_script_permission_override(service, version, mode, path + ["post_script_permission_override"])
                    self.retain_colormap_pos_for_avz = self.__class__.retain_colormap_pos_for_avz(service, version, mode, path + ["retain_colormap_pos_for_avz"])
                    self.save_embedded_hardcopies_separately = self.__class__.save_embedded_hardcopies_separately(service, version, mode, path + ["save_embedded_hardcopies_separately"])
                    self.save_embedded_windows_in_hardcopy = self.__class__.save_embedded_windows_in_hardcopy(service, version, mode, path + ["save_embedded_windows_in_hardcopy"])
                    self.transparent_embedded_windows = self.__class__.transparent_embedded_windows(service, version, mode, path + ["transparent_embedded_windows"])
                    super().__init__(service, version, mode, path)
                class export_edges_for_avz(TUIMethod):
                    """
                    .
                    """
                class hardcopy_driver(TUIMethod):
                    """
                    .
                    """
                class hardcopy_line_width(TUIMethod):
                    """
                    .
                    """
                class hardware_image_accel(TUIMethod):
                    """
                    .
                    """
                class post_script_permission_override(TUIMethod):
                    """
                    .
                    """
                class retain_colormap_pos_for_avz(TUIMethod):
                    """
                    .
                    """
                class save_embedded_hardcopies_separately(TUIMethod):
                    """
                    .
                    """
                class save_embedded_windows_in_hardcopy(TUIMethod):
                    """
                    .
                    """
                class transparent_embedded_windows(TUIMethod):
                    """
                    .
                    """

            class lighting(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.ambient_light_intensity = self.__class__.ambient_light_intensity(service, version, mode, path + ["ambient_light_intensity"])
                    self.headlight = self.__class__.headlight(service, version, mode, path + ["headlight"])
                    self.headlight_intensity = self.__class__.headlight_intensity(service, version, mode, path + ["headlight_intensity"])
                    self.lighting_method = self.__class__.lighting_method(service, version, mode, path + ["lighting_method"])
                    super().__init__(service, version, mode, path)
                class ambient_light_intensity(TUIMethod):
                    """
                    .
                    """
                class headlight(TUIMethod):
                    """
                    .
                    """
                class headlight_intensity(TUIMethod):
                    """
                    .
                    """
                class lighting_method(TUIMethod):
                    """
                    .
                    """

            class manage_hoops_memory(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.enabled = self.__class__.enabled(service, version, mode, path + ["enabled"])
                    self.hsfimport_limit = self.__class__.hsfimport_limit(service, version, mode, path + ["hsfimport_limit"])
                    super().__init__(service, version, mode, path)
                class enabled(TUIMethod):
                    """
                    .
                    """
                class hsfimport_limit(TUIMethod):
                    """
                    .
                    """

            class material_effects(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.decimation_filter = self.__class__.decimation_filter(service, version, mode, path + ["decimation_filter"])
                    self.parameterization_source = self.__class__.parameterization_source(service, version, mode, path + ["parameterization_source"])
                    self.tiling_style = self.__class__.tiling_style(service, version, mode, path + ["tiling_style"])
                    super().__init__(service, version, mode, path)
                class decimation_filter(TUIMethod):
                    """
                    .
                    """
                class parameterization_source(TUIMethod):
                    """
                    .
                    """
                class tiling_style(TUIMethod):
                    """
                    .
                    """

            class meshing_mode(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.graphics_window_display_timeout = self.__class__.graphics_window_display_timeout(service, version, mode, path + ["graphics_window_display_timeout"])
                    self.graphics_window_display_timeout_value = self.__class__.graphics_window_display_timeout_value(service, version, mode, path + ["graphics_window_display_timeout_value"])
                    super().__init__(service, version, mode, path)
                class graphics_window_display_timeout(TUIMethod):
                    """
                    .
                    """
                class graphics_window_display_timeout_value(TUIMethod):
                    """
                    .
                    """

            class performance(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.fast_display_mode = self.__class__.fast_display_mode(service, version, mode, path + ["fast_display_mode"])
                    self.minimum_frame_rate = self.__class__.minimum_frame_rate(service, version, mode, path + ["minimum_frame_rate"])
                    self.optimize_for = self.__class__.optimize_for(service, version, mode, path + ["optimize_for"])
                    self.ratio_of_target_frame_rate_to_classify_heavy_geometry = self.__class__.ratio_of_target_frame_rate_to_classify_heavy_geometry(service, version, mode, path + ["ratio_of_target_frame_rate_to_classify_heavy_geometry"])
                    self.ratio_of_target_frame_rate_to_declassify_heavy_geometry = self.__class__.ratio_of_target_frame_rate_to_declassify_heavy_geometry(service, version, mode, path + ["ratio_of_target_frame_rate_to_declassify_heavy_geometry"])
                    super().__init__(service, version, mode, path)
                class optimize_for(TUIMethod):
                    """
                    .
                    """
                class ratio_of_target_frame_rate_to_classify_heavy_geometry(TUIMethod):
                    """
                    .
                    """
                class ratio_of_target_frame_rate_to_declassify_heavy_geometry(TUIMethod):
                    """
                    .
                    """

                class fast_display_mode(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.culling = self.__class__.culling(service, version, mode, path + ["culling"])
                        self.faces_shown = self.__class__.faces_shown(service, version, mode, path + ["faces_shown"])
                        self.markers_decimation = self.__class__.markers_decimation(service, version, mode, path + ["markers_decimation"])
                        self.nodes_shown = self.__class__.nodes_shown(service, version, mode, path + ["nodes_shown"])
                        self.perimeter_edges_shown = self.__class__.perimeter_edges_shown(service, version, mode, path + ["perimeter_edges_shown"])
                        self.silhouette_shown = self.__class__.silhouette_shown(service, version, mode, path + ["silhouette_shown"])
                        self.status = self.__class__.status(service, version, mode, path + ["status"])
                        self.transparency = self.__class__.transparency(service, version, mode, path + ["transparency"])
                        super().__init__(service, version, mode, path)
                    class culling(TUIMethod):
                        """
                        .
                        """
                    class faces_shown(TUIMethod):
                        """
                        .
                        """
                    class markers_decimation(TUIMethod):
                        """
                        .
                        """
                    class nodes_shown(TUIMethod):
                        """
                        .
                        """
                    class perimeter_edges_shown(TUIMethod):
                        """
                        .
                        """
                    class silhouette_shown(TUIMethod):
                        """
                        .
                        """
                    class status(TUIMethod):
                        """
                        .
                        """
                    class transparency(TUIMethod):
                        """
                        .
                        """

                class minimum_frame_rate(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.dynamic_adjustment = self.__class__.dynamic_adjustment(service, version, mode, path + ["dynamic_adjustment"])
                        self.enabled = self.__class__.enabled(service, version, mode, path + ["enabled"])
                        self.fixed_culling_value = self.__class__.fixed_culling_value(service, version, mode, path + ["fixed_culling_value"])
                        self.maximum_culling_threshold = self.__class__.maximum_culling_threshold(service, version, mode, path + ["maximum_culling_threshold"])
                        self.minimum_culling_threshold = self.__class__.minimum_culling_threshold(service, version, mode, path + ["minimum_culling_threshold"])
                        self.target_fps = self.__class__.target_fps(service, version, mode, path + ["target_fps"])
                        super().__init__(service, version, mode, path)
                    class dynamic_adjustment(TUIMethod):
                        """
                        .
                        """
                    class enabled(TUIMethod):
                        """
                        .
                        """
                    class fixed_culling_value(TUIMethod):
                        """
                        .
                        """
                    class maximum_culling_threshold(TUIMethod):
                        """
                        .
                        """
                    class minimum_culling_threshold(TUIMethod):
                        """
                        .
                        """
                    class target_fps(TUIMethod):
                        """
                        .
                        """

            class transparency(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.algorithm_for_modern_drivers = self.__class__.algorithm_for_modern_drivers(service, version, mode, path + ["algorithm_for_modern_drivers"])
                    self.depth_peeling_layers = self.__class__.depth_peeling_layers(service, version, mode, path + ["depth_peeling_layers"])
                    self.depth_peeling_preference = self.__class__.depth_peeling_preference(service, version, mode, path + ["depth_peeling_preference"])
                    self.quick_moves = self.__class__.quick_moves(service, version, mode, path + ["quick_moves"])
                    self.zsort_options = self.__class__.zsort_options(service, version, mode, path + ["zsort_options"])
                    super().__init__(service, version, mode, path)
                class algorithm_for_modern_drivers(TUIMethod):
                    """
                    .
                    """
                class depth_peeling_layers(TUIMethod):
                    """
                    .
                    """
                class depth_peeling_preference(TUIMethod):
                    """
                    .
                    """
                class quick_moves(TUIMethod):
                    """
                    .
                    """
                class zsort_options(TUIMethod):
                    """
                    .
                    """

            class vector_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.arrow3_dradius1_factor = self.__class__.arrow3_dradius1_factor(service, version, mode, path + ["arrow3_dradius1_factor"])
                    self.arrow3_dradius2_factor = self.__class__.arrow3_dradius2_factor(service, version, mode, path + ["arrow3_dradius2_factor"])
                    self.arrowhead3_dradius1_factor = self.__class__.arrowhead3_dradius1_factor(service, version, mode, path + ["arrowhead3_dradius1_factor"])
                    self.line_arrow3_dperpendicular_radius = self.__class__.line_arrow3_dperpendicular_radius(service, version, mode, path + ["line_arrow3_dperpendicular_radius"])
                    super().__init__(service, version, mode, path)
                class arrow3_dradius1_factor(TUIMethod):
                    """
                    .
                    """
                class arrow3_dradius2_factor(TUIMethod):
                    """
                    .
                    """
                class arrowhead3_dradius1_factor(TUIMethod):
                    """
                    .
                    """
                class line_arrow3_dperpendicular_radius(TUIMethod):
                    """
                    .
                    """

        class mat_pro_app(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.check_expression = self.__class__.check_expression(service, version, mode, path + ["check_expression"])
                self.beta_features = self.__class__.beta_features(service, version, mode, path + ["beta_features"])
                self.focus = self.__class__.focus(service, version, mode, path + ["focus"])
                self.mesh_naming = self.__class__.mesh_naming(service, version, mode, path + ["mesh_naming"])
                self.tracking = self.__class__.tracking(service, version, mode, path + ["tracking"])
                self.warning = self.__class__.warning(service, version, mode, path + ["warning"])
                super().__init__(service, version, mode, path)
            class beta_features(TUIMethod):
                """
                .
                """
            class focus(TUIMethod):
                """
                .
                """
            class mesh_naming(TUIMethod):
                """
                .
                """
            class tracking(TUIMethod):
                """
                .
                """
            class warning(TUIMethod):
                """
                .
                """

            class check_expression(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.cdot = self.__class__.cdot(service, version, mode, path + ["cdot"])
                    self.coordinates = self.__class__.coordinates(service, version, mode, path + ["coordinates"])
                    self.dvv = self.__class__.dvv(service, version, mode, path + ["dvv"])
                    self.edot = self.__class__.edot(service, version, mode, path + ["edot"])
                    self.gdot = self.__class__.gdot(service, version, mode, path + ["gdot"])
                    self.giesekus = self.__class__.giesekus(service, version, mode, path + ["giesekus"])
                    self.pressure = self.__class__.pressure(service, version, mode, path + ["pressure"])
                    self.species = self.__class__.species(service, version, mode, path + ["species"])
                    self.temperature = self.__class__.temperature(service, version, mode, path + ["temperature"])
                    self.time = self.__class__.time(service, version, mode, path + ["time"])
                    self.velocities = self.__class__.velocities(service, version, mode, path + ["velocities"])
                    self.vorticity = self.__class__.vorticity(service, version, mode, path + ["vorticity"])
                    super().__init__(service, version, mode, path)
                class cdot(TUIMethod):
                    """
                    .
                    """
                class coordinates(TUIMethod):
                    """
                    .
                    """
                class dvv(TUIMethod):
                    """
                    .
                    """
                class edot(TUIMethod):
                    """
                    .
                    """
                class gdot(TUIMethod):
                    """
                    .
                    """
                class giesekus(TUIMethod):
                    """
                    .
                    """
                class pressure(TUIMethod):
                    """
                    .
                    """
                class species(TUIMethod):
                    """
                    .
                    """
                class temperature(TUIMethod):
                    """
                    .
                    """
                class time(TUIMethod):
                    """
                    .
                    """
                class velocities(TUIMethod):
                    """
                    .
                    """
                class vorticity(TUIMethod):
                    """
                    .
                    """

        class meshing_workflow(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.draw_settings = self.__class__.draw_settings(service, version, mode, path + ["draw_settings"])
                self.checkpointing_option = self.__class__.checkpointing_option(service, version, mode, path + ["checkpointing_option"])
                self.save_checkpoint_files = self.__class__.save_checkpoint_files(service, version, mode, path + ["save_checkpoint_files"])
                self.save_wft_file_with_mesh = self.__class__.save_wft_file_with_mesh(service, version, mode, path + ["save_wft_file_with_mesh"])
                self.temp_folder = self.__class__.temp_folder(service, version, mode, path + ["temp_folder"])
                self.templates_folder = self.__class__.templates_folder(service, version, mode, path + ["templates_folder"])
                self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                super().__init__(service, version, mode, path)
            class checkpointing_option(TUIMethod):
                """
                .
                """
            class save_checkpoint_files(TUIMethod):
                """
                .
                """
            class save_wft_file_with_mesh(TUIMethod):
                """
                .
                """
            class temp_folder(TUIMethod):
                """
                .
                """
            class templates_folder(TUIMethod):
                """
                .
                """
            class verbosity(TUIMethod):
                """
                .
                """

            class draw_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.auto_draw = self.__class__.auto_draw(service, version, mode, path + ["auto_draw"])
                    self.face_zone_limit = self.__class__.face_zone_limit(service, version, mode, path + ["face_zone_limit"])
                    self.facet_limit = self.__class__.facet_limit(service, version, mode, path + ["facet_limit"])
                    super().__init__(service, version, mode, path)
                class auto_draw(TUIMethod):
                    """
                    .
                    """
                class face_zone_limit(TUIMethod):
                    """
                    .
                    """
                class facet_limit(TUIMethod):
                    """
                    .
                    """

        class navigation(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.mouse_mapping = self.__class__.mouse_mapping(service, version, mode, path + ["mouse_mapping"])
                super().__init__(service, version, mode, path)

            class mouse_mapping(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.additional = self.__class__.additional(service, version, mode, path + ["additional"])
                    self.basic = self.__class__.basic(service, version, mode, path + ["basic"])
                    self.mousemaptheme = self.__class__.mousemaptheme(service, version, mode, path + ["mousemaptheme"])
                    super().__init__(service, version, mode, path)
                class mousemaptheme(TUIMethod):
                    """
                    .
                    """

                class additional(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.ctrllmbclick = self.__class__.ctrllmbclick(service, version, mode, path + ["ctrllmbclick"])
                        self.ctrllmbdrag = self.__class__.ctrllmbdrag(service, version, mode, path + ["ctrllmbdrag"])
                        self.ctrlmmbclick = self.__class__.ctrlmmbclick(service, version, mode, path + ["ctrlmmbclick"])
                        self.ctrlmmbdrag = self.__class__.ctrlmmbdrag(service, version, mode, path + ["ctrlmmbdrag"])
                        self.ctrlrmbclick = self.__class__.ctrlrmbclick(service, version, mode, path + ["ctrlrmbclick"])
                        self.ctrlrmbdrag = self.__class__.ctrlrmbdrag(service, version, mode, path + ["ctrlrmbdrag"])
                        self.mouseprobe = self.__class__.mouseprobe(service, version, mode, path + ["mouseprobe"])
                        self.mousewheel = self.__class__.mousewheel(service, version, mode, path + ["mousewheel"])
                        self.mousewheelsensitivity = self.__class__.mousewheelsensitivity(service, version, mode, path + ["mousewheelsensitivity"])
                        self.reversewheeldirection = self.__class__.reversewheeldirection(service, version, mode, path + ["reversewheeldirection"])
                        self.shiftlmbclick = self.__class__.shiftlmbclick(service, version, mode, path + ["shiftlmbclick"])
                        self.shiftlmbdrag = self.__class__.shiftlmbdrag(service, version, mode, path + ["shiftlmbdrag"])
                        self.shiftmmbclick = self.__class__.shiftmmbclick(service, version, mode, path + ["shiftmmbclick"])
                        self.shiftmmbdrag = self.__class__.shiftmmbdrag(service, version, mode, path + ["shiftmmbdrag"])
                        self.shiftrmbclick = self.__class__.shiftrmbclick(service, version, mode, path + ["shiftrmbclick"])
                        self.shiftrmbdrag = self.__class__.shiftrmbdrag(service, version, mode, path + ["shiftrmbdrag"])
                        super().__init__(service, version, mode, path)
                    class ctrllmbclick(TUIMethod):
                        """
                        .
                        """
                    class ctrllmbdrag(TUIMethod):
                        """
                        .
                        """
                    class ctrlmmbclick(TUIMethod):
                        """
                        .
                        """
                    class ctrlmmbdrag(TUIMethod):
                        """
                        .
                        """
                    class ctrlrmbclick(TUIMethod):
                        """
                        .
                        """
                    class ctrlrmbdrag(TUIMethod):
                        """
                        .
                        """
                    class mouseprobe(TUIMethod):
                        """
                        .
                        """
                    class mousewheel(TUIMethod):
                        """
                        .
                        """
                    class mousewheelsensitivity(TUIMethod):
                        """
                        .
                        """
                    class reversewheeldirection(TUIMethod):
                        """
                        .
                        """
                    class shiftlmbclick(TUIMethod):
                        """
                        .
                        """
                    class shiftlmbdrag(TUIMethod):
                        """
                        .
                        """
                    class shiftmmbclick(TUIMethod):
                        """
                        .
                        """
                    class shiftmmbdrag(TUIMethod):
                        """
                        .
                        """
                    class shiftrmbclick(TUIMethod):
                        """
                        .
                        """
                    class shiftrmbdrag(TUIMethod):
                        """
                        .
                        """

                class basic(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.lmb = self.__class__.lmb(service, version, mode, path + ["lmb"])
                        self.lmbclick = self.__class__.lmbclick(service, version, mode, path + ["lmbclick"])
                        self.mmb = self.__class__.mmb(service, version, mode, path + ["mmb"])
                        self.mmbclick = self.__class__.mmbclick(service, version, mode, path + ["mmbclick"])
                        self.rmb = self.__class__.rmb(service, version, mode, path + ["rmb"])
                        self.rmbclick = self.__class__.rmbclick(service, version, mode, path + ["rmbclick"])
                        super().__init__(service, version, mode, path)
                    class lmb(TUIMethod):
                        """
                        .
                        """
                    class lmbclick(TUIMethod):
                        """
                        .
                        """
                    class mmb(TUIMethod):
                        """
                        .
                        """
                    class mmbclick(TUIMethod):
                        """
                        .
                        """
                    class rmb(TUIMethod):
                        """
                        .
                        """
                    class rmbclick(TUIMethod):
                        """
                        .
                        """

        class parametric_study(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.layout_options = self.__class__.layout_options(service, version, mode, path + ["layout_options"])
                self.update_options = self.__class__.update_options(service, version, mode, path + ["update_options"])
                super().__init__(service, version, mode, path)

            class layout_options(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.current_case_parameters = self.__class__.current_case_parameters(service, version, mode, path + ["current_case_parameters"])
                    self.parametric_study_tree = self.__class__.parametric_study_tree(service, version, mode, path + ["parametric_study_tree"])
                    super().__init__(service, version, mode, path)
                class current_case_parameters(TUIMethod):
                    """
                    .
                    """
                class parametric_study_tree(TUIMethod):
                    """
                    .
                    """

            class update_options(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.auto_refresh_time = self.__class__.auto_refresh_time(service, version, mode, path + ["auto_refresh_time"])
                    self.capture_sim_report_data = self.__class__.capture_sim_report_data(service, version, mode, path + ["capture_sim_report_data"])
                    self.enable_auto_refresh = self.__class__.enable_auto_refresh(service, version, mode, path + ["enable_auto_refresh"])
                    self.save_project_after_dpupdate = self.__class__.save_project_after_dpupdate(service, version, mode, path + ["save_project_after_dpupdate"])
                    self.write_data = self.__class__.write_data(service, version, mode, path + ["write_data"])
                    super().__init__(service, version, mode, path)
                class auto_refresh_time(TUIMethod):
                    """
                    .
                    """
                class capture_sim_report_data(TUIMethod):
                    """
                    .
                    """
                class enable_auto_refresh(TUIMethod):
                    """
                    .
                    """
                class save_project_after_dpupdate(TUIMethod):
                    """
                    .
                    """
                class write_data(TUIMethod):
                    """
                    .
                    """

        class simulation(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.report_definitions = self.__class__.report_definitions(service, version, mode, path + ["report_definitions"])
                self.flow_model = self.__class__.flow_model(service, version, mode, path + ["flow_model"])
                self.local_residual_scaling = self.__class__.local_residual_scaling(service, version, mode, path + ["local_residual_scaling"])
                self.pdf_combustion_robust_numerics = self.__class__.pdf_combustion_robust_numerics(service, version, mode, path + ["pdf_combustion_robust_numerics"])
                super().__init__(service, version, mode, path)
            class flow_model(TUIMethod):
                """
                .
                """
            class local_residual_scaling(TUIMethod):
                """
                .
                """
            class pdf_combustion_robust_numerics(TUIMethod):
                """
                .
                """

            class report_definitions(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.automatic_plot_file = self.__class__.automatic_plot_file(service, version, mode, path + ["automatic_plot_file"])
                    self.report_plot_history_data_size = self.__class__.report_plot_history_data_size(service, version, mode, path + ["report_plot_history_data_size"])
                    super().__init__(service, version, mode, path)
                class automatic_plot_file(TUIMethod):
                    """
                    .
                    """
                class report_plot_history_data_size(TUIMethod):
                    """
                    .
                    """

        class turbo_workflow(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.face_zone_settings = self.__class__.face_zone_settings(service, version, mode, path + ["face_zone_settings"])
                self.graphics_settings = self.__class__.graphics_settings(service, version, mode, path + ["graphics_settings"])
                self.checkpointing_option = self.__class__.checkpointing_option(service, version, mode, path + ["checkpointing_option"])
                self.save_checkpoint_files = self.__class__.save_checkpoint_files(service, version, mode, path + ["save_checkpoint_files"])
                super().__init__(service, version, mode, path)
            class checkpointing_option(TUIMethod):
                """
                .
                """
            class save_checkpoint_files(TUIMethod):
                """
                .
                """

            class face_zone_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.blade_region = self.__class__.blade_region(service, version, mode, path + ["blade_region"])
                    self.fzsearch_order = self.__class__.fzsearch_order(service, version, mode, path + ["fzsearch_order"])
                    self.hub_region = self.__class__.hub_region(service, version, mode, path + ["hub_region"])
                    self.inlet_region = self.__class__.inlet_region(service, version, mode, path + ["inlet_region"])
                    self.interior_region = self.__class__.interior_region(service, version, mode, path + ["interior_region"])
                    self.outlet_region = self.__class__.outlet_region(service, version, mode, path + ["outlet_region"])
                    self.periodic1_region = self.__class__.periodic1_region(service, version, mode, path + ["periodic1_region"])
                    self.periodic2_region = self.__class__.periodic2_region(service, version, mode, path + ["periodic2_region"])
                    self.shroud_region = self.__class__.shroud_region(service, version, mode, path + ["shroud_region"])
                    self.symmetry_region = self.__class__.symmetry_region(service, version, mode, path + ["symmetry_region"])
                    self.tip1_region = self.__class__.tip1_region(service, version, mode, path + ["tip1_region"])
                    self.tip2_region = self.__class__.tip2_region(service, version, mode, path + ["tip2_region"])
                    super().__init__(service, version, mode, path)
                class blade_region(TUIMethod):
                    """
                    .
                    """
                class fzsearch_order(TUIMethod):
                    """
                    .
                    """
                class hub_region(TUIMethod):
                    """
                    .
                    """
                class inlet_region(TUIMethod):
                    """
                    .
                    """
                class interior_region(TUIMethod):
                    """
                    .
                    """
                class outlet_region(TUIMethod):
                    """
                    .
                    """
                class periodic1_region(TUIMethod):
                    """
                    .
                    """
                class periodic2_region(TUIMethod):
                    """
                    .
                    """
                class shroud_region(TUIMethod):
                    """
                    .
                    """
                class symmetry_region(TUIMethod):
                    """
                    .
                    """
                class tip1_region(TUIMethod):
                    """
                    .
                    """
                class tip2_region(TUIMethod):
                    """
                    .
                    """

            class graphics_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.auto_draw = self.__class__.auto_draw(service, version, mode, path + ["auto_draw"])
                    super().__init__(service, version, mode, path)
                class auto_draw(TUIMethod):
                    """
                    .
                    """

    class report(TUIMenu):
        """
        Enter the report menu.
        """
        def __init__(self, service, version, mode, path):
            self.dpm_histogram = self.__class__.dpm_histogram(service, version, mode, path + ["dpm_histogram"])
            self.efficiency = self.__class__.efficiency(service, version, mode, path + ["efficiency"])
            self.fluxes = self.__class__.fluxes(service, version, mode, path + ["fluxes"])
            self.forces = self.__class__.forces(service, version, mode, path + ["forces"])
            self.heat_exchanger = self.__class__.heat_exchanger(service, version, mode, path + ["heat_exchanger"])
            self.icing = self.__class__.icing(service, version, mode, path + ["icing"])
            self.modified_setting = self.__class__.modified_setting(service, version, mode, path + ["modified_setting"])
            self.population_balance = self.__class__.population_balance(service, version, mode, path + ["population_balance"])
            self.reference_values = self.__class__.reference_values(service, version, mode, path + ["reference_values"])
            self.simulation_reports = self.__class__.simulation_reports(service, version, mode, path + ["simulation_reports"])
            self.surface_integrals = self.__class__.surface_integrals(service, version, mode, path + ["surface_integrals"])
            self.system = self.__class__.system(service, version, mode, path + ["system"])
            self.volume_integrals = self.__class__.volume_integrals(service, version, mode, path + ["volume_integrals"])
            self.aero_optical_distortions = self.__class__.aero_optical_distortions(service, version, mode, path + ["aero_optical_distortions"])
            self.dpm_extended_summary = self.__class__.dpm_extended_summary(service, version, mode, path + ["dpm_extended_summary"])
            self.dpm_sample = self.__class__.dpm_sample(service, version, mode, path + ["dpm_sample"])
            self.dpm_sample_output_udf = self.__class__.dpm_sample_output_udf(service, version, mode, path + ["dpm_sample_output_udf"])
            self.dpm_sample_sort_file = self.__class__.dpm_sample_sort_file(service, version, mode, path + ["dpm_sample_sort_file"])
            self.dpm_summary = self.__class__.dpm_summary(service, version, mode, path + ["dpm_summary"])
            self.dpm_zone_summaries_per_injection = self.__class__.dpm_zone_summaries_per_injection(service, version, mode, path + ["dpm_zone_summaries_per_injection"])
            self.element_mass_flow = self.__class__.element_mass_flow(service, version, mode, path + ["element_mass_flow"])
            self.evap_mass_details_in_dpm_summ_rep = self.__class__.evap_mass_details_in_dpm_summ_rep(service, version, mode, path + ["evap_mass_details_in_dpm_summ_rep"])
            self.mphase_summary = self.__class__.mphase_summary(service, version, mode, path + ["mphase_summary"])
            self.particle_summary = self.__class__.particle_summary(service, version, mode, path + ["particle_summary"])
            self.path_line_summary = self.__class__.path_line_summary(service, version, mode, path + ["path_line_summary"])
            self.print_histogram = self.__class__.print_histogram(service, version, mode, path + ["print_histogram"])
            self.projected_surface_area = self.__class__.projected_surface_area(service, version, mode, path + ["projected_surface_area"])
            self.species_mass_flow = self.__class__.species_mass_flow(service, version, mode, path + ["species_mass_flow"])
            self.summary = self.__class__.summary(service, version, mode, path + ["summary"])
            self.uds_flow = self.__class__.uds_flow(service, version, mode, path + ["uds_flow"])
            self.virtual_blade_model = self.__class__.virtual_blade_model(service, version, mode, path + ["virtual_blade_model"])
            self.write_histogram = self.__class__.write_histogram(service, version, mode, path + ["write_histogram"])
            super().__init__(service, version, mode, path)
        class aero_optical_distortions(TUIMethod):
            """
            .
            """
        class dpm_extended_summary(TUIMethod):
            """
            Create an extended discrete phase summary report of the discrete phase injection(s). You can choose whether you want to save the extended report to a file or print it in the console window. For unsteady tracking, you will be asked whether you want to include in-domain particle/tracks in the report. You will be also prompted whether you want to select a single injection for the summary report. By default, all injections are included. The output depends on whether you have enabled the report/dpm-zone-summaries-per-injection? text command, in which case additional information is printed for escaped particles, such as per-injection data. Note that, for unsteady particle tracking, it is necessary to enable the report/dpm-zone-summaries-per-injection? text command before any particle parcels are injected into the domain.
            """
        class dpm_sample(TUIMethod):
            """
            Samples trajectories at boundaries and lines/planes.
            """
        class dpm_sample_output_udf(TUIMethod):
            """
            Allows you to hook a previously loaded DEFINE_DPM_OUTPUT UDF for file format specification for sampling of trajectories and VOF-to-DPM lump conversion transcripts.
            """
        class dpm_sample_sort_file(TUIMethod):
            """
            Enables/disables writing of sorted DPM sample files.
            """
        class dpm_summary(TUIMethod):
            """
            Prints discrete phase summary report.
            """
        class dpm_zone_summaries_per_injection(TUIMethod):
            """
            Enables/disables calculation of the escaped mass per injection. Note that for unsteady particle tracking, if you want to report the mass of escaped particles per injection, this text command must be enabled before any particles are injected into the domain.
            """
        class element_mass_flow(TUIMethod):
            """
            Prints list of element flow rate at inlets and outlets. This reports the mass flow rates of all chemical elements (in kg/s) flowing through the simulation boundaries.
            """
        class evap_mass_details_in_dpm_summ_rep(TUIMethod):
            """
            .
            """
        class mphase_summary(TUIMethod):
            """
            Prints summary report for a multiphase case setup.
            """
        class particle_summary(TUIMethod):
            """
            Prints summary report for all current particles.
            """
        class path_line_summary(TUIMethod):
            """
            Prints pathline summary report.
            """
        class print_histogram(TUIMethod):
            """
            Prints a histogram of a scalar quantity.
            """
        class projected_surface_area(TUIMethod):
            """
            Computes the area of the projection of selected surfaces along the  ,  , or   axis.
            """
        class species_mass_flow(TUIMethod):
            """
            Prints list of species mass flow rate at inlets and outlets. This reports the mass flow rates of all species (in kg/s) flowing through the simulation boundaries.
            """
        class summary(TUIMethod):
            """
            Prints the current settings for physical models, boundary conditions, material properties, and solution parameters.
            """
        class uds_flow(TUIMethod):
            """
            Prints list of user-defined scalar flow rate at boundaries.
            """
        class virtual_blade_model(TUIMethod):
            """
            .
            """
        class write_histogram(TUIMethod):
            """
            Write a histogram of a scalar quantity to a file.
            """

        class dpm_histogram(TUIMenu):
            """
            Enters the DPM histogram menu.
            """
            def __init__(self, service, version, mode, path):
                self.set = self.__class__.set(service, version, mode, path + ["set"])
                self.setup_reduction = self.__class__.setup_reduction(service, version, mode, path + ["setup_reduction"])
                self.compute_sample = self.__class__.compute_sample(service, version, mode, path + ["compute_sample"])
                self.delete_sample = self.__class__.delete_sample(service, version, mode, path + ["delete_sample"])
                self.list_samples = self.__class__.list_samples(service, version, mode, path + ["list_samples"])
                self.pick_sample_to_reduce = self.__class__.pick_sample_to_reduce(service, version, mode, path + ["pick_sample_to_reduce"])
                self.plot_sample = self.__class__.plot_sample(service, version, mode, path + ["plot_sample"])
                self.prep_dpm_sample_cont_plot_exprs = self.__class__.prep_dpm_sample_cont_plot_exprs(service, version, mode, path + ["prep_dpm_sample_cont_plot_exprs"])
                self.read_sample = self.__class__.read_sample(service, version, mode, path + ["read_sample"])
                self.reduce_picked_sample = self.__class__.reduce_picked_sample(service, version, mode, path + ["reduce_picked_sample"])
                self.write_sample = self.__class__.write_sample(service, version, mode, path + ["write_sample"])
                super().__init__(service, version, mode, path)
            class compute_sample(TUIMethod):
                """
                Computes the minimum/maximum of a sample variable.
                """
            class delete_sample(TUIMethod):
                """
                Deletes a sample from the loaded sample list.
                """
            class list_samples(TUIMethod):
                """
                Shows all samples in a loaded sample list.
                """
            class pick_sample_to_reduce(TUIMethod):
                """
                Select a sample to be reduced.
                """
            class plot_sample(TUIMethod):
                """
                Plots a histogram of a loaded sample.
                """
            class prep_dpm_sample_cont_plot_exprs(TUIMethod):
                """
                Prepare named expressions from data in a DPM sample file (collected at a cut plane surface) for contour plotting.
                """
            class read_sample(TUIMethod):
                """
                Reads a sample file and adds it to the sample list.
                """
            class reduce_picked_sample(TUIMethod):
                """
                Reduce a sample as specified by the data reduction parameters. This command is available only after you selected the sample using the pick-sample-to-reduce text command.
                """
            class write_sample(TUIMethod):
                """
                Write a histogram of a loaded sample into a file.
                """

            class set(TUIMenu):
                """
                Enters the settings menu for the histogram.
                """
                def __init__(self, service, version, mode, path):
                    self.auto_range = self.__class__.auto_range(service, version, mode, path + ["auto_range"])
                    self.correlation = self.__class__.correlation(service, version, mode, path + ["correlation"])
                    self.cumulation_curve = self.__class__.cumulation_curve(service, version, mode, path + ["cumulation_curve"])
                    self.diameter_statistics = self.__class__.diameter_statistics(service, version, mode, path + ["diameter_statistics"])
                    self.histogram_mode = self.__class__.histogram_mode(service, version, mode, path + ["histogram_mode"])
                    self.logarithmic = self.__class__.logarithmic(service, version, mode, path + ["logarithmic"])
                    self.maximum = self.__class__.maximum(service, version, mode, path + ["maximum"])
                    self.minimum = self.__class__.minimum(service, version, mode, path + ["minimum"])
                    self.number_of_bins = self.__class__.number_of_bins(service, version, mode, path + ["number_of_bins"])
                    self.percentage = self.__class__.percentage(service, version, mode, path + ["percentage"])
                    self.variable_power_3 = self.__class__.variable_power_3(service, version, mode, path + ["variable_power_3"])
                    self.weighting = self.__class__.weighting(service, version, mode, path + ["weighting"])
                    super().__init__(service, version, mode, path)
                class auto_range(TUIMethod):
                    """
                    Automatically computes the range of the sampling variable for histogram plots.
                    """
                class correlation(TUIMethod):
                    """
                    Computes the correlation of the sampling variable with another variable.
                    """
                class cumulation_curve(TUIMethod):
                    """
                    Computes a cumulative curve for the sampling variable or correlation variable when correlation? is specified.
                    """
                class diameter_statistics(TUIMethod):
                    """
                    Computes the Rosin Rammler parameters, Sauter, and other mean diameters.
                    """
                class histogram_mode(TUIMethod):
                    """
                    Uses bars for the histogram plot or xy-style.
                    """
                class logarithmic(TUIMethod):
                    """
                    Enables/disables the use of logarithmic scaling on the abscissa of the histogram.
                    """
                class maximum(TUIMethod):
                    """
                    Specifies the maximum value of the x-axis variable for histogram plots.
                    """
                class minimum(TUIMethod):
                    """
                    Specifies the minimum value of the x-axis variable for histogram plots.
                    """
                class number_of_bins(TUIMethod):
                    """
                    Specifies the number of bins.
                    """
                class percentage(TUIMethod):
                    """
                    Uses percentages of bins to be computed.
                    """
                class variable_power_3(TUIMethod):
                    """
                    Use the cubic of the cumulation variable during computation of the cumulative curve.
                    When the particle mass was not sampled, the diameter can be used instead.
                    """
                class weighting(TUIMethod):
                    """
                    Uses weighting with additional variables when sorting data into samples.
                    """

            class setup_reduction(TUIMenu):
                """
                Set up the sample data reduction by specifying all relevant options and setting parameters as desired.
                """
                def __init__(self, service, version, mode, path):
                    self.all_variables_number_of_bins = self.__class__.all_variables_number_of_bins(service, version, mode, path + ["all_variables_number_of_bins"])
                    self.list_settings = self.__class__.list_settings(service, version, mode, path + ["list_settings"])
                    self.logarithmic = self.__class__.logarithmic(service, version, mode, path + ["logarithmic"])
                    self.make_steady_from_unsteady_file = self.__class__.make_steady_from_unsteady_file(service, version, mode, path + ["make_steady_from_unsteady_file"])
                    self.maximum = self.__class__.maximum(service, version, mode, path + ["maximum"])
                    self.minimum = self.__class__.minimum(service, version, mode, path + ["minimum"])
                    self.number_of_bins = self.__class__.number_of_bins(service, version, mode, path + ["number_of_bins"])
                    self.reset_min_and_max = self.__class__.reset_min_and_max(service, version, mode, path + ["reset_min_and_max"])
                    self.use_weighting = self.__class__.use_weighting(service, version, mode, path + ["use_weighting"])
                    self.weighting_variable = self.__class__.weighting_variable(service, version, mode, path + ["weighting_variable"])
                    super().__init__(service, version, mode, path)
                class all_variables_number_of_bins(TUIMethod):
                    """
                    Set the number of bins to be used for ALL variables in the data reduction.
                    """
                class list_settings(TUIMethod):
                    """
                    List all user inputs for the sample picked for data reduction.
                    """
                class logarithmic(TUIMethod):
                    """
                    Switch on or off logarithmic scaling to be used for a specific variable in the data reduction.
                    """
                class make_steady_from_unsteady_file(TUIMethod):
                    """
                    Specify whether the unsteady sample is to be reduced into a steady-state injection file.
                    """
                class maximum(TUIMethod):
                    """
                    Set the maximum value of the range to be considered for a specific variable in the data reduction.
                    """
                class minimum(TUIMethod):
                    """
                    Set the minimum value of the range to be considered for a specific variable in the data reduction.
                    """
                class number_of_bins(TUIMethod):
                    """
                    Set the number of bins to be used for a specific variable in the data reduction.
                    """
                class reset_min_and_max(TUIMethod):
                    """
                    Reset the min and max values of the range to be considered for a specific variable in the data reduction.
                    """
                class use_weighting(TUIMethod):
                    """
                    Specify whether to use any weighting in the averaging that is done in each bin in the data reduction.
                    """
                class weighting_variable(TUIMethod):
                    """
                    Choose the weighting variable for the averaging in each bin in the data reduction.
                    """

        class efficiency(TUIMenu):
            """
            Enter the menu for efficiency computations.
            """
            def __init__(self, service, version, mode, path):
                self.isentropic = self.__class__.isentropic(service, version, mode, path + ["isentropic"])
                self.polytropic = self.__class__.polytropic(service, version, mode, path + ["polytropic"])
                self.use_in_turbo_report = self.__class__.use_in_turbo_report(service, version, mode, path + ["use_in_turbo_report"])
                super().__init__(service, version, mode, path)
            class isentropic(TUIMethod):
                """
                Calculate isentropic efficiency.
                """
            class polytropic(TUIMethod):
                """
                Calculate polytropic efficiency.
                """
            class use_in_turbo_report(TUIMethod):
                """
                Use this general method instead of constant Cp-based to compute efficiency with Turbo Report tool.
                """

        class fluxes(TUIMenu):
            """
            Enters the fluxes menu.
            """
            def __init__(self, service, version, mode, path):
                self.electric_current = self.__class__.electric_current(service, version, mode, path + ["electric_current"])
                self.film_heat_transfer = self.__class__.film_heat_transfer(service, version, mode, path + ["film_heat_transfer"])
                self.film_mass_flow = self.__class__.film_mass_flow(service, version, mode, path + ["film_mass_flow"])
                self.heat_transfer = self.__class__.heat_transfer(service, version, mode, path + ["heat_transfer"])
                self.heat_transfer_sensible = self.__class__.heat_transfer_sensible(service, version, mode, path + ["heat_transfer_sensible"])
                self.mass_flow = self.__class__.mass_flow(service, version, mode, path + ["mass_flow"])
                self.pressure_work = self.__class__.pressure_work(service, version, mode, path + ["pressure_work"])
                self.rad_heat_trans = self.__class__.rad_heat_trans(service, version, mode, path + ["rad_heat_trans"])
                self.viscous_work = self.__class__.viscous_work(service, version, mode, path + ["viscous_work"])
                super().__init__(service, version, mode, path)
            class electric_current(TUIMethod):
                """
                .
                """
            class film_heat_transfer(TUIMethod):
                """
                Prints wall film heat transfer rate at boundaries. This text command is only available when you enable the Eulerian wall film model.
                """
            class film_mass_flow(TUIMethod):
                """
                Prints wall film mass flow rate at boundaries. This text command is only available when you enable the Eulerian wall film model.
                """
            class heat_transfer(TUIMethod):
                """
                Prints heat transfer rate at boundaries.
                """
            class heat_transfer_sensible(TUIMethod):
                """
                Prints the sensible heat transfer rate at the boundaries.
                """
            class mass_flow(TUIMethod):
                """
                Prints mass flow rate at inlets and outlets.
                """
            class pressure_work(TUIMethod):
                """
                Prints the pressure work rate at the boundaries. This text command is only available when the energy equation is enabled, the absolute velocity formulation is selected, and zone motion is enabled for a fluid cell zone.
                """
            class rad_heat_trans(TUIMethod):
                """
                Prints radiation heat transfer rate at boundaries.
                """
            class viscous_work(TUIMethod):
                """
                Prints the viscous work rate at the boundaries. This text command is only available when the energy equation is enabled and the pressure-based solver is selected.
                """

        class forces(TUIMenu):
            """
            Enters the forces menu.
            """
            def __init__(self, service, version, mode, path):
                self.pressure_center = self.__class__.pressure_center(service, version, mode, path + ["pressure_center"])
                self.wall_forces = self.__class__.wall_forces(service, version, mode, path + ["wall_forces"])
                self.wall_moments = self.__class__.wall_moments(service, version, mode, path + ["wall_moments"])
                super().__init__(service, version, mode, path)
            class pressure_center(TUIMethod):
                """
                Prints the center of pressure on wall zones.
                """
            class wall_forces(TUIMethod):
                """
                Computes the forces along the specified force vector for all wall zones.
                """
            class wall_moments(TUIMethod):
                """
                Computes the moments about the specified moment center for all wall zones.
                """

        class heat_exchanger(TUIMenu):
            """
            Enters the heat exchanger menu.
            """
            def __init__(self, service, version, mode, path):
                self.computed_heat_rejection = self.__class__.computed_heat_rejection(service, version, mode, path + ["computed_heat_rejection"])
                self.inlet_temperature = self.__class__.inlet_temperature(service, version, mode, path + ["inlet_temperature"])
                self.mass_flow_rate = self.__class__.mass_flow_rate(service, version, mode, path + ["mass_flow_rate"])
                self.outlet_temperature = self.__class__.outlet_temperature(service, version, mode, path + ["outlet_temperature"])
                self.specific_heat = self.__class__.specific_heat(service, version, mode, path + ["specific_heat"])
                super().__init__(service, version, mode, path)
            class computed_heat_rejection(TUIMethod):
                """
                Prints total heat rejection.
                """
            class inlet_temperature(TUIMethod):
                """
                Prints inlet temperature.
                """
            class mass_flow_rate(TUIMethod):
                """
                Prints mass flow rate.
                """
            class outlet_temperature(TUIMethod):
                """
                Prints outlet temperature.
                """
            class specific_heat(TUIMethod):
                """
                Prints fluids specific heat.
                """

        class icing(TUIMenu):
            """
            Icing reports menu.
            """
            def __init__(self, service, version, mode, path):
                self.energy_of_ice_formation = self.__class__.energy_of_ice_formation(service, version, mode, path + ["energy_of_ice_formation"])
                self.energy_of_water_impinged = self.__class__.energy_of_water_impinged(service, version, mode, path + ["energy_of_water_impinged"])
                self.icing_energy_of_conduction = self.__class__.icing_energy_of_conduction(service, version, mode, path + ["icing_energy_of_conduction"])
                self.mass_of_ice = self.__class__.mass_of_ice(service, version, mode, path + ["mass_of_ice"])
                self.mass_of_water_impinged = self.__class__.mass_of_water_impinged(service, version, mode, path + ["mass_of_water_impinged"])
                self.particles_crystals_collection_eff = self.__class__.particles_crystals_collection_eff(service, version, mode, path + ["particles_crystals_collection_eff"])
                self.particles_droplets_collection_eff = self.__class__.particles_droplets_collection_eff(service, version, mode, path + ["particles_droplets_collection_eff"])
                super().__init__(service, version, mode, path)
            class energy_of_ice_formation(TUIMethod):
                """
                Print Energy of Ice Formation.
                """
            class energy_of_water_impinged(TUIMethod):
                """
                Print Energy of Water Impingement.
                """
            class icing_energy_of_conduction(TUIMethod):
                """
                Print Energy of Conduction.
                """
            class mass_of_ice(TUIMethod):
                """
                Print Mass of Ice Accretion.
                """
            class mass_of_water_impinged(TUIMethod):
                """
                Print Mass of Water Impingement.
                """
            class particles_crystals_collection_eff(TUIMethod):
                """
                Print Crystals Collection Efficiency.
                """
            class particles_droplets_collection_eff(TUIMethod):
                """
                Print Droplets Collection Efficiency.
                """

        class modified_setting(TUIMenu):
            """
            Enter the modified settings menu.
            """
            def __init__(self, service, version, mode, path):
                self.modified_setting = self.__class__.modified_setting(service, version, mode, path + ["modified_setting"])
                self.write_user_setting = self.__class__.write_user_setting(service, version, mode, path + ["write_user_setting"])
                super().__init__(service, version, mode, path)
            class modified_setting(TUIMethod):
                """
                Specify which areas of setup will be checked for non-default settings for generating the Modified Settings Summary table. The table is displayed tabbed with the graphics window.
                """
            class write_user_setting(TUIMethod):
                """
                Write the contents of the Modified Settings Summary table to a file.
                """

        class population_balance(TUIMenu):
            """
            Population Balance menu.
            """
            def __init__(self, service, version, mode, path):
                self.moments = self.__class__.moments(service, version, mode, path + ["moments"])
                self.number_density = self.__class__.number_density(service, version, mode, path + ["number_density"])
                super().__init__(service, version, mode, path)
            class moments(TUIMethod):
                """
                .
                """
            class number_density(TUIMethod):
                """
                Set number density functions.
                """

        class reference_values(TUIMenu):
            """
            Enters the reference value menu.
            """
            def __init__(self, service, version, mode, path):
                self.compute = self.__class__.compute(service, version, mode, path + ["compute"])
                self.area = self.__class__.area(service, version, mode, path + ["area"])
                self.density = self.__class__.density(service, version, mode, path + ["density"])
                self.depth = self.__class__.depth(service, version, mode, path + ["depth"])
                self.enthalpy = self.__class__.enthalpy(service, version, mode, path + ["enthalpy"])
                self.length = self.__class__.length(service, version, mode, path + ["length"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.pressure = self.__class__.pressure(service, version, mode, path + ["pressure"])
                self.temperature = self.__class__.temperature(service, version, mode, path + ["temperature"])
                self.velocity = self.__class__.velocity(service, version, mode, path + ["velocity"])
                self.viscosity = self.__class__.viscosity(service, version, mode, path + ["viscosity"])
                self.yplus = self.__class__.yplus(service, version, mode, path + ["yplus"])
                self.zone = self.__class__.zone(service, version, mode, path + ["zone"])
                super().__init__(service, version, mode, path)
            class area(TUIMethod):
                """
                Sets reference area for normalization.
                """
            class density(TUIMethod):
                """
                Sets reference density for normalization.
                """
            class depth(TUIMethod):
                """
                Sets reference depth for volume calculation.
                """
            class enthalpy(TUIMethod):
                """
                Sets reference enthalpy for enthalpy damping and normalization.
                """
            class length(TUIMethod):
                """
                Sets reference length for normalization.
                """
            class list(TUIMethod):
                """
                Lists current reference values.
                """
            class pressure(TUIMethod):
                """
                Sets reference pressure for normalization.
                """
            class temperature(TUIMethod):
                """
                Sets reference temperature for normalization.
                """
            class velocity(TUIMethod):
                """
                Sets reference velocity for normalization.
                """
            class viscosity(TUIMethod):
                """
                Sets reference viscosity for normalization.
                """
            class yplus(TUIMethod):
                """
                Sets reference yplus for calculation of Yplus Based Heat Transfer Coefficient.
                """
            class zone(TUIMethod):
                """
                Sets reference zone.
                """

            class compute(TUIMenu):
                """
                Computes reference values from zone boundary conditions.
                """
                def __init__(self, service, version, mode, path):
                    self.axis = self.__class__.axis(service, version, mode, path + ["axis"])
                    self.degassing = self.__class__.degassing(service, version, mode, path + ["degassing"])
                    self.dummy_entry = self.__class__.dummy_entry(service, version, mode, path + ["dummy_entry"])
                    self.exhaust_fan = self.__class__.exhaust_fan(service, version, mode, path + ["exhaust_fan"])
                    self.fan = self.__class__.fan(service, version, mode, path + ["fan"])
                    self.fluid = self.__class__.fluid(service, version, mode, path + ["fluid"])
                    self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
                    self.inlet_vent = self.__class__.inlet_vent(service, version, mode, path + ["inlet_vent"])
                    self.intake_fan = self.__class__.intake_fan(service, version, mode, path + ["intake_fan"])
                    self.interface = self.__class__.interface(service, version, mode, path + ["interface"])
                    self.interior = self.__class__.interior(service, version, mode, path + ["interior"])
                    self.mass_flow_inlet = self.__class__.mass_flow_inlet(service, version, mode, path + ["mass_flow_inlet"])
                    self.mass_flow_outlet = self.__class__.mass_flow_outlet(service, version, mode, path + ["mass_flow_outlet"])
                    self.network = self.__class__.network(service, version, mode, path + ["network"])
                    self.network_end = self.__class__.network_end(service, version, mode, path + ["network_end"])
                    self.outflow = self.__class__.outflow(service, version, mode, path + ["outflow"])
                    self.outlet_vent = self.__class__.outlet_vent(service, version, mode, path + ["outlet_vent"])
                    self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                    self.periodic = self.__class__.periodic(service, version, mode, path + ["periodic"])
                    self.porous_jump = self.__class__.porous_jump(service, version, mode, path + ["porous_jump"])
                    self.pressure_far_field = self.__class__.pressure_far_field(service, version, mode, path + ["pressure_far_field"])
                    self.pressure_inlet = self.__class__.pressure_inlet(service, version, mode, path + ["pressure_inlet"])
                    self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                    self.radiator = self.__class__.radiator(service, version, mode, path + ["radiator"])
                    self.rans_les_interface = self.__class__.rans_les_interface(service, version, mode, path + ["rans_les_interface"])
                    self.recirculation_inlet = self.__class__.recirculation_inlet(service, version, mode, path + ["recirculation_inlet"])
                    self.recirculation_outlet = self.__class__.recirculation_outlet(service, version, mode, path + ["recirculation_outlet"])
                    self.shadow = self.__class__.shadow(service, version, mode, path + ["shadow"])
                    self.solid = self.__class__.solid(service, version, mode, path + ["solid"])
                    self.symmetry = self.__class__.symmetry(service, version, mode, path + ["symmetry"])
                    self.velocity_inlet = self.__class__.velocity_inlet(service, version, mode, path + ["velocity_inlet"])
                    self.wall = self.__class__.wall(service, version, mode, path + ["wall"])
                    super().__init__(service, version, mode, path)
                class axis(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class degassing(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class dummy_entry(TUIMethod):
                    """
                    .
                    """
                class exhaust_fan(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class fan(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class fluid(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class geometry(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class inlet_vent(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class intake_fan(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class interface(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class interior(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class mass_flow_inlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class mass_flow_outlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class network(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class network_end(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class outflow(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class outlet_vent(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class overset(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class periodic(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class porous_jump(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class pressure_far_field(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class pressure_inlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class pressure_outlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class radiator(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class rans_les_interface(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class recirculation_inlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class recirculation_outlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class shadow(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class solid(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class symmetry(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class velocity_inlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class wall(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """

        class simulation_reports(TUIMenu):
            """
            Enter the simulation reports menu.
            """
            def __init__(self, service, version, mode, path):
                self.parametric_study = self.__class__.parametric_study(service, version, mode, path + ["parametric_study"])
                self.add_histogram_to_report = self.__class__.add_histogram_to_report(service, version, mode, path + ["add_histogram_to_report"])
                self.delete_simulation_report = self.__class__.delete_simulation_report(service, version, mode, path + ["delete_simulation_report"])
                self.duplicate_simulation_report = self.__class__.duplicate_simulation_report(service, version, mode, path + ["duplicate_simulation_report"])
                self.export_simulation_report_as_html = self.__class__.export_simulation_report_as_html(service, version, mode, path + ["export_simulation_report_as_html"])
                self.export_simulation_report_as_pdf = self.__class__.export_simulation_report_as_pdf(service, version, mode, path + ["export_simulation_report_as_pdf"])
                self.export_simulation_report_as_pptx = self.__class__.export_simulation_report_as_pptx(service, version, mode, path + ["export_simulation_report_as_pptx"])
                self.generate_simulation_report = self.__class__.generate_simulation_report(service, version, mode, path + ["generate_simulation_report"])
                self.list_simulation_reports = self.__class__.list_simulation_reports(service, version, mode, path + ["list_simulation_reports"])
                self.read_simulation_report_template_file = self.__class__.read_simulation_report_template_file(service, version, mode, path + ["read_simulation_report_template_file"])
                self.rename_simulation_report = self.__class__.rename_simulation_report(service, version, mode, path + ["rename_simulation_report"])
                self.reset_report_to_defaults = self.__class__.reset_report_to_defaults(service, version, mode, path + ["reset_report_to_defaults"])
                self.view_simulation_report = self.__class__.view_simulation_report(service, version, mode, path + ["view_simulation_report"])
                self.write_report_names_to_file = self.__class__.write_report_names_to_file(service, version, mode, path + ["write_report_names_to_file"])
                self.write_simulation_report_template_file = self.__class__.write_simulation_report_template_file(service, version, mode, path + ["write_simulation_report_template_file"])
                super().__init__(service, version, mode, path)
            class add_histogram_to_report(TUIMethod):
                """
                .
                """
            class delete_simulation_report(TUIMethod):
                """
                .
                """
            class duplicate_simulation_report(TUIMethod):
                """
                .
                """
            class export_simulation_report_as_html(TUIMethod):
                """
                .
                """
            class export_simulation_report_as_pdf(TUIMethod):
                """
                .
                """
            class export_simulation_report_as_pptx(TUIMethod):
                """
                .
                """
            class generate_simulation_report(TUIMethod):
                """
                .
                """
            class list_simulation_reports(TUIMethod):
                """
                .
                """
            class read_simulation_report_template_file(TUIMethod):
                """
                .
                """
            class rename_simulation_report(TUIMethod):
                """
                .
                """
            class reset_report_to_defaults(TUIMethod):
                """
                .
                """
            class view_simulation_report(TUIMethod):
                """
                .
                """
            class write_report_names_to_file(TUIMethod):
                """
                .
                """
            class write_simulation_report_template_file(TUIMethod):
                """
                .
                """

            class parametric_study(TUIMenu):
                """
                Enter the parametric study menu.
                """
                def __init__(self, service, version, mode, path):
                    self.generate_design_point_report = self.__class__.generate_design_point_report(service, version, mode, path + ["generate_design_point_report"])
                    self.generate_parametric_report = self.__class__.generate_parametric_report(service, version, mode, path + ["generate_parametric_report"])
                    super().__init__(service, version, mode, path)
                class generate_design_point_report(TUIMethod):
                    """
                    Generate a simulation report for an updated design point.
                    """
                class generate_parametric_report(TUIMethod):
                    """
                    Generate a parametric report for your study.
                    """

        class surface_integrals(TUIMenu):
            """
            Enters the surface integral menu.
            """
            def __init__(self, service, version, mode, path):
                self.area = self.__class__.area(service, version, mode, path + ["area"])
                self.area_weighted_avg = self.__class__.area_weighted_avg(service, version, mode, path + ["area_weighted_avg"])
                self.facet_avg = self.__class__.facet_avg(service, version, mode, path + ["facet_avg"])
                self.facet_max = self.__class__.facet_max(service, version, mode, path + ["facet_max"])
                self.facet_min = self.__class__.facet_min(service, version, mode, path + ["facet_min"])
                self.flow_rate = self.__class__.flow_rate(service, version, mode, path + ["flow_rate"])
                self.integral = self.__class__.integral(service, version, mode, path + ["integral"])
                self.mass_flow_rate = self.__class__.mass_flow_rate(service, version, mode, path + ["mass_flow_rate"])
                self.mass_weighted_avg = self.__class__.mass_weighted_avg(service, version, mode, path + ["mass_weighted_avg"])
                self.standard_deviation = self.__class__.standard_deviation(service, version, mode, path + ["standard_deviation"])
                self.sum = self.__class__.sum(service, version, mode, path + ["sum"])
                self.uniformity_index_area_weighted = self.__class__.uniformity_index_area_weighted(service, version, mode, path + ["uniformity_index_area_weighted"])
                self.uniformity_index_mass_weighted = self.__class__.uniformity_index_mass_weighted(service, version, mode, path + ["uniformity_index_mass_weighted"])
                self.vector_based_flux = self.__class__.vector_based_flux(service, version, mode, path + ["vector_based_flux"])
                self.vector_flux = self.__class__.vector_flux(service, version, mode, path + ["vector_flux"])
                self.vector_weighted_average = self.__class__.vector_weighted_average(service, version, mode, path + ["vector_weighted_average"])
                self.vertex_avg = self.__class__.vertex_avg(service, version, mode, path + ["vertex_avg"])
                self.vertex_max = self.__class__.vertex_max(service, version, mode, path + ["vertex_max"])
                self.vertex_min = self.__class__.vertex_min(service, version, mode, path + ["vertex_min"])
                self.volume_flow_rate = self.__class__.volume_flow_rate(service, version, mode, path + ["volume_flow_rate"])
                super().__init__(service, version, mode, path)
            class area(TUIMethod):
                """
                Prints the area of the selected surfaces.
                """
            class area_weighted_avg(TUIMethod):
                """
                .
                """
            class facet_avg(TUIMethod):
                """
                Prints the facet average of the specified quantity over the selected surfaces.
                """
            class facet_max(TUIMethod):
                """
                Prints the maximum of the specified quantity over facet centroids of the selected surfaces.
                """
            class facet_min(TUIMethod):
                """
                Prints the minimum of the specified quantity over facet centroids of the selected surfaces.
                """
            class flow_rate(TUIMethod):
                """
                Prints the flow rate of the specified quantity over the selected surfaces.
                """
            class integral(TUIMethod):
                """
                Prints the integral of the specified quantity over the selected surfaces. You can include a wildcard (\\*) within the surface names.
                """
            class mass_flow_rate(TUIMethod):
                """
                Prints the mass flow rate through the selected surfaces.
                """
            class mass_weighted_avg(TUIMethod):
                """
                Prints the mass-averaged quantity over the selected surfaces.
                """
            class standard_deviation(TUIMethod):
                """
                Prints the standard deviation of the scalar at the facet centroids of the surface.
                """
            class sum(TUIMethod):
                """
                Prints sum of scalar at facet centroids of the surfaces.
                """
            class uniformity_index_area_weighted(TUIMethod):
                """
                Prints the area-weighted uniformity index of the specified quantity over the selected surfaces.
                """
            class uniformity_index_mass_weighted(TUIMethod):
                """
                Prints the mass-weighted uniformity index of the specified quantity over the selected surfaces.
                """
            class vector_based_flux(TUIMethod):
                """
                Prints the vector-based flux of the specified quantity over the selected surfaces.
                """
            class vector_flux(TUIMethod):
                """
                Prints the vector flux over the selected surfaces.
                """
            class vector_weighted_average(TUIMethod):
                """
                Prints the vector-averaged quantity over the selected surfaces.
                """
            class vertex_avg(TUIMethod):
                """
                Prints the vertex average of the specified quantity over the selected surfaces.
                """
            class vertex_max(TUIMethod):
                """
                Prints the maximum of the specified quantity over vertices of the selected surfaces.
                """
            class vertex_min(TUIMethod):
                """
                Prints the minimum of the specified quantity over vertices of the selected surfaces.
                """
            class volume_flow_rate(TUIMethod):
                """
                Prints the volume flow rate through the selected surfaces.
                """

        class system(TUIMenu):
            """
            Enters the system menu.
            """
            def __init__(self, service, version, mode, path):
                self.gpgpu_stats = self.__class__.gpgpu_stats(service, version, mode, path + ["gpgpu_stats"])
                self.proc_stats = self.__class__.proc_stats(service, version, mode, path + ["proc_stats"])
                self.sys_stats = self.__class__.sys_stats(service, version, mode, path + ["sys_stats"])
                self.time_stats = self.__class__.time_stats(service, version, mode, path + ["time_stats"])
                super().__init__(service, version, mode, path)
            class gpgpu_stats(TUIMethod):
                """
                Prints information about installed general purpose graphical processing units.
                """
            class proc_stats(TUIMethod):
                """
                Prints ANSYS Fluent process information. This is used to report the memory usage of each of the ANSYS Fluent processes.
                """
            class sys_stats(TUIMethod):
                """
                System information. This is used to report the CPU configuration of the machines where ANSYS Fluent processes have been spawned.
                """
            class time_stats(TUIMethod):
                """
                Timer information. This is used to report CPU timings for user and kernel processes and detailed solver timings.
                """

        class volume_integrals(TUIMenu):
            """
            Enters the volume integral menu.
            """
            def __init__(self, service, version, mode, path):
                self.mass = self.__class__.mass(service, version, mode, path + ["mass"])
                self.mass_avg = self.__class__.mass_avg(service, version, mode, path + ["mass_avg"])
                self.mass_integral = self.__class__.mass_integral(service, version, mode, path + ["mass_integral"])
                self.maximum = self.__class__.maximum(service, version, mode, path + ["maximum"])
                self.minimum = self.__class__.minimum(service, version, mode, path + ["minimum"])
                self.sum = self.__class__.sum(service, version, mode, path + ["sum"])
                self.twopisum = self.__class__.twopisum(service, version, mode, path + ["twopisum"])
                self.volume = self.__class__.volume(service, version, mode, path + ["volume"])
                self.volume_avg = self.__class__.volume_avg(service, version, mode, path + ["volume_avg"])
                self.volume_integral = self.__class__.volume_integral(service, version, mode, path + ["volume_integral"])
                super().__init__(service, version, mode, path)
            class mass(TUIMethod):
                """
                .
                """
            class mass_avg(TUIMethod):
                """
                Prints mass-average of scalar over cell zones.
                """
            class mass_integral(TUIMethod):
                """
                Prints mass-weighted integral of scalar over cell zones.
                """
            class maximum(TUIMethod):
                """
                Prints maximum of scalar over all cell zones.
                """
            class minimum(TUIMethod):
                """
                Prints minimum of scalar over all cell zones.
                """
            class sum(TUIMethod):
                """
                Prints sum of scalar over all cell zones.
                """
            class twopisum(TUIMethod):
                """
                Prints sum of scalar over all cell zones multiplied by 2.
                """
            class volume(TUIMethod):
                """
                Prints total volume of specified cell zones.
                """
            class volume_avg(TUIMethod):
                """
                Prints volume-weighted average of scalar over cell zones.
                """
            class volume_integral(TUIMethod):
                """
                Prints integral of scalar over cell zones.
                """

    class results(TUIMenu):
        """
        .
        """
        def __init__(self, service, version, mode, path):
            self.animations = self.__class__.animations(service, version, mode, path + ["animations"])
            self.custom_vectors = self.__class__.custom_vectors(service, version, mode, path + ["custom_vectors"])
            self.graphics = self.__class__.graphics(service, version, mode, path + ["graphics"])
            self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
            self.report = self.__class__.report(service, version, mode, path + ["report"])
            self.scene = self.__class__.scene(service, version, mode, path + ["scene"])
            self.surfaces = self.__class__.surfaces(service, version, mode, path + ["surfaces"])
            super().__init__(service, version, mode, path)

        class animations(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.playback = self.__class__.playback(service, version, mode, path + ["playback"])
                self.scene_animation = self.__class__.scene_animation(service, version, mode, path + ["scene_animation"])
                super().__init__(service, version, mode, path)

            class playback(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.set_custom_frames = self.__class__.set_custom_frames(service, version, mode, path + ["set_custom_frames"])
                    self.video = self.__class__.video(service, version, mode, path + ["video"])
                    self.current_animation = self.__class__.current_animation(service, version, mode, path + ["current_animation"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.play = self.__class__.play(service, version, mode, path + ["play"])
                    self.read_animation_file = self.__class__.read_animation_file(service, version, mode, path + ["read_animation_file"])
                    self.stored_view = self.__class__.stored_view(service, version, mode, path + ["stored_view"])
                    self.write_animation = self.__class__.write_animation(service, version, mode, path + ["write_animation"])
                    super().__init__(service, version, mode, path)
                class current_animation(TUIMethod):
                    """
                    .
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class play(TUIMethod):
                    """
                    .
                    """
                class read_animation_file(TUIMethod):
                    """
                    .
                    """
                class stored_view(TUIMethod):
                    """
                    .
                    """
                class write_animation(TUIMethod):
                    """
                    .
                    """

                class set_custom_frames(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.end_frame = self.__class__.end_frame(service, version, mode, path + ["end_frame"])
                        self.increment = self.__class__.increment(service, version, mode, path + ["increment"])
                        self.start_frame = self.__class__.start_frame(service, version, mode, path + ["start_frame"])
                        super().__init__(service, version, mode, path)
                    class end_frame(TUIMethod):
                        """
                        .
                        """
                    class increment(TUIMethod):
                        """
                        .
                        """
                    class start_frame(TUIMethod):
                        """
                        .
                        """

                class video(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.advance_quality = self.__class__.advance_quality(service, version, mode, path + ["advance_quality"])
                        self.format = self.__class__.format(service, version, mode, path + ["format"])
                        self.fps = self.__class__.fps(service, version, mode, path + ["fps"])
                        self.height = self.__class__.height(service, version, mode, path + ["height"])
                        self.name = self.__class__.name(service, version, mode, path + ["name"])
                        self.quality = self.__class__.quality(service, version, mode, path + ["quality"])
                        self.scale = self.__class__.scale(service, version, mode, path + ["scale"])
                        self.set_standard_resolution = self.__class__.set_standard_resolution(service, version, mode, path + ["set_standard_resolution"])
                        self.use_original_resolution = self.__class__.use_original_resolution(service, version, mode, path + ["use_original_resolution"])
                        self.width = self.__class__.width(service, version, mode, path + ["width"])
                        super().__init__(service, version, mode, path)
                    class format(TUIMethod):
                        """
                        .
                        """
                    class fps(TUIMethod):
                        """
                        .
                        """
                    class height(TUIMethod):
                        """
                        .
                        """
                    class name(TUIMethod):
                        """
                        .
                        """
                    class quality(TUIMethod):
                        """
                        .
                        """
                    class scale(TUIMethod):
                        """
                        .
                        """
                    class set_standard_resolution(TUIMethod):
                        """
                        .
                        """
                    class use_original_resolution(TUIMethod):
                        """
                        .
                        """
                    class width(TUIMethod):
                        """
                        .
                        """

                    class advance_quality(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.bitrate = self.__class__.bitrate(service, version, mode, path + ["bitrate"])
                            self.bitrate_scale = self.__class__.bitrate_scale(service, version, mode, path + ["bitrate_scale"])
                            self.compression_method = self.__class__.compression_method(service, version, mode, path + ["compression_method"])
                            self.enable_h264 = self.__class__.enable_h264(service, version, mode, path + ["enable_h264"])
                            self.keyframe = self.__class__.keyframe(service, version, mode, path + ["keyframe"])
                            super().__init__(service, version, mode, path)
                        class bitrate(TUIMethod):
                            """
                            .
                            """
                        class bitrate_scale(TUIMethod):
                            """
                            .
                            """
                        class compression_method(TUIMethod):
                            """
                            .
                            """
                        class enable_h264(TUIMethod):
                            """
                            .
                            """
                        class keyframe(TUIMethod):
                            """
                            .
                            """

            class scene_animation(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.set_custom_frames = self.__class__.set_custom_frames(service, version, mode, path + ["set_custom_frames"])
                    self.add_keyframe = self.__class__.add_keyframe(service, version, mode, path + ["add_keyframe"])
                    self.delete_all_keyframes = self.__class__.delete_all_keyframes(service, version, mode, path + ["delete_all_keyframes"])
                    self.delete_keyframe = self.__class__.delete_keyframe(service, version, mode, path + ["delete_keyframe"])
                    self.play = self.__class__.play(service, version, mode, path + ["play"])
                    self.read_animation = self.__class__.read_animation(service, version, mode, path + ["read_animation"])
                    self.write_animation = self.__class__.write_animation(service, version, mode, path + ["write_animation"])
                    super().__init__(service, version, mode, path)
                class add_keyframe(TUIMethod):
                    """
                    .
                    """
                class delete_all_keyframes(TUIMethod):
                    """
                    .
                    """
                class delete_keyframe(TUIMethod):
                    """
                    .
                    """
                class play(TUIMethod):
                    """
                    .
                    """
                class read_animation(TUIMethod):
                    """
                    .
                    """
                class write_animation(TUIMethod):
                    """
                    .
                    """

                class set_custom_frames(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.end_keyframe = self.__class__.end_keyframe(service, version, mode, path + ["end_keyframe"])
                        self.increment = self.__class__.increment(service, version, mode, path + ["increment"])
                        self.start_keyframe = self.__class__.start_keyframe(service, version, mode, path + ["start_keyframe"])
                        super().__init__(service, version, mode, path)
                    class end_keyframe(TUIMethod):
                        """
                        .
                        """
                    class increment(TUIMethod):
                        """
                        .
                        """
                    class start_keyframe(TUIMethod):
                        """
                        .
                        """

        class custom_vectors(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                super().__init__(service, version, mode, path)
            class create(TUIMethod):
                """
                Create a new custom-vectors object.
                """
            class delete(TUIMethod):
                """
                .
                """
            class edit(TUIMethod):
                """
                Edit custom-vectors object.
                """
            class list(TUIMethod):
                """
                .
                """
            class list_properties(TUIMethod):
                """
                .
                """
            class make_a_copy(TUIMethod):
                """
                .
                """
            class rename(TUIMethod):
                """
                Rename custom-vectors object.
                """

        class graphics(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.colors = self.__class__.colors(service, version, mode, path + ["colors"])
                self.contour = self.__class__.contour(service, version, mode, path + ["contour"])
                self.contours = self.__class__.contours(service, version, mode, path + ["contours"])
                self.lic = self.__class__.lic(service, version, mode, path + ["lic"])
                self.lighting = self.__class__.lighting(service, version, mode, path + ["lighting"])
                self.mesh = self.__class__.mesh(service, version, mode, path + ["mesh"])
                self.olic = self.__class__.olic(service, version, mode, path + ["olic"])
                self.particle_track = self.__class__.particle_track(service, version, mode, path + ["particle_track"])
                self.particle_tracks = self.__class__.particle_tracks(service, version, mode, path + ["particle_tracks"])
                self.pathline = self.__class__.pathline(service, version, mode, path + ["pathline"])
                self.picture = self.__class__.picture(service, version, mode, path + ["picture"])
                self.pulse = self.__class__.pulse(service, version, mode, path + ["pulse"])
                self.raytracing_options = self.__class__.raytracing_options(service, version, mode, path + ["raytracing_options"])
                self.vector = self.__class__.vector(service, version, mode, path + ["vector"])
                self.views = self.__class__.views(service, version, mode, path + ["views"])
                self.volumes = self.__class__.volumes(service, version, mode, path + ["volumes"])
                self.windows = self.__class__.windows(service, version, mode, path + ["windows"])
                super().__init__(service, version, mode, path)

            class colors(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.by_surface = self.__class__.by_surface(service, version, mode, path + ["by_surface"])
                    self.by_type = self.__class__.by_type(service, version, mode, path + ["by_type"])
                    self.automatic_skip = self.__class__.automatic_skip(service, version, mode, path + ["automatic_skip"])
                    self.axis_faces = self.__class__.axis_faces(service, version, mode, path + ["axis_faces"])
                    self.background = self.__class__.background(service, version, mode, path + ["background"])
                    self.color_by_type = self.__class__.color_by_type(service, version, mode, path + ["color_by_type"])
                    self.far_field_faces = self.__class__.far_field_faces(service, version, mode, path + ["far_field_faces"])
                    self.foreground = self.__class__.foreground(service, version, mode, path + ["foreground"])
                    self.free_surface_faces = self.__class__.free_surface_faces(service, version, mode, path + ["free_surface_faces"])
                    self.inlet_faces = self.__class__.inlet_faces(service, version, mode, path + ["inlet_faces"])
                    self.interface_faces = self.__class__.interface_faces(service, version, mode, path + ["interface_faces"])
                    self.interior_faces = self.__class__.interior_faces(service, version, mode, path + ["interior_faces"])
                    self.internal_faces = self.__class__.internal_faces(service, version, mode, path + ["internal_faces"])
                    self.list_colors = self.__class__.list_colors(service, version, mode, path + ["list_colors"])
                    self.outlet_faces = self.__class__.outlet_faces(service, version, mode, path + ["outlet_faces"])
                    self.overset_faces = self.__class__.overset_faces(service, version, mode, path + ["overset_faces"])
                    self.periodic_faces = self.__class__.periodic_faces(service, version, mode, path + ["periodic_faces"])
                    self.rans_les_interface_faces = self.__class__.rans_les_interface_faces(service, version, mode, path + ["rans_les_interface_faces"])
                    self.reset_colors = self.__class__.reset_colors(service, version, mode, path + ["reset_colors"])
                    self.skip_label = self.__class__.skip_label(service, version, mode, path + ["skip_label"])
                    self.surface = self.__class__.surface(service, version, mode, path + ["surface"])
                    self.symmetry_faces = self.__class__.symmetry_faces(service, version, mode, path + ["symmetry_faces"])
                    self.traction_faces = self.__class__.traction_faces(service, version, mode, path + ["traction_faces"])
                    self.wall_faces = self.__class__.wall_faces(service, version, mode, path + ["wall_faces"])
                    super().__init__(service, version, mode, path)
                class automatic_skip(TUIMethod):
                    """
                    .
                    """
                class axis_faces(TUIMethod):
                    """
                    .
                    """
                class background(TUIMethod):
                    """
                    .
                    """
                class color_by_type(TUIMethod):
                    """
                    .
                    """
                class far_field_faces(TUIMethod):
                    """
                    .
                    """
                class foreground(TUIMethod):
                    """
                    .
                    """
                class free_surface_faces(TUIMethod):
                    """
                    .
                    """
                class inlet_faces(TUIMethod):
                    """
                    .
                    """
                class interface_faces(TUIMethod):
                    """
                    .
                    """
                class interior_faces(TUIMethod):
                    """
                    .
                    """
                class internal_faces(TUIMethod):
                    """
                    .
                    """
                class list_colors(TUIMethod):
                    """
                    .
                    """
                class outlet_faces(TUIMethod):
                    """
                    .
                    """
                class overset_faces(TUIMethod):
                    """
                    .
                    """
                class periodic_faces(TUIMethod):
                    """
                    .
                    """
                class rans_les_interface_faces(TUIMethod):
                    """
                    .
                    """
                class reset_colors(TUIMethod):
                    """
                    .
                    """
                class skip_label(TUIMethod):
                    """
                    .
                    """
                class surface(TUIMethod):
                    """
                    .
                    """
                class symmetry_faces(TUIMethod):
                    """
                    .
                    """
                class traction_faces(TUIMethod):
                    """
                    .
                    """
                class wall_faces(TUIMethod):
                    """
                    .
                    """

                class by_surface(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.list_surfaces_by_color = self.__class__.list_surfaces_by_color(service, version, mode, path + ["list_surfaces_by_color"])
                        self.list_surfaces_by_material = self.__class__.list_surfaces_by_material(service, version, mode, path + ["list_surfaces_by_material"])
                        self.reset = self.__class__.reset(service, version, mode, path + ["reset"])
                        self.surfaces = self.__class__.surfaces(service, version, mode, path + ["surfaces"])
                        self.use_inherent_material_color = self.__class__.use_inherent_material_color(service, version, mode, path + ["use_inherent_material_color"])
                        super().__init__(service, version, mode, path)
                    class list_surfaces_by_color(TUIMethod):
                        """
                        .
                        """
                    class list_surfaces_by_material(TUIMethod):
                        """
                        .
                        """
                    class reset(TUIMethod):
                        """
                        .
                        """
                    class surfaces(TUIMethod):
                        """
                        .
                        """
                    class use_inherent_material_color(TUIMethod):
                        """
                        .
                        """

                class by_type(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.type_name = self.__class__.type_name(service, version, mode, path + ["type_name"])
                        self.only_list_case_boundaries = self.__class__.only_list_case_boundaries(service, version, mode, path + ["only_list_case_boundaries"])
                        self.reset = self.__class__.reset(service, version, mode, path + ["reset"])
                        self.use_inherent_material_color = self.__class__.use_inherent_material_color(service, version, mode, path + ["use_inherent_material_color"])
                        super().__init__(service, version, mode, path)
                    class only_list_case_boundaries(TUIMethod):
                        """
                        .
                        """
                    class reset(TUIMethod):
                        """
                        .
                        """
                    class use_inherent_material_color(TUIMethod):
                        """
                        .
                        """

                    class type_name(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.create = self.__class__.create(service, version, mode, path + ["create"])
                            self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                            self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                            self.list = self.__class__.list(service, version, mode, path + ["list"])
                            self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                            self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                            self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                            super().__init__(service, version, mode, path)
                        class create(TUIMethod):
                            """
                            Create a new type-name object.
                            """
                        class delete(TUIMethod):
                            """
                            .
                            """
                        class edit(TUIMethod):
                            """
                            Edit type-name object.
                            """
                        class list(TUIMethod):
                            """
                            .
                            """
                        class list_properties(TUIMethod):
                            """
                            .
                            """
                        class make_a_copy(TUIMethod):
                            """
                            .
                            """
                        class rename(TUIMethod):
                            """
                            Rename type-name object.
                            """

            class contour(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.add_to_graphics = self.__class__.add_to_graphics(service, version, mode, path + ["add_to_graphics"])
                    self.clear_history = self.__class__.clear_history(service, version, mode, path + ["clear_history"])
                    self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.display = self.__class__.display(service, version, mode, path + ["display"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class add_to_graphics(TUIMethod):
                    """
                    .
                    """
                class clear_history(TUIMethod):
                    """
                    .
                    """
                class copy(TUIMethod):
                    """
                    .
                    """
                class create(TUIMethod):
                    """
                    Create a new contour object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class display(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit contour object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename contour object.
                    """

            class contours(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.coloring = self.__class__.coloring(service, version, mode, path + ["coloring"])
                    self.auto_scale = self.__class__.auto_scale(service, version, mode, path + ["auto_scale"])
                    self.clip_to_range = self.__class__.clip_to_range(service, version, mode, path + ["clip_to_range"])
                    self.filled_contours = self.__class__.filled_contours(service, version, mode, path + ["filled_contours"])
                    self.global_range = self.__class__.global_range(service, version, mode, path + ["global_range"])
                    self.line_contours = self.__class__.line_contours(service, version, mode, path + ["line_contours"])
                    self.log_scale = self.__class__.log_scale(service, version, mode, path + ["log_scale"])
                    self.n_contour = self.__class__.n_contour(service, version, mode, path + ["n_contour"])
                    self.node_values = self.__class__.node_values(service, version, mode, path + ["node_values"])
                    self.render_mesh = self.__class__.render_mesh(service, version, mode, path + ["render_mesh"])
                    self.surfaces = self.__class__.surfaces(service, version, mode, path + ["surfaces"])
                    super().__init__(service, version, mode, path)
                class auto_scale(TUIMethod):
                    """
                    .
                    """
                class clip_to_range(TUIMethod):
                    """
                    .
                    """
                class filled_contours(TUIMethod):
                    """
                    .
                    """
                class global_range(TUIMethod):
                    """
                    .
                    """
                class line_contours(TUIMethod):
                    """
                    .
                    """
                class log_scale(TUIMethod):
                    """
                    .
                    """
                class n_contour(TUIMethod):
                    """
                    .
                    """
                class node_values(TUIMethod):
                    """
                    .
                    """
                class render_mesh(TUIMethod):
                    """
                    .
                    """
                class surfaces(TUIMethod):
                    """
                    .
                    """

                class coloring(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.banded_coloring = self.__class__.banded_coloring(service, version, mode, path + ["banded_coloring"])
                        self.number_of_bands = self.__class__.number_of_bands(service, version, mode, path + ["number_of_bands"])
                        super().__init__(service, version, mode, path)
                    class banded_coloring(TUIMethod):
                        """
                        .
                        """
                    class number_of_bands(TUIMethod):
                        """
                        .
                        """

            class lic(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.add_to_graphics = self.__class__.add_to_graphics(service, version, mode, path + ["add_to_graphics"])
                    self.clear_history = self.__class__.clear_history(service, version, mode, path + ["clear_history"])
                    self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.display = self.__class__.display(service, version, mode, path + ["display"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class add_to_graphics(TUIMethod):
                    """
                    .
                    """
                class clear_history(TUIMethod):
                    """
                    .
                    """
                class copy(TUIMethod):
                    """
                    .
                    """
                class create(TUIMethod):
                    """
                    Create a new lic object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class display(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit lic object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename lic object.
                    """

            class lighting(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.lights = self.__class__.lights(service, version, mode, path + ["lights"])
                    self.ambient_color = self.__class__.ambient_color(service, version, mode, path + ["ambient_color"])
                    self.headlight_setting = self.__class__.headlight_setting(service, version, mode, path + ["headlight_setting"])
                    self.lighting_interpolation = self.__class__.lighting_interpolation(service, version, mode, path + ["lighting_interpolation"])
                    self.lights_on = self.__class__.lights_on(service, version, mode, path + ["lights_on"])
                    super().__init__(service, version, mode, path)
                class ambient_color(TUIMethod):
                    """
                    .
                    """
                class headlight_setting(TUIMethod):
                    """
                    .
                    """
                class lighting_interpolation(TUIMethod):
                    """
                    .
                    """
                class lights_on(TUIMethod):
                    """
                    .
                    """

                class lights(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.number_of_objects = self.__class__.number_of_objects(service, version, mode, path + ["number_of_objects"])
                        super().__init__(service, version, mode, path)
                    class edit(TUIMethod):
                        """
                        Edit lights object.
                        """
                    class list_properties(TUIMethod):
                        """
                        .
                        """
                    class number_of_objects(TUIMethod):
                        """
                        Set number of objects for lights.
                        """

            class mesh(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.add_to_graphics = self.__class__.add_to_graphics(service, version, mode, path + ["add_to_graphics"])
                    self.clear_history = self.__class__.clear_history(service, version, mode, path + ["clear_history"])
                    self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.display = self.__class__.display(service, version, mode, path + ["display"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class add_to_graphics(TUIMethod):
                    """
                    .
                    """
                class clear_history(TUIMethod):
                    """
                    .
                    """
                class copy(TUIMethod):
                    """
                    .
                    """
                class create(TUIMethod):
                    """
                    Create a new mesh object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class display(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit mesh object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename mesh object.
                    """

            class olic(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.add_to_graphics = self.__class__.add_to_graphics(service, version, mode, path + ["add_to_graphics"])
                    self.clear_history = self.__class__.clear_history(service, version, mode, path + ["clear_history"])
                    self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.display = self.__class__.display(service, version, mode, path + ["display"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class add_to_graphics(TUIMethod):
                    """
                    .
                    """
                class clear_history(TUIMethod):
                    """
                    .
                    """
                class copy(TUIMethod):
                    """
                    .
                    """
                class create(TUIMethod):
                    """
                    Create a new olic object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class display(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit olic object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename olic object.
                    """

            class particle_track(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.add_to_graphics = self.__class__.add_to_graphics(service, version, mode, path + ["add_to_graphics"])
                    self.clear_history = self.__class__.clear_history(service, version, mode, path + ["clear_history"])
                    self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.display = self.__class__.display(service, version, mode, path + ["display"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class add_to_graphics(TUIMethod):
                    """
                    .
                    """
                class clear_history(TUIMethod):
                    """
                    .
                    """
                class copy(TUIMethod):
                    """
                    .
                    """
                class create(TUIMethod):
                    """
                    Create a new particle-track object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class display(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit particle-track object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename particle-track object.
                    """

            class particle_tracks(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.arrow_scale = self.__class__.arrow_scale(service, version, mode, path + ["arrow_scale"])
                    self.arrow_space = self.__class__.arrow_space(service, version, mode, path + ["arrow_space"])
                    self.coarsen_factor = self.__class__.coarsen_factor(service, version, mode, path + ["coarsen_factor"])
                    self.display = self.__class__.display(service, version, mode, path + ["display"])
                    self.history_filename = self.__class__.history_filename(service, version, mode, path + ["history_filename"])
                    self.line_width = self.__class__.line_width(service, version, mode, path + ["line_width"])
                    self.report_default_variables = self.__class__.report_default_variables(service, version, mode, path + ["report_default_variables"])
                    self.track_single_particle_stream = self.__class__.track_single_particle_stream(service, version, mode, path + ["track_single_particle_stream"])
                    super().__init__(service, version, mode, path)
                class arrow_scale(TUIMethod):
                    """
                    .
                    """
                class arrow_space(TUIMethod):
                    """
                    .
                    """
                class coarsen_factor(TUIMethod):
                    """
                    .
                    """
                class display(TUIMethod):
                    """
                    .
                    """
                class history_filename(TUIMethod):
                    """
                    .
                    """
                class line_width(TUIMethod):
                    """
                    .
                    """
                class report_default_variables(TUIMethod):
                    """
                    .
                    """
                class track_single_particle_stream(TUIMethod):
                    """
                    .
                    """

            class pathline(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.add_to_graphics = self.__class__.add_to_graphics(service, version, mode, path + ["add_to_graphics"])
                    self.clear_history = self.__class__.clear_history(service, version, mode, path + ["clear_history"])
                    self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.display = self.__class__.display(service, version, mode, path + ["display"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class add_to_graphics(TUIMethod):
                    """
                    .
                    """
                class clear_history(TUIMethod):
                    """
                    .
                    """
                class copy(TUIMethod):
                    """
                    .
                    """
                class create(TUIMethod):
                    """
                    Create a new pathline object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class display(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit pathline object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename pathline object.
                    """

            class picture(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.driver_options = self.__class__.driver_options(service, version, mode, path + ["driver_options"])
                    self.color_mode = self.__class__.color_mode(service, version, mode, path + ["color_mode"])
                    self.dpi = self.__class__.dpi(service, version, mode, path + ["dpi"])
                    self.invert_background = self.__class__.invert_background(service, version, mode, path + ["invert_background"])
                    self.jpeg_hardcopy_quality = self.__class__.jpeg_hardcopy_quality(service, version, mode, path + ["jpeg_hardcopy_quality"])
                    self.landscape = self.__class__.landscape(service, version, mode, path + ["landscape"])
                    self.list_color_mode = self.__class__.list_color_mode(service, version, mode, path + ["list_color_mode"])
                    self.preview = self.__class__.preview(service, version, mode, path + ["preview"])
                    self.raytracer_image = self.__class__.raytracer_image(service, version, mode, path + ["raytracer_image"])
                    self.save_picture = self.__class__.save_picture(service, version, mode, path + ["save_picture"])
                    self.standard_resolution = self.__class__.standard_resolution(service, version, mode, path + ["standard_resolution"])
                    self.use_window_resolution = self.__class__.use_window_resolution(service, version, mode, path + ["use_window_resolution"])
                    self.x_resolution = self.__class__.x_resolution(service, version, mode, path + ["x_resolution"])
                    self.y_resolution = self.__class__.y_resolution(service, version, mode, path + ["y_resolution"])
                    super().__init__(service, version, mode, path)
                class color_mode(TUIMethod):
                    """
                    .
                    """
                class dpi(TUIMethod):
                    """
                    .
                    """
                class invert_background(TUIMethod):
                    """
                    .
                    """
                class jpeg_hardcopy_quality(TUIMethod):
                    """
                    .
                    """
                class landscape(TUIMethod):
                    """
                    .
                    """
                class list_color_mode(TUIMethod):
                    """
                    .
                    """
                class preview(TUIMethod):
                    """
                    .
                    """
                class raytracer_image(TUIMethod):
                    """
                    .
                    """
                class save_picture(TUIMethod):
                    """
                    .
                    """
                class standard_resolution(TUIMethod):
                    """
                    .
                    """
                class use_window_resolution(TUIMethod):
                    """
                    .
                    """
                class x_resolution(TUIMethod):
                    """
                    .
                    """
                class y_resolution(TUIMethod):
                    """
                    .
                    """

                class driver_options(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.current_driver = self.__class__.current_driver(service, version, mode, path + ["current_driver"])
                        self.hardcopy_format = self.__class__.hardcopy_format(service, version, mode, path + ["hardcopy_format"])
                        self.hardcopy_options = self.__class__.hardcopy_options(service, version, mode, path + ["hardcopy_options"])
                        self.post_format = self.__class__.post_format(service, version, mode, path + ["post_format"])
                        self.window_dump_cmd = self.__class__.window_dump_cmd(service, version, mode, path + ["window_dump_cmd"])
                        super().__init__(service, version, mode, path)
                    class current_driver(TUIMethod):
                        """
                        .
                        """
                    class hardcopy_format(TUIMethod):
                        """
                        .
                        """
                    class hardcopy_options(TUIMethod):
                        """
                        .
                        """
                    class post_format(TUIMethod):
                        """
                        .
                        """
                    class window_dump_cmd(TUIMethod):
                        """
                        .
                        """

            class pulse(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.pulse_mode = self.__class__.pulse_mode(service, version, mode, path + ["pulse_mode"])
                    self.write = self.__class__.write(service, version, mode, path + ["write"])
                    super().__init__(service, version, mode, path)
                class pulse_mode(TUIMethod):
                    """
                    .
                    """
                class write(TUIMethod):
                    """
                    .
                    """

            class raytracing_options(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.background = self.__class__.background(service, version, mode, path + ["background"])
                    self.rendering = self.__class__.rendering(service, version, mode, path + ["rendering"])
                    self.display_live_preview = self.__class__.display_live_preview(service, version, mode, path + ["display_live_preview"])
                    super().__init__(service, version, mode, path)
                class display_live_preview(TUIMethod):
                    """
                    .
                    """

                class background(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.backplate_color = self.__class__.backplate_color(service, version, mode, path + ["backplate_color"])
                        self.backplate_image = self.__class__.backplate_image(service, version, mode, path + ["backplate_image"])
                        self.env_color = self.__class__.env_color(service, version, mode, path + ["env_color"])
                        self.env_intensity = self.__class__.env_intensity(service, version, mode, path + ["env_intensity"])
                        self.env_light_dirvec = self.__class__.env_light_dirvec(service, version, mode, path + ["env_light_dirvec"])
                        self.env_light_upvec = self.__class__.env_light_upvec(service, version, mode, path + ["env_light_upvec"])
                        self.environment_image = self.__class__.environment_image(service, version, mode, path + ["environment_image"])
                        self.hide_environment_keep_effects = self.__class__.hide_environment_keep_effects(service, version, mode, path + ["hide_environment_keep_effects"])
                        self.horizontal = self.__class__.horizontal(service, version, mode, path + ["horizontal"])
                        self.show_backplate = self.__class__.show_backplate(service, version, mode, path + ["show_backplate"])
                        self.spin = self.__class__.spin(service, version, mode, path + ["spin"])
                        self.vertical = self.__class__.vertical(service, version, mode, path + ["vertical"])
                        self.view_zoom = self.__class__.view_zoom(service, version, mode, path + ["view_zoom"])
                        super().__init__(service, version, mode, path)
                    class backplate_color(TUIMethod):
                        """
                        .
                        """
                    class backplate_image(TUIMethod):
                        """
                        .
                        """
                    class env_color(TUIMethod):
                        """
                        .
                        """
                    class env_intensity(TUIMethod):
                        """
                        .
                        """
                    class env_light_dirvec(TUIMethod):
                        """
                        .
                        """
                    class env_light_upvec(TUIMethod):
                        """
                        .
                        """
                    class environment_image(TUIMethod):
                        """
                        .
                        """
                    class hide_environment_keep_effects(TUIMethod):
                        """
                        .
                        """
                    class horizontal(TUIMethod):
                        """
                        .
                        """
                    class show_backplate(TUIMethod):
                        """
                        .
                        """
                    class spin(TUIMethod):
                        """
                        .
                        """
                    class vertical(TUIMethod):
                        """
                        .
                        """
                    class view_zoom(TUIMethod):
                        """
                        .
                        """

                class rendering(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.denoiser = self.__class__.denoiser(service, version, mode, path + ["denoiser"])
                        self.max_rendering_timeout = self.__class__.max_rendering_timeout(service, version, mode, path + ["max_rendering_timeout"])
                        self.quality = self.__class__.quality(service, version, mode, path + ["quality"])
                        self.thread_count = self.__class__.thread_count(service, version, mode, path + ["thread_count"])
                        super().__init__(service, version, mode, path)
                    class denoiser(TUIMethod):
                        """
                        .
                        """
                    class max_rendering_timeout(TUIMethod):
                        """
                        .
                        """
                    class quality(TUIMethod):
                        """
                        .
                        """
                    class thread_count(TUIMethod):
                        """
                        .
                        """

            class vector(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.add_to_graphics = self.__class__.add_to_graphics(service, version, mode, path + ["add_to_graphics"])
                    self.clear_history = self.__class__.clear_history(service, version, mode, path + ["clear_history"])
                    self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.display = self.__class__.display(service, version, mode, path + ["display"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class add_to_graphics(TUIMethod):
                    """
                    .
                    """
                class clear_history(TUIMethod):
                    """
                    .
                    """
                class copy(TUIMethod):
                    """
                    .
                    """
                class create(TUIMethod):
                    """
                    Create a new vector object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class display(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit vector object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename vector object.
                    """

            class views(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.camera = self.__class__.camera(service, version, mode, path + ["camera"])
                    self.display_states = self.__class__.display_states(service, version, mode, path + ["display_states"])
                    self.rendering_options = self.__class__.rendering_options(service, version, mode, path + ["rendering_options"])
                    self.auto_scale = self.__class__.auto_scale(service, version, mode, path + ["auto_scale"])
                    self.delete_view = self.__class__.delete_view(service, version, mode, path + ["delete_view"])
                    self.last_view = self.__class__.last_view(service, version, mode, path + ["last_view"])
                    self.list_views = self.__class__.list_views(service, version, mode, path + ["list_views"])
                    self.next_view = self.__class__.next_view(service, version, mode, path + ["next_view"])
                    self.read_views = self.__class__.read_views(service, version, mode, path + ["read_views"])
                    self.reset_to_default_view = self.__class__.reset_to_default_view(service, version, mode, path + ["reset_to_default_view"])
                    self.restore_view = self.__class__.restore_view(service, version, mode, path + ["restore_view"])
                    self.save_view = self.__class__.save_view(service, version, mode, path + ["save_view"])
                    self.write_views = self.__class__.write_views(service, version, mode, path + ["write_views"])
                    super().__init__(service, version, mode, path)
                class auto_scale(TUIMethod):
                    """
                    .
                    """
                class delete_view(TUIMethod):
                    """
                    .
                    """
                class last_view(TUIMethod):
                    """
                    .
                    """
                class list_views(TUIMethod):
                    """
                    .
                    """
                class next_view(TUIMethod):
                    """
                    .
                    """
                class read_views(TUIMethod):
                    """
                    .
                    """
                class reset_to_default_view(TUIMethod):
                    """
                    .
                    """
                class restore_view(TUIMethod):
                    """
                    .
                    """
                class save_view(TUIMethod):
                    """
                    .
                    """
                class write_views(TUIMethod):
                    """
                    .
                    """

                class camera(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.dolly = self.__class__.dolly(service, version, mode, path + ["dolly"])
                        self.field = self.__class__.field(service, version, mode, path + ["field"])
                        self.orbit = self.__class__.orbit(service, version, mode, path + ["orbit"])
                        self.pan = self.__class__.pan(service, version, mode, path + ["pan"])
                        self.position = self.__class__.position(service, version, mode, path + ["position"])
                        self.projection = self.__class__.projection(service, version, mode, path + ["projection"])
                        self.roll = self.__class__.roll(service, version, mode, path + ["roll"])
                        self.target = self.__class__.target(service, version, mode, path + ["target"])
                        self.up_vector = self.__class__.up_vector(service, version, mode, path + ["up_vector"])
                        self.zoom = self.__class__.zoom(service, version, mode, path + ["zoom"])
                        super().__init__(service, version, mode, path)
                    class dolly(TUIMethod):
                        """
                        .
                        """
                    class field(TUIMethod):
                        """
                        .
                        """
                    class orbit(TUIMethod):
                        """
                        .
                        """
                    class pan(TUIMethod):
                        """
                        .
                        """
                    class position(TUIMethod):
                        """
                        .
                        """
                    class projection(TUIMethod):
                        """
                        .
                        """
                    class roll(TUIMethod):
                        """
                        .
                        """
                    class target(TUIMethod):
                        """
                        .
                        """
                    class up_vector(TUIMethod):
                        """
                        .
                        """
                    class zoom(TUIMethod):
                        """
                        .
                        """

                class display_states(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                        self.create = self.__class__.create(service, version, mode, path + ["create"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                        self.read = self.__class__.read(service, version, mode, path + ["read"])
                        self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                        self.restore_state = self.__class__.restore_state(service, version, mode, path + ["restore_state"])
                        self.use_active = self.__class__.use_active(service, version, mode, path + ["use_active"])
                        self.write = self.__class__.write(service, version, mode, path + ["write"])
                        super().__init__(service, version, mode, path)
                    class copy(TUIMethod):
                        """
                        .
                        """
                    class create(TUIMethod):
                        """
                        Create a new display-states object.
                        """
                    class delete(TUIMethod):
                        """
                        .
                        """
                    class edit(TUIMethod):
                        """
                        Edit display-states object.
                        """
                    class list(TUIMethod):
                        """
                        .
                        """
                    class list_properties(TUIMethod):
                        """
                        .
                        """
                    class make_a_copy(TUIMethod):
                        """
                        .
                        """
                    class read(TUIMethod):
                        """
                        .
                        """
                    class rename(TUIMethod):
                        """
                        Rename display-states object.
                        """
                    class restore_state(TUIMethod):
                        """
                        .
                        """
                    class use_active(TUIMethod):
                        """
                        .
                        """
                    class write(TUIMethod):
                        """
                        .
                        """

                class rendering_options(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.animation_option = self.__class__.animation_option(service, version, mode, path + ["animation_option"])
                        self.auto_spin = self.__class__.auto_spin(service, version, mode, path + ["auto_spin"])
                        self.color_map_alignment = self.__class__.color_map_alignment(service, version, mode, path + ["color_map_alignment"])
                        self.device_info = self.__class__.device_info(service, version, mode, path + ["device_info"])
                        self.double_buffering = self.__class__.double_buffering(service, version, mode, path + ["double_buffering"])
                        self.driver = self.__class__.driver(service, version, mode, path + ["driver"])
                        self.face_displacement = self.__class__.face_displacement(service, version, mode, path + ["face_displacement"])
                        self.front_faces_transparent = self.__class__.front_faces_transparent(service, version, mode, path + ["front_faces_transparent"])
                        self.hidden_surface_method = self.__class__.hidden_surface_method(service, version, mode, path + ["hidden_surface_method"])
                        self.hidden_surfaces = self.__class__.hidden_surfaces(service, version, mode, path + ["hidden_surfaces"])
                        self.set_rendering_options = self.__class__.set_rendering_options(service, version, mode, path + ["set_rendering_options"])
                        self.show_colormap = self.__class__.show_colormap(service, version, mode, path + ["show_colormap"])
                        super().__init__(service, version, mode, path)
                    class animation_option(TUIMethod):
                        """
                        .
                        """
                    class auto_spin(TUIMethod):
                        """
                        .
                        """
                    class color_map_alignment(TUIMethod):
                        """
                        .
                        """
                    class device_info(TUIMethod):
                        """
                        .
                        """
                    class double_buffering(TUIMethod):
                        """
                        .
                        """
                    class driver(TUIMethod):
                        """
                        .
                        """
                    class face_displacement(TUIMethod):
                        """
                        .
                        """
                    class front_faces_transparent(TUIMethod):
                        """
                        .
                        """
                    class hidden_surface_method(TUIMethod):
                        """
                        .
                        """
                    class hidden_surfaces(TUIMethod):
                        """
                        .
                        """
                    class set_rendering_options(TUIMethod):
                        """
                        .
                        """
                    class show_colormap(TUIMethod):
                        """
                        .
                        """

            class volumes(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.add_to_graphics = self.__class__.add_to_graphics(service, version, mode, path + ["add_to_graphics"])
                    self.clear_history = self.__class__.clear_history(service, version, mode, path + ["clear_history"])
                    self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.display = self.__class__.display(service, version, mode, path + ["display"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class add_to_graphics(TUIMethod):
                    """
                    .
                    """
                class clear_history(TUIMethod):
                    """
                    .
                    """
                class copy(TUIMethod):
                    """
                    .
                    """
                class create(TUIMethod):
                    """
                    Create a new volumes object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class display(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit volumes object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename volumes object.
                    """

            class windows(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                    self.main = self.__class__.main(service, version, mode, path + ["main"])
                    self.scale = self.__class__.scale(service, version, mode, path + ["scale"])
                    self.text = self.__class__.text(service, version, mode, path + ["text"])
                    self.video = self.__class__.video(service, version, mode, path + ["video"])
                    self.xy = self.__class__.xy(service, version, mode, path + ["xy"])
                    self.aspect_ratio = self.__class__.aspect_ratio(service, version, mode, path + ["aspect_ratio"])
                    self.close_window = self.__class__.close_window(service, version, mode, path + ["close_window"])
                    self.close_window_by_name = self.__class__.close_window_by_name(service, version, mode, path + ["close_window_by_name"])
                    self.logo = self.__class__.logo(service, version, mode, path + ["logo"])
                    self.logo_color = self.__class__.logo_color(service, version, mode, path + ["logo_color"])
                    self.open_window = self.__class__.open_window(service, version, mode, path + ["open_window"])
                    self.ruler = self.__class__.ruler(service, version, mode, path + ["ruler"])
                    self.set_window = self.__class__.set_window(service, version, mode, path + ["set_window"])
                    self.set_window_by_name = self.__class__.set_window_by_name(service, version, mode, path + ["set_window_by_name"])
                    super().__init__(service, version, mode, path)
                class aspect_ratio(TUIMethod):
                    """
                    .
                    """
                class close_window(TUIMethod):
                    """
                    .
                    """
                class close_window_by_name(TUIMethod):
                    """
                    .
                    """
                class logo(TUIMethod):
                    """
                    .
                    """
                class logo_color(TUIMethod):
                    """
                    .
                    """
                class open_window(TUIMethod):
                    """
                    .
                    """
                class ruler(TUIMethod):
                    """
                    .
                    """
                class set_window(TUIMethod):
                    """
                    .
                    """
                class set_window_by_name(TUIMethod):
                    """
                    .
                    """

                class axes(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                        self.left = self.__class__.left(service, version, mode, path + ["left"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.top = self.__class__.top(service, version, mode, path + ["top"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        super().__init__(service, version, mode, path)
                    class border(TUIMethod):
                        """
                        .
                        """
                    class bottom(TUIMethod):
                        """
                        .
                        """
                    class clear(TUIMethod):
                        """
                        .
                        """
                    class left(TUIMethod):
                        """
                        .
                        """
                    class right(TUIMethod):
                        """
                        .
                        """
                    class top(TUIMethod):
                        """
                        .
                        """
                    class visible(TUIMethod):
                        """
                        .
                        """

                class main(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.left = self.__class__.left(service, version, mode, path + ["left"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.top = self.__class__.top(service, version, mode, path + ["top"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        super().__init__(service, version, mode, path)
                    class border(TUIMethod):
                        """
                        .
                        """
                    class bottom(TUIMethod):
                        """
                        .
                        """
                    class left(TUIMethod):
                        """
                        .
                        """
                    class right(TUIMethod):
                        """
                        .
                        """
                    class top(TUIMethod):
                        """
                        .
                        """
                    class visible(TUIMethod):
                        """
                        .
                        """

                class scale(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                        self.font_size = self.__class__.font_size(service, version, mode, path + ["font_size"])
                        self.format = self.__class__.format(service, version, mode, path + ["format"])
                        self.left = self.__class__.left(service, version, mode, path + ["left"])
                        self.margin = self.__class__.margin(service, version, mode, path + ["margin"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.top = self.__class__.top(service, version, mode, path + ["top"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        super().__init__(service, version, mode, path)
                    class border(TUIMethod):
                        """
                        .
                        """
                    class bottom(TUIMethod):
                        """
                        .
                        """
                    class clear(TUIMethod):
                        """
                        .
                        """
                    class font_size(TUIMethod):
                        """
                        .
                        """
                    class format(TUIMethod):
                        """
                        .
                        """
                    class left(TUIMethod):
                        """
                        .
                        """
                    class margin(TUIMethod):
                        """
                        .
                        """
                    class right(TUIMethod):
                        """
                        .
                        """
                    class top(TUIMethod):
                        """
                        .
                        """
                    class visible(TUIMethod):
                        """
                        .
                        """

                class text(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.alignment = self.__class__.alignment(service, version, mode, path + ["alignment"])
                        self.application = self.__class__.application(service, version, mode, path + ["application"])
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                        self.company = self.__class__.company(service, version, mode, path + ["company"])
                        self.date = self.__class__.date(service, version, mode, path + ["date"])
                        self.left = self.__class__.left(service, version, mode, path + ["left"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.top = self.__class__.top(service, version, mode, path + ["top"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        super().__init__(service, version, mode, path)
                    class alignment(TUIMethod):
                        """
                        .
                        """
                    class application(TUIMethod):
                        """
                        .
                        """
                    class border(TUIMethod):
                        """
                        .
                        """
                    class bottom(TUIMethod):
                        """
                        .
                        """
                    class clear(TUIMethod):
                        """
                        .
                        """
                    class company(TUIMethod):
                        """
                        .
                        """
                    class date(TUIMethod):
                        """
                        .
                        """
                    class left(TUIMethod):
                        """
                        .
                        """
                    class right(TUIMethod):
                        """
                        .
                        """
                    class top(TUIMethod):
                        """
                        .
                        """
                    class visible(TUIMethod):
                        """
                        .
                        """

                class video(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.pixel_size = self.__class__.pixel_size(service, version, mode, path + ["pixel_size"])
                        self.background = self.__class__.background(service, version, mode, path + ["background"])
                        self.color_filter = self.__class__.color_filter(service, version, mode, path + ["color_filter"])
                        self.foreground = self.__class__.foreground(service, version, mode, path + ["foreground"])
                        self.on = self.__class__.on(service, version, mode, path + ["on"])
                        super().__init__(service, version, mode, path)
                    class background(TUIMethod):
                        """
                        .
                        """
                    class color_filter(TUIMethod):
                        """
                        .
                        """
                    class foreground(TUIMethod):
                        """
                        .
                        """
                    class on(TUIMethod):
                        """
                        .
                        """

                    class pixel_size(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.height = self.__class__.height(service, version, mode, path + ["height"])
                            self.margin = self.__class__.margin(service, version, mode, path + ["margin"])
                            self.width = self.__class__.width(service, version, mode, path + ["width"])
                            super().__init__(service, version, mode, path)
                        class height(TUIMethod):
                            """
                            .
                            """
                        class margin(TUIMethod):
                            """
                            .
                            """
                        class width(TUIMethod):
                            """
                            .
                            """

                class xy(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.left = self.__class__.left(service, version, mode, path + ["left"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.top = self.__class__.top(service, version, mode, path + ["top"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        super().__init__(service, version, mode, path)
                    class border(TUIMethod):
                        """
                        .
                        """
                    class bottom(TUIMethod):
                        """
                        .
                        """
                    class left(TUIMethod):
                        """
                        .
                        """
                    class right(TUIMethod):
                        """
                        .
                        """
                    class top(TUIMethod):
                        """
                        .
                        """
                    class visible(TUIMethod):
                        """
                        .
                        """

        class plot(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.cumulative_plot = self.__class__.cumulative_plot(service, version, mode, path + ["cumulative_plot"])
                self.histogram = self.__class__.histogram(service, version, mode, path + ["histogram"])
                self.xy_plot = self.__class__.xy_plot(service, version, mode, path + ["xy_plot"])
                super().__init__(service, version, mode, path)

            class cumulative_plot(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.display = self.__class__.display(service, version, mode, path + ["display"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new cumulative-plot object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class display(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit cumulative-plot object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename cumulative-plot object.
                    """

            class histogram(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                    self.curves = self.__class__.curves(service, version, mode, path + ["curves"])
                    self.all_zones = self.__class__.all_zones(service, version, mode, path + ["all_zones"])
                    self.auto_range = self.__class__.auto_range(service, version, mode, path + ["auto_range"])
                    self.cell_function = self.__class__.cell_function(service, version, mode, path + ["cell_function"])
                    self.maximum = self.__class__.maximum(service, version, mode, path + ["maximum"])
                    self.minimum = self.__class__.minimum(service, version, mode, path + ["minimum"])
                    self.num_divisions = self.__class__.num_divisions(service, version, mode, path + ["num_divisions"])
                    self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
                    self.print = self.__class__.print(service, version, mode, path + ["print"])
                    self.write = self.__class__.write(service, version, mode, path + ["write"])
                    self.zones = self.__class__.zones(service, version, mode, path + ["zones"])
                    super().__init__(service, version, mode, path)
                class all_zones(TUIMethod):
                    """
                    .
                    """
                class auto_range(TUIMethod):
                    """
                    .
                    """
                class cell_function(TUIMethod):
                    """
                    .
                    """
                class maximum(TUIMethod):
                    """
                    .
                    """
                class minimum(TUIMethod):
                    """
                    .
                    """
                class num_divisions(TUIMethod):
                    """
                    .
                    """
                class plot(TUIMethod):
                    """
                    .
                    """
                class print(TUIMethod):
                    """
                    .
                    """
                class write(TUIMethod):
                    """
                    .
                    """
                class zones(TUIMethod):
                    """
                    .
                    """

                class axes(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.x = self.__class__.x(service, version, mode, path + ["x"])
                        self.y = self.__class__.y(service, version, mode, path + ["y"])
                        self.background_color = self.__class__.background_color(service, version, mode, path + ["background_color"])
                        super().__init__(service, version, mode, path)
                    class background_color(TUIMethod):
                        """
                        .
                        """

                    class x(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.major_gridlines = self.__class__.major_gridlines(service, version, mode, path + ["major_gridlines"])
                            self.minor_gridlines = self.__class__.minor_gridlines(service, version, mode, path + ["minor_gridlines"])
                            self.number_format = self.__class__.number_format(service, version, mode, path + ["number_format"])
                            self.auto_range = self.__class__.auto_range(service, version, mode, path + ["auto_range"])
                            self.label = self.__class__.label(service, version, mode, path + ["label"])
                            self.log_scale = self.__class__.log_scale(service, version, mode, path + ["log_scale"])
                            self.max = self.__class__.max(service, version, mode, path + ["max"])
                            self.min = self.__class__.min(service, version, mode, path + ["min"])
                            self.show_major_gridlines = self.__class__.show_major_gridlines(service, version, mode, path + ["show_major_gridlines"])
                            self.show_minor_gridlines = self.__class__.show_minor_gridlines(service, version, mode, path + ["show_minor_gridlines"])
                            super().__init__(service, version, mode, path)
                        class auto_range(TUIMethod):
                            """
                            .
                            """
                        class label(TUIMethod):
                            """
                            .
                            """
                        class log_scale(TUIMethod):
                            """
                            .
                            """
                        class max(TUIMethod):
                            """
                            .
                            """
                        class min(TUIMethod):
                            """
                            .
                            """
                        class show_major_gridlines(TUIMethod):
                            """
                            .
                            """
                        class show_minor_gridlines(TUIMethod):
                            """
                            .
                            """

                        class major_gridlines(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.weight = self.__class__.weight(service, version, mode, path + ["weight"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                .
                                """
                            class weight(TUIMethod):
                                """
                                .
                                """

                        class minor_gridlines(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.weight = self.__class__.weight(service, version, mode, path + ["weight"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                .
                                """
                            class weight(TUIMethod):
                                """
                                .
                                """

                        class number_format(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.format_type = self.__class__.format_type(service, version, mode, path + ["format_type"])
                                self.precision = self.__class__.precision(service, version, mode, path + ["precision"])
                                super().__init__(service, version, mode, path)
                            class format_type(TUIMethod):
                                """
                                .
                                """
                            class precision(TUIMethod):
                                """
                                .
                                """

                    class y(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.major_gridlines = self.__class__.major_gridlines(service, version, mode, path + ["major_gridlines"])
                            self.minor_gridlines = self.__class__.minor_gridlines(service, version, mode, path + ["minor_gridlines"])
                            self.number_format = self.__class__.number_format(service, version, mode, path + ["number_format"])
                            self.auto_range = self.__class__.auto_range(service, version, mode, path + ["auto_range"])
                            self.label = self.__class__.label(service, version, mode, path + ["label"])
                            self.log_scale = self.__class__.log_scale(service, version, mode, path + ["log_scale"])
                            self.max = self.__class__.max(service, version, mode, path + ["max"])
                            self.min = self.__class__.min(service, version, mode, path + ["min"])
                            self.show_major_gridlines = self.__class__.show_major_gridlines(service, version, mode, path + ["show_major_gridlines"])
                            self.show_minor_gridlines = self.__class__.show_minor_gridlines(service, version, mode, path + ["show_minor_gridlines"])
                            super().__init__(service, version, mode, path)
                        class auto_range(TUIMethod):
                            """
                            .
                            """
                        class label(TUIMethod):
                            """
                            .
                            """
                        class log_scale(TUIMethod):
                            """
                            .
                            """
                        class max(TUIMethod):
                            """
                            .
                            """
                        class min(TUIMethod):
                            """
                            .
                            """
                        class show_major_gridlines(TUIMethod):
                            """
                            .
                            """
                        class show_minor_gridlines(TUIMethod):
                            """
                            .
                            """

                        class major_gridlines(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.weight = self.__class__.weight(service, version, mode, path + ["weight"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                .
                                """
                            class weight(TUIMethod):
                                """
                                .
                                """

                        class minor_gridlines(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.weight = self.__class__.weight(service, version, mode, path + ["weight"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                .
                                """
                            class weight(TUIMethod):
                                """
                                .
                                """

                        class number_format(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.format_type = self.__class__.format_type(service, version, mode, path + ["format_type"])
                                self.precision = self.__class__.precision(service, version, mode, path + ["precision"])
                                super().__init__(service, version, mode, path)
                            class format_type(TUIMethod):
                                """
                                .
                                """
                            class precision(TUIMethod):
                                """
                                .
                                """

                class curves(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.number_of_objects = self.__class__.number_of_objects(service, version, mode, path + ["number_of_objects"])
                        super().__init__(service, version, mode, path)
                    class edit(TUIMethod):
                        """
                        Edit curves object.
                        """
                    class list_properties(TUIMethod):
                        """
                        .
                        """
                    class number_of_objects(TUIMethod):
                        """
                        Set number of objects for curves.
                        """

            class xy_plot(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.add_to_graphics = self.__class__.add_to_graphics(service, version, mode, path + ["add_to_graphics"])
                    self.clear_history = self.__class__.clear_history(service, version, mode, path + ["clear_history"])
                    self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.display = self.__class__.display(service, version, mode, path + ["display"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class add_to_graphics(TUIMethod):
                    """
                    .
                    """
                class clear_history(TUIMethod):
                    """
                    .
                    """
                class copy(TUIMethod):
                    """
                    .
                    """
                class create(TUIMethod):
                    """
                    Create a new xy-plot object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class display(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit xy-plot object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename xy-plot object.
                    """

        class report(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.discrete_phase = self.__class__.discrete_phase(service, version, mode, path + ["discrete_phase"])
                self.flow = self.__class__.flow(service, version, mode, path + ["flow"])
                self.fluxes = self.__class__.fluxes(service, version, mode, path + ["fluxes"])
                self.heat_exchanger = self.__class__.heat_exchanger(service, version, mode, path + ["heat_exchanger"])
                self.modified_setting_options = self.__class__.modified_setting_options(service, version, mode, path + ["modified_setting_options"])
                self.population_balance = self.__class__.population_balance(service, version, mode, path + ["population_balance"])
                self.simulation_reports = self.__class__.simulation_reports(service, version, mode, path + ["simulation_reports"])
                self.surface_integrals = self.__class__.surface_integrals(service, version, mode, path + ["surface_integrals"])
                self.system = self.__class__.system(service, version, mode, path + ["system"])
                self.volume_integrals = self.__class__.volume_integrals(service, version, mode, path + ["volume_integrals"])
                self.aero_optical_distortions = self.__class__.aero_optical_distortions(service, version, mode, path + ["aero_optical_distortions"])
                self.forces = self.__class__.forces(service, version, mode, path + ["forces"])
                self.multiphase_summary = self.__class__.multiphase_summary(service, version, mode, path + ["multiphase_summary"])
                self.particle_summary = self.__class__.particle_summary(service, version, mode, path + ["particle_summary"])
                self.pathline_summary = self.__class__.pathline_summary(service, version, mode, path + ["pathline_summary"])
                self.projected_surface_area = self.__class__.projected_surface_area(service, version, mode, path + ["projected_surface_area"])
                self.summary = self.__class__.summary(service, version, mode, path + ["summary"])
                self.vbm = self.__class__.vbm(service, version, mode, path + ["vbm"])
                super().__init__(service, version, mode, path)
            class aero_optical_distortions(TUIMethod):
                """
                .
                """
            class forces(TUIMethod):
                """
                .
                """
            class multiphase_summary(TUIMethod):
                """
                .
                """
            class particle_summary(TUIMethod):
                """
                .
                """
            class pathline_summary(TUIMethod):
                """
                .
                """
            class projected_surface_area(TUIMethod):
                """
                .
                """
            class summary(TUIMethod):
                """
                .
                """
            class vbm(TUIMethod):
                """
                .
                """

            class discrete_phase(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.histogram = self.__class__.histogram(service, version, mode, path + ["histogram"])
                    self.sample_trajectories = self.__class__.sample_trajectories(service, version, mode, path + ["sample_trajectories"])
                    self.evap_mass_details_in_dpm_summ_rep = self.__class__.evap_mass_details_in_dpm_summ_rep(service, version, mode, path + ["evap_mass_details_in_dpm_summ_rep"])
                    self.extended_summary = self.__class__.extended_summary(service, version, mode, path + ["extended_summary"])
                    self.summary = self.__class__.summary(service, version, mode, path + ["summary"])
                    self.zone_summaries_per_injection = self.__class__.zone_summaries_per_injection(service, version, mode, path + ["zone_summaries_per_injection"])
                    super().__init__(service, version, mode, path)
                class evap_mass_details_in_dpm_summ_rep(TUIMethod):
                    """
                    .
                    """
                class extended_summary(TUIMethod):
                    """
                    .
                    """
                class summary(TUIMethod):
                    """
                    .
                    """
                class zone_summaries_per_injection(TUIMethod):
                    """
                    .
                    """

                class histogram(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.histogram_options = self.__class__.histogram_options(service, version, mode, path + ["histogram_options"])
                        self.histogram_parameters = self.__class__.histogram_parameters(service, version, mode, path + ["histogram_parameters"])
                        self.plot_write_sample = self.__class__.plot_write_sample(service, version, mode, path + ["plot_write_sample"])
                        self.reduction = self.__class__.reduction(service, version, mode, path + ["reduction"])
                        self.compute_sample = self.__class__.compute_sample(service, version, mode, path + ["compute_sample"])
                        self.delete_sample = self.__class__.delete_sample(service, version, mode, path + ["delete_sample"])
                        self.dpm_sample_contour_plots = self.__class__.dpm_sample_contour_plots(service, version, mode, path + ["dpm_sample_contour_plots"])
                        self.list_samples = self.__class__.list_samples(service, version, mode, path + ["list_samples"])
                        self.read_sample_file = self.__class__.read_sample_file(service, version, mode, path + ["read_sample_file"])
                        super().__init__(service, version, mode, path)
                    class compute_sample(TUIMethod):
                        """
                        .
                        """
                    class delete_sample(TUIMethod):
                        """
                        .
                        """
                    class dpm_sample_contour_plots(TUIMethod):
                        """
                        .
                        """
                    class list_samples(TUIMethod):
                        """
                        .
                        """
                    class read_sample_file(TUIMethod):
                        """
                        .
                        """

                    class histogram_options(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.auto_range = self.__class__.auto_range(service, version, mode, path + ["auto_range"])
                            self.correlation = self.__class__.correlation(service, version, mode, path + ["correlation"])
                            self.cumulation_curve = self.__class__.cumulation_curve(service, version, mode, path + ["cumulation_curve"])
                            self.diameter_statistics = self.__class__.diameter_statistics(service, version, mode, path + ["diameter_statistics"])
                            self.histogram_mode = self.__class__.histogram_mode(service, version, mode, path + ["histogram_mode"])
                            self.logarithmic = self.__class__.logarithmic(service, version, mode, path + ["logarithmic"])
                            self.percentage = self.__class__.percentage(service, version, mode, path + ["percentage"])
                            self.variable_cubed = self.__class__.variable_cubed(service, version, mode, path + ["variable_cubed"])
                            self.weighting = self.__class__.weighting(service, version, mode, path + ["weighting"])
                            super().__init__(service, version, mode, path)
                        class auto_range(TUIMethod):
                            """
                            .
                            """
                        class correlation(TUIMethod):
                            """
                            .
                            """
                        class cumulation_curve(TUIMethod):
                            """
                            .
                            """
                        class diameter_statistics(TUIMethod):
                            """
                            .
                            """
                        class histogram_mode(TUIMethod):
                            """
                            .
                            """
                        class logarithmic(TUIMethod):
                            """
                            .
                            """
                        class percentage(TUIMethod):
                            """
                            .
                            """
                        class variable_cubed(TUIMethod):
                            """
                            .
                            """
                        class weighting(TUIMethod):
                            """
                            .
                            """

                    class histogram_parameters(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.maximum_val = self.__class__.maximum_val(service, version, mode, path + ["maximum_val"])
                            self.minimum_val = self.__class__.minimum_val(service, version, mode, path + ["minimum_val"])
                            self.number_of_bins = self.__class__.number_of_bins(service, version, mode, path + ["number_of_bins"])
                            super().__init__(service, version, mode, path)
                        class maximum_val(TUIMethod):
                            """
                            .
                            """
                        class minimum_val(TUIMethod):
                            """
                            .
                            """
                        class number_of_bins(TUIMethod):
                            """
                            .
                            """

                    class plot_write_sample(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.plot_sample = self.__class__.plot_sample(service, version, mode, path + ["plot_sample"])
                            self.write_sample = self.__class__.write_sample(service, version, mode, path + ["write_sample"])
                            super().__init__(service, version, mode, path)
                        class plot_sample(TUIMethod):
                            """
                            .
                            """
                        class write_sample(TUIMethod):
                            """
                            .
                            """

                    class reduction(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.setup_reduction = self.__class__.setup_reduction(service, version, mode, path + ["setup_reduction"])
                            self.pick_sample_to_reduce = self.__class__.pick_sample_to_reduce(service, version, mode, path + ["pick_sample_to_reduce"])
                            self.reduce_picked_sample = self.__class__.reduce_picked_sample(service, version, mode, path + ["reduce_picked_sample"])
                            super().__init__(service, version, mode, path)
                        class pick_sample_to_reduce(TUIMethod):
                            """
                            .
                            """
                        class reduce_picked_sample(TUIMethod):
                            """
                            .
                            """

                        class setup_reduction(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.all_variables_number_of_bins = self.__class__.all_variables_number_of_bins(service, version, mode, path + ["all_variables_number_of_bins"])
                                self.list_settings = self.__class__.list_settings(service, version, mode, path + ["list_settings"])
                                self.make_steady_from_unsteady_file = self.__class__.make_steady_from_unsteady_file(service, version, mode, path + ["make_steady_from_unsteady_file"])
                                self.number_of_bins = self.__class__.number_of_bins(service, version, mode, path + ["number_of_bins"])
                                self.reset_min_and_max = self.__class__.reset_min_and_max(service, version, mode, path + ["reset_min_and_max"])
                                self.set_maximum = self.__class__.set_maximum(service, version, mode, path + ["set_maximum"])
                                self.set_minimum = self.__class__.set_minimum(service, version, mode, path + ["set_minimum"])
                                self.use_logarithmic = self.__class__.use_logarithmic(service, version, mode, path + ["use_logarithmic"])
                                self.use_weighting = self.__class__.use_weighting(service, version, mode, path + ["use_weighting"])
                                self.weighting_variable = self.__class__.weighting_variable(service, version, mode, path + ["weighting_variable"])
                                super().__init__(service, version, mode, path)
                            class all_variables_number_of_bins(TUIMethod):
                                """
                                .
                                """
                            class list_settings(TUIMethod):
                                """
                                .
                                """
                            class make_steady_from_unsteady_file(TUIMethod):
                                """
                                .
                                """
                            class number_of_bins(TUIMethod):
                                """
                                .
                                """
                            class reset_min_and_max(TUIMethod):
                                """
                                .
                                """
                            class set_maximum(TUIMethod):
                                """
                                .
                                """
                            class set_minimum(TUIMethod):
                                """
                                .
                                """
                            class use_logarithmic(TUIMethod):
                                """
                                .
                                """
                            class use_weighting(TUIMethod):
                                """
                                .
                                """
                            class weighting_variable(TUIMethod):
                                """
                                .
                                """

                class sample_trajectories(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.compute = self.__class__.compute(service, version, mode, path + ["compute"])
                        self.sort_sample_files = self.__class__.sort_sample_files(service, version, mode, path + ["sort_sample_files"])
                        self.start_file_write = self.__class__.start_file_write(service, version, mode, path + ["start_file_write"])
                        self.stop_file_write = self.__class__.stop_file_write(service, version, mode, path + ["stop_file_write"])
                        self.user_defined_functions = self.__class__.user_defined_functions(service, version, mode, path + ["user_defined_functions"])
                        super().__init__(service, version, mode, path)
                    class compute(TUIMethod):
                        """
                        .
                        """
                    class sort_sample_files(TUIMethod):
                        """
                        .
                        """
                    class start_file_write(TUIMethod):
                        """
                        .
                        """
                    class stop_file_write(TUIMethod):
                        """
                        .
                        """
                    class user_defined_functions(TUIMethod):
                        """
                        .
                        """

            class flow(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.element_mass_flow = self.__class__.element_mass_flow(service, version, mode, path + ["element_mass_flow"])
                    self.species_mass_flow = self.__class__.species_mass_flow(service, version, mode, path + ["species_mass_flow"])
                    self.uds_flow = self.__class__.uds_flow(service, version, mode, path + ["uds_flow"])
                    super().__init__(service, version, mode, path)
                class element_mass_flow(TUIMethod):
                    """
                    .
                    """
                class species_mass_flow(TUIMethod):
                    """
                    .
                    """
                class uds_flow(TUIMethod):
                    """
                    .
                    """

            class fluxes(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.electric_current = self.__class__.electric_current(service, version, mode, path + ["electric_current"])
                    self.film_heat_transfer = self.__class__.film_heat_transfer(service, version, mode, path + ["film_heat_transfer"])
                    self.film_mass_flow = self.__class__.film_mass_flow(service, version, mode, path + ["film_mass_flow"])
                    self.heat_transfer = self.__class__.heat_transfer(service, version, mode, path + ["heat_transfer"])
                    self.heat_transfer_sensible = self.__class__.heat_transfer_sensible(service, version, mode, path + ["heat_transfer_sensible"])
                    self.mass_flow = self.__class__.mass_flow(service, version, mode, path + ["mass_flow"])
                    self.pressure_work = self.__class__.pressure_work(service, version, mode, path + ["pressure_work"])
                    self.radiation_heat_transfer = self.__class__.radiation_heat_transfer(service, version, mode, path + ["radiation_heat_transfer"])
                    self.viscous_work = self.__class__.viscous_work(service, version, mode, path + ["viscous_work"])
                    super().__init__(service, version, mode, path)
                class electric_current(TUIMethod):
                    """
                    .
                    """
                class film_heat_transfer(TUIMethod):
                    """
                    .
                    """
                class film_mass_flow(TUIMethod):
                    """
                    .
                    """
                class heat_transfer(TUIMethod):
                    """
                    .
                    """
                class heat_transfer_sensible(TUIMethod):
                    """
                    .
                    """
                class mass_flow(TUIMethod):
                    """
                    .
                    """
                class pressure_work(TUIMethod):
                    """
                    .
                    """
                class radiation_heat_transfer(TUIMethod):
                    """
                    .
                    """
                class viscous_work(TUIMethod):
                    """
                    .
                    """

            class heat_exchanger(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.computed_heat_rejection = self.__class__.computed_heat_rejection(service, version, mode, path + ["computed_heat_rejection"])
                    self.inlet_temperature = self.__class__.inlet_temperature(service, version, mode, path + ["inlet_temperature"])
                    self.mass_flow_rate = self.__class__.mass_flow_rate(service, version, mode, path + ["mass_flow_rate"])
                    self.outlet_temperature = self.__class__.outlet_temperature(service, version, mode, path + ["outlet_temperature"])
                    self.specific_heat = self.__class__.specific_heat(service, version, mode, path + ["specific_heat"])
                    super().__init__(service, version, mode, path)
                class computed_heat_rejection(TUIMethod):
                    """
                    .
                    """
                class inlet_temperature(TUIMethod):
                    """
                    .
                    """
                class mass_flow_rate(TUIMethod):
                    """
                    .
                    """
                class outlet_temperature(TUIMethod):
                    """
                    .
                    """
                class specific_heat(TUIMethod):
                    """
                    .
                    """

            class modified_setting_options(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.modified_setting = self.__class__.modified_setting(service, version, mode, path + ["modified_setting"])
                    self.write_user_setting = self.__class__.write_user_setting(service, version, mode, path + ["write_user_setting"])
                    super().__init__(service, version, mode, path)
                class modified_setting(TUIMethod):
                    """
                    .
                    """
                class write_user_setting(TUIMethod):
                    """
                    .
                    """

            class population_balance(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.moments = self.__class__.moments(service, version, mode, path + ["moments"])
                    self.number_density = self.__class__.number_density(service, version, mode, path + ["number_density"])
                    super().__init__(service, version, mode, path)
                class moments(TUIMethod):
                    """
                    .
                    """
                class number_density(TUIMethod):
                    """
                    .
                    """

            class simulation_reports(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.add_histogram_to_report = self.__class__.add_histogram_to_report(service, version, mode, path + ["add_histogram_to_report"])
                    self.delete_simulation_report = self.__class__.delete_simulation_report(service, version, mode, path + ["delete_simulation_report"])
                    self.duplicate_simulation_report = self.__class__.duplicate_simulation_report(service, version, mode, path + ["duplicate_simulation_report"])
                    self.export_simulation_report_as_html = self.__class__.export_simulation_report_as_html(service, version, mode, path + ["export_simulation_report_as_html"])
                    self.export_simulation_report_as_pdf = self.__class__.export_simulation_report_as_pdf(service, version, mode, path + ["export_simulation_report_as_pdf"])
                    self.export_simulation_report_as_pptx = self.__class__.export_simulation_report_as_pptx(service, version, mode, path + ["export_simulation_report_as_pptx"])
                    self.generate_simulation_report = self.__class__.generate_simulation_report(service, version, mode, path + ["generate_simulation_report"])
                    self.list_simulation_reports = self.__class__.list_simulation_reports(service, version, mode, path + ["list_simulation_reports"])
                    self.read_simulation_report_template_file = self.__class__.read_simulation_report_template_file(service, version, mode, path + ["read_simulation_report_template_file"])
                    self.rename_simulation_report = self.__class__.rename_simulation_report(service, version, mode, path + ["rename_simulation_report"])
                    self.reset_report_to_defaults = self.__class__.reset_report_to_defaults(service, version, mode, path + ["reset_report_to_defaults"])
                    self.view_simulation_report = self.__class__.view_simulation_report(service, version, mode, path + ["view_simulation_report"])
                    self.write_simulation_report_names_to_file = self.__class__.write_simulation_report_names_to_file(service, version, mode, path + ["write_simulation_report_names_to_file"])
                    self.write_simulation_report_template_file = self.__class__.write_simulation_report_template_file(service, version, mode, path + ["write_simulation_report_template_file"])
                    super().__init__(service, version, mode, path)
                class add_histogram_to_report(TUIMethod):
                    """
                    .
                    """
                class delete_simulation_report(TUIMethod):
                    """
                    .
                    """
                class duplicate_simulation_report(TUIMethod):
                    """
                    .
                    """
                class export_simulation_report_as_html(TUIMethod):
                    """
                    .
                    """
                class export_simulation_report_as_pdf(TUIMethod):
                    """
                    .
                    """
                class export_simulation_report_as_pptx(TUIMethod):
                    """
                    .
                    """
                class generate_simulation_report(TUIMethod):
                    """
                    .
                    """
                class list_simulation_reports(TUIMethod):
                    """
                    .
                    """
                class read_simulation_report_template_file(TUIMethod):
                    """
                    .
                    """
                class rename_simulation_report(TUIMethod):
                    """
                    .
                    """
                class reset_report_to_defaults(TUIMethod):
                    """
                    .
                    """
                class view_simulation_report(TUIMethod):
                    """
                    .
                    """
                class write_simulation_report_names_to_file(TUIMethod):
                    """
                    .
                    """
                class write_simulation_report_template_file(TUIMethod):
                    """
                    .
                    """

            class surface_integrals(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.area = self.__class__.area(service, version, mode, path + ["area"])
                    self.area_weighted_avg = self.__class__.area_weighted_avg(service, version, mode, path + ["area_weighted_avg"])
                    self.facet_avg = self.__class__.facet_avg(service, version, mode, path + ["facet_avg"])
                    self.facet_max = self.__class__.facet_max(service, version, mode, path + ["facet_max"])
                    self.facet_min = self.__class__.facet_min(service, version, mode, path + ["facet_min"])
                    self.flow_rate = self.__class__.flow_rate(service, version, mode, path + ["flow_rate"])
                    self.integral = self.__class__.integral(service, version, mode, path + ["integral"])
                    self.mass_flow_rate = self.__class__.mass_flow_rate(service, version, mode, path + ["mass_flow_rate"])
                    self.mass_weighted_avg = self.__class__.mass_weighted_avg(service, version, mode, path + ["mass_weighted_avg"])
                    self.standard_deviation = self.__class__.standard_deviation(service, version, mode, path + ["standard_deviation"])
                    self.sum = self.__class__.sum(service, version, mode, path + ["sum"])
                    self.uniformity_index_area_weighted = self.__class__.uniformity_index_area_weighted(service, version, mode, path + ["uniformity_index_area_weighted"])
                    self.uniformity_index_mass_weighted = self.__class__.uniformity_index_mass_weighted(service, version, mode, path + ["uniformity_index_mass_weighted"])
                    self.vector_based_flux = self.__class__.vector_based_flux(service, version, mode, path + ["vector_based_flux"])
                    self.vector_flux = self.__class__.vector_flux(service, version, mode, path + ["vector_flux"])
                    self.vector_weighted_average = self.__class__.vector_weighted_average(service, version, mode, path + ["vector_weighted_average"])
                    self.vertex_avg = self.__class__.vertex_avg(service, version, mode, path + ["vertex_avg"])
                    self.vertex_max = self.__class__.vertex_max(service, version, mode, path + ["vertex_max"])
                    self.vertex_min = self.__class__.vertex_min(service, version, mode, path + ["vertex_min"])
                    self.volume_flow_rate = self.__class__.volume_flow_rate(service, version, mode, path + ["volume_flow_rate"])
                    super().__init__(service, version, mode, path)
                class area(TUIMethod):
                    """
                    .
                    """
                class area_weighted_avg(TUIMethod):
                    """
                    .
                    """
                class facet_avg(TUIMethod):
                    """
                    .
                    """
                class facet_max(TUIMethod):
                    """
                    .
                    """
                class facet_min(TUIMethod):
                    """
                    .
                    """
                class flow_rate(TUIMethod):
                    """
                    .
                    """
                class integral(TUIMethod):
                    """
                    .
                    """
                class mass_flow_rate(TUIMethod):
                    """
                    .
                    """
                class mass_weighted_avg(TUIMethod):
                    """
                    .
                    """
                class standard_deviation(TUIMethod):
                    """
                    .
                    """
                class sum(TUIMethod):
                    """
                    .
                    """
                class uniformity_index_area_weighted(TUIMethod):
                    """
                    .
                    """
                class uniformity_index_mass_weighted(TUIMethod):
                    """
                    .
                    """
                class vector_based_flux(TUIMethod):
                    """
                    .
                    """
                class vector_flux(TUIMethod):
                    """
                    .
                    """
                class vector_weighted_average(TUIMethod):
                    """
                    .
                    """
                class vertex_avg(TUIMethod):
                    """
                    .
                    """
                class vertex_max(TUIMethod):
                    """
                    .
                    """
                class vertex_min(TUIMethod):
                    """
                    .
                    """
                class volume_flow_rate(TUIMethod):
                    """
                    .
                    """

            class system(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.print_gpgpu_statistics = self.__class__.print_gpgpu_statistics(service, version, mode, path + ["print_gpgpu_statistics"])
                    self.print_process_statistics = self.__class__.print_process_statistics(service, version, mode, path + ["print_process_statistics"])
                    self.print_system_statistics = self.__class__.print_system_statistics(service, version, mode, path + ["print_system_statistics"])
                    self.print_time_statistics = self.__class__.print_time_statistics(service, version, mode, path + ["print_time_statistics"])
                    super().__init__(service, version, mode, path)
                class print_gpgpu_statistics(TUIMethod):
                    """
                    .
                    """
                class print_process_statistics(TUIMethod):
                    """
                    .
                    """
                class print_system_statistics(TUIMethod):
                    """
                    .
                    """
                class print_time_statistics(TUIMethod):
                    """
                    .
                    """

            class volume_integrals(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.mass = self.__class__.mass(service, version, mode, path + ["mass"])
                    self.mass_average = self.__class__.mass_average(service, version, mode, path + ["mass_average"])
                    self.mass_integral = self.__class__.mass_integral(service, version, mode, path + ["mass_integral"])
                    self.maximum = self.__class__.maximum(service, version, mode, path + ["maximum"])
                    self.minimum = self.__class__.minimum(service, version, mode, path + ["minimum"])
                    self.sum = self.__class__.sum(service, version, mode, path + ["sum"])
                    self.twopisum = self.__class__.twopisum(service, version, mode, path + ["twopisum"])
                    self.volume = self.__class__.volume(service, version, mode, path + ["volume"])
                    self.volume_average = self.__class__.volume_average(service, version, mode, path + ["volume_average"])
                    self.volume_integral = self.__class__.volume_integral(service, version, mode, path + ["volume_integral"])
                    super().__init__(service, version, mode, path)
                class mass(TUIMethod):
                    """
                    .
                    """
                class mass_average(TUIMethod):
                    """
                    .
                    """
                class mass_integral(TUIMethod):
                    """
                    .
                    """
                class maximum(TUIMethod):
                    """
                    .
                    """
                class minimum(TUIMethod):
                    """
                    .
                    """
                class sum(TUIMethod):
                    """
                    .
                    """
                class twopisum(TUIMethod):
                    """
                    .
                    """
                class volume(TUIMethod):
                    """
                    .
                    """
                class volume_average(TUIMethod):
                    """
                    .
                    """
                class volume_integral(TUIMethod):
                    """
                    .
                    """

        class scene(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.add_to_graphics = self.__class__.add_to_graphics(service, version, mode, path + ["add_to_graphics"])
                self.clear_history = self.__class__.clear_history(service, version, mode, path + ["clear_history"])
                self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                super().__init__(service, version, mode, path)
            class add_to_graphics(TUIMethod):
                """
                .
                """
            class clear_history(TUIMethod):
                """
                .
                """
            class copy(TUIMethod):
                """
                .
                """
            class create(TUIMethod):
                """
                Create a new scene object.
                """
            class delete(TUIMethod):
                """
                .
                """
            class display(TUIMethod):
                """
                .
                """
            class edit(TUIMethod):
                """
                Edit scene object.
                """
            class list(TUIMethod):
                """
                .
                """
            class list_properties(TUIMethod):
                """
                .
                """
            class make_a_copy(TUIMethod):
                """
                .
                """
            class rename(TUIMethod):
                """
                Rename scene object.
                """

        class surfaces(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.imprint_surface = self.__class__.imprint_surface(service, version, mode, path + ["imprint_surface"])
                self.iso_clip = self.__class__.iso_clip(service, version, mode, path + ["iso_clip"])
                self.iso_surface = self.__class__.iso_surface(service, version, mode, path + ["iso_surface"])
                self.line_surface = self.__class__.line_surface(service, version, mode, path + ["line_surface"])
                self.partition_surface = self.__class__.partition_surface(service, version, mode, path + ["partition_surface"])
                self.plane_slice = self.__class__.plane_slice(service, version, mode, path + ["plane_slice"])
                self.plane_surface = self.__class__.plane_surface(service, version, mode, path + ["plane_surface"])
                self.point_surface = self.__class__.point_surface(service, version, mode, path + ["point_surface"])
                self.quadric_surface = self.__class__.quadric_surface(service, version, mode, path + ["quadric_surface"])
                self.rake_surface = self.__class__.rake_surface(service, version, mode, path + ["rake_surface"])
                self.sphere_slice = self.__class__.sphere_slice(service, version, mode, path + ["sphere_slice"])
                self.surface_cells = self.__class__.surface_cells(service, version, mode, path + ["surface_cells"])
                self.transform_surface = self.__class__.transform_surface(service, version, mode, path + ["transform_surface"])
                self.zone_surface = self.__class__.zone_surface(service, version, mode, path + ["zone_surface"])
                self.create_group_surfaces = self.__class__.create_group_surfaces(service, version, mode, path + ["create_group_surfaces"])
                self.create_multiple_iso_surfaces = self.__class__.create_multiple_iso_surfaces(service, version, mode, path + ["create_multiple_iso_surfaces"])
                self.create_multiple_zone_surfaces = self.__class__.create_multiple_zone_surfaces(service, version, mode, path + ["create_multiple_zone_surfaces"])
                self.reset_zone_surfaces = self.__class__.reset_zone_surfaces(service, version, mode, path + ["reset_zone_surfaces"])
                self.set_rendering_priority = self.__class__.set_rendering_priority(service, version, mode, path + ["set_rendering_priority"])
                self.ungroup_surfaces = self.__class__.ungroup_surfaces(service, version, mode, path + ["ungroup_surfaces"])
                super().__init__(service, version, mode, path)
            class create_group_surfaces(TUIMethod):
                """
                .
                """
            class create_multiple_iso_surfaces(TUIMethod):
                """
                .
                """
            class create_multiple_zone_surfaces(TUIMethod):
                """
                .
                """
            class reset_zone_surfaces(TUIMethod):
                """
                .
                """
            class set_rendering_priority(TUIMethod):
                """
                .
                """
            class ungroup_surfaces(TUIMethod):
                """
                .
                """

            class imprint_surface(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new imprint-surface object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit imprint-surface object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename imprint-surface object.
                    """

            class iso_clip(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new iso-clip object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit iso-clip object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename iso-clip object.
                    """

            class iso_surface(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new iso-surface object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit iso-surface object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename iso-surface object.
                    """

            class line_surface(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new line-surface object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit line-surface object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename line-surface object.
                    """

            class partition_surface(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new partition-surface object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit partition-surface object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename partition-surface object.
                    """

            class plane_slice(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new plane-slice object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit plane-slice object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename plane-slice object.
                    """

            class plane_surface(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new plane-surface object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit plane-surface object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename plane-surface object.
                    """

            class point_surface(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new point-surface object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit point-surface object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename point-surface object.
                    """

            class quadric_surface(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new quadric-surface object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit quadric-surface object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename quadric-surface object.
                    """

            class rake_surface(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new rake-surface object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit rake-surface object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename rake-surface object.
                    """

            class sphere_slice(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new sphere-slice object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit sphere-slice object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename sphere-slice object.
                    """

            class surface_cells(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new surface-cells object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit surface-cells object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename surface-cells object.
                    """

            class transform_surface(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new transform-surface object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit transform-surface object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename transform-surface object.
                    """

            class zone_surface(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new zone-surface object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit zone-surface object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename zone-surface object.
                    """

    class server(TUIMenu):
        """
        Enter the server menu.
        """
        def __init__(self, service, version, mode, path):
            self.print_connected_clients = self.__class__.print_connected_clients(service, version, mode, path + ["print_connected_clients"])
            self.print_server_address = self.__class__.print_server_address(service, version, mode, path + ["print_server_address"])
            self.print_web_server_info = self.__class__.print_web_server_info(service, version, mode, path + ["print_web_server_info"])
            self.shutdown_server = self.__class__.shutdown_server(service, version, mode, path + ["shutdown_server"])
            self.start_client = self.__class__.start_client(service, version, mode, path + ["start_client"])
            self.start_server = self.__class__.start_server(service, version, mode, path + ["start_server"])
            self.start_web_server = self.__class__.start_web_server(service, version, mode, path + ["start_web_server"])
            self.stop_web_server = self.__class__.stop_web_server(service, version, mode, path + ["stop_web_server"])
            self.write_or_reset_server_info = self.__class__.write_or_reset_server_info(service, version, mode, path + ["write_or_reset_server_info"])
            super().__init__(service, version, mode, path)
        class print_connected_clients(TUIMethod):
            """
            Prints the name of the connected client and its IP address to the console.
            """
        class print_server_address(TUIMethod):
            """
            Prints the host address and port number of the server to the console.
            """
        class print_web_server_info(TUIMethod):
            """
            .
            """
        class shutdown_server(TUIMethod):
            """
            Shuts-down the server and disconnects the connected client.
            """
        class start_client(TUIMethod):
            """
            Start the ANSYS Fluent remote visualization client.
            """
        class start_server(TUIMethod):
            """
            Starts the server for the ANSYS Fluent remote visualization client.
            """
        class start_web_server(TUIMethod):
            """
            .
            """
        class stop_web_server(TUIMethod):
            """
            .
            """
        class write_or_reset_server_info(TUIMethod):
            """
            Allows you to create a new server_info.txt file (with any name you specify), which resets the password for connecting to this server session. It does not restart the server.
            """

    class setup(TUIMenu):
        """
        Enter setup menu.
        """
        def __init__(self, service, version, mode, path):
            self.boundary_conditions = self.__class__.boundary_conditions(service, version, mode, path + ["boundary_conditions"])
            super().__init__(service, version, mode, path)

        class boundary_conditions(TUIMenu):
            """
            Enter the boudary conditions menu.
            """
            def __init__(self, service, version, mode, path):
                self.query = self.__class__.query(service, version, mode, path + ["query"])
                self.axis = self.__class__.axis(service, version, mode, path + ["axis"])
                self.degassing = self.__class__.degassing(service, version, mode, path + ["degassing"])
                self.exhaust_fan = self.__class__.exhaust_fan(service, version, mode, path + ["exhaust_fan"])
                self.fan = self.__class__.fan(service, version, mode, path + ["fan"])
                self.fluid = self.__class__.fluid(service, version, mode, path + ["fluid"])
                self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
                self.inlet_vent = self.__class__.inlet_vent(service, version, mode, path + ["inlet_vent"])
                self.intake_fan = self.__class__.intake_fan(service, version, mode, path + ["intake_fan"])
                self.interface = self.__class__.interface(service, version, mode, path + ["interface"])
                self.interior = self.__class__.interior(service, version, mode, path + ["interior"])
                self.mass_flow_inlet = self.__class__.mass_flow_inlet(service, version, mode, path + ["mass_flow_inlet"])
                self.mass_flow_outlet = self.__class__.mass_flow_outlet(service, version, mode, path + ["mass_flow_outlet"])
                self.network = self.__class__.network(service, version, mode, path + ["network"])
                self.network_end = self.__class__.network_end(service, version, mode, path + ["network_end"])
                self.outflow = self.__class__.outflow(service, version, mode, path + ["outflow"])
                self.outlet_vent = self.__class__.outlet_vent(service, version, mode, path + ["outlet_vent"])
                self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                self.periodic = self.__class__.periodic(service, version, mode, path + ["periodic"])
                self.porous_jump = self.__class__.porous_jump(service, version, mode, path + ["porous_jump"])
                self.pressure_far_field = self.__class__.pressure_far_field(service, version, mode, path + ["pressure_far_field"])
                self.pressure_inlet = self.__class__.pressure_inlet(service, version, mode, path + ["pressure_inlet"])
                self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                self.radiator = self.__class__.radiator(service, version, mode, path + ["radiator"])
                self.rans_les_interface = self.__class__.rans_les_interface(service, version, mode, path + ["rans_les_interface"])
                self.recirculation_inlet = self.__class__.recirculation_inlet(service, version, mode, path + ["recirculation_inlet"])
                self.recirculation_outlet = self.__class__.recirculation_outlet(service, version, mode, path + ["recirculation_outlet"])
                self.shadow = self.__class__.shadow(service, version, mode, path + ["shadow"])
                self.solid = self.__class__.solid(service, version, mode, path + ["solid"])
                self.symmetry = self.__class__.symmetry(service, version, mode, path + ["symmetry"])
                self.velocity_inlet = self.__class__.velocity_inlet(service, version, mode, path + ["velocity_inlet"])
                self.wall = self.__class__.wall(service, version, mode, path + ["wall"])
                super().__init__(service, version, mode, path)
            class axis(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class degassing(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class exhaust_fan(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class fan(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class fluid(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class geometry(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class inlet_vent(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class intake_fan(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class interface(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class interior(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class mass_flow_inlet(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class mass_flow_outlet(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class network(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class network_end(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class outflow(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class outlet_vent(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class overset(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class periodic(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class porous_jump(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class pressure_far_field(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class pressure_inlet(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class pressure_outlet(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class radiator(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class rans_les_interface(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class recirculation_inlet(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class recirculation_outlet(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class shadow(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class solid(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class symmetry(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class velocity_inlet(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class wall(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """

            class query(TUIMenu):
                """
                Enter zone query menu.
                """
                def __init__(self, service, version, mode, path):
                    self.axis = self.__class__.axis(service, version, mode, path + ["axis"])
                    self.degassing = self.__class__.degassing(service, version, mode, path + ["degassing"])
                    self.delete_query = self.__class__.delete_query(service, version, mode, path + ["delete_query"])
                    self.exhaust_fan = self.__class__.exhaust_fan(service, version, mode, path + ["exhaust_fan"])
                    self.fan = self.__class__.fan(service, version, mode, path + ["fan"])
                    self.fluid = self.__class__.fluid(service, version, mode, path + ["fluid"])
                    self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
                    self.inlet_vent = self.__class__.inlet_vent(service, version, mode, path + ["inlet_vent"])
                    self.intake_fan = self.__class__.intake_fan(service, version, mode, path + ["intake_fan"])
                    self.interface = self.__class__.interface(service, version, mode, path + ["interface"])
                    self.interior = self.__class__.interior(service, version, mode, path + ["interior"])
                    self.list_boundary_conditions = self.__class__.list_boundary_conditions(service, version, mode, path + ["list_boundary_conditions"])
                    self.list_cell_zone_conditions = self.__class__.list_cell_zone_conditions(service, version, mode, path + ["list_cell_zone_conditions"])
                    self.list_named_selection = self.__class__.list_named_selection(service, version, mode, path + ["list_named_selection"])
                    self.list_queries = self.__class__.list_queries(service, version, mode, path + ["list_queries"])
                    self.mass_flow_inlet = self.__class__.mass_flow_inlet(service, version, mode, path + ["mass_flow_inlet"])
                    self.mass_flow_outlet = self.__class__.mass_flow_outlet(service, version, mode, path + ["mass_flow_outlet"])
                    self.named_zone_list = self.__class__.named_zone_list(service, version, mode, path + ["named_zone_list"])
                    self.network = self.__class__.network(service, version, mode, path + ["network"])
                    self.network_end = self.__class__.network_end(service, version, mode, path + ["network_end"])
                    self.outflow = self.__class__.outflow(service, version, mode, path + ["outflow"])
                    self.outlet_vent = self.__class__.outlet_vent(service, version, mode, path + ["outlet_vent"])
                    self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                    self.periodic = self.__class__.periodic(service, version, mode, path + ["periodic"])
                    self.porous_jump = self.__class__.porous_jump(service, version, mode, path + ["porous_jump"])
                    self.pressure_far_field = self.__class__.pressure_far_field(service, version, mode, path + ["pressure_far_field"])
                    self.pressure_inlet = self.__class__.pressure_inlet(service, version, mode, path + ["pressure_inlet"])
                    self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                    self.radiator = self.__class__.radiator(service, version, mode, path + ["radiator"])
                    self.rans_les_interface = self.__class__.rans_les_interface(service, version, mode, path + ["rans_les_interface"])
                    self.recirculation_inlet = self.__class__.recirculation_inlet(service, version, mode, path + ["recirculation_inlet"])
                    self.recirculation_outlet = self.__class__.recirculation_outlet(service, version, mode, path + ["recirculation_outlet"])
                    self.shadow = self.__class__.shadow(service, version, mode, path + ["shadow"])
                    self.solid = self.__class__.solid(service, version, mode, path + ["solid"])
                    self.symmetry = self.__class__.symmetry(service, version, mode, path + ["symmetry"])
                    self.velocity_inlet = self.__class__.velocity_inlet(service, version, mode, path + ["velocity_inlet"])
                    self.wall = self.__class__.wall(service, version, mode, path + ["wall"])
                    super().__init__(service, version, mode, path)
                class axis(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class degassing(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class delete_query(TUIMethod):
                    """
                    Delete saved query.
                    """
                class exhaust_fan(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class fan(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class fluid(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class geometry(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class inlet_vent(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class intake_fan(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class interface(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class interior(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class list_boundary_conditions(TUIMethod):
                    """
                    List boundary conditions.
                    """
                class list_cell_zone_conditions(TUIMethod):
                    """
                    List cell zone conditions.
                    """
                class list_named_selection(TUIMethod):
                    """
                    List named selection of zone type.
                    """
                class list_queries(TUIMethod):
                    """
                    List all saved queries.
                    """
                class mass_flow_inlet(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class mass_flow_outlet(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class named_zone_list(TUIMethod):
                    """
                    Create named list of zones.
                    """
                class network(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class network_end(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class outflow(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class outlet_vent(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class overset(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class periodic(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class porous_jump(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class pressure_far_field(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class pressure_inlet(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class pressure_outlet(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class radiator(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class rans_les_interface(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class recirculation_inlet(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class recirculation_outlet(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class shadow(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class solid(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class symmetry(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class velocity_inlet(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class wall(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """

    class solution(TUIMenu):
        """
        .
        """
        def __init__(self, service, version, mode, path):
            self.calculation_activity = self.__class__.calculation_activity(service, version, mode, path + ["calculation_activity"])
            self.cell_registers = self.__class__.cell_registers(service, version, mode, path + ["cell_registers"])
            self.controls = self.__class__.controls(service, version, mode, path + ["controls"])
            self.initialization = self.__class__.initialization(service, version, mode, path + ["initialization"])
            self.methods = self.__class__.methods(service, version, mode, path + ["methods"])
            self.monitor = self.__class__.monitor(service, version, mode, path + ["monitor"])
            self.report_definitions = self.__class__.report_definitions(service, version, mode, path + ["report_definitions"])
            self.run_calculation = self.__class__.run_calculation(service, version, mode, path + ["run_calculation"])
            super().__init__(service, version, mode, path)

        class calculation_activity(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.case_modification = self.__class__.case_modification(service, version, mode, path + ["case_modification"])
                self.execute_commands = self.__class__.execute_commands(service, version, mode, path + ["execute_commands"])
                self.poor_mesh_numerics = self.__class__.poor_mesh_numerics(service, version, mode, path + ["poor_mesh_numerics"])
                self.solution_animations = self.__class__.solution_animations(service, version, mode, path + ["solution_animations"])
                super().__init__(service, version, mode, path)

            class case_modification(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.case_modification = self.__class__.case_modification(service, version, mode, path + ["case_modification"])
                    self.initialization_method = self.__class__.initialization_method(service, version, mode, path + ["initialization_method"])
                    self.automatic_initialization = self.__class__.automatic_initialization(service, version, mode, path + ["automatic_initialization"])
                    self.continue_strategy_execution = self.__class__.continue_strategy_execution(service, version, mode, path + ["continue_strategy_execution"])
                    self.copy_modification = self.__class__.copy_modification(service, version, mode, path + ["copy_modification"])
                    self.delete_modification = self.__class__.delete_modification(service, version, mode, path + ["delete_modification"])
                    self.disable_modification = self.__class__.disable_modification(service, version, mode, path + ["disable_modification"])
                    self.enable_modification = self.__class__.enable_modification(service, version, mode, path + ["enable_modification"])
                    self.enable_strategy = self.__class__.enable_strategy(service, version, mode, path + ["enable_strategy"])
                    self.enabled = self.__class__.enabled(service, version, mode, path + ["enabled"])
                    self.execute_strategy = self.__class__.execute_strategy(service, version, mode, path + ["execute_strategy"])
                    self.export_modifications = self.__class__.export_modifications(service, version, mode, path + ["export_modifications"])
                    self.import_modifications = self.__class__.import_modifications(service, version, mode, path + ["import_modifications"])
                    super().__init__(service, version, mode, path)
                class automatic_initialization(TUIMethod):
                    """
                    .
                    """
                class continue_strategy_execution(TUIMethod):
                    """
                    .
                    """
                class copy_modification(TUIMethod):
                    """
                    .
                    """
                class delete_modification(TUIMethod):
                    """
                    .
                    """
                class disable_modification(TUIMethod):
                    """
                    .
                    """
                class enable_modification(TUIMethod):
                    """
                    .
                    """
                class enable_strategy(TUIMethod):
                    """
                    .
                    """
                class enabled(TUIMethod):
                    """
                    .
                    """
                class execute_strategy(TUIMethod):
                    """
                    .
                    """
                class export_modifications(TUIMethod):
                    """
                    .
                    """
                class import_modifications(TUIMethod):
                    """
                    .
                    """

                class case_modification(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.before_init_modification = self.__class__.before_init_modification(service, version, mode, path + ["before_init_modification"])
                        self.modifications = self.__class__.modifications(service, version, mode, path + ["modifications"])
                        self.original_settings = self.__class__.original_settings(service, version, mode, path + ["original_settings"])
                        super().__init__(service, version, mode, path)

                    class before_init_modification(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.active = self.__class__.active(service, version, mode, path + ["active"])
                            self.command = self.__class__.command(service, version, mode, path + ["command"])
                            self.count = self.__class__.count(service, version, mode, path + ["count"])
                            self.flowtime = self.__class__.flowtime(service, version, mode, path + ["flowtime"])
                            self.ftselected = self.__class__.ftselected(service, version, mode, path + ["ftselected"])
                            self.name = self.__class__.name(service, version, mode, path + ["name"])
                            self.python_cmd = self.__class__.python_cmd(service, version, mode, path + ["python_cmd"])
                            super().__init__(service, version, mode, path)
                        class active(TUIMethod):
                            """
                            .
                            """
                        class command(TUIMethod):
                            """
                            .
                            """
                        class count(TUIMethod):
                            """
                            .
                            """
                        class flowtime(TUIMethod):
                            """
                            .
                            """
                        class ftselected(TUIMethod):
                            """
                            .
                            """
                        class name(TUIMethod):
                            """
                            .
                            """
                        class python_cmd(TUIMethod):
                            """
                            .
                            """

                    class modifications(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                            self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                            self.number_of_objects = self.__class__.number_of_objects(service, version, mode, path + ["number_of_objects"])
                            super().__init__(service, version, mode, path)
                        class edit(TUIMethod):
                            """
                            Edit modifications object.
                            """
                        class list_properties(TUIMethod):
                            """
                            .
                            """
                        class number_of_objects(TUIMethod):
                            """
                            Set number of objects for modifications.
                            """

                    class original_settings(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.active = self.__class__.active(service, version, mode, path + ["active"])
                            self.command = self.__class__.command(service, version, mode, path + ["command"])
                            self.count = self.__class__.count(service, version, mode, path + ["count"])
                            self.flowtime = self.__class__.flowtime(service, version, mode, path + ["flowtime"])
                            self.ftselected = self.__class__.ftselected(service, version, mode, path + ["ftselected"])
                            self.name = self.__class__.name(service, version, mode, path + ["name"])
                            self.python_cmd = self.__class__.python_cmd(service, version, mode, path + ["python_cmd"])
                            super().__init__(service, version, mode, path)
                        class active(TUIMethod):
                            """
                            .
                            """
                        class command(TUIMethod):
                            """
                            .
                            """
                        class count(TUIMethod):
                            """
                            .
                            """
                        class flowtime(TUIMethod):
                            """
                            .
                            """
                        class ftselected(TUIMethod):
                            """
                            .
                            """
                        class name(TUIMethod):
                            """
                            .
                            """
                        class python_cmd(TUIMethod):
                            """
                            .
                            """

                class initialization_method(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.init_from_solution = self.__class__.init_from_solution(service, version, mode, path + ["init_from_solution"])
                        self.init_from_data_file = self.__class__.init_from_data_file(service, version, mode, path + ["init_from_data_file"])
                        super().__init__(service, version, mode, path)
                    class init_from_data_file(TUIMethod):
                        """
                        .
                        """

                    class init_from_solution(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.init_from_data_file = self.__class__.init_from_data_file(service, version, mode, path + ["init_from_data_file"])
                            self.option = self.__class__.option(service, version, mode, path + ["option"])
                            super().__init__(service, version, mode, path)
                        class init_from_data_file(TUIMethod):
                            """
                            .
                            """
                        class option(TUIMethod):
                            """
                            .
                            """

            class execute_commands(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.disable = self.__class__.disable(service, version, mode, path + ["disable"])
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.export = self.__class__.export(service, version, mode, path + ["export"])
                    self.import_ = self.__class__.import_(service, version, mode, path + ["import"])
                    super().__init__(service, version, mode, path)
                class copy(TUIMethod):
                    """
                    .
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class disable(TUIMethod):
                    """
                    .
                    """
                class enable(TUIMethod):
                    """
                    .
                    """
                class export(TUIMethod):
                    """
                    .
                    """
                class import_(TUIMethod):
                    """
                    .
                    """

            class poor_mesh_numerics(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.register_based = self.__class__.register_based(service, version, mode, path + ["register_based"])
                    super().__init__(service, version, mode, path)

                class register_based(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.create = self.__class__.create(service, version, mode, path + ["create"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                        self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                        self.set = self.__class__.set(service, version, mode, path + ["set"])
                        super().__init__(service, version, mode, path)
                    class create(TUIMethod):
                        """
                        Add a new definition for poor mesh numerics.
                        """
                    class delete(TUIMethod):
                        """
                        .
                        """
                    class edit(TUIMethod):
                        """
                        Edit a definition for poor mesh numerics.
                        """
                    class list(TUIMethod):
                        """
                        .
                        """
                    class list_properties(TUIMethod):
                        """
                        .
                        """
                    class make_a_copy(TUIMethod):
                        """
                        .
                        """
                    class rename(TUIMethod):
                        """
                        Rename register-based object.
                        """
                    class set(TUIMethod):
                        """
                        .
                        """

            class solution_animations(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.add_to_graphics = self.__class__.add_to_graphics(service, version, mode, path + ["add_to_graphics"])
                    self.clear_history = self.__class__.clear_history(service, version, mode, path + ["clear_history"])
                    self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.display = self.__class__.display(service, version, mode, path + ["display"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class add_to_graphics(TUIMethod):
                    """
                    .
                    """
                class clear_history(TUIMethod):
                    """
                    .
                    """
                class copy(TUIMethod):
                    """
                    .
                    """
                class create(TUIMethod):
                    """
                    Create a new solution-animations object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class display(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit solution-animations object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename solution-animations object.
                    """

        class cell_registers(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                super().__init__(service, version, mode, path)
            class create(TUIMethod):
                """
                Create a new cell-registers object.
                """
            class delete(TUIMethod):
                """
                .
                """
            class edit(TUIMethod):
                """
                Edit cell-registers object.
                """
            class list(TUIMethod):
                """
                .
                """
            class list_properties(TUIMethod):
                """
                .
                """
            class make_a_copy(TUIMethod):
                """
                .
                """
            class rename(TUIMethod):
                """
                Rename cell-registers object.
                """

        class controls(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.acoustics_wave_eqn_controls = self.__class__.acoustics_wave_eqn_controls(service, version, mode, path + ["acoustics_wave_eqn_controls"])
                self.advanced = self.__class__.advanced(service, version, mode, path + ["advanced"])
                self.contact_solution_controls = self.__class__.contact_solution_controls(service, version, mode, path + ["contact_solution_controls"])
                self.equations = self.__class__.equations(service, version, mode, path + ["equations"])
                self.limits = self.__class__.limits(service, version, mode, path + ["limits"])
                self.p_v_controls = self.__class__.p_v_controls(service, version, mode, path + ["p_v_controls"])
                self.pseudo_time_explicit_relaxation_factor = self.__class__.pseudo_time_explicit_relaxation_factor(service, version, mode, path + ["pseudo_time_explicit_relaxation_factor"])
                self.pseudo_time_method_local_time_step = self.__class__.pseudo_time_method_local_time_step(service, version, mode, path + ["pseudo_time_method_local_time_step"])
                self.relaxation_factor = self.__class__.relaxation_factor(service, version, mode, path + ["relaxation_factor"])
                self.under_relaxation = self.__class__.under_relaxation(service, version, mode, path + ["under_relaxation"])
                self.courant_number = self.__class__.courant_number(service, version, mode, path + ["courant_number"])
                self.reset_amg_controls = self.__class__.reset_amg_controls(service, version, mode, path + ["reset_amg_controls"])
                self.reset_limits = self.__class__.reset_limits(service, version, mode, path + ["reset_limits"])
                self.reset_multi_stage_parameters = self.__class__.reset_multi_stage_parameters(service, version, mode, path + ["reset_multi_stage_parameters"])
                self.reset_pseudo_time_method_equations = self.__class__.reset_pseudo_time_method_equations(service, version, mode, path + ["reset_pseudo_time_method_equations"])
                self.reset_pseudo_time_method_generic = self.__class__.reset_pseudo_time_method_generic(service, version, mode, path + ["reset_pseudo_time_method_generic"])
                self.reset_pseudo_time_method_relaxations = self.__class__.reset_pseudo_time_method_relaxations(service, version, mode, path + ["reset_pseudo_time_method_relaxations"])
                self.reset_pseudo_time_method_scale_factors = self.__class__.reset_pseudo_time_method_scale_factors(service, version, mode, path + ["reset_pseudo_time_method_scale_factors"])
                self.reset_solution_controls = self.__class__.reset_solution_controls(service, version, mode, path + ["reset_solution_controls"])
                super().__init__(service, version, mode, path)
            class courant_number(TUIMethod):
                """
                .
                """
            class reset_amg_controls(TUIMethod):
                """
                .
                """
            class reset_limits(TUIMethod):
                """
                .
                """
            class reset_multi_stage_parameters(TUIMethod):
                """
                .
                """
            class reset_pseudo_time_method_equations(TUIMethod):
                """
                .
                """
            class reset_pseudo_time_method_generic(TUIMethod):
                """
                .
                """
            class reset_pseudo_time_method_relaxations(TUIMethod):
                """
                .
                """
            class reset_pseudo_time_method_scale_factors(TUIMethod):
                """
                .
                """
            class reset_solution_controls(TUIMethod):
                """
                .
                """

            class acoustics_wave_eqn_controls(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.max_iter_per_timestep_count = self.__class__.max_iter_per_timestep_count(service, version, mode, path + ["max_iter_per_timestep_count"])
                    self.relative_convergence_criterion = self.__class__.relative_convergence_criterion(service, version, mode, path + ["relative_convergence_criterion"])
                    super().__init__(service, version, mode, path)
                class max_iter_per_timestep_count(TUIMethod):
                    """
                    .
                    """
                class relative_convergence_criterion(TUIMethod):
                    """
                    .
                    """

                class expert(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.explicit_relaxation_factor = self.__class__.explicit_relaxation_factor(service, version, mode, path + ["explicit_relaxation_factor"])
                        self.under_relaxation_factor = self.__class__.under_relaxation_factor(service, version, mode, path + ["under_relaxation_factor"])
                        super().__init__(service, version, mode, path)
                    class explicit_relaxation_factor(TUIMethod):
                        """
                        .
                        """
                    class under_relaxation_factor(TUIMethod):
                        """
                        .
                        """

            class advanced(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.anisotropic_solid_heat_transfer = self.__class__.anisotropic_solid_heat_transfer(service, version, mode, path + ["anisotropic_solid_heat_transfer"])
                    self.correction_tolerance = self.__class__.correction_tolerance(service, version, mode, path + ["correction_tolerance"])
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.fast_transient_settings = self.__class__.fast_transient_settings(service, version, mode, path + ["fast_transient_settings"])
                    self.multi_grid = self.__class__.multi_grid(service, version, mode, path + ["multi_grid"])
                    self.multi_stage = self.__class__.multi_stage(service, version, mode, path + ["multi_stage"])
                    self.relaxation_method = self.__class__.relaxation_method(service, version, mode, path + ["relaxation_method"])
                    super().__init__(service, version, mode, path)
                class relaxation_method(TUIMethod):
                    """
                    .
                    """

                class anisotropic_solid_heat_transfer(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.flux = self.__class__.flux(service, version, mode, path + ["flux"])
                        self.gradient = self.__class__.gradient(service, version, mode, path + ["gradient"])
                        self.relaxation = self.__class__.relaxation(service, version, mode, path + ["relaxation"])
                        super().__init__(service, version, mode, path)
                    class flux(TUIMethod):
                        """
                        .
                        """
                    class gradient(TUIMethod):
                        """
                        .
                        """
                    class relaxation(TUIMethod):
                        """
                        .
                        """

                class correction_tolerance(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.create = self.__class__.create(service, version, mode, path + ["create"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                        self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                        super().__init__(service, version, mode, path)
                    class create(TUIMethod):
                        """
                        Create a new correction-tolerance object.
                        """
                    class delete(TUIMethod):
                        """
                        .
                        """
                    class edit(TUIMethod):
                        """
                        Edit correction-tolerance object.
                        """
                    class list(TUIMethod):
                        """
                        .
                        """
                    class list_properties(TUIMethod):
                        """
                        .
                        """
                    class make_a_copy(TUIMethod):
                        """
                        .
                        """
                    class rename(TUIMethod):
                        """
                        Rename correction-tolerance object.
                        """

                class expert(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.pseudo_time_method_usage = self.__class__.pseudo_time_method_usage(service, version, mode, path + ["pseudo_time_method_usage"])
                        self.spatial_discretization_limiter = self.__class__.spatial_discretization_limiter(service, version, mode, path + ["spatial_discretization_limiter"])
                        super().__init__(service, version, mode, path)

                    class pseudo_time_method_usage(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.global_dt = self.__class__.global_dt(service, version, mode, path + ["global_dt"])
                            self.local_dt = self.__class__.local_dt(service, version, mode, path + ["local_dt"])
                            super().__init__(service, version, mode, path)

                        class global_dt(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.create = self.__class__.create(service, version, mode, path + ["create"])
                                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                                self.list = self.__class__.list(service, version, mode, path + ["list"])
                                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                                self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                                self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                                super().__init__(service, version, mode, path)
                            class create(TUIMethod):
                                """
                                Create a new global-dt object.
                                """
                            class delete(TUIMethod):
                                """
                                .
                                """
                            class edit(TUIMethod):
                                """
                                Edit global-dt object.
                                """
                            class list(TUIMethod):
                                """
                                .
                                """
                            class list_properties(TUIMethod):
                                """
                                .
                                """
                            class make_a_copy(TUIMethod):
                                """
                                .
                                """
                            class rename(TUIMethod):
                                """
                                Rename global-dt object.
                                """

                        class local_dt(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.create = self.__class__.create(service, version, mode, path + ["create"])
                                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                                self.list = self.__class__.list(service, version, mode, path + ["list"])
                                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                                self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                                self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                                super().__init__(service, version, mode, path)
                            class create(TUIMethod):
                                """
                                Create a new local-dt object.
                                """
                            class delete(TUIMethod):
                                """
                                .
                                """
                            class edit(TUIMethod):
                                """
                                Edit local-dt object.
                                """
                            class list(TUIMethod):
                                """
                                .
                                """
                            class list_properties(TUIMethod):
                                """
                                .
                                """
                            class make_a_copy(TUIMethod):
                                """
                                .
                                """
                            class rename(TUIMethod):
                                """
                                Rename local-dt object.
                                """

                    class spatial_discretization_limiter(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.cell_to_limiting = self.__class__.cell_to_limiting(service, version, mode, path + ["cell_to_limiting"])
                            self.limiter_filter = self.__class__.limiter_filter(service, version, mode, path + ["limiter_filter"])
                            self.limiter_type = self.__class__.limiter_type(service, version, mode, path + ["limiter_type"])
                            super().__init__(service, version, mode, path)
                        class cell_to_limiting(TUIMethod):
                            """
                            .
                            """
                        class limiter_filter(TUIMethod):
                            """
                            .
                            """
                        class limiter_type(TUIMethod):
                            """
                            .
                            """

                class fast_transient_settings(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.runge_kutta = self.__class__.runge_kutta(service, version, mode, path + ["runge_kutta"])
                        super().__init__(service, version, mode, path)

                    class runge_kutta(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.default_multi_stage = self.__class__.default_multi_stage(service, version, mode, path + ["default_multi_stage"])
                            self.two_stage = self.__class__.two_stage(service, version, mode, path + ["two_stage"])
                            super().__init__(service, version, mode, path)
                        class default_multi_stage(TUIMethod):
                            """
                            .
                            """
                        class two_stage(TUIMethod):
                            """
                            .
                            """

                class multi_grid(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.amg_controls = self.__class__.amg_controls(service, version, mode, path + ["amg_controls"])
                        self.amg_gpgpu_options = self.__class__.amg_gpgpu_options(service, version, mode, path + ["amg_gpgpu_options"])
                        self.fas_mg_controls = self.__class__.fas_mg_controls(service, version, mode, path + ["fas_mg_controls"])
                        self.mg_controls = self.__class__.mg_controls(service, version, mode, path + ["mg_controls"])
                        super().__init__(service, version, mode, path)

                    class amg_controls(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.coupled_parameters = self.__class__.coupled_parameters(service, version, mode, path + ["coupled_parameters"])
                            self.flexible_cycle_parameters = self.__class__.flexible_cycle_parameters(service, version, mode, path + ["flexible_cycle_parameters"])
                            self.options = self.__class__.options(service, version, mode, path + ["options"])
                            self.scalar_parameters = self.__class__.scalar_parameters(service, version, mode, path + ["scalar_parameters"])
                            super().__init__(service, version, mode, path)

                        class coupled_parameters(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.coarsening_parameters = self.__class__.coarsening_parameters(service, version, mode, path + ["coarsening_parameters"])
                                self.fixed_cycle_parameters = self.__class__.fixed_cycle_parameters(service, version, mode, path + ["fixed_cycle_parameters"])
                                self.smoother_type = self.__class__.smoother_type(service, version, mode, path + ["smoother_type"])
                                super().__init__(service, version, mode, path)
                            class smoother_type(TUIMethod):
                                """
                                .
                                """

                            class coarsening_parameters(TUIMenu):
                                """
                                .
                                """
                                def __init__(self, service, version, mode, path):
                                    self.aggressive_coarsening = self.__class__.aggressive_coarsening(service, version, mode, path + ["aggressive_coarsening"])
                                    self.coarsen_by_interval = self.__class__.coarsen_by_interval(service, version, mode, path + ["coarsen_by_interval"])
                                    self.conservative_coarsening = self.__class__.conservative_coarsening(service, version, mode, path + ["conservative_coarsening"])
                                    self.laplace_coarsening = self.__class__.laplace_coarsening(service, version, mode, path + ["laplace_coarsening"])
                                    self.max_coarse_levels = self.__class__.max_coarse_levels(service, version, mode, path + ["max_coarse_levels"])
                                    super().__init__(service, version, mode, path)
                                class aggressive_coarsening(TUIMethod):
                                    """
                                    .
                                    """
                                class coarsen_by_interval(TUIMethod):
                                    """
                                    .
                                    """
                                class conservative_coarsening(TUIMethod):
                                    """
                                    .
                                    """
                                class laplace_coarsening(TUIMethod):
                                    """
                                    .
                                    """
                                class max_coarse_levels(TUIMethod):
                                    """
                                    .
                                    """

                            class fixed_cycle_parameters(TUIMenu):
                                """
                                .
                                """
                                def __init__(self, service, version, mode, path):
                                    self.max_cycle = self.__class__.max_cycle(service, version, mode, path + ["max_cycle"])
                                    self.post_sweeps = self.__class__.post_sweeps(service, version, mode, path + ["post_sweeps"])
                                    self.pre_sweeps = self.__class__.pre_sweeps(service, version, mode, path + ["pre_sweeps"])
                                    super().__init__(service, version, mode, path)
                                class max_cycle(TUIMethod):
                                    """
                                    .
                                    """
                                class post_sweeps(TUIMethod):
                                    """
                                    .
                                    """
                                class pre_sweeps(TUIMethod):
                                    """
                                    .
                                    """

                        class flexible_cycle_parameters(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.max_coarse_relaxations = self.__class__.max_coarse_relaxations(service, version, mode, path + ["max_coarse_relaxations"])
                                self.max_fine_relaxations = self.__class__.max_fine_relaxations(service, version, mode, path + ["max_fine_relaxations"])
                                super().__init__(service, version, mode, path)
                            class max_coarse_relaxations(TUIMethod):
                                """
                                .
                                """
                            class max_fine_relaxations(TUIMethod):
                                """
                                .
                                """

                        class options(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                                super().__init__(service, version, mode, path)
                            class verbosity(TUIMethod):
                                """
                                .
                                """

                        class scalar_parameters(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.coarsening_parameters = self.__class__.coarsening_parameters(service, version, mode, path + ["coarsening_parameters"])
                                self.fixed_cycle_parameters = self.__class__.fixed_cycle_parameters(service, version, mode, path + ["fixed_cycle_parameters"])
                                self.smoother_type = self.__class__.smoother_type(service, version, mode, path + ["smoother_type"])
                                super().__init__(service, version, mode, path)
                            class smoother_type(TUIMethod):
                                """
                                .
                                """

                            class coarsening_parameters(TUIMenu):
                                """
                                .
                                """
                                def __init__(self, service, version, mode, path):
                                    self.aggressive_coarsening = self.__class__.aggressive_coarsening(service, version, mode, path + ["aggressive_coarsening"])
                                    self.coarsen_by_interval = self.__class__.coarsen_by_interval(service, version, mode, path + ["coarsen_by_interval"])
                                    self.conservative_coarsening = self.__class__.conservative_coarsening(service, version, mode, path + ["conservative_coarsening"])
                                    self.laplace_coarsening = self.__class__.laplace_coarsening(service, version, mode, path + ["laplace_coarsening"])
                                    self.max_coarse_levels = self.__class__.max_coarse_levels(service, version, mode, path + ["max_coarse_levels"])
                                    super().__init__(service, version, mode, path)
                                class aggressive_coarsening(TUIMethod):
                                    """
                                    .
                                    """
                                class coarsen_by_interval(TUIMethod):
                                    """
                                    .
                                    """
                                class conservative_coarsening(TUIMethod):
                                    """
                                    .
                                    """
                                class laplace_coarsening(TUIMethod):
                                    """
                                    .
                                    """
                                class max_coarse_levels(TUIMethod):
                                    """
                                    .
                                    """

                            class fixed_cycle_parameters(TUIMenu):
                                """
                                .
                                """
                                def __init__(self, service, version, mode, path):
                                    self.max_cycle = self.__class__.max_cycle(service, version, mode, path + ["max_cycle"])
                                    self.post_sweeps = self.__class__.post_sweeps(service, version, mode, path + ["post_sweeps"])
                                    self.pre_sweeps = self.__class__.pre_sweeps(service, version, mode, path + ["pre_sweeps"])
                                    super().__init__(service, version, mode, path)
                                class max_cycle(TUIMethod):
                                    """
                                    .
                                    """
                                class post_sweeps(TUIMethod):
                                    """
                                    .
                                    """
                                class pre_sweeps(TUIMethod):
                                    """
                                    .
                                    """

                    class amg_gpgpu_options(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.create = self.__class__.create(service, version, mode, path + ["create"])
                            self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                            self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                            self.list = self.__class__.list(service, version, mode, path + ["list"])
                            self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                            self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                            self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                            super().__init__(service, version, mode, path)
                        class create(TUIMethod):
                            """
                            Create a new amg-gpgpu-options object.
                            """
                        class delete(TUIMethod):
                            """
                            .
                            """
                        class edit(TUIMethod):
                            """
                            Edit amg-gpgpu-options object.
                            """
                        class list(TUIMethod):
                            """
                            .
                            """
                        class list_properties(TUIMethod):
                            """
                            .
                            """
                        class make_a_copy(TUIMethod):
                            """
                            .
                            """
                        class rename(TUIMethod):
                            """
                            Rename amg-gpgpu-options object.
                            """

                    class fas_mg_controls(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.coarsening_parameters = self.__class__.coarsening_parameters(service, version, mode, path + ["coarsening_parameters"])
                            self.fixed_cycle_parameters = self.__class__.fixed_cycle_parameters(service, version, mode, path + ["fixed_cycle_parameters"])
                            self.options = self.__class__.options(service, version, mode, path + ["options"])
                            self.relaxation_factor = self.__class__.relaxation_factor(service, version, mode, path + ["relaxation_factor"])
                            super().__init__(service, version, mode, path)

                        class coarsening_parameters(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.coarsen_by_interval = self.__class__.coarsen_by_interval(service, version, mode, path + ["coarsen_by_interval"])
                                self.max_coarse_levels = self.__class__.max_coarse_levels(service, version, mode, path + ["max_coarse_levels"])
                                super().__init__(service, version, mode, path)
                            class coarsen_by_interval(TUIMethod):
                                """
                                .
                                """
                            class max_coarse_levels(TUIMethod):
                                """
                                .
                                """

                        class fixed_cycle_parameters(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.post_sweeps = self.__class__.post_sweeps(service, version, mode, path + ["post_sweeps"])
                                self.pre_sweeps = self.__class__.pre_sweeps(service, version, mode, path + ["pre_sweeps"])
                                super().__init__(service, version, mode, path)
                            class post_sweeps(TUIMethod):
                                """
                                .
                                """
                            class pre_sweeps(TUIMethod):
                                """
                                .
                                """

                        class options(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                                super().__init__(service, version, mode, path)
                            class verbosity(TUIMethod):
                                """
                                .
                                """

                        class relaxation_factor(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.correction_reduction = self.__class__.correction_reduction(service, version, mode, path + ["correction_reduction"])
                                self.correction_smoothing = self.__class__.correction_smoothing(service, version, mode, path + ["correction_smoothing"])
                                self.courant_number_reduction = self.__class__.courant_number_reduction(service, version, mode, path + ["courant_number_reduction"])
                                self.species_correction_reduction = self.__class__.species_correction_reduction(service, version, mode, path + ["species_correction_reduction"])
                                super().__init__(service, version, mode, path)
                            class correction_reduction(TUIMethod):
                                """
                                .
                                """
                            class correction_smoothing(TUIMethod):
                                """
                                .
                                """
                            class courant_number_reduction(TUIMethod):
                                """
                                .
                                """
                            class species_correction_reduction(TUIMethod):
                                """
                                .
                                """

                    class mg_controls(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.create = self.__class__.create(service, version, mode, path + ["create"])
                            self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                            self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                            self.list = self.__class__.list(service, version, mode, path + ["list"])
                            self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                            self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                            self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                            super().__init__(service, version, mode, path)
                        class create(TUIMethod):
                            """
                            Create a new mg-controls object.
                            """
                        class delete(TUIMethod):
                            """
                            .
                            """
                        class edit(TUIMethod):
                            """
                            Edit mg-controls object.
                            """
                        class list(TUIMethod):
                            """
                            .
                            """
                        class list_properties(TUIMethod):
                            """
                            .
                            """
                        class make_a_copy(TUIMethod):
                            """
                            .
                            """
                        class rename(TUIMethod):
                            """
                            Rename mg-controls object.
                            """

                class multi_stage(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.number_of_objects = self.__class__.number_of_objects(service, version, mode, path + ["number_of_objects"])
                        super().__init__(service, version, mode, path)
                    class edit(TUIMethod):
                        """
                        Edit multi-stage object.
                        """
                    class list_properties(TUIMethod):
                        """
                        .
                        """
                    class number_of_objects(TUIMethod):
                        """
                        Set number of objects for multi-stage.
                        """

            class contact_solution_controls(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.amg = self.__class__.amg(service, version, mode, path + ["amg"])
                    self.methods = self.__class__.methods(service, version, mode, path + ["methods"])
                    self.miscellaneous = self.__class__.miscellaneous(service, version, mode, path + ["miscellaneous"])
                    self.models = self.__class__.models(service, version, mode, path + ["models"])
                    self.parameters = self.__class__.parameters(service, version, mode, path + ["parameters"])
                    self.spatial = self.__class__.spatial(service, version, mode, path + ["spatial"])
                    self.transient = self.__class__.transient(service, version, mode, path + ["transient"])
                    self.set_settings_to_default = self.__class__.set_settings_to_default(service, version, mode, path + ["set_settings_to_default"])
                    self.solution_stabilization = self.__class__.solution_stabilization(service, version, mode, path + ["solution_stabilization"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    super().__init__(service, version, mode, path)
                class set_settings_to_default(TUIMethod):
                    """
                    .
                    """
                class solution_stabilization(TUIMethod):
                    """
                    .
                    """
                class verbosity(TUIMethod):
                    """
                    .
                    """

                class amg(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.coarsen_rate = self.__class__.coarsen_rate(service, version, mode, path + ["coarsen_rate"])
                        self.enforce_laplace_coarsening = self.__class__.enforce_laplace_coarsening(service, version, mode, path + ["enforce_laplace_coarsening"])
                        self.increase_pre_sweeps = self.__class__.increase_pre_sweeps(service, version, mode, path + ["increase_pre_sweeps"])
                        self.pre_sweeps = self.__class__.pre_sweeps(service, version, mode, path + ["pre_sweeps"])
                        self.specify_coarsening_rate = self.__class__.specify_coarsening_rate(service, version, mode, path + ["specify_coarsening_rate"])
                        super().__init__(service, version, mode, path)
                    class coarsen_rate(TUIMethod):
                        """
                        .
                        """
                    class enforce_laplace_coarsening(TUIMethod):
                        """
                        .
                        """
                    class increase_pre_sweeps(TUIMethod):
                        """
                        .
                        """
                    class pre_sweeps(TUIMethod):
                        """
                        .
                        """
                    class specify_coarsening_rate(TUIMethod):
                        """
                        .
                        """

                class methods(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.gradient_controls = self.__class__.gradient_controls(service, version, mode, path + ["gradient_controls"])
                        self.pv_coupling_controls = self.__class__.pv_coupling_controls(service, version, mode, path + ["pv_coupling_controls"])
                        self.pv_coupling_method = self.__class__.pv_coupling_method(service, version, mode, path + ["pv_coupling_method"])
                        self.specify_gradient_method = self.__class__.specify_gradient_method(service, version, mode, path + ["specify_gradient_method"])
                        super().__init__(service, version, mode, path)
                    class gradient_controls(TUIMethod):
                        """
                        .
                        """
                    class pv_coupling_controls(TUIMethod):
                        """
                        .
                        """
                    class pv_coupling_method(TUIMethod):
                        """
                        .
                        """
                    class specify_gradient_method(TUIMethod):
                        """
                        .
                        """

                class miscellaneous(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.compute_statistics = self.__class__.compute_statistics(service, version, mode, path + ["compute_statistics"])
                        self.statistics_level = self.__class__.statistics_level(service, version, mode, path + ["statistics_level"])
                        super().__init__(service, version, mode, path)
                    class compute_statistics(TUIMethod):
                        """
                        .
                        """
                    class statistics_level(TUIMethod):
                        """
                        .
                        """

                class models(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.model_ramping = self.__class__.model_ramping(service, version, mode, path + ["model_ramping"])
                        self.ramp_flow = self.__class__.ramp_flow(service, version, mode, path + ["ramp_flow"])
                        self.ramp_scalars = self.__class__.ramp_scalars(service, version, mode, path + ["ramp_scalars"])
                        self.ramp_turbulence = self.__class__.ramp_turbulence(service, version, mode, path + ["ramp_turbulence"])
                        super().__init__(service, version, mode, path)
                    class model_ramping(TUIMethod):
                        """
                        .
                        """
                    class ramp_flow(TUIMethod):
                        """
                        .
                        """
                    class ramp_scalars(TUIMethod):
                        """
                        .
                        """
                    class ramp_turbulence(TUIMethod):
                        """
                        .
                        """

                class parameters(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.extrapolation_method = self.__class__.extrapolation_method(service, version, mode, path + ["extrapolation_method"])
                        self.iter_count = self.__class__.iter_count(service, version, mode, path + ["iter_count"])
                        self.persistence_fixed_duration = self.__class__.persistence_fixed_duration(service, version, mode, path + ["persistence_fixed_duration"])
                        self.persistence_fixed_time_steps = self.__class__.persistence_fixed_time_steps(service, version, mode, path + ["persistence_fixed_time_steps"])
                        self.solution_stabilization_persistence = self.__class__.solution_stabilization_persistence(service, version, mode, path + ["solution_stabilization_persistence"])
                        super().__init__(service, version, mode, path)
                    class extrapolation_method(TUIMethod):
                        """
                        .
                        """
                    class iter_count(TUIMethod):
                        """
                        .
                        """
                    class persistence_fixed_duration(TUIMethod):
                        """
                        .
                        """
                    class persistence_fixed_time_steps(TUIMethod):
                        """
                        .
                        """
                    class solution_stabilization_persistence(TUIMethod):
                        """
                        .
                        """

                class spatial(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.first_to_second_order_blending = self.__class__.first_to_second_order_blending(service, version, mode, path + ["first_to_second_order_blending"])
                        self.first_to_second_order_blending_list = self.__class__.first_to_second_order_blending_list(service, version, mode, path + ["first_to_second_order_blending_list"])
                        self.flow_skew_diffusion_exclude = self.__class__.flow_skew_diffusion_exclude(service, version, mode, path + ["flow_skew_diffusion_exclude"])
                        self.rhie_chow_flux_specify = self.__class__.rhie_chow_flux_specify(service, version, mode, path + ["rhie_chow_flux_specify"])
                        self.rhie_chow_method = self.__class__.rhie_chow_method(service, version, mode, path + ["rhie_chow_method"])
                        self.scalars_skew_diffusion_exclude = self.__class__.scalars_skew_diffusion_exclude(service, version, mode, path + ["scalars_skew_diffusion_exclude"])
                        self.scheme = self.__class__.scheme(service, version, mode, path + ["scheme"])
                        super().__init__(service, version, mode, path)
                    class first_to_second_order_blending(TUIMethod):
                        """
                        .
                        """
                    class first_to_second_order_blending_list(TUIMethod):
                        """
                        .
                        """
                    class flow_skew_diffusion_exclude(TUIMethod):
                        """
                        .
                        """
                    class rhie_chow_flux_specify(TUIMethod):
                        """
                        .
                        """
                    class rhie_chow_method(TUIMethod):
                        """
                        .
                        """
                    class scalars_skew_diffusion_exclude(TUIMethod):
                        """
                        .
                        """
                    class scheme(TUIMethod):
                        """
                        .
                        """

                class transient(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.time_scale_modification_factor = self.__class__.time_scale_modification_factor(service, version, mode, path + ["time_scale_modification_factor"])
                        self.time_scale_modification_method = self.__class__.time_scale_modification_method(service, version, mode, path + ["time_scale_modification_method"])
                        self.transient_parameters_specify = self.__class__.transient_parameters_specify(service, version, mode, path + ["transient_parameters_specify"])
                        self.transient_scheme = self.__class__.transient_scheme(service, version, mode, path + ["transient_scheme"])
                        super().__init__(service, version, mode, path)
                    class time_scale_modification_factor(TUIMethod):
                        """
                        .
                        """
                    class time_scale_modification_method(TUIMethod):
                        """
                        .
                        """
                    class transient_parameters_specify(TUIMethod):
                        """
                        .
                        """
                    class transient_scheme(TUIMethod):
                        """
                        .
                        """

            class equations(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new equations object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit equations object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename equations object.
                    """

            class limits(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.max_pressure = self.__class__.max_pressure(service, version, mode, path + ["max_pressure"])
                    self.max_temperature = self.__class__.max_temperature(service, version, mode, path + ["max_temperature"])
                    self.max_turb_visc_ratio = self.__class__.max_turb_visc_ratio(service, version, mode, path + ["max_turb_visc_ratio"])
                    self.min_des_epsilon = self.__class__.min_des_epsilon(service, version, mode, path + ["min_des_epsilon"])
                    self.min_des_omega = self.__class__.min_des_omega(service, version, mode, path + ["min_des_omega"])
                    self.min_des_tke = self.__class__.min_des_tke(service, version, mode, path + ["min_des_tke"])
                    self.min_elliptic_relax_func = self.__class__.min_elliptic_relax_func(service, version, mode, path + ["min_elliptic_relax_func"])
                    self.min_epsilon = self.__class__.min_epsilon(service, version, mode, path + ["min_epsilon"])
                    self.min_lam_tke = self.__class__.min_lam_tke(service, version, mode, path + ["min_lam_tke"])
                    self.min_omega = self.__class__.min_omega(service, version, mode, path + ["min_omega"])
                    self.min_pressure = self.__class__.min_pressure(service, version, mode, path + ["min_pressure"])
                    self.min_temperature = self.__class__.min_temperature(service, version, mode, path + ["min_temperature"])
                    self.min_tke = self.__class__.min_tke(service, version, mode, path + ["min_tke"])
                    self.min_v2f_epsilon = self.__class__.min_v2f_epsilon(service, version, mode, path + ["min_v2f_epsilon"])
                    self.min_v2f_tke = self.__class__.min_v2f_tke(service, version, mode, path + ["min_v2f_tke"])
                    self.min_vel_var_scale = self.__class__.min_vel_var_scale(service, version, mode, path + ["min_vel_var_scale"])
                    self.min_vol_frac_for_matrix_sol = self.__class__.min_vol_frac_for_matrix_sol(service, version, mode, path + ["min_vol_frac_for_matrix_sol"])
                    self.positivity_rate = self.__class__.positivity_rate(service, version, mode, path + ["positivity_rate"])
                    super().__init__(service, version, mode, path)
                class max_pressure(TUIMethod):
                    """
                    .
                    """
                class max_temperature(TUIMethod):
                    """
                    .
                    """
                class max_turb_visc_ratio(TUIMethod):
                    """
                    .
                    """
                class min_des_epsilon(TUIMethod):
                    """
                    .
                    """
                class min_des_omega(TUIMethod):
                    """
                    .
                    """
                class min_des_tke(TUIMethod):
                    """
                    .
                    """
                class min_elliptic_relax_func(TUIMethod):
                    """
                    .
                    """
                class min_epsilon(TUIMethod):
                    """
                    .
                    """
                class min_lam_tke(TUIMethod):
                    """
                    .
                    """
                class min_omega(TUIMethod):
                    """
                    .
                    """
                class min_pressure(TUIMethod):
                    """
                    .
                    """
                class min_temperature(TUIMethod):
                    """
                    .
                    """
                class min_tke(TUIMethod):
                    """
                    .
                    """
                class min_v2f_epsilon(TUIMethod):
                    """
                    .
                    """
                class min_v2f_tke(TUIMethod):
                    """
                    .
                    """
                class min_vel_var_scale(TUIMethod):
                    """
                    .
                    """
                class min_vol_frac_for_matrix_sol(TUIMethod):
                    """
                    .
                    """
                class positivity_rate(TUIMethod):
                    """
                    .
                    """

            class p_v_controls(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.explicit_momentum_under_relaxation = self.__class__.explicit_momentum_under_relaxation(service, version, mode, path + ["explicit_momentum_under_relaxation"])
                    self.explicit_pressure_under_relaxation = self.__class__.explicit_pressure_under_relaxation(service, version, mode, path + ["explicit_pressure_under_relaxation"])
                    self.explicit_volume_fraction_under_relaxation = self.__class__.explicit_volume_fraction_under_relaxation(service, version, mode, path + ["explicit_volume_fraction_under_relaxation"])
                    self.flow_courant_number = self.__class__.flow_courant_number(service, version, mode, path + ["flow_courant_number"])
                    self.neighbor_correction_itr_count = self.__class__.neighbor_correction_itr_count(service, version, mode, path + ["neighbor_correction_itr_count"])
                    self.skewness_correction_itr_count = self.__class__.skewness_correction_itr_count(service, version, mode, path + ["skewness_correction_itr_count"])
                    self.skewness_neighbor_coupling = self.__class__.skewness_neighbor_coupling(service, version, mode, path + ["skewness_neighbor_coupling"])
                    self.vof_correction_itr_count = self.__class__.vof_correction_itr_count(service, version, mode, path + ["vof_correction_itr_count"])
                    self.volume_fraction_courant_number = self.__class__.volume_fraction_courant_number(service, version, mode, path + ["volume_fraction_courant_number"])
                    super().__init__(service, version, mode, path)
                class explicit_momentum_under_relaxation(TUIMethod):
                    """
                    .
                    """
                class explicit_pressure_under_relaxation(TUIMethod):
                    """
                    .
                    """
                class explicit_volume_fraction_under_relaxation(TUIMethod):
                    """
                    .
                    """
                class flow_courant_number(TUIMethod):
                    """
                    .
                    """
                class neighbor_correction_itr_count(TUIMethod):
                    """
                    .
                    """
                class skewness_correction_itr_count(TUIMethod):
                    """
                    .
                    """
                class skewness_neighbor_coupling(TUIMethod):
                    """
                    .
                    """
                class vof_correction_itr_count(TUIMethod):
                    """
                    .
                    """
                class volume_fraction_courant_number(TUIMethod):
                    """
                    .
                    """

            class pseudo_time_explicit_relaxation_factor(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.global_dt_pseudo_relax = self.__class__.global_dt_pseudo_relax(service, version, mode, path + ["global_dt_pseudo_relax"])
                    self.local_dt_dualts_relax = self.__class__.local_dt_dualts_relax(service, version, mode, path + ["local_dt_dualts_relax"])
                    super().__init__(service, version, mode, path)

                class global_dt_pseudo_relax(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.create = self.__class__.create(service, version, mode, path + ["create"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                        self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                        super().__init__(service, version, mode, path)
                    class create(TUIMethod):
                        """
                        Create a new global-dt-pseudo-relax object.
                        """
                    class delete(TUIMethod):
                        """
                        .
                        """
                    class edit(TUIMethod):
                        """
                        Edit global-dt-pseudo-relax object.
                        """
                    class list(TUIMethod):
                        """
                        .
                        """
                    class list_properties(TUIMethod):
                        """
                        .
                        """
                    class make_a_copy(TUIMethod):
                        """
                        .
                        """
                    class rename(TUIMethod):
                        """
                        Rename global-dt-pseudo-relax object.
                        """

                class local_dt_dualts_relax(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.create = self.__class__.create(service, version, mode, path + ["create"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                        self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                        super().__init__(service, version, mode, path)
                    class create(TUIMethod):
                        """
                        Create a new local-dt-dualts-relax object.
                        """
                    class delete(TUIMethod):
                        """
                        .
                        """
                    class edit(TUIMethod):
                        """
                        Edit local-dt-dualts-relax object.
                        """
                    class list(TUIMethod):
                        """
                        .
                        """
                    class list_properties(TUIMethod):
                        """
                        .
                        """
                    class make_a_copy(TUIMethod):
                        """
                        .
                        """
                    class rename(TUIMethod):
                        """
                        Rename local-dt-dualts-relax object.
                        """

            class pseudo_time_method_local_time_step(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.pseudo_time_courant_number = self.__class__.pseudo_time_courant_number(service, version, mode, path + ["pseudo_time_courant_number"])
                    self.pseudo_time_step_method_solid_zone = self.__class__.pseudo_time_step_method_solid_zone(service, version, mode, path + ["pseudo_time_step_method_solid_zone"])
                    self.time_step_size_scale_factor = self.__class__.time_step_size_scale_factor(service, version, mode, path + ["time_step_size_scale_factor"])
                    super().__init__(service, version, mode, path)
                class pseudo_time_courant_number(TUIMethod):
                    """
                    .
                    """
                class pseudo_time_step_method_solid_zone(TUIMethod):
                    """
                    .
                    """
                class time_step_size_scale_factor(TUIMethod):
                    """
                    .
                    """

            class relaxation_factor(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new relaxation-factor object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit relaxation-factor object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename relaxation-factor object.
                    """

            class under_relaxation(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new under-relaxation object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit under-relaxation object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename under-relaxation object.
                    """

        class initialization(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.defaults = self.__class__.defaults(service, version, mode, path + ["defaults"])
                self.fmg = self.__class__.fmg(service, version, mode, path + ["fmg"])
                self.hybrid_init_options = self.__class__.hybrid_init_options(service, version, mode, path + ["hybrid_init_options"])
                self.localized_turb_init = self.__class__.localized_turb_init(service, version, mode, path + ["localized_turb_init"])
                self.open_channel_auto_init = self.__class__.open_channel_auto_init(service, version, mode, path + ["open_channel_auto_init"])
                self.patch = self.__class__.patch(service, version, mode, path + ["patch"])
                self.compute_defaults = self.__class__.compute_defaults(service, version, mode, path + ["compute_defaults"])
                self.dpm_reset = self.__class__.dpm_reset(service, version, mode, path + ["dpm_reset"])
                self.hybrid_initialize = self.__class__.hybrid_initialize(service, version, mode, path + ["hybrid_initialize"])
                self.init_acoustics_options = self.__class__.init_acoustics_options(service, version, mode, path + ["init_acoustics_options"])
                self.init_flow_statistics = self.__class__.init_flow_statistics(service, version, mode, path + ["init_flow_statistics"])
                self.init_lwf = self.__class__.init_lwf(service, version, mode, path + ["init_lwf"])
                self.init_turb_vel_fluctuations = self.__class__.init_turb_vel_fluctuations(service, version, mode, path + ["init_turb_vel_fluctuations"])
                self.initialization_type = self.__class__.initialization_type(service, version, mode, path + ["initialization_type"])
                self.initialize = self.__class__.initialize(service, version, mode, path + ["initialize"])
                self.levelset_auto_init = self.__class__.levelset_auto_init(service, version, mode, path + ["levelset_auto_init"])
                self.list_defaults = self.__class__.list_defaults(service, version, mode, path + ["list_defaults"])
                self.lwf_reset = self.__class__.lwf_reset(service, version, mode, path + ["lwf_reset"])
                self.reference_frame = self.__class__.reference_frame(service, version, mode, path + ["reference_frame"])
                self.show_iterations_sampled = self.__class__.show_iterations_sampled(service, version, mode, path + ["show_iterations_sampled"])
                self.show_time_sampled = self.__class__.show_time_sampled(service, version, mode, path + ["show_time_sampled"])
                self.standard_initialize = self.__class__.standard_initialize(service, version, mode, path + ["standard_initialize"])
                super().__init__(service, version, mode, path)
            class compute_defaults(TUIMethod):
                """
                .
                """
            class dpm_reset(TUIMethod):
                """
                .
                """
            class hybrid_initialize(TUIMethod):
                """
                .
                """
            class init_acoustics_options(TUIMethod):
                """
                .
                """
            class init_flow_statistics(TUIMethod):
                """
                .
                """
            class init_lwf(TUIMethod):
                """
                .
                """
            class init_turb_vel_fluctuations(TUIMethod):
                """
                .
                """
            class initialization_type(TUIMethod):
                """
                .
                """
            class initialize(TUIMethod):
                """
                .
                """
            class levelset_auto_init(TUIMethod):
                """
                .
                """
            class list_defaults(TUIMethod):
                """
                .
                """
            class lwf_reset(TUIMethod):
                """
                .
                """
            class reference_frame(TUIMethod):
                """
                .
                """
            class show_iterations_sampled(TUIMethod):
                """
                .
                """
            class show_time_sampled(TUIMethod):
                """
                .
                """
            class standard_initialize(TUIMethod):
                """
                .
                """

            class defaults(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new defaults object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit defaults object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename defaults object.
                    """

            class fmg(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.customize = self.__class__.customize(service, version, mode, path + ["customize"])
                    self.enable_fmg_verbose = self.__class__.enable_fmg_verbose(service, version, mode, path + ["enable_fmg_verbose"])
                    self.fmg_courant_number = self.__class__.fmg_courant_number(service, version, mode, path + ["fmg_courant_number"])
                    self.fmg_initialize = self.__class__.fmg_initialize(service, version, mode, path + ["fmg_initialize"])
                    self.reset_to_defaults = self.__class__.reset_to_defaults(service, version, mode, path + ["reset_to_defaults"])
                    self.species_reactions = self.__class__.species_reactions(service, version, mode, path + ["species_reactions"])
                    self.turbulent_viscosity_ratio = self.__class__.turbulent_viscosity_ratio(service, version, mode, path + ["turbulent_viscosity_ratio"])
                    self.viscous_terms = self.__class__.viscous_terms(service, version, mode, path + ["viscous_terms"])
                    super().__init__(service, version, mode, path)
                class customize(TUIMethod):
                    """
                    .
                    """
                class enable_fmg_verbose(TUIMethod):
                    """
                    .
                    """
                class fmg_courant_number(TUIMethod):
                    """
                    .
                    """
                class fmg_initialize(TUIMethod):
                    """
                    .
                    """
                class reset_to_defaults(TUIMethod):
                    """
                    .
                    """
                class species_reactions(TUIMethod):
                    """
                    .
                    """
                class turbulent_viscosity_ratio(TUIMethod):
                    """
                    .
                    """
                class viscous_terms(TUIMethod):
                    """
                    .
                    """

            class hybrid_init_options(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.general_settings = self.__class__.general_settings(service, version, mode, path + ["general_settings"])
                    self.species_setting = self.__class__.species_setting(service, version, mode, path + ["species_setting"])
                    self.turbulent_setting = self.__class__.turbulent_setting(service, version, mode, path + ["turbulent_setting"])
                    super().__init__(service, version, mode, path)

                class general_settings(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.const_velocity = self.__class__.const_velocity(service, version, mode, path + ["const_velocity"])
                        self.explicit_urf = self.__class__.explicit_urf(service, version, mode, path + ["explicit_urf"])
                        self.external_aero = self.__class__.external_aero(service, version, mode, path + ["external_aero"])
                        self.initial_pressure = self.__class__.initial_pressure(service, version, mode, path + ["initial_pressure"])
                        self.iter_count = self.__class__.iter_count(service, version, mode, path + ["iter_count"])
                        super().__init__(service, version, mode, path)
                    class const_velocity(TUIMethod):
                        """
                        .
                        """
                    class explicit_urf(TUIMethod):
                        """
                        .
                        """
                    class external_aero(TUIMethod):
                        """
                        .
                        """
                    class initial_pressure(TUIMethod):
                        """
                        .
                        """
                    class iter_count(TUIMethod):
                        """
                        .
                        """

                class species_setting(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.species = self.__class__.species(service, version, mode, path + ["species"])
                        self.user_specified_species = self.__class__.user_specified_species(service, version, mode, path + ["user_specified_species"])
                        super().__init__(service, version, mode, path)
                    class user_specified_species(TUIMethod):
                        """
                        .
                        """

                    class species(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.create = self.__class__.create(service, version, mode, path + ["create"])
                            self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                            self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                            self.list = self.__class__.list(service, version, mode, path + ["list"])
                            self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                            self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                            self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                            super().__init__(service, version, mode, path)
                        class create(TUIMethod):
                            """
                            Create a new species object.
                            """
                        class delete(TUIMethod):
                            """
                            .
                            """
                        class edit(TUIMethod):
                            """
                            Edit species object.
                            """
                        class list(TUIMethod):
                            """
                            .
                            """
                        class list_properties(TUIMethod):
                            """
                            .
                            """
                        class make_a_copy(TUIMethod):
                            """
                            .
                            """
                        class rename(TUIMethod):
                            """
                            Rename species object.
                            """

                class turbulent_setting(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.averaged_turbulent_parameters = self.__class__.averaged_turbulent_parameters(service, version, mode, path + ["averaged_turbulent_parameters"])
                        self.turbulent_intensity = self.__class__.turbulent_intensity(service, version, mode, path + ["turbulent_intensity"])
                        self.viscosity_ratio = self.__class__.viscosity_ratio(service, version, mode, path + ["viscosity_ratio"])
                        super().__init__(service, version, mode, path)
                    class averaged_turbulent_parameters(TUIMethod):
                        """
                        .
                        """
                    class turbulent_intensity(TUIMethod):
                        """
                        .
                        """
                    class viscosity_ratio(TUIMethod):
                        """
                        .
                        """

            class localized_turb_init(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.enabled = self.__class__.enabled(service, version, mode, path + ["enabled"])
                    self.turbulent_intensity = self.__class__.turbulent_intensity(service, version, mode, path + ["turbulent_intensity"])
                    self.turbulent_viscosity_ratio = self.__class__.turbulent_viscosity_ratio(service, version, mode, path + ["turbulent_viscosity_ratio"])
                    super().__init__(service, version, mode, path)
                class enabled(TUIMethod):
                    """
                    .
                    """
                class turbulent_intensity(TUIMethod):
                    """
                    .
                    """
                class turbulent_viscosity_ratio(TUIMethod):
                    """
                    .
                    """

            class open_channel_auto_init(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.boundary_zone = self.__class__.boundary_zone(service, version, mode, path + ["boundary_zone"])
                    self.flat_init = self.__class__.flat_init(service, version, mode, path + ["flat_init"])
                    self.wavy_surface_init = self.__class__.wavy_surface_init(service, version, mode, path + ["wavy_surface_init"])
                    super().__init__(service, version, mode, path)
                class boundary_zone(TUIMethod):
                    """
                    .
                    """
                class flat_init(TUIMethod):
                    """
                    .
                    """
                class wavy_surface_init(TUIMethod):
                    """
                    .
                    """

            class patch(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.vof_smooth_options = self.__class__.vof_smooth_options(service, version, mode, path + ["vof_smooth_options"])
                    self.calculate_patch = self.__class__.calculate_patch(service, version, mode, path + ["calculate_patch"])
                    super().__init__(service, version, mode, path)
                class calculate_patch(TUIMethod):
                    """
                    .
                    """

                class vof_smooth_options(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.execute_smoothing = self.__class__.execute_smoothing(service, version, mode, path + ["execute_smoothing"])
                        self.patch_reconstructed_interface = self.__class__.patch_reconstructed_interface(service, version, mode, path + ["patch_reconstructed_interface"])
                        self.smoothing_relaxation_factor = self.__class__.smoothing_relaxation_factor(service, version, mode, path + ["smoothing_relaxation_factor"])
                        self.use_volumetric_smoothing = self.__class__.use_volumetric_smoothing(service, version, mode, path + ["use_volumetric_smoothing"])
                        super().__init__(service, version, mode, path)
                    class execute_smoothing(TUIMethod):
                        """
                        .
                        """
                    class patch_reconstructed_interface(TUIMethod):
                        """
                        .
                        """
                    class smoothing_relaxation_factor(TUIMethod):
                        """
                        .
                        """
                    class use_volumetric_smoothing(TUIMethod):
                        """
                        .
                        """

        class methods(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.convergence_acceleration_for_stretched_meshes = self.__class__.convergence_acceleration_for_stretched_meshes(service, version, mode, path + ["convergence_acceleration_for_stretched_meshes"])
                self.discretization_scheme = self.__class__.discretization_scheme(service, version, mode, path + ["discretization_scheme"])
                self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                self.flux_type = self.__class__.flux_type(service, version, mode, path + ["flux_type"])
                self.high_order_term_relaxation = self.__class__.high_order_term_relaxation(service, version, mode, path + ["high_order_term_relaxation"])
                self.multiphase_numerics = self.__class__.multiphase_numerics(service, version, mode, path + ["multiphase_numerics"])
                self.nb_gradient_boundary_option = self.__class__.nb_gradient_boundary_option(service, version, mode, path + ["nb_gradient_boundary_option"])
                self.nita_expert_controls = self.__class__.nita_expert_controls(service, version, mode, path + ["nita_expert_controls"])
                self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                self.p_v_coupling = self.__class__.p_v_coupling(service, version, mode, path + ["p_v_coupling"])
                self.phase_based_vof_discretization = self.__class__.phase_based_vof_discretization(service, version, mode, path + ["phase_based_vof_discretization"])
                self.pseudo_time_method = self.__class__.pseudo_time_method(service, version, mode, path + ["pseudo_time_method"])
                self.reduced_rank_extrapolation_options = self.__class__.reduced_rank_extrapolation_options(service, version, mode, path + ["reduced_rank_extrapolation_options"])
                self.residual_smoothing = self.__class__.residual_smoothing(service, version, mode, path + ["residual_smoothing"])
                self.vof_numerics = self.__class__.vof_numerics(service, version, mode, path + ["vof_numerics"])
                self.warped_face_gradient_correction = self.__class__.warped_face_gradient_correction(service, version, mode, path + ["warped_face_gradient_correction"])
                self.accelerated_non_iterative_time_marching = self.__class__.accelerated_non_iterative_time_marching(service, version, mode, path + ["accelerated_non_iterative_time_marching"])
                self.frozen_flux = self.__class__.frozen_flux(service, version, mode, path + ["frozen_flux"])
                self.gradient_scheme = self.__class__.gradient_scheme(service, version, mode, path + ["gradient_scheme"])
                self.nita = self.__class__.nita(service, version, mode, path + ["nita"])
                self.reduced_rank_extrapolation = self.__class__.reduced_rank_extrapolation(service, version, mode, path + ["reduced_rank_extrapolation"])
                self.set_solution_methods_to_default = self.__class__.set_solution_methods_to_default(service, version, mode, path + ["set_solution_methods_to_default"])
                self.transient_formulation = self.__class__.transient_formulation(service, version, mode, path + ["transient_formulation"])
                self.unsteady_global_time = self.__class__.unsteady_global_time(service, version, mode, path + ["unsteady_global_time"])
                super().__init__(service, version, mode, path)
            class accelerated_non_iterative_time_marching(TUIMethod):
                """
                .
                """
            class frozen_flux(TUIMethod):
                """
                .
                """
            class gradient_scheme(TUIMethod):
                """
                .
                """
            class nita(TUIMethod):
                """
                .
                """
            class reduced_rank_extrapolation(TUIMethod):
                """
                .
                """
            class set_solution_methods_to_default(TUIMethod):
                """
                .
                """
            class transient_formulation(TUIMethod):
                """
                .
                """
            class unsteady_global_time(TUIMethod):
                """
                .
                """

            class convergence_acceleration_for_stretched_meshes(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.casm_cutoff_multiplier = self.__class__.casm_cutoff_multiplier(service, version, mode, path + ["casm_cutoff_multiplier"])
                    self.convergence_acceleration_type = self.__class__.convergence_acceleration_type(service, version, mode, path + ["convergence_acceleration_type"])
                    super().__init__(service, version, mode, path)
                class casm_cutoff_multiplier(TUIMethod):
                    """
                    .
                    """
                class convergence_acceleration_type(TUIMethod):
                    """
                    .
                    """

            class discretization_scheme(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new discretization-scheme object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit discretization-scheme object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename discretization-scheme object.
                    """

            class expert(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.numerics_dbns = self.__class__.numerics_dbns(service, version, mode, path + ["numerics_dbns"])
                    self.numerics_pbns = self.__class__.numerics_pbns(service, version, mode, path + ["numerics_pbns"])
                    self.reaction_source_term_relaxation_factor = self.__class__.reaction_source_term_relaxation_factor(service, version, mode, path + ["reaction_source_term_relaxation_factor"])
                    self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                    super().__init__(service, version, mode, path)
                class reaction_source_term_relaxation_factor(TUIMethod):
                    """
                    .
                    """
                class reactions(TUIMethod):
                    """
                    .
                    """

                class numerics_dbns(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.first_to_second_order_blending_dbns = self.__class__.first_to_second_order_blending_dbns(service, version, mode, path + ["first_to_second_order_blending_dbns"])
                        super().__init__(service, version, mode, path)
                    class first_to_second_order_blending_dbns(TUIMethod):
                        """
                        .
                        """

                class numerics_pbns(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.alternate_diffusion_for_porous_region_solids = self.__class__.alternate_diffusion_for_porous_region_solids(service, version, mode, path + ["alternate_diffusion_for_porous_region_solids"])
                        self.disable_rhie_chow_flux = self.__class__.disable_rhie_chow_flux(service, version, mode, path + ["disable_rhie_chow_flux"])
                        self.first_to_second_order_blending = self.__class__.first_to_second_order_blending(service, version, mode, path + ["first_to_second_order_blending"])
                        self.implicit_bodyforce_treatment = self.__class__.implicit_bodyforce_treatment(service, version, mode, path + ["implicit_bodyforce_treatment"])
                        self.physical_velocity_formulation = self.__class__.physical_velocity_formulation(service, version, mode, path + ["physical_velocity_formulation"])
                        self.presto_pressure_scheme = self.__class__.presto_pressure_scheme(service, version, mode, path + ["presto_pressure_scheme"])
                        self.velocity_formulation = self.__class__.velocity_formulation(service, version, mode, path + ["velocity_formulation"])
                        super().__init__(service, version, mode, path)
                    class alternate_diffusion_for_porous_region_solids(TUIMethod):
                        """
                        .
                        """
                    class disable_rhie_chow_flux(TUIMethod):
                        """
                        .
                        """
                    class first_to_second_order_blending(TUIMethod):
                        """
                        .
                        """
                    class implicit_bodyforce_treatment(TUIMethod):
                        """
                        .
                        """
                    class physical_velocity_formulation(TUIMethod):
                        """
                        .
                        """
                    class presto_pressure_scheme(TUIMethod):
                        """
                        .
                        """
                    class velocity_formulation(TUIMethod):
                        """
                        .
                        """

            class flux_type(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.dbns_cases = self.__class__.dbns_cases(service, version, mode, path + ["dbns_cases"])
                    self.pbns_cases = self.__class__.pbns_cases(service, version, mode, path + ["pbns_cases"])
                    super().__init__(service, version, mode, path)

                class dbns_cases(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.flux_type = self.__class__.flux_type(service, version, mode, path + ["flux_type"])
                        super().__init__(service, version, mode, path)
                    class flux_type(TUIMethod):
                        """
                        .
                        """

                class pbns_cases(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.flux_auto_select = self.__class__.flux_auto_select(service, version, mode, path + ["flux_auto_select"])
                        self.flux_type = self.__class__.flux_type(service, version, mode, path + ["flux_type"])
                        super().__init__(service, version, mode, path)
                    class flux_auto_select(TUIMethod):
                        """
                        .
                        """
                    class flux_type(TUIMethod):
                        """
                        .
                        """

            class high_order_term_relaxation(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.options = self.__class__.options(service, version, mode, path + ["options"])
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    .
                    """

                class options(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.relaxation_factor = self.__class__.relaxation_factor(service, version, mode, path + ["relaxation_factor"])
                        self.select_variables = self.__class__.select_variables(service, version, mode, path + ["select_variables"])
                        self.type = self.__class__.type(service, version, mode, path + ["type"])
                        super().__init__(service, version, mode, path)
                    class relaxation_factor(TUIMethod):
                        """
                        .
                        """
                    class select_variables(TUIMethod):
                        """
                        .
                        """
                    class type(TUIMethod):
                        """
                        .
                        """

            class multiphase_numerics(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.advanced_stability_controls = self.__class__.advanced_stability_controls(service, version, mode, path + ["advanced_stability_controls"])
                    self.boiling_parameters = self.__class__.boiling_parameters(service, version, mode, path + ["boiling_parameters"])
                    self.compressible_flow = self.__class__.compressible_flow(service, version, mode, path + ["compressible_flow"])
                    self.default_controls = self.__class__.default_controls(service, version, mode, path + ["default_controls"])
                    self.face_pressure_controls = self.__class__.face_pressure_controls(service, version, mode, path + ["face_pressure_controls"])
                    self.heat_mass_transfer = self.__class__.heat_mass_transfer(service, version, mode, path + ["heat_mass_transfer"])
                    self.porous_media = self.__class__.porous_media(service, version, mode, path + ["porous_media"])
                    self.solution_stabilization = self.__class__.solution_stabilization(service, version, mode, path + ["solution_stabilization"])
                    self.viscous_flow = self.__class__.viscous_flow(service, version, mode, path + ["viscous_flow"])
                    super().__init__(service, version, mode, path)

                class advanced_stability_controls(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.anti_diffusion = self.__class__.anti_diffusion(service, version, mode, path + ["anti_diffusion"])
                        self.equation_order = self.__class__.equation_order(service, version, mode, path + ["equation_order"])
                        self.hybrid_nita = self.__class__.hybrid_nita(service, version, mode, path + ["hybrid_nita"])
                        self.p_v_coupling = self.__class__.p_v_coupling(service, version, mode, path + ["p_v_coupling"])
                        self.pseudo_transient = self.__class__.pseudo_transient(service, version, mode, path + ["pseudo_transient"])
                        super().__init__(service, version, mode, path)

                    class anti_diffusion(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.enable_dynamic_strength = self.__class__.enable_dynamic_strength(service, version, mode, path + ["enable_dynamic_strength"])
                            self.set_dynamic_strength_exponent = self.__class__.set_dynamic_strength_exponent(service, version, mode, path + ["set_dynamic_strength_exponent"])
                            self.set_maximum_dynamic_strength = self.__class__.set_maximum_dynamic_strength(service, version, mode, path + ["set_maximum_dynamic_strength"])
                            super().__init__(service, version, mode, path)
                        class enable_dynamic_strength(TUIMethod):
                            """
                            .
                            """
                        class set_dynamic_strength_exponent(TUIMethod):
                            """
                            .
                            """
                        class set_maximum_dynamic_strength(TUIMethod):
                            """
                            .
                            """

                    class equation_order(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.solve_exp_vof_at_end = self.__class__.solve_exp_vof_at_end(service, version, mode, path + ["solve_exp_vof_at_end"])
                            self.solve_flow_last = self.__class__.solve_flow_last(service, version, mode, path + ["solve_flow_last"])
                            super().__init__(service, version, mode, path)
                        class solve_exp_vof_at_end(TUIMethod):
                            """
                            .
                            """
                        class solve_flow_last(TUIMethod):
                            """
                            .
                            """

                    class hybrid_nita(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.initial_outer_iterations = self.__class__.initial_outer_iterations(service, version, mode, path + ["initial_outer_iterations"])
                            self.instability_detector = self.__class__.instability_detector(service, version, mode, path + ["instability_detector"])
                            self.outer_iterations = self.__class__.outer_iterations(service, version, mode, path + ["outer_iterations"])
                            super().__init__(service, version, mode, path)
                        class outer_iterations(TUIMethod):
                            """
                            .
                            """

                        class initial_outer_iterations(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.initial_outer_iter = self.__class__.initial_outer_iter(service, version, mode, path + ["initial_outer_iter"])
                                self.initial_time_steps = self.__class__.initial_time_steps(service, version, mode, path + ["initial_time_steps"])
                                super().__init__(service, version, mode, path)
                            class initial_outer_iter(TUIMethod):
                                """
                                .
                                """
                            class initial_time_steps(TUIMethod):
                                """
                                .
                                """

                        class instability_detector(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.enable_instability_detector = self.__class__.enable_instability_detector(service, version, mode, path + ["enable_instability_detector"])
                                self.set_cfl_limit = self.__class__.set_cfl_limit(service, version, mode, path + ["set_cfl_limit"])
                                self.set_cfl_type = self.__class__.set_cfl_type(service, version, mode, path + ["set_cfl_type"])
                                self.set_velocity_limit = self.__class__.set_velocity_limit(service, version, mode, path + ["set_velocity_limit"])
                                self.unstable_event_outer_iterations = self.__class__.unstable_event_outer_iterations(service, version, mode, path + ["unstable_event_outer_iterations"])
                                super().__init__(service, version, mode, path)
                            class enable_instability_detector(TUIMethod):
                                """
                                .
                                """
                            class set_cfl_limit(TUIMethod):
                                """
                                .
                                """
                            class set_cfl_type(TUIMethod):
                                """
                                .
                                """
                            class set_velocity_limit(TUIMethod):
                                """
                                .
                                """
                            class unstable_event_outer_iterations(TUIMethod):
                                """
                                .
                                """

                    class p_v_coupling(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.coupled_vof = self.__class__.coupled_vof(service, version, mode, path + ["coupled_vof"])
                            self.rhie_chow_flux = self.__class__.rhie_chow_flux(service, version, mode, path + ["rhie_chow_flux"])
                            self.skewness_correction = self.__class__.skewness_correction(service, version, mode, path + ["skewness_correction"])
                            super().__init__(service, version, mode, path)

                        class coupled_vof(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.blended_treatment_for_buoyancy_forces = self.__class__.blended_treatment_for_buoyancy_forces(service, version, mode, path + ["blended_treatment_for_buoyancy_forces"])
                                self.buoyancy_force_linearization = self.__class__.buoyancy_force_linearization(service, version, mode, path + ["buoyancy_force_linearization"])
                                super().__init__(service, version, mode, path)
                            class blended_treatment_for_buoyancy_forces(TUIMethod):
                                """
                                .
                                """
                            class buoyancy_force_linearization(TUIMethod):
                                """
                                .
                                """

                        class rhie_chow_flux(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.low_order_rhie_chow = self.__class__.low_order_rhie_chow(service, version, mode, path + ["low_order_rhie_chow"])
                                super().__init__(service, version, mode, path)
                            class low_order_rhie_chow(TUIMethod):
                                """
                                .
                                """

                        class skewness_correction(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.limit_pressure_correction_gradient = self.__class__.limit_pressure_correction_gradient(service, version, mode, path + ["limit_pressure_correction_gradient"])
                                super().__init__(service, version, mode, path)
                            class limit_pressure_correction_gradient(TUIMethod):
                                """
                                .
                                """

                    class pseudo_transient(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.auto_dt_advanced_controls = self.__class__.auto_dt_advanced_controls(service, version, mode, path + ["auto_dt_advanced_controls"])
                            self.false_time_step_linearization = self.__class__.false_time_step_linearization(service, version, mode, path + ["false_time_step_linearization"])
                            self.num_of_density_smoothing = self.__class__.num_of_density_smoothing(service, version, mode, path + ["num_of_density_smoothing"])
                            self.smoothed_density_stabilization_method = self.__class__.smoothed_density_stabilization_method(service, version, mode, path + ["smoothed_density_stabilization_method"])
                            super().__init__(service, version, mode, path)
                        class false_time_step_linearization(TUIMethod):
                            """
                            .
                            """
                        class num_of_density_smoothing(TUIMethod):
                            """
                            .
                            """
                        class smoothed_density_stabilization_method(TUIMethod):
                            """
                            .
                            """

                        class auto_dt_advanced_controls(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.dt_factor_max = self.__class__.dt_factor_max(service, version, mode, path + ["dt_factor_max"])
                                self.dt_factor_min = self.__class__.dt_factor_min(service, version, mode, path + ["dt_factor_min"])
                                self.dt_init_limit = self.__class__.dt_init_limit(service, version, mode, path + ["dt_init_limit"])
                                self.dt_max = self.__class__.dt_max(service, version, mode, path + ["dt_max"])
                                self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                                self.max_velocity_ratio = self.__class__.max_velocity_ratio(service, version, mode, path + ["max_velocity_ratio"])
                                super().__init__(service, version, mode, path)
                            class dt_factor_max(TUIMethod):
                                """
                                .
                                """
                            class dt_factor_min(TUIMethod):
                                """
                                .
                                """
                            class dt_init_limit(TUIMethod):
                                """
                                .
                                """
                            class dt_max(TUIMethod):
                                """
                                .
                                """
                            class enable(TUIMethod):
                                """
                                .
                                """
                            class max_velocity_ratio(TUIMethod):
                                """
                                .
                                """

                class boiling_parameters(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.liquid_vof_factor = self.__class__.liquid_vof_factor(service, version, mode, path + ["liquid_vof_factor"])
                        self.thin_film = self.__class__.thin_film(service, version, mode, path + ["thin_film"])
                        super().__init__(service, version, mode, path)
                    class liquid_vof_factor(TUIMethod):
                        """
                        .
                        """
                    class thin_film(TUIMethod):
                        """
                        .
                        """

                class compressible_flow(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.alternate_bc_formulation = self.__class__.alternate_bc_formulation(service, version, mode, path + ["alternate_bc_formulation"])
                        self.analytical_thermodynamic_derivatives = self.__class__.analytical_thermodynamic_derivatives(service, version, mode, path + ["analytical_thermodynamic_derivatives"])
                        self.enhanced_numerics = self.__class__.enhanced_numerics(service, version, mode, path + ["enhanced_numerics"])
                        super().__init__(service, version, mode, path)
                    class alternate_bc_formulation(TUIMethod):
                        """
                        .
                        """
                    class analytical_thermodynamic_derivatives(TUIMethod):
                        """
                        .
                        """
                    class enhanced_numerics(TUIMethod):
                        """
                        .
                        """

                class default_controls(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.revert_to_pre_r20_1_default_settings = self.__class__.revert_to_pre_r20_1_default_settings(service, version, mode, path + ["revert_to_pre_r20_1_default_settings"])
                        self.recommended_defaults_for_existing_cases = self.__class__.recommended_defaults_for_existing_cases(service, version, mode, path + ["recommended_defaults_for_existing_cases"])
                        super().__init__(service, version, mode, path)
                    class recommended_defaults_for_existing_cases(TUIMethod):
                        """
                        .
                        """

                    class revert_to_pre_r20_1_default_settings(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.old_default_of_operating_density_method = self.__class__.old_default_of_operating_density_method(service, version, mode, path + ["old_default_of_operating_density_method"])
                            self.old_default_of_volume_fraction_smoothing = self.__class__.old_default_of_volume_fraction_smoothing(service, version, mode, path + ["old_default_of_volume_fraction_smoothing"])
                            self.old_variant_of_pesto_for_cases_using_structured_mesh = self.__class__.old_variant_of_pesto_for_cases_using_structured_mesh(service, version, mode, path + ["old_variant_of_pesto_for_cases_using_structured_mesh"])
                            super().__init__(service, version, mode, path)
                        class old_default_of_operating_density_method(TUIMethod):
                            """
                            .
                            """
                        class old_default_of_volume_fraction_smoothing(TUIMethod):
                            """
                            .
                            """
                        class old_variant_of_pesto_for_cases_using_structured_mesh(TUIMethod):
                            """
                            .
                            """

                class face_pressure_controls(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.face_pressure_options = self.__class__.face_pressure_options(service, version, mode, path + ["face_pressure_options"])
                        super().__init__(service, version, mode, path)

                    class face_pressure_options(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.exclude_transient_term_in_face_pressure_calc = self.__class__.exclude_transient_term_in_face_pressure_calc(service, version, mode, path + ["exclude_transient_term_in_face_pressure_calc"])
                            self.face_pressure_calculation_method = self.__class__.face_pressure_calculation_method(service, version, mode, path + ["face_pressure_calculation_method"])
                            self.pressure_corr_grad = self.__class__.pressure_corr_grad(service, version, mode, path + ["pressure_corr_grad"])
                            super().__init__(service, version, mode, path)
                        class exclude_transient_term_in_face_pressure_calc(TUIMethod):
                            """
                            .
                            """
                        class face_pressure_calculation_method(TUIMethod):
                            """
                            .
                            """
                        class pressure_corr_grad(TUIMethod):
                            """
                            .
                            """

                class heat_mass_transfer(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.area_density = self.__class__.area_density(service, version, mode, path + ["area_density"])
                        self.boiling = self.__class__.boiling(service, version, mode, path + ["boiling"])
                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                        self.evaporation_condensation = self.__class__.evaporation_condensation(service, version, mode, path + ["evaporation_condensation"])
                        self.alternative_energy_treatment = self.__class__.alternative_energy_treatment(service, version, mode, path + ["alternative_energy_treatment"])
                        super().__init__(service, version, mode, path)
                    class alternative_energy_treatment(TUIMethod):
                        """
                        .
                        """

                    class area_density(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.ia_grad_sym = self.__class__.ia_grad_sym(service, version, mode, path + ["ia_grad_sym"])
                            self.vof_min_seeding = self.__class__.vof_min_seeding(service, version, mode, path + ["vof_min_seeding"])
                            super().__init__(service, version, mode, path)
                        class ia_grad_sym(TUIMethod):
                            """
                            .
                            """
                        class vof_min_seeding(TUIMethod):
                            """
                            .
                            """

                    class boiling(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.heat_flux_relaxation_factor = self.__class__.heat_flux_relaxation_factor(service, version, mode, path + ["heat_flux_relaxation_factor"])
                            self.show_expert_options = self.__class__.show_expert_options(service, version, mode, path + ["show_expert_options"])
                            self.two_resistance_boiling_framework = self.__class__.two_resistance_boiling_framework(service, version, mode, path + ["two_resistance_boiling_framework"])
                            super().__init__(service, version, mode, path)
                        class heat_flux_relaxation_factor(TUIMethod):
                            """
                            .
                            """
                        class show_expert_options(TUIMethod):
                            """
                            .
                            """
                        class two_resistance_boiling_framework(TUIMethod):
                            """
                            .
                            """

                    class cavitation(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.display_clipped_pressure = self.__class__.display_clipped_pressure(service, version, mode, path + ["display_clipped_pressure"])
                            self.max_vapor_pressure_ratio = self.__class__.max_vapor_pressure_ratio(service, version, mode, path + ["max_vapor_pressure_ratio"])
                            self.min_vapor_pressure = self.__class__.min_vapor_pressure(service, version, mode, path + ["min_vapor_pressure"])
                            self.old_treatment_for_turbulent_diffusion = self.__class__.old_treatment_for_turbulent_diffusion(service, version, mode, path + ["old_treatment_for_turbulent_diffusion"])
                            self.p_limit_method = self.__class__.p_limit_method(service, version, mode, path + ["p_limit_method"])
                            self.schnerr_cond_coeff = self.__class__.schnerr_cond_coeff(service, version, mode, path + ["schnerr_cond_coeff"])
                            self.schnerr_evap_coeff = self.__class__.schnerr_evap_coeff(service, version, mode, path + ["schnerr_evap_coeff"])
                            self.turbulent_diffusion = self.__class__.turbulent_diffusion(service, version, mode, path + ["turbulent_diffusion"])
                            super().__init__(service, version, mode, path)
                        class display_clipped_pressure(TUIMethod):
                            """
                            .
                            """
                        class max_vapor_pressure_ratio(TUIMethod):
                            """
                            .
                            """
                        class min_vapor_pressure(TUIMethod):
                            """
                            .
                            """
                        class old_treatment_for_turbulent_diffusion(TUIMethod):
                            """
                            .
                            """
                        class p_limit_method(TUIMethod):
                            """
                            .
                            """
                        class schnerr_cond_coeff(TUIMethod):
                            """
                            .
                            """
                        class schnerr_evap_coeff(TUIMethod):
                            """
                            .
                            """
                        class turbulent_diffusion(TUIMethod):
                            """
                            .
                            """

                    class evaporation_condensation(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.ia_norm_min_limit = self.__class__.ia_norm_min_limit(service, version, mode, path + ["ia_norm_min_limit"])
                            self.max_rel_humidity = self.__class__.max_rel_humidity(service, version, mode, path + ["max_rel_humidity"])
                            self.vof_from_max_limit = self.__class__.vof_from_max_limit(service, version, mode, path + ["vof_from_max_limit"])
                            self.vof_from_min_limit = self.__class__.vof_from_min_limit(service, version, mode, path + ["vof_from_min_limit"])
                            self.vof_to_max_limit = self.__class__.vof_to_max_limit(service, version, mode, path + ["vof_to_max_limit"])
                            self.vof_to_min_limit = self.__class__.vof_to_min_limit(service, version, mode, path + ["vof_to_min_limit"])
                            super().__init__(service, version, mode, path)
                        class ia_norm_min_limit(TUIMethod):
                            """
                            .
                            """
                        class max_rel_humidity(TUIMethod):
                            """
                            .
                            """
                        class vof_from_max_limit(TUIMethod):
                            """
                            .
                            """
                        class vof_from_min_limit(TUIMethod):
                            """
                            .
                            """
                        class vof_to_max_limit(TUIMethod):
                            """
                            .
                            """
                        class vof_to_min_limit(TUIMethod):
                            """
                            .
                            """

                class porous_media(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.capillary_pressure_as_diffusion = self.__class__.capillary_pressure_as_diffusion(service, version, mode, path + ["capillary_pressure_as_diffusion"])
                        self.relative_permeability = self.__class__.relative_permeability(service, version, mode, path + ["relative_permeability"])
                        super().__init__(service, version, mode, path)
                    class capillary_pressure_as_diffusion(TUIMethod):
                        """
                        .
                        """
                    class relative_permeability(TUIMethod):
                        """
                        .
                        """

                class solution_stabilization(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.additional_stabilization_controls = self.__class__.additional_stabilization_controls(service, version, mode, path + ["additional_stabilization_controls"])
                        self.velocity_limiting_treatment = self.__class__.velocity_limiting_treatment(service, version, mode, path + ["velocity_limiting_treatment"])
                        self.execute_additional_stability_controls = self.__class__.execute_additional_stability_controls(service, version, mode, path + ["execute_additional_stability_controls"])
                        self.execute_advanced_stabilization = self.__class__.execute_advanced_stabilization(service, version, mode, path + ["execute_advanced_stabilization"])
                        self.execute_settings_optimization = self.__class__.execute_settings_optimization(service, version, mode, path + ["execute_settings_optimization"])
                        super().__init__(service, version, mode, path)
                    class execute_additional_stability_controls(TUIMethod):
                        """
                        .
                        """
                    class execute_advanced_stabilization(TUIMethod):
                        """
                        .
                        """
                    class execute_settings_optimization(TUIMethod):
                        """
                        .
                        """

                    class additional_stabilization_controls(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.blended_compressive_scheme = self.__class__.blended_compressive_scheme(service, version, mode, path + ["blended_compressive_scheme"])
                            self.pseudo_time_stabilization = self.__class__.pseudo_time_stabilization(service, version, mode, path + ["pseudo_time_stabilization"])
                            super().__init__(service, version, mode, path)
                        class blended_compressive_scheme(TUIMethod):
                            """
                            .
                            """
                        class pseudo_time_stabilization(TUIMethod):
                            """
                            .
                            """

                    class velocity_limiting_treatment(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.set_damping_strengths = self.__class__.set_damping_strengths(service, version, mode, path + ["set_damping_strengths"])
                            self.set_velocity_and_vof_cutoffs = self.__class__.set_velocity_and_vof_cutoffs(service, version, mode, path + ["set_velocity_and_vof_cutoffs"])
                            self.enable_velocity_limiting = self.__class__.enable_velocity_limiting(service, version, mode, path + ["enable_velocity_limiting"])
                            self.set_damping_strength = self.__class__.set_damping_strength(service, version, mode, path + ["set_damping_strength"])
                            self.set_velocity_cutoff = self.__class__.set_velocity_cutoff(service, version, mode, path + ["set_velocity_cutoff"])
                            self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                            super().__init__(service, version, mode, path)
                        class enable_velocity_limiting(TUIMethod):
                            """
                            .
                            """
                        class set_damping_strength(TUIMethod):
                            """
                            .
                            """
                        class set_velocity_cutoff(TUIMethod):
                            """
                            .
                            """
                        class verbosity(TUIMethod):
                            """
                            .
                            """

                        class set_damping_strengths(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.create = self.__class__.create(service, version, mode, path + ["create"])
                                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                                self.list = self.__class__.list(service, version, mode, path + ["list"])
                                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                                self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                                self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                                super().__init__(service, version, mode, path)
                            class create(TUIMethod):
                                """
                                Create a new set-damping-strengths object.
                                """
                            class delete(TUIMethod):
                                """
                                .
                                """
                            class edit(TUIMethod):
                                """
                                Edit set-damping-strengths object.
                                """
                            class list(TUIMethod):
                                """
                                .
                                """
                            class list_properties(TUIMethod):
                                """
                                .
                                """
                            class make_a_copy(TUIMethod):
                                """
                                .
                                """
                            class rename(TUIMethod):
                                """
                                Rename set-damping-strengths object.
                                """

                        class set_velocity_and_vof_cutoffs(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.create = self.__class__.create(service, version, mode, path + ["create"])
                                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                                self.list = self.__class__.list(service, version, mode, path + ["list"])
                                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                                self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                                self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                                super().__init__(service, version, mode, path)
                            class create(TUIMethod):
                                """
                                Create a new set-velocity-and-vof-cutoffs object.
                                """
                            class delete(TUIMethod):
                                """
                                .
                                """
                            class edit(TUIMethod):
                                """
                                Edit set-velocity-and-vof-cutoffs object.
                                """
                            class list(TUIMethod):
                                """
                                .
                                """
                            class list_properties(TUIMethod):
                                """
                                .
                                """
                            class make_a_copy(TUIMethod):
                                """
                                .
                                """
                            class rename(TUIMethod):
                                """
                                Rename set-velocity-and-vof-cutoffs object.
                                """

                class viscous_flow(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.interfacial_artificial_viscosity = self.__class__.interfacial_artificial_viscosity(service, version, mode, path + ["interfacial_artificial_viscosity"])
                        self.density_func_expo = self.__class__.density_func_expo(service, version, mode, path + ["density_func_expo"])
                        self.density_ratio_cutoff = self.__class__.density_ratio_cutoff(service, version, mode, path + ["density_ratio_cutoff"])
                        self.turb_visc_based_damping = self.__class__.turb_visc_based_damping(service, version, mode, path + ["turb_visc_based_damping"])
                        self.viscosity_averaging = self.__class__.viscosity_averaging(service, version, mode, path + ["viscosity_averaging"])
                        super().__init__(service, version, mode, path)
                    class density_func_expo(TUIMethod):
                        """
                        .
                        """
                    class density_ratio_cutoff(TUIMethod):
                        """
                        .
                        """
                    class turb_visc_based_damping(TUIMethod):
                        """
                        .
                        """
                    class viscosity_averaging(TUIMethod):
                        """
                        .
                        """

                    class interfacial_artificial_viscosity(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.boundry_treatment = self.__class__.boundry_treatment(service, version, mode, path + ["boundry_treatment"])
                            self.density_func_options = self.__class__.density_func_options(service, version, mode, path + ["density_func_options"])
                            self.exponent_density_func = self.__class__.exponent_density_func(service, version, mode, path + ["exponent_density_func"])
                            self.exponent_smoothing_func = self.__class__.exponent_smoothing_func(service, version, mode, path + ["exponent_smoothing_func"])
                            self.n_smooth_for_interfacial_regims = self.__class__.n_smooth_for_interfacial_regims(service, version, mode, path + ["n_smooth_for_interfacial_regims"])
                            self.near_wall_treatment = self.__class__.near_wall_treatment(service, version, mode, path + ["near_wall_treatment"])
                            self.sm_relax_factor = self.__class__.sm_relax_factor(service, version, mode, path + ["sm_relax_factor"])
                            self.viscous_func_options = self.__class__.viscous_func_options(service, version, mode, path + ["viscous_func_options"])
                            super().__init__(service, version, mode, path)
                        class boundry_treatment(TUIMethod):
                            """
                            .
                            """
                        class density_func_options(TUIMethod):
                            """
                            .
                            """
                        class exponent_density_func(TUIMethod):
                            """
                            .
                            """
                        class exponent_smoothing_func(TUIMethod):
                            """
                            .
                            """
                        class n_smooth_for_interfacial_regims(TUIMethod):
                            """
                            .
                            """
                        class near_wall_treatment(TUIMethod):
                            """
                            .
                            """
                        class sm_relax_factor(TUIMethod):
                            """
                            .
                            """
                        class viscous_func_options(TUIMethod):
                            """
                            .
                            """

            class nb_gradient_boundary_option(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.nb_gradient = self.__class__.nb_gradient(service, version, mode, path + ["nb_gradient"])
                    self.nb_gradient_dbns = self.__class__.nb_gradient_dbns(service, version, mode, path + ["nb_gradient_dbns"])
                    super().__init__(service, version, mode, path)
                class nb_gradient(TUIMethod):
                    """
                    .
                    """
                class nb_gradient_dbns(TUIMethod):
                    """
                    .
                    """

            class nita_expert_controls(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.hybrid_nita_settings = self.__class__.hybrid_nita_settings(service, version, mode, path + ["hybrid_nita_settings"])
                    self.skewness_neighbor_coupling = self.__class__.skewness_neighbor_coupling(service, version, mode, path + ["skewness_neighbor_coupling"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    super().__init__(service, version, mode, path)
                class skewness_neighbor_coupling(TUIMethod):
                    """
                    .
                    """
                class verbosity(TUIMethod):
                    """
                    .
                    """

                class hybrid_nita_settings(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.multi_phase_setting = self.__class__.multi_phase_setting(service, version, mode, path + ["multi_phase_setting"])
                        self.single_phase_setting = self.__class__.single_phase_setting(service, version, mode, path + ["single_phase_setting"])
                        super().__init__(service, version, mode, path)
                    class single_phase_setting(TUIMethod):
                        """
                        .
                        """

                    class multi_phase_setting(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                            self.options = self.__class__.options(service, version, mode, path + ["options"])
                            super().__init__(service, version, mode, path)
                        class enable(TUIMethod):
                            """
                            .
                            """
                        class options(TUIMethod):
                            """
                            .
                            """

            class overset(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.high_order_pressure = self.__class__.high_order_pressure(service, version, mode, path + ["high_order_pressure"])
                    self.interpolation_method = self.__class__.interpolation_method(service, version, mode, path + ["interpolation_method"])
                    self.orphan_cell_treatment = self.__class__.orphan_cell_treatment(service, version, mode, path + ["orphan_cell_treatment"])
                    super().__init__(service, version, mode, path)
                class high_order_pressure(TUIMethod):
                    """
                    .
                    """
                class interpolation_method(TUIMethod):
                    """
                    .
                    """
                class orphan_cell_treatment(TUIMethod):
                    """
                    .
                    """

                class expert(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.hybrid_mode_selection = self.__class__.hybrid_mode_selection(service, version, mode, path + ["hybrid_mode_selection"])
                        self.mass_flux_correction_method = self.__class__.mass_flux_correction_method(service, version, mode, path + ["mass_flux_correction_method"])
                        super().__init__(service, version, mode, path)
                    class hybrid_mode_selection(TUIMethod):
                        """
                        .
                        """
                    class mass_flux_correction_method(TUIMethod):
                        """
                        .
                        """

            class p_v_coupling(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.coupled_form = self.__class__.coupled_form(service, version, mode, path + ["coupled_form"])
                    self.flow_scheme = self.__class__.flow_scheme(service, version, mode, path + ["flow_scheme"])
                    self.solve_n_phase = self.__class__.solve_n_phase(service, version, mode, path + ["solve_n_phase"])
                    super().__init__(service, version, mode, path)
                class coupled_form(TUIMethod):
                    """
                    .
                    """
                class flow_scheme(TUIMethod):
                    """
                    .
                    """
                class solve_n_phase(TUIMethod):
                    """
                    .
                    """

            class phase_based_vof_discretization(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new phase-based-vof-discretization object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit phase-based-vof-discretization object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename phase-based-vof-discretization object.
                    """

            class pseudo_time_method(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.convergence_acceleration_for_stretched_meshes = self.__class__.convergence_acceleration_for_stretched_meshes(service, version, mode, path + ["convergence_acceleration_for_stretched_meshes"])
                    self.formulation = self.__class__.formulation(service, version, mode, path + ["formulation"])
                    self.relaxation_bounds = self.__class__.relaxation_bounds(service, version, mode, path + ["relaxation_bounds"])
                    self.relaxation_method = self.__class__.relaxation_method(service, version, mode, path + ["relaxation_method"])
                    super().__init__(service, version, mode, path)
                class relaxation_bounds(TUIMethod):
                    """
                    .
                    """
                class relaxation_method(TUIMethod):
                    """
                    .
                    """

                class convergence_acceleration_for_stretched_meshes(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.casm_cutoff_multiplier = self.__class__.casm_cutoff_multiplier(service, version, mode, path + ["casm_cutoff_multiplier"])
                        self.convergence_acceleration_type = self.__class__.convergence_acceleration_type(service, version, mode, path + ["convergence_acceleration_type"])
                        super().__init__(service, version, mode, path)
                    class casm_cutoff_multiplier(TUIMethod):
                        """
                        .
                        """
                    class convergence_acceleration_type(TUIMethod):
                        """
                        .
                        """

                class formulation(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.coupled_solver = self.__class__.coupled_solver(service, version, mode, path + ["coupled_solver"])
                        self.density_based_solver = self.__class__.density_based_solver(service, version, mode, path + ["density_based_solver"])
                        self.segregated_solver = self.__class__.segregated_solver(service, version, mode, path + ["segregated_solver"])
                        super().__init__(service, version, mode, path)
                    class coupled_solver(TUIMethod):
                        """
                        .
                        """
                    class density_based_solver(TUIMethod):
                        """
                        .
                        """
                    class segregated_solver(TUIMethod):
                        """
                        .
                        """

            class reduced_rank_extrapolation_options(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.skip_iter_count = self.__class__.skip_iter_count(service, version, mode, path + ["skip_iter_count"])
                    self.subspace_size = self.__class__.subspace_size(service, version, mode, path + ["subspace_size"])
                    super().__init__(service, version, mode, path)
                class skip_iter_count(TUIMethod):
                    """
                    .
                    """
                class subspace_size(TUIMethod):
                    """
                    .
                    """

            class residual_smoothing(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.residual_smoothing_factor = self.__class__.residual_smoothing_factor(service, version, mode, path + ["residual_smoothing_factor"])
                    self.residual_smoothing_iter_count = self.__class__.residual_smoothing_iter_count(service, version, mode, path + ["residual_smoothing_iter_count"])
                    super().__init__(service, version, mode, path)
                class residual_smoothing_factor(TUIMethod):
                    """
                    .
                    """
                class residual_smoothing_iter_count(TUIMethod):
                    """
                    .
                    """

            class vof_numerics(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.force_treatment_of_unsteady_rc = self.__class__.force_treatment_of_unsteady_rc(service, version, mode, path + ["force_treatment_of_unsteady_rc"])
                    self.high_order_rc = self.__class__.high_order_rc(service, version, mode, path + ["high_order_rc"])
                    self.high_order_rc_hybrid_treatment = self.__class__.high_order_rc_hybrid_treatment(service, version, mode, path + ["high_order_rc_hybrid_treatment"])
                    self.new_framework_for_vof_specific_node_based_treatment = self.__class__.new_framework_for_vof_specific_node_based_treatment(service, version, mode, path + ["new_framework_for_vof_specific_node_based_treatment"])
                    self.unstructured_var_presto_scheme = self.__class__.unstructured_var_presto_scheme(service, version, mode, path + ["unstructured_var_presto_scheme"])
                    super().__init__(service, version, mode, path)
                class force_treatment_of_unsteady_rc(TUIMethod):
                    """
                    .
                    """
                class high_order_rc(TUIMethod):
                    """
                    .
                    """
                class high_order_rc_hybrid_treatment(TUIMethod):
                    """
                    .
                    """
                class new_framework_for_vof_specific_node_based_treatment(TUIMethod):
                    """
                    .
                    """
                class unstructured_var_presto_scheme(TUIMethod):
                    """
                    .
                    """

            class warped_face_gradient_correction(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.mode = self.__class__.mode(service, version, mode, path + ["mode"])
                    self.turbulence_options = self.__class__.turbulence_options(service, version, mode, path + ["turbulence_options"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    .
                    """
                class mode(TUIMethod):
                    """
                    .
                    """
                class turbulence_options(TUIMethod):
                    """
                    .
                    """

        class monitor(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.convergence_conditions = self.__class__.convergence_conditions(service, version, mode, path + ["convergence_conditions"])
                self.report_files = self.__class__.report_files(service, version, mode, path + ["report_files"])
                self.report_plots = self.__class__.report_plots(service, version, mode, path + ["report_plots"])
                self.residual = self.__class__.residual(service, version, mode, path + ["residual"])
                super().__init__(service, version, mode, path)

            class convergence_conditions(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.convergence_reports = self.__class__.convergence_reports(service, version, mode, path + ["convergence_reports"])
                    self.check_for = self.__class__.check_for(service, version, mode, path + ["check_for"])
                    self.condition = self.__class__.condition(service, version, mode, path + ["condition"])
                    self.frequency = self.__class__.frequency(service, version, mode, path + ["frequency"])
                    super().__init__(service, version, mode, path)
                class check_for(TUIMethod):
                    """
                    .
                    """
                class condition(TUIMethod):
                    """
                    .
                    """
                class frequency(TUIMethod):
                    """
                    .
                    """

                class convergence_reports(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.create = self.__class__.create(service, version, mode, path + ["create"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                        self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                        super().__init__(service, version, mode, path)
                    class create(TUIMethod):
                        """
                        Create a new convergence-reports object.
                        """
                    class delete(TUIMethod):
                        """
                        .
                        """
                    class edit(TUIMethod):
                        """
                        Edit convergence-reports object.
                        """
                    class list(TUIMethod):
                        """
                        .
                        """
                    class list_properties(TUIMethod):
                        """
                        .
                        """
                    class make_a_copy(TUIMethod):
                        """
                        .
                        """
                    class rename(TUIMethod):
                        """
                        Rename convergence-reports object.
                        """

            class report_files(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new report-files object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit report-files object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename report-files object.
                    """

            class report_plots(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new report-plots object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit report-plots object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename report-plots object.
                    """

            class residual(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                    self.curves = self.__class__.curves(service, version, mode, path + ["curves"])
                    self.equations = self.__class__.equations(service, version, mode, path + ["equations"])
                    self.options = self.__class__.options(service, version, mode, path + ["options"])
                    self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
                    self.renormalize = self.__class__.renormalize(service, version, mode, path + ["renormalize"])
                    self.reset = self.__class__.reset(service, version, mode, path + ["reset"])
                    super().__init__(service, version, mode, path)
                class plot(TUIMethod):
                    """
                    .
                    """
                class renormalize(TUIMethod):
                    """
                    .
                    """
                class reset(TUIMethod):
                    """
                    .
                    """

                class axes(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.x = self.__class__.x(service, version, mode, path + ["x"])
                        self.y = self.__class__.y(service, version, mode, path + ["y"])
                        self.background_color = self.__class__.background_color(service, version, mode, path + ["background_color"])
                        super().__init__(service, version, mode, path)
                    class background_color(TUIMethod):
                        """
                        .
                        """

                    class x(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.major_gridlines = self.__class__.major_gridlines(service, version, mode, path + ["major_gridlines"])
                            self.minor_gridlines = self.__class__.minor_gridlines(service, version, mode, path + ["minor_gridlines"])
                            self.number_format = self.__class__.number_format(service, version, mode, path + ["number_format"])
                            self.auto_range = self.__class__.auto_range(service, version, mode, path + ["auto_range"])
                            self.label = self.__class__.label(service, version, mode, path + ["label"])
                            self.log_scale = self.__class__.log_scale(service, version, mode, path + ["log_scale"])
                            self.max = self.__class__.max(service, version, mode, path + ["max"])
                            self.min = self.__class__.min(service, version, mode, path + ["min"])
                            self.show_major_gridlines = self.__class__.show_major_gridlines(service, version, mode, path + ["show_major_gridlines"])
                            self.show_minor_gridlines = self.__class__.show_minor_gridlines(service, version, mode, path + ["show_minor_gridlines"])
                            super().__init__(service, version, mode, path)
                        class auto_range(TUIMethod):
                            """
                            .
                            """
                        class label(TUIMethod):
                            """
                            .
                            """
                        class log_scale(TUIMethod):
                            """
                            .
                            """
                        class max(TUIMethod):
                            """
                            .
                            """
                        class min(TUIMethod):
                            """
                            .
                            """
                        class show_major_gridlines(TUIMethod):
                            """
                            .
                            """
                        class show_minor_gridlines(TUIMethod):
                            """
                            .
                            """

                        class major_gridlines(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.weight = self.__class__.weight(service, version, mode, path + ["weight"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                .
                                """
                            class weight(TUIMethod):
                                """
                                .
                                """

                        class minor_gridlines(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.weight = self.__class__.weight(service, version, mode, path + ["weight"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                .
                                """
                            class weight(TUIMethod):
                                """
                                .
                                """

                        class number_format(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.format_type = self.__class__.format_type(service, version, mode, path + ["format_type"])
                                self.precision = self.__class__.precision(service, version, mode, path + ["precision"])
                                super().__init__(service, version, mode, path)
                            class format_type(TUIMethod):
                                """
                                .
                                """
                            class precision(TUIMethod):
                                """
                                .
                                """

                    class y(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.major_gridlines = self.__class__.major_gridlines(service, version, mode, path + ["major_gridlines"])
                            self.minor_gridlines = self.__class__.minor_gridlines(service, version, mode, path + ["minor_gridlines"])
                            self.number_format = self.__class__.number_format(service, version, mode, path + ["number_format"])
                            self.auto_range = self.__class__.auto_range(service, version, mode, path + ["auto_range"])
                            self.label = self.__class__.label(service, version, mode, path + ["label"])
                            self.log_scale = self.__class__.log_scale(service, version, mode, path + ["log_scale"])
                            self.max = self.__class__.max(service, version, mode, path + ["max"])
                            self.min = self.__class__.min(service, version, mode, path + ["min"])
                            self.show_major_gridlines = self.__class__.show_major_gridlines(service, version, mode, path + ["show_major_gridlines"])
                            self.show_minor_gridlines = self.__class__.show_minor_gridlines(service, version, mode, path + ["show_minor_gridlines"])
                            super().__init__(service, version, mode, path)
                        class auto_range(TUIMethod):
                            """
                            .
                            """
                        class label(TUIMethod):
                            """
                            .
                            """
                        class log_scale(TUIMethod):
                            """
                            .
                            """
                        class max(TUIMethod):
                            """
                            .
                            """
                        class min(TUIMethod):
                            """
                            .
                            """
                        class show_major_gridlines(TUIMethod):
                            """
                            .
                            """
                        class show_minor_gridlines(TUIMethod):
                            """
                            .
                            """

                        class major_gridlines(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.weight = self.__class__.weight(service, version, mode, path + ["weight"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                .
                                """
                            class weight(TUIMethod):
                                """
                                .
                                """

                        class minor_gridlines(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.weight = self.__class__.weight(service, version, mode, path + ["weight"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                .
                                """
                            class weight(TUIMethod):
                                """
                                .
                                """

                        class number_format(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.format_type = self.__class__.format_type(service, version, mode, path + ["format_type"])
                                self.precision = self.__class__.precision(service, version, mode, path + ["precision"])
                                super().__init__(service, version, mode, path)
                            class format_type(TUIMethod):
                                """
                                .
                                """
                            class precision(TUIMethod):
                                """
                                .
                                """

                class curves(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.number_of_objects = self.__class__.number_of_objects(service, version, mode, path + ["number_of_objects"])
                        super().__init__(service, version, mode, path)
                    class edit(TUIMethod):
                        """
                        Edit curves object.
                        """
                    class list_properties(TUIMethod):
                        """
                        .
                        """
                    class number_of_objects(TUIMethod):
                        """
                        Set number of objects for curves.
                        """

                class equations(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.create = self.__class__.create(service, version, mode, path + ["create"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                        self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                        super().__init__(service, version, mode, path)
                    class create(TUIMethod):
                        """
                        Create a new equations object.
                        """
                    class delete(TUIMethod):
                        """
                        .
                        """
                    class edit(TUIMethod):
                        """
                        Edit equations object.
                        """
                    class list(TUIMethod):
                        """
                        .
                        """
                    class list_properties(TUIMethod):
                        """
                        .
                        """
                    class make_a_copy(TUIMethod):
                        """
                        .
                        """
                    class rename(TUIMethod):
                        """
                        Rename equations object.
                        """

                class options(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.residual_values = self.__class__.residual_values(service, version, mode, path + ["residual_values"])
                        self.criterion_type = self.__class__.criterion_type(service, version, mode, path + ["criterion_type"])
                        self.enhanced_continuity_residual = self.__class__.enhanced_continuity_residual(service, version, mode, path + ["enhanced_continuity_residual"])
                        self.n_display = self.__class__.n_display(service, version, mode, path + ["n_display"])
                        self.n_maximize_norms = self.__class__.n_maximize_norms(service, version, mode, path + ["n_maximize_norms"])
                        self.n_save = self.__class__.n_save(service, version, mode, path + ["n_save"])
                        self.normalize = self.__class__.normalize(service, version, mode, path + ["normalize"])
                        self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
                        self.print = self.__class__.print(service, version, mode, path + ["print"])
                        super().__init__(service, version, mode, path)
                    class criterion_type(TUIMethod):
                        """
                        .
                        """
                    class enhanced_continuity_residual(TUIMethod):
                        """
                        .
                        """
                    class n_display(TUIMethod):
                        """
                        .
                        """
                    class n_maximize_norms(TUIMethod):
                        """
                        .
                        """
                    class n_save(TUIMethod):
                        """
                        .
                        """
                    class normalize(TUIMethod):
                        """
                        .
                        """
                    class plot(TUIMethod):
                        """
                        .
                        """
                    class print(TUIMethod):
                        """
                        .
                        """

                    class residual_values(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.compute_local_scale = self.__class__.compute_local_scale(service, version, mode, path + ["compute_local_scale"])
                            self.scale_residuals = self.__class__.scale_residuals(service, version, mode, path + ["scale_residuals"])
                            self.scale_type = self.__class__.scale_type(service, version, mode, path + ["scale_type"])
                            super().__init__(service, version, mode, path)
                        class compute_local_scale(TUIMethod):
                            """
                            .
                            """
                        class scale_residuals(TUIMethod):
                            """
                            .
                            """
                        class scale_type(TUIMethod):
                            """
                            .
                            """

        class report_definitions(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.aeromechanics = self.__class__.aeromechanics(service, version, mode, path + ["aeromechanics"])
                self.custom = self.__class__.custom(service, version, mode, path + ["custom"])
                self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                self.expression = self.__class__.expression(service, version, mode, path + ["expression"])
                self.flux = self.__class__.flux(service, version, mode, path + ["flux"])
                self.force = self.__class__.force(service, version, mode, path + ["force"])
                self.icing = self.__class__.icing(service, version, mode, path + ["icing"])
                self.injection = self.__class__.injection(service, version, mode, path + ["injection"])
                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                self.mesh = self.__class__.mesh(service, version, mode, path + ["mesh"])
                self.moment = self.__class__.moment(service, version, mode, path + ["moment"])
                self.single_valued_expression = self.__class__.single_valued_expression(service, version, mode, path + ["single_valued_expression"])
                self.surface = self.__class__.surface(service, version, mode, path + ["surface"])
                self.time = self.__class__.time(service, version, mode, path + ["time"])
                self.user_defined = self.__class__.user_defined(service, version, mode, path + ["user_defined"])
                self.volume = self.__class__.volume(service, version, mode, path + ["volume"])
                self.compute = self.__class__.compute(service, version, mode, path + ["compute"])
                self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                super().__init__(service, version, mode, path)
            class compute(TUIMethod):
                """
                .
                """
            class copy(TUIMethod):
                """
                .
                """

            class aeromechanics(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new aeromechanics object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit aeromechanics object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename aeromechanics object.
                    """

            class custom(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new custom object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit custom object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename custom object.
                    """

            class drag(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new drag object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit drag object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename drag object.
                    """

            class expression(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new expression object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit expression object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename expression object.
                    """

            class flux(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new flux object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit flux object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename flux object.
                    """

            class force(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new force object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit force object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename force object.
                    """

            class icing(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new icing object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit icing object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename icing object.
                    """

            class injection(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new injection object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit injection object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename injection object.
                    """

            class lift(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new lift object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit lift object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename lift object.
                    """

            class mesh(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new mesh object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit mesh object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename mesh object.
                    """

            class moment(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new moment object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit moment object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename moment object.
                    """

            class single_valued_expression(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new single-valued-expression object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit single-valued-expression object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename single-valued-expression object.
                    """

            class surface(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new surface object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit surface object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename surface object.
                    """

            class time(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new time object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit time object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename time object.
                    """

            class user_defined(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new user-defined object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit user-defined object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename user-defined object.
                    """

            class volume(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create a new volume object.
                    """
                class delete(TUIMethod):
                    """
                    .
                    """
                class edit(TUIMethod):
                    """
                    Edit volume object.
                    """
                class list(TUIMethod):
                    """
                    .
                    """
                class list_properties(TUIMethod):
                    """
                    .
                    """
                class make_a_copy(TUIMethod):
                    """
                    .
                    """
                class rename(TUIMethod):
                    """
                    Rename volume object.
                    """

        class run_calculation(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.adaptive_time_stepping = self.__class__.adaptive_time_stepping(service, version, mode, path + ["adaptive_time_stepping"])
                self.cfl_based_adaptive_time_stepping = self.__class__.cfl_based_adaptive_time_stepping(service, version, mode, path + ["cfl_based_adaptive_time_stepping"])
                self.data_sampling = self.__class__.data_sampling(service, version, mode, path + ["data_sampling"])
                self.data_sampling_options = self.__class__.data_sampling_options(service, version, mode, path + ["data_sampling_options"])
                self.pseudo_time_settings = self.__class__.pseudo_time_settings(service, version, mode, path + ["pseudo_time_settings"])
                self.transient_controls = self.__class__.transient_controls(service, version, mode, path + ["transient_controls"])
                self.calculate = self.__class__.calculate(service, version, mode, path + ["calculate"])
                self.dual_time_iterate = self.__class__.dual_time_iterate(service, version, mode, path + ["dual_time_iterate"])
                self.interrupt = self.__class__.interrupt(service, version, mode, path + ["interrupt"])
                self.iter_count = self.__class__.iter_count(service, version, mode, path + ["iter_count"])
                self.iterate = self.__class__.iterate(service, version, mode, path + ["iterate"])
                self.profile_update_interval = self.__class__.profile_update_interval(service, version, mode, path + ["profile_update_interval"])
                self.reporting_interval = self.__class__.reporting_interval(service, version, mode, path + ["reporting_interval"])
                self.residual_verbosity = self.__class__.residual_verbosity(service, version, mode, path + ["residual_verbosity"])
                self.time_step_count = self.__class__.time_step_count(service, version, mode, path + ["time_step_count"])
                super().__init__(service, version, mode, path)
            class calculate(TUIMethod):
                """
                .
                """
            class dual_time_iterate(TUIMethod):
                """
                .
                """
            class interrupt(TUIMethod):
                """
                .
                """
            class iter_count(TUIMethod):
                """
                .
                """
            class iterate(TUIMethod):
                """
                .
                """
            class profile_update_interval(TUIMethod):
                """
                .
                """
            class reporting_interval(TUIMethod):
                """
                .
                """
            class residual_verbosity(TUIMethod):
                """
                .
                """
            class time_step_count(TUIMethod):
                """
                .
                """

            class adaptive_time_stepping(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.enabled = self.__class__.enabled(service, version, mode, path + ["enabled"])
                    self.error_tolerance = self.__class__.error_tolerance(service, version, mode, path + ["error_tolerance"])
                    self.fixed_time_step_count = self.__class__.fixed_time_step_count(service, version, mode, path + ["fixed_time_step_count"])
                    self.max_step_change_factor = self.__class__.max_step_change_factor(service, version, mode, path + ["max_step_change_factor"])
                    self.max_time_step = self.__class__.max_time_step(service, version, mode, path + ["max_time_step"])
                    self.min_step_change_factor = self.__class__.min_step_change_factor(service, version, mode, path + ["min_step_change_factor"])
                    self.min_time_step = self.__class__.min_time_step(service, version, mode, path + ["min_time_step"])
                    self.time_end = self.__class__.time_end(service, version, mode, path + ["time_end"])
                    self.user_defined_timestep = self.__class__.user_defined_timestep(service, version, mode, path + ["user_defined_timestep"])
                    super().__init__(service, version, mode, path)
                class enabled(TUIMethod):
                    """
                    .
                    """
                class error_tolerance(TUIMethod):
                    """
                    .
                    """
                class fixed_time_step_count(TUIMethod):
                    """
                    .
                    """
                class max_step_change_factor(TUIMethod):
                    """
                    .
                    """
                class max_time_step(TUIMethod):
                    """
                    .
                    """
                class min_step_change_factor(TUIMethod):
                    """
                    .
                    """
                class min_time_step(TUIMethod):
                    """
                    .
                    """
                class time_end(TUIMethod):
                    """
                    .
                    """
                class user_defined_timestep(TUIMethod):
                    """
                    .
                    """

            class cfl_based_adaptive_time_stepping(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.desired_cfl = self.__class__.desired_cfl(service, version, mode, path + ["desired_cfl"])
                    self.enabled = self.__class__.enabled(service, version, mode, path + ["enabled"])
                    self.initial_time_step = self.__class__.initial_time_step(service, version, mode, path + ["initial_time_step"])
                    self.max_fixed_time_step = self.__class__.max_fixed_time_step(service, version, mode, path + ["max_fixed_time_step"])
                    self.max_step_change_factor = self.__class__.max_step_change_factor(service, version, mode, path + ["max_step_change_factor"])
                    self.max_time_step = self.__class__.max_time_step(service, version, mode, path + ["max_time_step"])
                    self.min_step_change_factor = self.__class__.min_step_change_factor(service, version, mode, path + ["min_step_change_factor"])
                    self.min_time_step = self.__class__.min_time_step(service, version, mode, path + ["min_time_step"])
                    self.time_end = self.__class__.time_end(service, version, mode, path + ["time_end"])
                    self.update_interval_time_step_size = self.__class__.update_interval_time_step_size(service, version, mode, path + ["update_interval_time_step_size"])
                    self.user_defined_timestep = self.__class__.user_defined_timestep(service, version, mode, path + ["user_defined_timestep"])
                    super().__init__(service, version, mode, path)
                class desired_cfl(TUIMethod):
                    """
                    .
                    """
                class enabled(TUIMethod):
                    """
                    .
                    """
                class initial_time_step(TUIMethod):
                    """
                    .
                    """
                class max_fixed_time_step(TUIMethod):
                    """
                    .
                    """
                class max_step_change_factor(TUIMethod):
                    """
                    .
                    """
                class max_time_step(TUIMethod):
                    """
                    .
                    """
                class min_step_change_factor(TUIMethod):
                    """
                    .
                    """
                class min_time_step(TUIMethod):
                    """
                    .
                    """
                class time_end(TUIMethod):
                    """
                    .
                    """
                class update_interval_time_step_size(TUIMethod):
                    """
                    .
                    """
                class user_defined_timestep(TUIMethod):
                    """
                    .
                    """

            class data_sampling(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.custom_field_functions = self.__class__.custom_field_functions(service, version, mode, path + ["custom_field_functions"])
                    self.dpm_variables = self.__class__.dpm_variables(service, version, mode, path + ["dpm_variables"])
                    self.enable_custom_field_functions = self.__class__.enable_custom_field_functions(service, version, mode, path + ["enable_custom_field_functions"])
                    self.enabled = self.__class__.enabled(service, version, mode, path + ["enabled"])
                    self.flow_heat_fluxes = self.__class__.flow_heat_fluxes(service, version, mode, path + ["flow_heat_fluxes"])
                    self.flow_shear_stresses = self.__class__.flow_shear_stresses(service, version, mode, path + ["flow_shear_stresses"])
                    self.force_statistics = self.__class__.force_statistics(service, version, mode, path + ["force_statistics"])
                    self.sampling_interval = self.__class__.sampling_interval(service, version, mode, path + ["sampling_interval"])
                    self.species_list = self.__class__.species_list(service, version, mode, path + ["species_list"])
                    self.statistics_mixture_fraction = self.__class__.statistics_mixture_fraction(service, version, mode, path + ["statistics_mixture_fraction"])
                    self.statistics_reaction_progress = self.__class__.statistics_reaction_progress(service, version, mode, path + ["statistics_reaction_progress"])
                    self.wall_statistics = self.__class__.wall_statistics(service, version, mode, path + ["wall_statistics"])
                    super().__init__(service, version, mode, path)
                class custom_field_functions(TUIMethod):
                    """
                    .
                    """
                class dpm_variables(TUIMethod):
                    """
                    .
                    """
                class enable_custom_field_functions(TUIMethod):
                    """
                    .
                    """
                class enabled(TUIMethod):
                    """
                    .
                    """
                class flow_heat_fluxes(TUIMethod):
                    """
                    .
                    """
                class flow_shear_stresses(TUIMethod):
                    """
                    .
                    """
                class force_statistics(TUIMethod):
                    """
                    .
                    """
                class sampling_interval(TUIMethod):
                    """
                    .
                    """
                class species_list(TUIMethod):
                    """
                    .
                    """
                class statistics_mixture_fraction(TUIMethod):
                    """
                    .
                    """
                class statistics_reaction_progress(TUIMethod):
                    """
                    .
                    """
                class wall_statistics(TUIMethod):
                    """
                    .
                    """

            class data_sampling_options(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.data_sets = self.__class__.data_sets(service, version, mode, path + ["data_sets"])
                    self.add_datasets = self.__class__.add_datasets(service, version, mode, path + ["add_datasets"])
                    self.list_datasets = self.__class__.list_datasets(service, version, mode, path + ["list_datasets"])
                    super().__init__(service, version, mode, path)
                class add_datasets(TUIMethod):
                    """
                    .
                    """
                class list_datasets(TUIMethod):
                    """
                    .
                    """

                class data_sets(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.create = self.__class__.create(service, version, mode, path + ["create"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                        self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                        super().__init__(service, version, mode, path)
                    class create(TUIMethod):
                        """
                        Create a new data-sets object.
                        """
                    class delete(TUIMethod):
                        """
                        .
                        """
                    class edit(TUIMethod):
                        """
                        Edit data-sets object.
                        """
                    class list(TUIMethod):
                        """
                        .
                        """
                    class list_properties(TUIMethod):
                        """
                        .
                        """
                    class make_a_copy(TUIMethod):
                        """
                        .
                        """
                    class rename(TUIMethod):
                        """
                        Rename data-sets object.
                        """

            class pseudo_time_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.time_step_method = self.__class__.time_step_method(service, version, mode, path + ["time_step_method"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    super().__init__(service, version, mode, path)
                class verbosity(TUIMethod):
                    """
                    .
                    """

                class time_step_method(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.auto_time_size_calc_solid_zone = self.__class__.auto_time_size_calc_solid_zone(service, version, mode, path + ["auto_time_size_calc_solid_zone"])
                        self.length_scale = self.__class__.length_scale(service, version, mode, path + ["length_scale"])
                        self.length_scale_methods = self.__class__.length_scale_methods(service, version, mode, path + ["length_scale_methods"])
                        self.pseudo_time_step_size = self.__class__.pseudo_time_step_size(service, version, mode, path + ["pseudo_time_step_size"])
                        self.time_solid_scale_factor = self.__class__.time_solid_scale_factor(service, version, mode, path + ["time_solid_scale_factor"])
                        self.time_step_method = self.__class__.time_step_method(service, version, mode, path + ["time_step_method"])
                        self.time_step_size_for_solid_zone = self.__class__.time_step_size_for_solid_zone(service, version, mode, path + ["time_step_size_for_solid_zone"])
                        self.time_step_size_scale_factor = self.__class__.time_step_size_scale_factor(service, version, mode, path + ["time_step_size_scale_factor"])
                        super().__init__(service, version, mode, path)
                    class auto_time_size_calc_solid_zone(TUIMethod):
                        """
                        .
                        """
                    class length_scale(TUIMethod):
                        """
                        .
                        """
                    class length_scale_methods(TUIMethod):
                        """
                        .
                        """
                    class pseudo_time_step_size(TUIMethod):
                        """
                        .
                        """
                    class time_solid_scale_factor(TUIMethod):
                        """
                        .
                        """
                    class time_step_method(TUIMethod):
                        """
                        .
                        """
                    class time_step_size_for_solid_zone(TUIMethod):
                        """
                        .
                        """
                    class time_step_size_scale_factor(TUIMethod):
                        """
                        .
                        """

            class transient_controls(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.cfl_based_time_stepping = self.__class__.cfl_based_time_stepping(service, version, mode, path + ["cfl_based_time_stepping"])
                    self.cfl_based_time_stepping_advanced_options = self.__class__.cfl_based_time_stepping_advanced_options(service, version, mode, path + ["cfl_based_time_stepping_advanced_options"])
                    self.error_based_time_stepping = self.__class__.error_based_time_stepping(service, version, mode, path + ["error_based_time_stepping"])
                    self.extrapolate_eqn_vars = self.__class__.extrapolate_eqn_vars(service, version, mode, path + ["extrapolate_eqn_vars"])
                    self.fixed_periodic = self.__class__.fixed_periodic(service, version, mode, path + ["fixed_periodic"])
                    self.mp_specific_time_stepping = self.__class__.mp_specific_time_stepping(service, version, mode, path + ["mp_specific_time_stepping"])
                    self.multiphase_specific_time_constraints = self.__class__.multiphase_specific_time_constraints(service, version, mode, path + ["multiphase_specific_time_constraints"])
                    self.solid_time_step_size = self.__class__.solid_time_step_size(service, version, mode, path + ["solid_time_step_size"])
                    self.duration_specification_method = self.__class__.duration_specification_method(service, version, mode, path + ["duration_specification_method"])
                    self.extrapolate_variables = self.__class__.extrapolate_variables(service, version, mode, path + ["extrapolate_variables"])
                    self.incremental_time = self.__class__.incremental_time(service, version, mode, path + ["incremental_time"])
                    self.max_flow_time = self.__class__.max_flow_time(service, version, mode, path + ["max_flow_time"])
                    self.max_iter_per_time_step = self.__class__.max_iter_per_time_step(service, version, mode, path + ["max_iter_per_time_step"])
                    self.method = self.__class__.method(service, version, mode, path + ["method"])
                    self.predict_next = self.__class__.predict_next(service, version, mode, path + ["predict_next"])
                    self.rotating_mesh_flow_predictor = self.__class__.rotating_mesh_flow_predictor(service, version, mode, path + ["rotating_mesh_flow_predictor"])
                    self.solution_status = self.__class__.solution_status(service, version, mode, path + ["solution_status"])
                    self.specified_time_step = self.__class__.specified_time_step(service, version, mode, path + ["specified_time_step"])
                    self.time_step_count = self.__class__.time_step_count(service, version, mode, path + ["time_step_count"])
                    self.time_step_size = self.__class__.time_step_size(service, version, mode, path + ["time_step_size"])
                    self.time_step_size_for_acoustic_export = self.__class__.time_step_size_for_acoustic_export(service, version, mode, path + ["time_step_size_for_acoustic_export"])
                    self.total_time = self.__class__.total_time(service, version, mode, path + ["total_time"])
                    self.total_time_step_count = self.__class__.total_time_step_count(service, version, mode, path + ["total_time_step_count"])
                    self.type = self.__class__.type(service, version, mode, path + ["type"])
                    self.udf_hook = self.__class__.udf_hook(service, version, mode, path + ["udf_hook"])
                    self.undo_timestep = self.__class__.undo_timestep(service, version, mode, path + ["undo_timestep"])
                    super().__init__(service, version, mode, path)
                class duration_specification_method(TUIMethod):
                    """
                    .
                    """
                class extrapolate_variables(TUIMethod):
                    """
                    .
                    """
                class incremental_time(TUIMethod):
                    """
                    .
                    """
                class max_flow_time(TUIMethod):
                    """
                    .
                    """
                class max_iter_per_time_step(TUIMethod):
                    """
                    .
                    """
                class method(TUIMethod):
                    """
                    .
                    """
                class predict_next(TUIMethod):
                    """
                    .
                    """
                class rotating_mesh_flow_predictor(TUIMethod):
                    """
                    .
                    """
                class solution_status(TUIMethod):
                    """
                    .
                    """
                class specified_time_step(TUIMethod):
                    """
                    .
                    """
                class time_step_count(TUIMethod):
                    """
                    .
                    """
                class time_step_size(TUIMethod):
                    """
                    .
                    """
                class time_step_size_for_acoustic_export(TUIMethod):
                    """
                    .
                    """
                class total_time(TUIMethod):
                    """
                    .
                    """
                class total_time_step_count(TUIMethod):
                    """
                    .
                    """
                class type(TUIMethod):
                    """
                    .
                    """
                class udf_hook(TUIMethod):
                    """
                    .
                    """
                class undo_timestep(TUIMethod):
                    """
                    .
                    """

                class cfl_based_time_stepping(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.courant_number = self.__class__.courant_number(service, version, mode, path + ["courant_number"])
                        self.fixed_time_step_size = self.__class__.fixed_time_step_size(service, version, mode, path + ["fixed_time_step_size"])
                        self.initial_time_step_size = self.__class__.initial_time_step_size(service, version, mode, path + ["initial_time_step_size"])
                        self.max_step_change_factor = self.__class__.max_step_change_factor(service, version, mode, path + ["max_step_change_factor"])
                        self.max_time_step_size = self.__class__.max_time_step_size(service, version, mode, path + ["max_time_step_size"])
                        self.min_step_change_factor = self.__class__.min_step_change_factor(service, version, mode, path + ["min_step_change_factor"])
                        self.min_time_step_size = self.__class__.min_time_step_size(service, version, mode, path + ["min_time_step_size"])
                        self.update_interval = self.__class__.update_interval(service, version, mode, path + ["update_interval"])
                        super().__init__(service, version, mode, path)
                    class courant_number(TUIMethod):
                        """
                        .
                        """
                    class fixed_time_step_size(TUIMethod):
                        """
                        .
                        """
                    class initial_time_step_size(TUIMethod):
                        """
                        .
                        """
                    class max_step_change_factor(TUIMethod):
                        """
                        .
                        """
                    class max_time_step_size(TUIMethod):
                        """
                        .
                        """
                    class min_step_change_factor(TUIMethod):
                        """
                        .
                        """
                    class min_time_step_size(TUIMethod):
                        """
                        .
                        """
                    class update_interval(TUIMethod):
                        """
                        .
                        """

                class cfl_based_time_stepping_advanced_options(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.cfl_type = self.__class__.cfl_type(service, version, mode, path + ["cfl_type"])
                        self.control_time_step_size_variation = self.__class__.control_time_step_size_variation(service, version, mode, path + ["control_time_step_size_variation"])
                        self.use_average_cfl = self.__class__.use_average_cfl(service, version, mode, path + ["use_average_cfl"])
                        super().__init__(service, version, mode, path)
                    class cfl_type(TUIMethod):
                        """
                        .
                        """
                    class control_time_step_size_variation(TUIMethod):
                        """
                        .
                        """
                    class use_average_cfl(TUIMethod):
                        """
                        .
                        """

                class error_based_time_stepping(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.error_tolerance = self.__class__.error_tolerance(service, version, mode, path + ["error_tolerance"])
                        self.fixed_time_step_size = self.__class__.fixed_time_step_size(service, version, mode, path + ["fixed_time_step_size"])
                        self.initial_time_step_size = self.__class__.initial_time_step_size(service, version, mode, path + ["initial_time_step_size"])
                        self.max_step_change_factor = self.__class__.max_step_change_factor(service, version, mode, path + ["max_step_change_factor"])
                        self.max_time_step_size = self.__class__.max_time_step_size(service, version, mode, path + ["max_time_step_size"])
                        self.min_step_change_factor = self.__class__.min_step_change_factor(service, version, mode, path + ["min_step_change_factor"])
                        self.min_time_step_size = self.__class__.min_time_step_size(service, version, mode, path + ["min_time_step_size"])
                        self.update_interval = self.__class__.update_interval(service, version, mode, path + ["update_interval"])
                        super().__init__(service, version, mode, path)
                    class error_tolerance(TUIMethod):
                        """
                        .
                        """
                    class fixed_time_step_size(TUIMethod):
                        """
                        .
                        """
                    class initial_time_step_size(TUIMethod):
                        """
                        .
                        """
                    class max_step_change_factor(TUIMethod):
                        """
                        .
                        """
                    class max_time_step_size(TUIMethod):
                        """
                        .
                        """
                    class min_step_change_factor(TUIMethod):
                        """
                        .
                        """
                    class min_time_step_size(TUIMethod):
                        """
                        .
                        """
                    class update_interval(TUIMethod):
                        """
                        .
                        """

                class extrapolate_eqn_vars(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.create = self.__class__.create(service, version, mode, path + ["create"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                        self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                        super().__init__(service, version, mode, path)
                    class create(TUIMethod):
                        """
                        Create a new extrapolate-eqn-vars object.
                        """
                    class delete(TUIMethod):
                        """
                        .
                        """
                    class edit(TUIMethod):
                        """
                        Edit extrapolate-eqn-vars object.
                        """
                    class list(TUIMethod):
                        """
                        .
                        """
                    class list_properties(TUIMethod):
                        """
                        .
                        """
                    class make_a_copy(TUIMethod):
                        """
                        .
                        """
                    class rename(TUIMethod):
                        """
                        Rename extrapolate-eqn-vars object.
                        """

                class fixed_periodic(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.enabled = self.__class__.enabled(service, version, mode, path + ["enabled"])
                        self.fixed_periodic_type = self.__class__.fixed_periodic_type(service, version, mode, path + ["fixed_periodic_type"])
                        self.period = self.__class__.period(service, version, mode, path + ["period"])
                        self.times_steps_per_period = self.__class__.times_steps_per_period(service, version, mode, path + ["times_steps_per_period"])
                        self.total_periods = self.__class__.total_periods(service, version, mode, path + ["total_periods"])
                        super().__init__(service, version, mode, path)
                    class enabled(TUIMethod):
                        """
                        .
                        """
                    class fixed_periodic_type(TUIMethod):
                        """
                        .
                        """
                    class period(TUIMethod):
                        """
                        .
                        """
                    class times_steps_per_period(TUIMethod):
                        """
                        .
                        """
                    class total_periods(TUIMethod):
                        """
                        .
                        """

                class mp_specific_time_stepping(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.enabled = self.__class__.enabled(service, version, mode, path + ["enabled"])
                        self.fixed_time_step_size = self.__class__.fixed_time_step_size(service, version, mode, path + ["fixed_time_step_size"])
                        self.global_courant_number = self.__class__.global_courant_number(service, version, mode, path + ["global_courant_number"])
                        self.initial_time_step_size = self.__class__.initial_time_step_size(service, version, mode, path + ["initial_time_step_size"])
                        self.max_step_change_factor = self.__class__.max_step_change_factor(service, version, mode, path + ["max_step_change_factor"])
                        self.max_time_step_size = self.__class__.max_time_step_size(service, version, mode, path + ["max_time_step_size"])
                        self.min_step_change_factor = self.__class__.min_step_change_factor(service, version, mode, path + ["min_step_change_factor"])
                        self.min_time_step_size = self.__class__.min_time_step_size(service, version, mode, path + ["min_time_step_size"])
                        self.update_interval = self.__class__.update_interval(service, version, mode, path + ["update_interval"])
                        super().__init__(service, version, mode, path)
                    class enabled(TUIMethod):
                        """
                        .
                        """
                    class fixed_time_step_size(TUIMethod):
                        """
                        .
                        """
                    class global_courant_number(TUIMethod):
                        """
                        .
                        """
                    class initial_time_step_size(TUIMethod):
                        """
                        .
                        """
                    class max_step_change_factor(TUIMethod):
                        """
                        .
                        """
                    class max_time_step_size(TUIMethod):
                        """
                        .
                        """
                    class min_step_change_factor(TUIMethod):
                        """
                        .
                        """
                    class min_time_step_size(TUIMethod):
                        """
                        .
                        """
                    class update_interval(TUIMethod):
                        """
                        .
                        """

                class multiphase_specific_time_constraints(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.moving_mesh_cfl_constraint = self.__class__.moving_mesh_cfl_constraint(service, version, mode, path + ["moving_mesh_cfl_constraint"])
                        self.time_scale_options = self.__class__.time_scale_options(service, version, mode, path + ["time_scale_options"])
                        self.physics_based_constraint = self.__class__.physics_based_constraint(service, version, mode, path + ["physics_based_constraint"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        super().__init__(service, version, mode, path)
                    class physics_based_constraint(TUIMethod):
                        """
                        .
                        """
                    class verbosity(TUIMethod):
                        """
                        .
                        """

                    class moving_mesh_cfl_constraint(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.mesh_courant_number = self.__class__.mesh_courant_number(service, version, mode, path + ["mesh_courant_number"])
                            self.moving_mesh_constraint = self.__class__.moving_mesh_constraint(service, version, mode, path + ["moving_mesh_constraint"])
                            super().__init__(service, version, mode, path)
                        class mesh_courant_number(TUIMethod):
                            """
                            .
                            """
                        class moving_mesh_constraint(TUIMethod):
                            """
                            .
                            """

                    class time_scale_options(TUIMenu):
                        """
                        .
                        """
                        def __init__(self, service, version, mode, path):
                            self.acoustic_scale = self.__class__.acoustic_scale(service, version, mode, path + ["acoustic_scale"])
                            self.gravity_scale = self.__class__.gravity_scale(service, version, mode, path + ["gravity_scale"])
                            self.surface_tension_scale = self.__class__.surface_tension_scale(service, version, mode, path + ["surface_tension_scale"])
                            self.viscous_scale = self.__class__.viscous_scale(service, version, mode, path + ["viscous_scale"])
                            super().__init__(service, version, mode, path)
                        class acoustic_scale(TUIMethod):
                            """
                            .
                            """
                        class gravity_scale(TUIMethod):
                            """
                            .
                            """
                        class surface_tension_scale(TUIMethod):
                            """
                            .
                            """
                        class viscous_scale(TUIMethod):
                            """
                            .
                            """

                class solid_time_step_size(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.choose_auto_time_stepping = self.__class__.choose_auto_time_stepping(service, version, mode, path + ["choose_auto_time_stepping"])
                        self.enable_solid_time_step = self.__class__.enable_solid_time_step(service, version, mode, path + ["enable_solid_time_step"])
                        self.time_step_size = self.__class__.time_step_size(service, version, mode, path + ["time_step_size"])
                        super().__init__(service, version, mode, path)
                    class choose_auto_time_stepping(TUIMethod):
                        """
                        .
                        """
                    class enable_solid_time_step(TUIMethod):
                        """
                        .
                        """
                    class time_step_size(TUIMethod):
                        """
                        .
                        """

    class solve(TUIMenu):
        """
        Enter the solve menu.
        """
        def __init__(self, service, version, mode, path):
            self.animate = self.__class__.animate(service, version, mode, path + ["animate"])
            self.cell_register_operations = self.__class__.cell_register_operations(service, version, mode, path + ["cell_register_operations"])
            self.cell_registers = self.__class__.cell_registers(service, version, mode, path + ["cell_registers"])
            self.execute_commands = self.__class__.execute_commands(service, version, mode, path + ["execute_commands"])
            self.initialize = self.__class__.initialize(service, version, mode, path + ["initialize"])
            self.monitors = self.__class__.monitors(service, version, mode, path + ["monitors"])
            self.report_definitions = self.__class__.report_definitions(service, version, mode, path + ["report_definitions"])
            self.report_files = self.__class__.report_files(service, version, mode, path + ["report_files"])
            self.report_plots = self.__class__.report_plots(service, version, mode, path + ["report_plots"])
            self.set = self.__class__.set(service, version, mode, path + ["set"])
            self.convergence_conditions = self.__class__.convergence_conditions(service, version, mode, path + ["convergence_conditions"])
            self.dpm_update = self.__class__.dpm_update(service, version, mode, path + ["dpm_update"])
            self.dual_time_iterate = self.__class__.dual_time_iterate(service, version, mode, path + ["dual_time_iterate"])
            self.iterate = self.__class__.iterate(service, version, mode, path + ["iterate"])
            self.iterate_steady_2way_fsi = self.__class__.iterate_steady_2way_fsi(service, version, mode, path + ["iterate_steady_2way_fsi"])
            self.max_iterations_per_time_step = self.__class__.max_iterations_per_time_step(service, version, mode, path + ["max_iterations_per_time_step"])
            self.mesh_motion = self.__class__.mesh_motion(service, version, mode, path + ["mesh_motion"])
            self.multistage_time_iterate = self.__class__.multistage_time_iterate(service, version, mode, path + ["multistage_time_iterate"])
            self.patch = self.__class__.patch(service, version, mode, path + ["patch"])
            self.update_physical_time = self.__class__.update_physical_time(service, version, mode, path + ["update_physical_time"])
            super().__init__(service, version, mode, path)
        class convergence_conditions(TUIMethod):
            """
            Enters the convergence conditions menu.
            """
        class dpm_update(TUIMethod):
            """
            Updates discrete phase source terms.
            """
        class dual_time_iterate(TUIMethod):
            """
            Performs unsteady iterations for a specified number of time steps.
            """
        class iterate(TUIMethod):
            """
            Performs a specified number of iterations.  This option is still available during transient simulations, since it can be used to add more iterations to the same time step after interrupting iterations within a time step.
            """
        class iterate_steady_2way_fsi(TUIMethod):
            """
            Perform a specified number of steps.
            """
        class max_iterations_per_time_step(TUIMethod):
            """
            Set maximum iterations per time step for transient case.
            """
        class mesh_motion(TUIMethod):
            """
            Performs mesh motion.
            """
        class multistage_time_iterate(TUIMethod):
            """
            Perform unsteady iterations.
            """
        class patch(TUIMethod):
            """
            Patches a value for a flow variable in the domain. You can either provide a numerical value, which you can enter directly, or you can enter an expression, which must be entered within quotation marks.
            """
        class update_physical_time(TUIMethod):
            """
            Advances the unsteady solution to the next physical time level. Using this command in conjunction with theiterate command allows you to manually advance the solution in time (rather than doing it automatically with the dual-time-iterate command).
            """

        class animate(TUIMenu):
            """
            Enters the animation menu.
            """
            def __init__(self, service, version, mode, path):
                self.define = self.__class__.define(service, version, mode, path + ["define"])
                self.inverse_dft = self.__class__.inverse_dft(service, version, mode, path + ["inverse_dft"])
                self.keyframe_animation = self.__class__.keyframe_animation(service, version, mode, path + ["keyframe_animation"])
                self.objects = self.__class__.objects(service, version, mode, path + ["objects"])
                self.playback = self.__class__.playback(service, version, mode, path + ["playback"])
                self.pulse = self.__class__.pulse(service, version, mode, path + ["pulse"])
                super().__init__(service, version, mode, path)

            class define(TUIMenu):
                """
                Enters the animation definition menu.
                """
                def __init__(self, service, version, mode, path):
                    self.define_monitor = self.__class__.define_monitor(service, version, mode, path + ["define_monitor"])
                    self.edit_monitor = self.__class__.edit_monitor(service, version, mode, path + ["edit_monitor"])
                    super().__init__(service, version, mode, path)
                class define_monitor(TUIMethod):
                    """
                    Defines new animation.
                    """
                class edit_monitor(TUIMethod):
                    """
                    Changes animation monitor attributes.
                    """

            class inverse_dft(TUIMenu):
                """
                Reconstruct DFT signal.
                """
                def __init__(self, service, version, mode, path):
                    self.run = self.__class__.run(service, version, mode, path + ["run"])
                    self.set = self.__class__.set(service, version, mode, path + ["set"])
                    super().__init__(service, version, mode, path)
                class run(TUIMethod):
                    """
                    Make inverse DFT recontruction.
                    """
                class set(TUIMethod):
                    """
                    Set reconstruction parameters.
                    """

            class keyframe_animation(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.set_custom_frames = self.__class__.set_custom_frames(service, version, mode, path + ["set_custom_frames"])
                    self.add_keyframe = self.__class__.add_keyframe(service, version, mode, path + ["add_keyframe"])
                    self.delete_all_keyframes = self.__class__.delete_all_keyframes(service, version, mode, path + ["delete_all_keyframes"])
                    self.delete_keyframe = self.__class__.delete_keyframe(service, version, mode, path + ["delete_keyframe"])
                    self.play = self.__class__.play(service, version, mode, path + ["play"])
                    self.read_animation = self.__class__.read_animation(service, version, mode, path + ["read_animation"])
                    self.write_animation = self.__class__.write_animation(service, version, mode, path + ["write_animation"])
                    super().__init__(service, version, mode, path)
                class add_keyframe(TUIMethod):
                    """
                    .
                    """
                class delete_all_keyframes(TUIMethod):
                    """
                    .
                    """
                class delete_keyframe(TUIMethod):
                    """
                    .
                    """
                class play(TUIMethod):
                    """
                    .
                    """
                class read_animation(TUIMethod):
                    """
                    .
                    """
                class write_animation(TUIMethod):
                    """
                    .
                    """

                class set_custom_frames(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.end_keyframe = self.__class__.end_keyframe(service, version, mode, path + ["end_keyframe"])
                        self.increment = self.__class__.increment(service, version, mode, path + ["increment"])
                        self.start_keyframe = self.__class__.start_keyframe(service, version, mode, path + ["start_keyframe"])
                        super().__init__(service, version, mode, path)
                    class end_keyframe(TUIMethod):
                        """
                        .
                        """
                    class increment(TUIMethod):
                        """
                        .
                        """
                    class start_keyframe(TUIMethod):
                        """
                        .
                        """

            class objects(TUIMenu):
                """
                Enters the object manipulation menu.
                """
                def __init__(self, service, version, mode, path):
                    self.clear_history = self.__class__.clear_history(service, version, mode, path + ["clear_history"])
                    self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.get_window_id = self.__class__.get_window_id(service, version, mode, path + ["get_window_id"])
                    super().__init__(service, version, mode, path)
                class clear_history(TUIMethod):
                    """
                    Clears solution animation object history.
                    """
                class copy(TUIMethod):
                    """
                    Copies solution animation object.
                    """
                class create(TUIMethod):
                    """
                    Creates new solution animation object.
                    """
                class delete(TUIMethod):
                    """
                    Deletes solution animation object.
                    """
                class edit(TUIMethod):
                    """
                    Edits solution animation object.
                    """
                class get_window_id(TUIMethod):
                    """
                    Get animation object window id.
                    """

            class playback(TUIMenu):
                """
                Enters the animation playback menu.
                """
                def __init__(self, service, version, mode, path):
                    self.video = self.__class__.video(service, version, mode, path + ["video"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.play = self.__class__.play(service, version, mode, path + ["play"])
                    self.read = self.__class__.read(service, version, mode, path + ["read"])
                    self.set_custom_frames = self.__class__.set_custom_frames(service, version, mode, path + ["set_custom_frames"])
                    self.stored_view = self.__class__.stored_view(service, version, mode, path + ["stored_view"])
                    self.write = self.__class__.write(service, version, mode, path + ["write"])
                    super().__init__(service, version, mode, path)
                class delete(TUIMethod):
                    """
                    Deletes animation sequence.
                    """
                class play(TUIMethod):
                    """
                    Plays the selected animation.
                    """
                class read(TUIMethod):
                    """
                    Reads new animation from file or already defined animations.
                    """
                class set_custom_frames(TUIMethod):
                    """
                    Specify a custom start frame, increment, and end frame for video export.
                    """
                class stored_view(TUIMethod):
                    """
                    Plays the 3D animation sequence using the view stored in the sequence.
                    """
                class write(TUIMethod):
                    """
                    Writes animation sequence to the file.
                    """

                class video(TUIMenu):
                    """
                    Enters the video menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.advance_quality = self.__class__.advance_quality(service, version, mode, path + ["advance_quality"])
                        self.format = self.__class__.format(service, version, mode, path + ["format"])
                        self.fps = self.__class__.fps(service, version, mode, path + ["fps"])
                        self.height = self.__class__.height(service, version, mode, path + ["height"])
                        self.name = self.__class__.name(service, version, mode, path + ["name"])
                        self.quality = self.__class__.quality(service, version, mode, path + ["quality"])
                        self.scale = self.__class__.scale(service, version, mode, path + ["scale"])
                        self.set_standard_resolution = self.__class__.set_standard_resolution(service, version, mode, path + ["set_standard_resolution"])
                        self.use_original_resolution = self.__class__.use_original_resolution(service, version, mode, path + ["use_original_resolution"])
                        self.width = self.__class__.width(service, version, mode, path + ["width"])
                        super().__init__(service, version, mode, path)
                    class format(TUIMethod):
                        """
                        Specifies what format the video file will be written in (MP4 | AVI |  FLV | MOV | MPEG).
                        """
                    class fps(TUIMethod):
                        """
                        Sets the target frames per second (FPS) for the saved video  file.
                        """
                    class height(TUIMethod):
                        """
                        Set the height for exporting video file.
                        """
                    class name(TUIMethod):
                        """
                        Sets the name of the saved video file.
                        """
                    class quality(TUIMethod):
                        """
                        Set quality for exporting video file.
                        """
                    class scale(TUIMethod):
                        """
                        Expands or collapses the resolution based on this scaling  factor.
                        """
                    class set_standard_resolution(TUIMethod):
                        """
                        Select from pre-defined resolution list.
                        """
                    class use_original_resolution(TUIMethod):
                        """
                        Controls whether the resolution of the saved video file matches that  of the images used to create it.
                        """
                    class width(TUIMethod):
                        """
                        Set the width for exporting video file.
                        """

                    class advance_quality(TUIMenu):
                        """
                        Advance Quality setting.
                        """
                        def __init__(self, service, version, mode, path):
                            self.bitrate = self.__class__.bitrate(service, version, mode, path + ["bitrate"])
                            self.bitrate_scale = self.__class__.bitrate_scale(service, version, mode, path + ["bitrate_scale"])
                            self.compression_method = self.__class__.compression_method(service, version, mode, path + ["compression_method"])
                            self.enable_h264 = self.__class__.enable_h264(service, version, mode, path + ["enable_h264"])
                            self.keyframe = self.__class__.keyframe(service, version, mode, path + ["keyframe"])
                            super().__init__(service, version, mode, path)
                        class bitrate(TUIMethod):
                            """
                            Set video bitrate(kbits/sec) for exporting video file.
                            """
                        class bitrate_scale(TUIMethod):
                            """
                            Mp4 bitrate scale - Best-64000 High-32000 Medium-16000 Low-8000.
                            """
                        class compression_method(TUIMethod):
                            """
                            Compression methode for Microsoft AVI movie.
                            """
                        class enable_h264(TUIMethod):
                            """
                            H264 encoding flag.
                            """
                        class keyframe(TUIMethod):
                            """
                            Set video keyframe rate for exporting video file.
                            """

            class pulse(TUIMenu):
                """
                Enter the pulse animation menu (only available when one or more particle track or pathline graphics objects are defined).
                """
                def __init__(self, service, version, mode, path):
                    self.hardcopy = self.__class__.hardcopy(service, version, mode, path + ["hardcopy"])
                    self.video = self.__class__.video(service, version, mode, path + ["video"])
                    self.pulse_mode = self.__class__.pulse_mode(service, version, mode, path + ["pulse_mode"])
                    self.write = self.__class__.write(service, version, mode, path + ["write"])
                    super().__init__(service, version, mode, path)
                class pulse_mode(TUIMethod):
                    """
                    Set whether the pulse is a single pulse or continuous.
                    """
                class write(TUIMethod):
                    """
                    Select a pathline or particle track graphics object, specify whether you want to write a video file or picture files, and enter the destination directory for the files. Continuous pulse animations result in a 5 second video. Single pulse animations run for a full cycle.
                    """

                class hardcopy(TUIMenu):
                    """
                    Hardcopy options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.color_mode = self.__class__.color_mode(service, version, mode, path + ["color_mode"])
                        self.driver = self.__class__.driver(service, version, mode, path + ["driver"])
                        self.dpi = self.__class__.dpi(service, version, mode, path + ["dpi"])
                        self.invert_background = self.__class__.invert_background(service, version, mode, path + ["invert_background"])
                        self.jpeg_hardcopy_quality = self.__class__.jpeg_hardcopy_quality(service, version, mode, path + ["jpeg_hardcopy_quality"])
                        self.landscape = self.__class__.landscape(service, version, mode, path + ["landscape"])
                        self.preview = self.__class__.preview(service, version, mode, path + ["preview"])
                        self.raytracer_image = self.__class__.raytracer_image(service, version, mode, path + ["raytracer_image"])
                        self.set_standard_resolution = self.__class__.set_standard_resolution(service, version, mode, path + ["set_standard_resolution"])
                        self.use_window_resolution = self.__class__.use_window_resolution(service, version, mode, path + ["use_window_resolution"])
                        self.x_resolution = self.__class__.x_resolution(service, version, mode, path + ["x_resolution"])
                        self.y_resolution = self.__class__.y_resolution(service, version, mode, path + ["y_resolution"])
                        super().__init__(service, version, mode, path)
                    class dpi(TUIMethod):
                        """
                        Set the DPI for EPS and Postscript files, specifies the resolution in dots per inch (DPI) instead of setting the width and height.
                        """
                    class invert_background(TUIMethod):
                        """
                        Use a white background when the picture is saved.
                        """
                    class jpeg_hardcopy_quality(TUIMethod):
                        """
                        To set jpeg hardcopy quality.
                        """
                    class landscape(TUIMethod):
                        """
                        Plot hardcopies in landscape or portrait orientation.
                        """
                    class preview(TUIMethod):
                        """
                        Display a preview image of a hardcopy.
                        """
                    class raytracer_image(TUIMethod):
                        """
                        Enable raytracering rendering.
                        """
                    class set_standard_resolution(TUIMethod):
                        """
                        Select from pre-defined resolution list.
                        """
                    class use_window_resolution(TUIMethod):
                        """
                        Use the currently active window's resolution for hardcopy (ignores the x-resolution and y-resolution in this case).
                        """
                    class x_resolution(TUIMethod):
                        """
                        Set the width of raster-formatted images in pixels (0 implies current window size).
                        """
                    class y_resolution(TUIMethod):
                        """
                        Set the height of raster-formatted images in pixels (0 implies current window size).
                        """

                    class color_mode(TUIMenu):
                        """
                        Enter the hardcopy color mode menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.color = self.__class__.color(service, version, mode, path + ["color"])
                            self.gray_scale = self.__class__.gray_scale(service, version, mode, path + ["gray_scale"])
                            self.list = self.__class__.list(service, version, mode, path + ["list"])
                            self.mono_chrome = self.__class__.mono_chrome(service, version, mode, path + ["mono_chrome"])
                            super().__init__(service, version, mode, path)
                        class color(TUIMethod):
                            """
                            Plot hardcopies in color.
                            """
                        class gray_scale(TUIMethod):
                            """
                            Convert color to grayscale for hardcopy.
                            """
                        class list(TUIMethod):
                            """
                            Display the current hardcopy color mode.
                            """
                        class mono_chrome(TUIMethod):
                            """
                            Convert color to monochrome (black and white) for hardcopy.
                            """

                    class driver(TUIMenu):
                        """
                        Enter the set hardcopy driver menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.post_format = self.__class__.post_format(service, version, mode, path + ["post_format"])
                            self.avz = self.__class__.avz(service, version, mode, path + ["avz"])
                            self.dump_window = self.__class__.dump_window(service, version, mode, path + ["dump_window"])
                            self.eps = self.__class__.eps(service, version, mode, path + ["eps"])
                            self.glb = self.__class__.glb(service, version, mode, path + ["glb"])
                            self.hsf = self.__class__.hsf(service, version, mode, path + ["hsf"])
                            self.jpeg = self.__class__.jpeg(service, version, mode, path + ["jpeg"])
                            self.list = self.__class__.list(service, version, mode, path + ["list"])
                            self.options = self.__class__.options(service, version, mode, path + ["options"])
                            self.png = self.__class__.png(service, version, mode, path + ["png"])
                            self.post_script = self.__class__.post_script(service, version, mode, path + ["post_script"])
                            self.ppm = self.__class__.ppm(service, version, mode, path + ["ppm"])
                            self.tiff = self.__class__.tiff(service, version, mode, path + ["tiff"])
                            self.vrml = self.__class__.vrml(service, version, mode, path + ["vrml"])
                            super().__init__(service, version, mode, path)
                        class avz(TUIMethod):
                            """
                            Use AVZ output for hardcopies.
                            """
                        class dump_window(TUIMethod):
                            """
                            Set the command used to dump the graphics window to a file.
                            """
                        class eps(TUIMethod):
                            """
                            Produce encapsulated PostScript (EPS) output for hardcopies.
                            """
                        class glb(TUIMethod):
                            """
                            Use GLB output for hardcopies.
                            """
                        class hsf(TUIMethod):
                            """
                            Use HSF output for hardcopies.
                            """
                        class jpeg(TUIMethod):
                            """
                            Produce JPEG output for hardcopies.
                            """
                        class list(TUIMethod):
                            """
                            List the current hardcopy driver.
                            """
                        class options(TUIMethod):
                            """
                            Set the hardcopy options. Available options are:
                            "no gamma correction", disables gamma correction of colors,
                            "physical size = (width,height)", where width and height
                            are the actual measurements of the printable area of the page
                            in centimeters.
                            "subscreen = (left,right,bottom,top)", where left,right,
                            bottom, and top are numbers in [-1,1] describing a subwindow on
                            the page in which to place the hardcopy.
                            The options may be combined by separating them with commas.
                            """
                        class png(TUIMethod):
                            """
                            Use PNG output for hardcopies.
                            """
                        class post_script(TUIMethod):
                            """
                            Produce PostScript output for hardcopies.
                            """
                        class ppm(TUIMethod):
                            """
                            Produce PPM output for hardcopies.
                            """
                        class tiff(TUIMethod):
                            """
                            Use TIFF output for hardcopies.
                            """
                        class vrml(TUIMethod):
                            """
                            Use VRML output for hardcopies.
                            """

                        class post_format(TUIMenu):
                            """
                            Enter the PostScript driver format menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.fast_raster = self.__class__.fast_raster(service, version, mode, path + ["fast_raster"])
                                self.raster = self.__class__.raster(service, version, mode, path + ["raster"])
                                self.rle_raster = self.__class__.rle_raster(service, version, mode, path + ["rle_raster"])
                                self.vector = self.__class__.vector(service, version, mode, path + ["vector"])
                                super().__init__(service, version, mode, path)
                            class fast_raster(TUIMethod):
                                """
                                Use the new raster format.
                                """
                            class raster(TUIMethod):
                                """
                                Use the original raster format.
                                """
                            class rle_raster(TUIMethod):
                                """
                                Use the run-length encoded raster format.
                                """
                            class vector(TUIMethod):
                                """
                                Use vector format.
                                """

                class video(TUIMenu):
                    """
                    Enter the video window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.advance_quality = self.__class__.advance_quality(service, version, mode, path + ["advance_quality"])
                        self.format = self.__class__.format(service, version, mode, path + ["format"])
                        self.fps = self.__class__.fps(service, version, mode, path + ["fps"])
                        self.height = self.__class__.height(service, version, mode, path + ["height"])
                        self.name = self.__class__.name(service, version, mode, path + ["name"])
                        self.quality = self.__class__.quality(service, version, mode, path + ["quality"])
                        self.scale = self.__class__.scale(service, version, mode, path + ["scale"])
                        self.set_standard_resolution = self.__class__.set_standard_resolution(service, version, mode, path + ["set_standard_resolution"])
                        self.use_original_resolution = self.__class__.use_original_resolution(service, version, mode, path + ["use_original_resolution"])
                        self.width = self.__class__.width(service, version, mode, path + ["width"])
                        super().__init__(service, version, mode, path)
                    class format(TUIMethod):
                        """
                        Set format for exporting video file.
                        """
                    class fps(TUIMethod):
                        """
                        Set the Frame Per Sec(FPS) for exporting video file.
                        """
                    class height(TUIMethod):
                        """
                        Set the height for exporting video file.
                        """
                    class name(TUIMethod):
                        """
                        Exporting video file name.
                        """
                    class quality(TUIMethod):
                        """
                        Set quality for exporting video file.
                        """
                    class scale(TUIMethod):
                        """
                        Set scale by which video resolution will expand.
                        """
                    class set_standard_resolution(TUIMethod):
                        """
                        Select from pre-defined resolution list.
                        """
                    class use_original_resolution(TUIMethod):
                        """
                        Enable original resolution.
                        """
                    class width(TUIMethod):
                        """
                        Set the width for exporting video file.
                        """

                    class advance_quality(TUIMenu):
                        """
                        Advance Quality setting.
                        """
                        def __init__(self, service, version, mode, path):
                            self.bitrate = self.__class__.bitrate(service, version, mode, path + ["bitrate"])
                            self.bitrate_scale = self.__class__.bitrate_scale(service, version, mode, path + ["bitrate_scale"])
                            self.compression_method = self.__class__.compression_method(service, version, mode, path + ["compression_method"])
                            self.enable_h264 = self.__class__.enable_h264(service, version, mode, path + ["enable_h264"])
                            self.keyframe = self.__class__.keyframe(service, version, mode, path + ["keyframe"])
                            super().__init__(service, version, mode, path)
                        class bitrate(TUIMethod):
                            """
                            Set video bitrate(kbits/sec) for exporting video file.
                            """
                        class bitrate_scale(TUIMethod):
                            """
                            Mp4 bitrate scale - Best-64000 High-32000 Medium-16000 Low-8000.
                            """
                        class compression_method(TUIMethod):
                            """
                            Compression methode for Microsoft AVI movie.
                            """
                        class enable_h264(TUIMethod):
                            """
                            H264 encoding flag.
                            """
                        class keyframe(TUIMethod):
                            """
                            Set video keyframe rate for exporting video file.
                            """

        class cell_register_operations(TUIMenu):
            """
            Enters the cell register operations menu.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Creates a new cell register operation.
                """
            class delete(TUIMethod):
                """
                Deletes a cell register operation.
                """
            class edit(TUIMethod):
                """
                Edits an existing cell register operation.
                """
            class list(TUIMethod):
                """
                Lists the currently defined cell register operations.
                """
            class list_properties(TUIMethod):
                """
                Lists the properties of a report register operation.
                """

        class cell_registers(TUIMenu):
            """
            Enters the cell registers menu.
            """
            def __init__(self, service, version, mode, path):
                self.adapt = self.__class__.adapt(service, version, mode, path + ["adapt"])
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.apply_poor_mesh_numerics = self.__class__.apply_poor_mesh_numerics(service, version, mode, path + ["apply_poor_mesh_numerics"])
                self.coarsen = self.__class__.coarsen(service, version, mode, path + ["coarsen"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                self.refine = self.__class__.refine(service, version, mode, path + ["refine"])
                super().__init__(service, version, mode, path)
            class adapt(TUIMethod):
                """
                Adapt cell register objects.
                """
            class add(TUIMethod):
                """
                Add a new object.
                """
            class apply_poor_mesh_numerics(TUIMethod):
                """
                Applies poor mesh numerics to the mesh of a cell register.
                """
            class coarsen(TUIMethod):
                """
                Coarsen the mesh based on a cell register.
                """
            class delete(TUIMethod):
                """
                Deletes a cell register.
                """
            class display(TUIMethod):
                """
                Displays a cell register.
                """
            class edit(TUIMethod):
                """
                Edit an object.
                """
            class list(TUIMethod):
                """
                Lists all of the currently defined cell registers.
                """
            class list_properties(TUIMethod):
                """
                Lists the properties of a cell register.
                """
            class refine(TUIMethod):
                """
                Refine the mesh based on a cell register.
                """

        class execute_commands(TUIMenu):
            """
            Enters the execute commands menu.
            """
            def __init__(self, service, version, mode, path):
                self.add_edit = self.__class__.add_edit(service, version, mode, path + ["add_edit"])
                self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.disable = self.__class__.disable(service, version, mode, path + ["disable"])
                self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                self.export = self.__class__.export(service, version, mode, path + ["export"])
                self.import_ = self.__class__.import_(service, version, mode, path + ["import_"])
                super().__init__(service, version, mode, path)
            class add_edit(TUIMethod):
                """
                Adds or edits execute commands.
                """
            class copy(TUIMethod):
                """
                .
                """
            class delete(TUIMethod):
                """
                .
                """
            class disable(TUIMethod):
                """
                Disables an execute command.
                """
            class enable(TUIMethod):
                """
                Enables an execute command.
                """
            class export(TUIMethod):
                """
                .
                """
            class import_(TUIMethod):
                """
                .
                """

        class initialize(TUIMenu):
            """
            Enters the flow initialization menu.
            """
            def __init__(self, service, version, mode, path):
                self.compute_defaults = self.__class__.compute_defaults(service, version, mode, path + ["compute_defaults"])
                self.mp_localized_turb_init = self.__class__.mp_localized_turb_init(service, version, mode, path + ["mp_localized_turb_init"])
                self.set_hyb_initialization = self.__class__.set_hyb_initialization(service, version, mode, path + ["set_hyb_initialization"])
                self.vof_patch_smooth_options = self.__class__.vof_patch_smooth_options(service, version, mode, path + ["vof_patch_smooth_options"])
                self.dpm_reset = self.__class__.dpm_reset(service, version, mode, path + ["dpm_reset"])
                self.fmg_initialization = self.__class__.fmg_initialization(service, version, mode, path + ["fmg_initialization"])
                self.hyb_initialization = self.__class__.hyb_initialization(service, version, mode, path + ["hyb_initialization"])
                self.init_acoustics_options = self.__class__.init_acoustics_options(service, version, mode, path + ["init_acoustics_options"])
                self.init_flow_statistics = self.__class__.init_flow_statistics(service, version, mode, path + ["init_flow_statistics"])
                self.init_instantaneous_vel = self.__class__.init_instantaneous_vel(service, version, mode, path + ["init_instantaneous_vel"])
                self.init_turb_vel_fluctuations = self.__class__.init_turb_vel_fluctuations(service, version, mode, path + ["init_turb_vel_fluctuations"])
                self.initialize_flow = self.__class__.initialize_flow(service, version, mode, path + ["initialize_flow"])
                self.initialize_lwf = self.__class__.initialize_lwf(service, version, mode, path + ["initialize_lwf"])
                self.levelset_auto_init = self.__class__.levelset_auto_init(service, version, mode, path + ["levelset_auto_init"])
                self.list_defaults = self.__class__.list_defaults(service, version, mode, path + ["list_defaults"])
                self.lwf_reset = self.__class__.lwf_reset(service, version, mode, path + ["lwf_reset"])
                self.open_channel_auto_init = self.__class__.open_channel_auto_init(service, version, mode, path + ["open_channel_auto_init"])
                self.reference_frame = self.__class__.reference_frame(service, version, mode, path + ["reference_frame"])
                self.repair_wall_distance = self.__class__.repair_wall_distance(service, version, mode, path + ["repair_wall_distance"])
                self.set_defaults = self.__class__.set_defaults(service, version, mode, path + ["set_defaults"])
                self.set_fmg_initialization = self.__class__.set_fmg_initialization(service, version, mode, path + ["set_fmg_initialization"])
                self.set_fmg_options = self.__class__.set_fmg_options(service, version, mode, path + ["set_fmg_options"])
                self.show_iterations_sampled = self.__class__.show_iterations_sampled(service, version, mode, path + ["show_iterations_sampled"])
                self.show_time_sampled = self.__class__.show_time_sampled(service, version, mode, path + ["show_time_sampled"])
                super().__init__(service, version, mode, path)
            class dpm_reset(TUIMethod):
                """
                Resets discrete phase source terms to zero.
                """
            class fmg_initialization(TUIMethod):
                """
                Initializes using the full-multigrid initialization (FMG).
                """
            class hyb_initialization(TUIMethod):
                """
                Initializes using the hybrid initialization method.
                """
            class init_acoustics_options(TUIMethod):
                """
                Specifies the number of timesteps for ramping of sound sources and re-initializes the acoustics wave equation solution. For the initialized acoustics solution, Fluent reports the current state of the sound sources ramping.
                """
            class init_flow_statistics(TUIMethod):
                """
                Initializes unsteady statistics.
                """
            class init_instantaneous_vel(TUIMethod):
                """
                Initialize unsteady velocity.
                """
            class init_turb_vel_fluctuations(TUIMethod):
                """
                Initializes instantaneous velocity field out of steady state RANS results, for use before enabling a scale resolving simulation such as LES.
                """
            class initialize_flow(TUIMethod):
                """
                Initializes the flow field with the current default values.
                """
            class initialize_lwf(TUIMethod):
                """
                Initalize Lagrangian wall film according to the settings made for individual wall zones.
                """
            class levelset_auto_init(TUIMethod):
                """
                .
                """
            class list_defaults(TUIMethod):
                """
                Lists default values.
                """
            class lwf_reset(TUIMethod):
                """
                Delete wall film particles and initialize wall film variables to zero.
                """
            class open_channel_auto_init(TUIMethod):
                """
                Opens channel automatic initialization.
                """
            class reference_frame(TUIMethod):
                """
                Sets reference frame to absolute or relative.
                """
            class repair_wall_distance(TUIMethod):
                """
                Corrects wall distance at very high aspect ratio hexahedral/polyhedral cells.
                """
            class set_defaults(TUIMethod):
                """
                Sets default initial values.
                """
            class set_fmg_initialization(TUIMethod):
                """
                Enters the set full-multigrid for initialization menu. Initial values for each variable can be set within this menu.
                """
            class set_fmg_options(TUIMethod):
                """
                Enter the additional fmg options menu.
                """
            class show_iterations_sampled(TUIMethod):
                """
                Displays the number of iterations covered by the data sampled for steady statistics.
                """
            class show_time_sampled(TUIMethod):
                """
                Displays the amount of simulated time covered by the data sampled for unsteady statistics.
                """

            class compute_defaults(TUIMenu):
                """
                Enters the compute default values menu.
                """
                def __init__(self, service, version, mode, path):
                    self.all_zones = self.__class__.all_zones(service, version, mode, path + ["all_zones"])
                    self.axis = self.__class__.axis(service, version, mode, path + ["axis"])
                    self.degassing = self.__class__.degassing(service, version, mode, path + ["degassing"])
                    self.dummy_entry = self.__class__.dummy_entry(service, version, mode, path + ["dummy_entry"])
                    self.exhaust_fan = self.__class__.exhaust_fan(service, version, mode, path + ["exhaust_fan"])
                    self.fan = self.__class__.fan(service, version, mode, path + ["fan"])
                    self.fluid = self.__class__.fluid(service, version, mode, path + ["fluid"])
                    self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
                    self.inlet_vent = self.__class__.inlet_vent(service, version, mode, path + ["inlet_vent"])
                    self.intake_fan = self.__class__.intake_fan(service, version, mode, path + ["intake_fan"])
                    self.interface = self.__class__.interface(service, version, mode, path + ["interface"])
                    self.interior = self.__class__.interior(service, version, mode, path + ["interior"])
                    self.mass_flow_inlet = self.__class__.mass_flow_inlet(service, version, mode, path + ["mass_flow_inlet"])
                    self.mass_flow_outlet = self.__class__.mass_flow_outlet(service, version, mode, path + ["mass_flow_outlet"])
                    self.network = self.__class__.network(service, version, mode, path + ["network"])
                    self.network_end = self.__class__.network_end(service, version, mode, path + ["network_end"])
                    self.outflow = self.__class__.outflow(service, version, mode, path + ["outflow"])
                    self.outlet_vent = self.__class__.outlet_vent(service, version, mode, path + ["outlet_vent"])
                    self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                    self.periodic = self.__class__.periodic(service, version, mode, path + ["periodic"])
                    self.porous_jump = self.__class__.porous_jump(service, version, mode, path + ["porous_jump"])
                    self.pressure_far_field = self.__class__.pressure_far_field(service, version, mode, path + ["pressure_far_field"])
                    self.pressure_inlet = self.__class__.pressure_inlet(service, version, mode, path + ["pressure_inlet"])
                    self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                    self.radiator = self.__class__.radiator(service, version, mode, path + ["radiator"])
                    self.rans_les_interface = self.__class__.rans_les_interface(service, version, mode, path + ["rans_les_interface"])
                    self.recirculation_inlet = self.__class__.recirculation_inlet(service, version, mode, path + ["recirculation_inlet"])
                    self.recirculation_outlet = self.__class__.recirculation_outlet(service, version, mode, path + ["recirculation_outlet"])
                    self.shadow = self.__class__.shadow(service, version, mode, path + ["shadow"])
                    self.solid = self.__class__.solid(service, version, mode, path + ["solid"])
                    self.symmetry = self.__class__.symmetry(service, version, mode, path + ["symmetry"])
                    self.velocity_inlet = self.__class__.velocity_inlet(service, version, mode, path + ["velocity_inlet"])
                    self.wall = self.__class__.wall(service, version, mode, path + ["wall"])
                    super().__init__(service, version, mode, path)
                class all_zones(TUIMethod):
                    """
                    Initializes the flow field with the default values.
                    """
                class axis(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class degassing(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class dummy_entry(TUIMethod):
                    """
                    .
                    """
                class exhaust_fan(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class fan(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class fluid(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class geometry(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class inlet_vent(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class intake_fan(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class interface(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class interior(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class mass_flow_inlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class mass_flow_outlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class network(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class network_end(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class outflow(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class outlet_vent(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class overset(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class periodic(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class porous_jump(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class pressure_far_field(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class pressure_inlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class pressure_outlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class radiator(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class rans_les_interface(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class recirculation_inlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class recirculation_outlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class shadow(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class solid(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class symmetry(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class velocity_inlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class wall(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """

            class mp_localized_turb_init(TUIMenu):
                """
                Enters the menu for localized turbulent flow initialization.
                """
                def __init__(self, service, version, mode, path):
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.turb_init_parameters = self.__class__.turb_init_parameters(service, version, mode, path + ["turb_init_parameters"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enables/disables localized initialization of turbulent flow variables.
                    """
                class turb_init_parameters(TUIMethod):
                    """
                    Sets values for the turbulent intensity and turbulent viscosity ratio for localized initialization.
                    """

            class set_hyb_initialization(TUIMenu):
                """
                Enters the hybrid initialization menu.
                """
                def __init__(self, service, version, mode, path):
                    self.general_settings = self.__class__.general_settings(service, version, mode, path + ["general_settings"])
                    self.species_settings = self.__class__.species_settings(service, version, mode, path + ["species_settings"])
                    self.turbulent_settings = self.__class__.turbulent_settings(service, version, mode, path + ["turbulent_settings"])
                    super().__init__(service, version, mode, path)
                class general_settings(TUIMethod):
                    """
                    Enters the general settings menu.
                    """
                class species_settings(TUIMethod):
                    """
                    Enters the species-settings menu.
                    """
                class turbulent_settings(TUIMethod):
                    """
                    Enter the turbulent settings menu.
                    """

            class vof_patch_smooth_options(TUIMenu):
                """
                Enters the vof patch/smooth options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.execute_smoothing = self.__class__.execute_smoothing(service, version, mode, path + ["execute_smoothing"])
                    self.set_options = self.__class__.set_options(service, version, mode, path + ["set_options"])
                    super().__init__(service, version, mode, path)
                class execute_smoothing(TUIMethod):
                    """
                    .
                    """
                class set_options(TUIMethod):
                    """
                    Sets options for patching and smoothing volume fraction.
                    """

        class monitors(TUIMenu):
            """
            Sets solution monitors.
            """
            def __init__(self, service, version, mode, path):
                self.convergence = self.__class__.convergence(service, version, mode, path + ["convergence"])
                self.force = self.__class__.force(service, version, mode, path + ["force"])
                self.residual = self.__class__.residual(service, version, mode, path + ["residual"])
                self.statistic = self.__class__.statistic(service, version, mode, path + ["statistic"])
                self.surface = self.__class__.surface(service, version, mode, path + ["surface"])
                self.volume = self.__class__.volume(service, version, mode, path + ["volume"])
                self.set_average_over = self.__class__.set_average_over(service, version, mode, path + ["set_average_over"])
                super().__init__(service, version, mode, path)
            class set_average_over(TUIMethod):
                """
                Set the average over input for monitors.
                """

            class convergence(TUIMenu):
                """
                Enter the convergence menu to add surface, volume, drag, lift and moment monitors to convergence criteria.
                """
                def __init__(self, service, version, mode, path):
                    self.add_edit = self.__class__.add_edit(service, version, mode, path + ["add_edit"])
                    self.average_over_last_n_iterations_timesteps = self.__class__.average_over_last_n_iterations_timesteps(service, version, mode, path + ["average_over_last_n_iterations_timesteps"])
                    self.condition = self.__class__.condition(service, version, mode, path + ["condition"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.frequency = self.__class__.frequency(service, version, mode, path + ["frequency"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    super().__init__(service, version, mode, path)
                class add_edit(TUIMethod):
                    """
                    Add or edit convergence criterion for surface, volume, drag, lift and moment monitors.
                    """
                class average_over_last_n_iterations_timesteps(TUIMethod):
                    """
                    Option to average over previous values for checking convergence.
                    """
                class condition(TUIMethod):
                    """
                    Option to stop the calculations. All convergence conditions are met or any convergence condition is met.
                    """
                class delete(TUIMethod):
                    """
                    Delete a monitor from convergence criteria.
                    """
                class frequency(TUIMethod):
                    """
                    To set how often convergence checks are done with respect to iterations or time steps.
                    """
                class list(TUIMethod):
                    """
                    List defined convergence criteria for monitors.
                    """

            class force(TUIMenu):
                """
                Enter the force monitors menu.
                """
                def __init__(self, service, version, mode, path):
                    self.clear_all_monitors_data = self.__class__.clear_all_monitors_data(service, version, mode, path + ["clear_all_monitors_data"])
                    self.clear_drag_monitor_data = self.__class__.clear_drag_monitor_data(service, version, mode, path + ["clear_drag_monitor_data"])
                    self.clear_lift_monitor_data = self.__class__.clear_lift_monitor_data(service, version, mode, path + ["clear_lift_monitor_data"])
                    self.clear_moment_monitor_data = self.__class__.clear_moment_monitor_data(service, version, mode, path + ["clear_moment_monitor_data"])
                    self.clear_monitors = self.__class__.clear_monitors(service, version, mode, path + ["clear_monitors"])
                    self.delete_monitors = self.__class__.delete_monitors(service, version, mode, path + ["delete_monitors"])
                    self.drag_coefficient = self.__class__.drag_coefficient(service, version, mode, path + ["drag_coefficient"])
                    self.lift_coefficient = self.__class__.lift_coefficient(service, version, mode, path + ["lift_coefficient"])
                    self.list_monitors = self.__class__.list_monitors(service, version, mode, path + ["list_monitors"])
                    self.moment_coefficient = self.__class__.moment_coefficient(service, version, mode, path + ["moment_coefficient"])
                    self.monitor_unsteady_iters = self.__class__.monitor_unsteady_iters(service, version, mode, path + ["monitor_unsteady_iters"])
                    self.set_drag_monitor = self.__class__.set_drag_monitor(service, version, mode, path + ["set_drag_monitor"])
                    self.set_lift_monitor = self.__class__.set_lift_monitor(service, version, mode, path + ["set_lift_monitor"])
                    self.set_moment_monitor = self.__class__.set_moment_monitor(service, version, mode, path + ["set_moment_monitor"])
                    self.unscaled = self.__class__.unscaled(service, version, mode, path + ["unscaled"])
                    super().__init__(service, version, mode, path)
                class clear_all_monitors_data(TUIMethod):
                    """
                    Clear all monitoring data.
                    """
                class clear_drag_monitor_data(TUIMethod):
                    """
                    Clear the drag monitoring data.
                    """
                class clear_lift_monitor_data(TUIMethod):
                    """
                    Clear the lift monitoring data.
                    """
                class clear_moment_monitor_data(TUIMethod):
                    """
                    Clear the moment monitoring data.
                    """
                class clear_monitors(TUIMethod):
                    """
                    Clear all or specified monitor data.
                    """
                class delete_monitors(TUIMethod):
                    """
                    Delete the specified monitor.
                    """
                class drag_coefficient(TUIMethod):
                    """
                    Set variables for monitoring the drag coefficient.
                    """
                class lift_coefficient(TUIMethod):
                    """
                    Set variables for monitoring the lift coefficient.
                    """
                class list_monitors(TUIMethod):
                    """
                    List defined force monitors.
                    """
                class moment_coefficient(TUIMethod):
                    """
                    Set variables for monitoring the moment coefficient.
                    """
                class monitor_unsteady_iters(TUIMethod):
                    """
                    Specify whether monitors are updated every iteration or every time step for transient calculations.
                    """
                class set_drag_monitor(TUIMethod):
                    """
                    Set variables for monitoring the drag coefficient.
                    """
                class set_lift_monitor(TUIMethod):
                    """
                    Set variables for monitoring the lift coefficient.
                    """
                class set_moment_monitor(TUIMethod):
                    """
                    Set variables for monitoring the moment coefficient.
                    """
                class unscaled(TUIMethod):
                    """
                    Specify whether unscaled values are desired.
                    """

            class residual(TUIMenu):
                """
                Enters the residual monitors menu.
                """
                def __init__(self, service, version, mode, path):
                    self.check_convergence = self.__class__.check_convergence(service, version, mode, path + ["check_convergence"])
                    self.convergence_criteria = self.__class__.convergence_criteria(service, version, mode, path + ["convergence_criteria"])
                    self.criterion_type = self.__class__.criterion_type(service, version, mode, path + ["criterion_type"])
                    self.enhanced_continuity_residual = self.__class__.enhanced_continuity_residual(service, version, mode, path + ["enhanced_continuity_residual"])
                    self.monitor = self.__class__.monitor(service, version, mode, path + ["monitor"])
                    self.n_display = self.__class__.n_display(service, version, mode, path + ["n_display"])
                    self.n_maximize_norms = self.__class__.n_maximize_norms(service, version, mode, path + ["n_maximize_norms"])
                    self.n_save = self.__class__.n_save(service, version, mode, path + ["n_save"])
                    self.normalization_factors = self.__class__.normalization_factors(service, version, mode, path + ["normalization_factors"])
                    self.normalize = self.__class__.normalize(service, version, mode, path + ["normalize"])
                    self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
                    self.print = self.__class__.print(service, version, mode, path + ["print"])
                    self.re_normalize = self.__class__.re_normalize(service, version, mode, path + ["re_normalize"])
                    self.relative_conv_criteria = self.__class__.relative_conv_criteria(service, version, mode, path + ["relative_conv_criteria"])
                    self.reset = self.__class__.reset(service, version, mode, path + ["reset"])
                    self.scale_by_coefficient = self.__class__.scale_by_coefficient(service, version, mode, path + ["scale_by_coefficient"])
                    self.window = self.__class__.window(service, version, mode, path + ["window"])
                    super().__init__(service, version, mode, path)
                class check_convergence(TUIMethod):
                    """
                    Chooses which currently monitored residuals should be checked for convergence.
                    """
                class convergence_criteria(TUIMethod):
                    """
                    Sets convergence criteria for residuals that are currently being both monitored and checked.
                    """
                class criterion_type(TUIMethod):
                    """
                    Sets convergence criterion type.
                    """
                class enhanced_continuity_residual(TUIMethod):
                    """
                    Enables/disables an enhanced formulation for the local scaling of the continuity residuals with the pressure-based solver, so that the absolute mass flow rate at each cell is used. This text command is only available when the computing of the local scale is enabled through the solve/monitors/residual/scale-by-coefficient? text command.
                    """
                class monitor(TUIMethod):
                    """
                    Chooses which residuals to monitor as printed and/or plotted output.
                    """
                class n_display(TUIMethod):
                    """
                    Sets the number of most recent residuals to display in plots.
                    """
                class n_maximize_norms(TUIMethod):
                    """
                    Sets the number of iterations through which normalization factors will be maximized.
                    """
                class n_save(TUIMethod):
                    """
                    Sets number of residuals to be saved with data. History is automatically compacted when buffer becomes full.
                    """
                class normalization_factors(TUIMethod):
                    """
                    Sets normalization factors for currently monitored residuals (if normalize? is set to yes).
                    """
                class normalize(TUIMethod):
                    """
                    Chooses whether to normalize residuals in printed and plotted output.
                    """
                class plot(TUIMethod):
                    """
                    Chooses whether residuals will be plotted during iteration.
                    """
                class print(TUIMethod):
                    """
                    Chooses whether residuals will be printed during iteration.
                    """
                class re_normalize(TUIMethod):
                    """
                    Re-normalize residuals by maximum values.
                    """
                class relative_conv_criteria(TUIMethod):
                    """
                    Sets relative convergence criteria for residuals that are currently being both monitored and checked.
                    """
                class reset(TUIMethod):
                    """
                    Chooses whether to delete the residual history and reset iteration counter to 1.
                    """
                class scale_by_coefficient(TUIMethod):
                    """
                    Chooses whether to scale residuals by coefficient sum in printed and plotted output.
                    """
                class window(TUIMethod):
                    """
                    Specifies window in which residuals will be plotted during iteration.
                    """

            class statistic(TUIMenu):
                """
                Enter the statistic monitors menu.
                """
                def __init__(self, service, version, mode, path):
                    self.file_basename = self.__class__.file_basename(service, version, mode, path + ["file_basename"])
                    self.monitors = self.__class__.monitors(service, version, mode, path + ["monitors"])
                    self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
                    self.print = self.__class__.print(service, version, mode, path + ["print"])
                    self.window = self.__class__.window(service, version, mode, path + ["window"])
                    self.write = self.__class__.write(service, version, mode, path + ["write"])
                    self.x_axis = self.__class__.x_axis(service, version, mode, path + ["x_axis"])
                    super().__init__(service, version, mode, path)
                class file_basename(TUIMethod):
                    """
                    Specify the file basename and extension. The name of the individual monitor will be insterted automatically.
                    """
                class monitors(TUIMethod):
                    """
                    Choose which statistics to monitor as printed and/or plotted output.
                    """
                class plot(TUIMethod):
                    """
                    Enable/disable plotting of statistics during iteration.
                    """
                class print(TUIMethod):
                    """
                    Enable/disable printing of statistics during iteration.
                    """
                class window(TUIMethod):
                    """
                    Specify first window in which statistics will be plotted during iteration.
                    Multiple statistics are plotted in separate windows, beginning with this one.
                    """
                class write(TUIMethod):
                    """
                    Enable/disable writing of statistics during iteration.
                    """
                class x_axis(TUIMethod):
                    """
                    Choose what quantity to use on the abscissa in the plot and in the data written to files.
                    """

            class surface(TUIMenu):
                """
                Enter the surface menu to set integrated scalar quantities on surface(s) monitors.
                """
                def __init__(self, service, version, mode, path):
                    self.curves = self.__class__.curves(service, version, mode, path + ["curves"])
                    self.clear_data = self.__class__.clear_data(service, version, mode, path + ["clear_data"])
                    self.clear_monitors = self.__class__.clear_monitors(service, version, mode, path + ["clear_monitors"])
                    self.list_monitors = self.__class__.list_monitors(service, version, mode, path + ["list_monitors"])
                    self.set_monitor = self.__class__.set_monitor(service, version, mode, path + ["set_monitor"])
                    super().__init__(service, version, mode, path)
                class clear_data(TUIMethod):
                    """
                    Clear current surface monitor data.
                    """
                class clear_monitors(TUIMethod):
                    """
                    Remove all defined surface monitors.
                    """
                class list_monitors(TUIMethod):
                    """
                    List defined surface monitors.
                    """
                class set_monitor(TUIMethod):
                    """
                    Define or modify a surface monitor.
                    """

                class curves(TUIMenu):
                    """
                    Enter the curves menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.lines = self.__class__.lines(service, version, mode, path + ["lines"])
                        self.markers = self.__class__.markers(service, version, mode, path + ["markers"])
                        super().__init__(service, version, mode, path)
                    class lines(TUIMethod):
                        """
                        Set lines parameters for surface monitors.
                        """
                    class markers(TUIMethod):
                        """
                        Set markers parameters for surface monitors.
                        """

            class volume(TUIMenu):
                """
                Enter the volume menu to set integrated scalar quantities on volume(s) monitors.
                """
                def __init__(self, service, version, mode, path):
                    self.clear_data = self.__class__.clear_data(service, version, mode, path + ["clear_data"])
                    self.clear_monitors = self.__class__.clear_monitors(service, version, mode, path + ["clear_monitors"])
                    self.list_monitors = self.__class__.list_monitors(service, version, mode, path + ["list_monitors"])
                    self.set_monitor = self.__class__.set_monitor(service, version, mode, path + ["set_monitor"])
                    super().__init__(service, version, mode, path)
                class clear_data(TUIMethod):
                    """
                    Clear current volume monitor data.
                    """
                class clear_monitors(TUIMethod):
                    """
                    Remove all defined volume monitors.
                    """
                class list_monitors(TUIMethod):
                    """
                    List defined volume monitors.
                    """
                class set_monitor(TUIMethod):
                    """
                    Define or modify a volume monitor.
                    """

        class report_definitions(TUIMenu):
            """
            Enters the report definitions menu.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.compute = self.__class__.compute(service, version, mode, path + ["compute"])
                self.convert_monitors_to_report_defns = self.__class__.convert_monitors_to_report_defns(service, version, mode, path + ["convert_monitors_to_report_defns"])
                self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Add a new object.
                """
            class compute(TUIMethod):
                """
                Computes selected report definition.
                """
            class convert_monitors_to_report_defns(TUIMethod):
                """
                Converts all monitors to Report Definitions and create new Report Sets/Plot Sets if required.
                """
            class copy(TUIMethod):
                """
                Creates a copy of a report definition.
                """
            class delete(TUIMethod):
                """
                Deletes a report definition.
                """
            class delete_all(TUIMethod):
                """
                Deletes all of the report definition objects.
                """
            class edit(TUIMethod):
                """
                Edits a report definition.
                """
            class list(TUIMethod):
                """
                Lists all defined report definitions.
                """
            class list_properties(TUIMethod):
                """
                Lists the properties of a report definition.
                """
            class rename(TUIMethod):
                """
                Renames a report definition.
                """

        class report_files(TUIMenu):
            """
            Enters the report files menu.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.clear_data = self.__class__.clear_data(service, version, mode, path + ["clear_data"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Creates a report file.
                """
            class clear_data(TUIMethod):
                """
                Clears the data associated with a report file.
                """
            class delete(TUIMethod):
                """
                Deletes a report file object.
                """
            class delete_all(TUIMethod):
                """
                Deletes all of the report file objects.
                """
            class edit(TUIMethod):
                """
                Edits a report file.
                """
            class list(TUIMethod):
                """
                Lists all defined report files.
                """
            class list_properties(TUIMethod):
                """
                Lists the properties of a report file.
                """

        class report_plots(TUIMenu):
            """
            Enters the report plots menu.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                self.clear_data = self.__class__.clear_data(service, version, mode, path + ["clear_data"])
                self.curves = self.__class__.curves(service, version, mode, path + ["curves"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.get_window_id = self.__class__.get_window_id(service, version, mode, path + ["get_window_id"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Creates a report plot.
                """
            class axes(TUIMethod):
                """
                Defines the axes for a report plot.
                """
            class clear_data(TUIMethod):
                """
                Clears the data associated with a report plot.
                """
            class curves(TUIMethod):
                """
                Defines the curves for a report plot.
                """
            class delete(TUIMethod):
                """
                Deletes a report plot object.
                """
            class delete_all(TUIMethod):
                """
                Deletes all of the report plot objects.
                """
            class edit(TUIMethod):
                """
                Edits a report plot.
                """
            class get_window_id(TUIMethod):
                """
                Get report-plot object window id.
                """
            class list(TUIMethod):
                """
                Lists all defined report plots.
                """
            class list_properties(TUIMethod):
                """
                Lists the properties of a report plot.
                """
            class plot(TUIMethod):
                """
                Plots the specified report plot.
                """

        class set(TUIMenu):
            """
            Enters the set solution parameters menu.
            """
            def __init__(self, service, version, mode, path):
                self.acoustics_wave_equation_controls = self.__class__.acoustics_wave_equation_controls(service, version, mode, path + ["acoustics_wave_equation_controls"])
                self.advanced = self.__class__.advanced(service, version, mode, path + ["advanced"])
                self.amg_options = self.__class__.amg_options(service, version, mode, path + ["amg_options"])
                self.contact_solution_controls = self.__class__.contact_solution_controls(service, version, mode, path + ["contact_solution_controls"])
                self.data_sampling_options = self.__class__.data_sampling_options(service, version, mode, path + ["data_sampling_options"])
                self.divergence_prevention = self.__class__.divergence_prevention(service, version, mode, path + ["divergence_prevention"])
                self.enhanced_les_numerics = self.__class__.enhanced_les_numerics(service, version, mode, path + ["enhanced_les_numerics"])
                self.fast_transient_settings = self.__class__.fast_transient_settings(service, version, mode, path + ["fast_transient_settings"])
                self.high_order_term_relaxation = self.__class__.high_order_term_relaxation(service, version, mode, path + ["high_order_term_relaxation"])
                self.high_speed_numerics = self.__class__.high_speed_numerics(service, version, mode, path + ["high_speed_numerics"])
                self.multiphase_numerics = self.__class__.multiphase_numerics(service, version, mode, path + ["multiphase_numerics"])
                self.nita_expert_controls = self.__class__.nita_expert_controls(service, version, mode, path + ["nita_expert_controls"])
                self.open_channel_wave_options = self.__class__.open_channel_wave_options(service, version, mode, path + ["open_channel_wave_options"])
                self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                self.poor_mesh_numerics = self.__class__.poor_mesh_numerics(service, version, mode, path + ["poor_mesh_numerics"])
                self.poor_mesh_removal = self.__class__.poor_mesh_removal(service, version, mode, path + ["poor_mesh_removal"])
                self.previous_defaults = self.__class__.previous_defaults(service, version, mode, path + ["previous_defaults"])
                self.pseudo_time_method = self.__class__.pseudo_time_method(service, version, mode, path + ["pseudo_time_method"])
                self.slope_limiter_menu = self.__class__.slope_limiter_menu(service, version, mode, path + ["slope_limiter_menu"])
                self.transient_controls = self.__class__.transient_controls(service, version, mode, path + ["transient_controls"])
                self.warped_face_gradient_correction = self.__class__.warped_face_gradient_correction(service, version, mode, path + ["warped_face_gradient_correction"])
                self.accelerated_non_iterative_time_marching = self.__class__.accelerated_non_iterative_time_marching(service, version, mode, path + ["accelerated_non_iterative_time_marching"])
                self.adaptive_time_stepping = self.__class__.adaptive_time_stepping(service, version, mode, path + ["adaptive_time_stepping"])
                self.bc_pressure_extrapolations = self.__class__.bc_pressure_extrapolations(service, version, mode, path + ["bc_pressure_extrapolations"])
                self.cfl_based_adaptive_time_stepping = self.__class__.cfl_based_adaptive_time_stepping(service, version, mode, path + ["cfl_based_adaptive_time_stepping"])
                self.convergence_acceleration_for_stretched_meshes = self.__class__.convergence_acceleration_for_stretched_meshes(service, version, mode, path + ["convergence_acceleration_for_stretched_meshes"])
                self.correction_tolerance = self.__class__.correction_tolerance(service, version, mode, path + ["correction_tolerance"])
                self.coupled_vof_expert = self.__class__.coupled_vof_expert(service, version, mode, path + ["coupled_vof_expert"])
                self.courant_number = self.__class__.courant_number(service, version, mode, path + ["courant_number"])
                self.data_sampling = self.__class__.data_sampling(service, version, mode, path + ["data_sampling"])
                self.disable_reconstruction = self.__class__.disable_reconstruction(service, version, mode, path + ["disable_reconstruction"])
                self.discretization_scheme = self.__class__.discretization_scheme(service, version, mode, path + ["discretization_scheme"])
                self.enable_output_dp_dt = self.__class__.enable_output_dp_dt(service, version, mode, path + ["enable_output_dp_dt"])
                self.equation_ordering = self.__class__.equation_ordering(service, version, mode, path + ["equation_ordering"])
                self.equations = self.__class__.equations(service, version, mode, path + ["equations"])
                self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                self.flow_warnings = self.__class__.flow_warnings(service, version, mode, path + ["flow_warnings"])
                self.flux_type = self.__class__.flux_type(service, version, mode, path + ["flux_type"])
                self.gradient_scheme = self.__class__.gradient_scheme(service, version, mode, path + ["gradient_scheme"])
                self.heterogeneous_stiff_chemistry = self.__class__.heterogeneous_stiff_chemistry(service, version, mode, path + ["heterogeneous_stiff_chemistry"])
                self.limiter_warnings = self.__class__.limiter_warnings(service, version, mode, path + ["limiter_warnings"])
                self.limits = self.__class__.limits(service, version, mode, path + ["limits"])
                self.lock_solid_temperature = self.__class__.lock_solid_temperature(service, version, mode, path + ["lock_solid_temperature"])
                self.material_property_warnings = self.__class__.material_property_warnings(service, version, mode, path + ["material_property_warnings"])
                self.max_corrections = self.__class__.max_corrections(service, version, mode, path + ["max_corrections"])
                self.moving_mesh_numerics = self.__class__.moving_mesh_numerics(service, version, mode, path + ["moving_mesh_numerics"])
                self.mp_mfluid_aniso_drag = self.__class__.mp_mfluid_aniso_drag(service, version, mode, path + ["mp_mfluid_aniso_drag"])
                self.mp_reference_density = self.__class__.mp_reference_density(service, version, mode, path + ["mp_reference_density"])
                self.multi_grid_amg = self.__class__.multi_grid_amg(service, version, mode, path + ["multi_grid_amg"])
                self.multi_grid_controls = self.__class__.multi_grid_controls(service, version, mode, path + ["multi_grid_controls"])
                self.multi_grid_fas = self.__class__.multi_grid_fas(service, version, mode, path + ["multi_grid_fas"])
                self.multi_stage = self.__class__.multi_stage(service, version, mode, path + ["multi_stage"])
                self.nb_gradient_boundary_option = self.__class__.nb_gradient_boundary_option(service, version, mode, path + ["nb_gradient_boundary_option"])
                self.nb_gradient_new_symmetry_periodic = self.__class__.nb_gradient_new_symmetry_periodic(service, version, mode, path + ["nb_gradient_new_symmetry_periodic"])
                self.number_of_iterations = self.__class__.number_of_iterations(service, version, mode, path + ["number_of_iterations"])
                self.numerical_beach_controls = self.__class__.numerical_beach_controls(service, version, mode, path + ["numerical_beach_controls"])
                self.numerics = self.__class__.numerics(service, version, mode, path + ["numerics"])
                self.open_channel_controls = self.__class__.open_channel_controls(service, version, mode, path + ["open_channel_controls"])
                self.p_v_controls = self.__class__.p_v_controls(service, version, mode, path + ["p_v_controls"])
                self.p_v_controls_advanced = self.__class__.p_v_controls_advanced(service, version, mode, path + ["p_v_controls_advanced"])
                self.p_v_coupling = self.__class__.p_v_coupling(service, version, mode, path + ["p_v_coupling"])
                self.phase_based_vof_discretization = self.__class__.phase_based_vof_discretization(service, version, mode, path + ["phase_based_vof_discretization"])
                self.pseudo_relaxation_factor = self.__class__.pseudo_relaxation_factor(service, version, mode, path + ["pseudo_relaxation_factor"])
                self.pseudo_transient = self.__class__.pseudo_transient(service, version, mode, path + ["pseudo_transient"])
                self.pseudo_transient_expert = self.__class__.pseudo_transient_expert(service, version, mode, path + ["pseudo_transient_expert"])
                self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                self.reduced_rank_extrapolation = self.__class__.reduced_rank_extrapolation(service, version, mode, path + ["reduced_rank_extrapolation"])
                self.reduced_rank_extrapolation_options = self.__class__.reduced_rank_extrapolation_options(service, version, mode, path + ["reduced_rank_extrapolation_options"])
                self.relaxation_factor = self.__class__.relaxation_factor(service, version, mode, path + ["relaxation_factor"])
                self.relaxation_method = self.__class__.relaxation_method(service, version, mode, path + ["relaxation_method"])
                self.reporting_interval = self.__class__.reporting_interval(service, version, mode, path + ["reporting_interval"])
                self.residual_smoothing = self.__class__.residual_smoothing(service, version, mode, path + ["residual_smoothing"])
                self.residual_tolerance = self.__class__.residual_tolerance(service, version, mode, path + ["residual_tolerance"])
                self.residual_verbosity = self.__class__.residual_verbosity(service, version, mode, path + ["residual_verbosity"])
                self.second_order_time_options = self.__class__.second_order_time_options(service, version, mode, path + ["second_order_time_options"])
                self.set_all_species_together = self.__class__.set_all_species_together(service, version, mode, path + ["set_all_species_together"])
                self.set_controls_to_default = self.__class__.set_controls_to_default(service, version, mode, path + ["set_controls_to_default"])
                self.set_solution_methods_to_default = self.__class__.set_solution_methods_to_default(service, version, mode, path + ["set_solution_methods_to_default"])
                self.set_solution_steering = self.__class__.set_solution_steering(service, version, mode, path + ["set_solution_steering"])
                self.slope_limiter_set = self.__class__.slope_limiter_set(service, version, mode, path + ["slope_limiter_set"])
                self.solution_steering = self.__class__.solution_steering(service, version, mode, path + ["solution_steering"])
                self.stiff_chemistry = self.__class__.stiff_chemistry(service, version, mode, path + ["stiff_chemistry"])
                self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                self.surface_tension_expert = self.__class__.surface_tension_expert(service, version, mode, path + ["surface_tension_expert"])
                self.time_step = self.__class__.time_step(service, version, mode, path + ["time_step"])
                self.under_relaxation = self.__class__.under_relaxation(service, version, mode, path + ["under_relaxation"])
                self.variable_time_stepping = self.__class__.variable_time_stepping(service, version, mode, path + ["variable_time_stepping"])
                self.vof_explicit_controls = self.__class__.vof_explicit_controls(service, version, mode, path + ["vof_explicit_controls"])
                self.vof_numerics = self.__class__.vof_numerics(service, version, mode, path + ["vof_numerics"])
                super().__init__(service, version, mode, path)
            class accelerated_non_iterative_time_marching(TUIMethod):
                """
                Enables a modified NITA scheme and other setting changes that can speed up the simulation. This option is only available with the Large Eddy Simulation (LES) turbulence model, and is intended for unreacting flow simulations that use a constant-density fluid.
                """
            class adaptive_time_stepping(TUIMethod):
                """
                Set Error-based adaptive time-stepping parameters.
                """
            class bc_pressure_extrapolations(TUIMethod):
                """
                Sets pressure extrapolations schemes on boundaries.
                """
            class cfl_based_adaptive_time_stepping(TUIMethod):
                """
                Set CFL-based adaptive time-stepping parameters.
                """
            class convergence_acceleration_for_stretched_meshes(TUIMethod):
                """
                Enables convergence acceleration for stretched meshes to improve the convergence of the implicit density based solver on meshes with high cell stretching.
                """
            class correction_tolerance(TUIMethod):
                """
                Enters the correction tolerance menu.
                """
            class coupled_vof_expert(TUIMethod):
                """
                Set coupled vof expert controls.
                """
            class courant_number(TUIMethod):
                """
                Sets the fine-grid Courant number (time step factor). This command is available only for the coupled solvers.
                """
            class data_sampling(TUIMethod):
                """
                Enables data sampling for steady or unsteady flow statistics.
                """
            class disable_reconstruction(TUIMethod):
                """
                Completely disables reconstruction, resulting in totally first-order accuracy.
                """
            class discretization_scheme(TUIMethod):
                """
                Enters the discretization scheme menu. This allows you to select the discretization scheme for the convection terms in the solution equations. The following text commands can make a selection from a subset of the models in the following table:.
                """
            class enable_output_dp_dt(TUIMethod):
                """
                Controls whether the output field variabledp-dt will be available for transient simulation postprocessing. If you select no, pressure fields at the previous time steps will not be stored in memory which reduces memory usage.
                """
            class equation_ordering(TUIMethod):
                """
                Sets the order in which the model equations are solved, which can affect the convergence speed when you are using the pressure-based solver. The standard method is enabled by default and corresponds to the ordering shown in  and  in the Theory Guide; alternatively, you can select theoptimized-for-volumetric-expansion method, which is recommended for flows in which the density is strongly dependent on thermal effects, chemical composition, and so on (such as combustion simulations). This text command is not available for steady simulations and/or when a multiphase model is enabled.
                """
            class equations(TUIMethod):
                """
                Selects the equations to be solved.
                """
            class expert(TUIMethod):
                """
                Sets expert options.
                """
            class flow_warnings(TUIMethod):
                """
                Specifies whether or not to print warning messages when reversed flow occurs at inlets and outlets, and when mass-flow inlets develop supersonic regions. By default, flow warnings are printed.
                """
            class flux_type(TUIMethod):
                """
                Enter the flux type.
                """
            class gradient_scheme(TUIMethod):
                """
                Sets gradient options.
                """
            class heterogeneous_stiff_chemistry(TUIMethod):
                """
                Sets the heterogeneous stiff-chemistry solver.
                """
            class limiter_warnings(TUIMethod):
                """
                Specifies whether or not to print warning messages when quantities are being limited. By default, limiter warnings are printed.
                """
            class limits(TUIMethod):
                """
                Sets solver limits for various solution variables, in order to improve the stability of the solution.
                """
            class lock_solid_temperature(TUIMethod):
                """
                Specifies whether you want to lock (or freeze) the temperature values for all the cells in solid zones (including those to which you have a hooked an energy source through a UDF) and in walls that have shell conduction enabled, so that the values do not change during further solver iterations.
                """
            class material_property_warnings(TUIMethod):
                """
                Control the display of material property warning diagnostics:
                0 - off (no messages)
                1 - messages per material
                2 - messages per material and per property.
                """
            class max_corrections(TUIMethod):
                """
                Enters the max-corrections menu.
                """
            class moving_mesh_numerics(TUIMethod):
                """
                Transient options for sliding, moving, and/or dynamic mesh.
                """
            class mp_mfluid_aniso_drag(TUIMethod):
                """
                Sets anisotropic drag parameters for the Eulerian multiphase model.
                """
            class mp_reference_density(TUIMethod):
                """
                Sets the reference density method for the Eulerian multiphase model. The following options are available:
                0 (default): Averaged density of the phase
                1: Cell density of the phase
                1: Constant value of 1
                1: Cell density of the phase
                See  for more information.
                """
            class multi_grid_amg(TUIMethod):
                """
                Sets the parameters that govern the algebraic multigrid procedure.
                """
            class multi_grid_controls(TUIMethod):
                """
                Sets multigrid parameters and termination criteria.
                """
            class multi_grid_fas(TUIMethod):
                """
                Sets the parameters that control the FAS multigrid solver. This command appears only when the explicit coupled solver is used.
                """
            class multi_stage(TUIMethod):
                """
                Sets the multi-stage coefficients and the dissipation and viscous evaluation stages. This command appears only when the explicit coupled solver is used.
                """
            class nb_gradient_boundary_option(TUIMethod):
                """
                Switches between the modified treatment of node-based gradients at boundary cells and the legacy treatment (R14.5.7 and earlier). If using the density-based solver, you can also specify the extended treatment. For details, see .
                """
            class nb_gradient_new_symmetry_periodic(TUIMethod):
                """
                Set improved ggnb symmetric/periodic boundary treatment.
                """
            class number_of_iterations(TUIMethod):
                """
                Sets the number of iterations for a steady-state simulation without starting the calculation.
                """
            class numerical_beach_controls(TUIMethod):
                """
                Sets damping function in flow direction. This command appears only when the VOF model is enabled. Select the damping function to be used:
                Index
                Damping Function
                0
                Linear
                1
                Quadratic
                2
                Cubic
                3
                Cosine.
                """
            class numerics(TUIMethod):
                """
                Sets numerics options.
                """
            class open_channel_controls(TUIMethod):
                """
                For flows that do not transition from sub-critical to super-critical, or vice-versa, you can speed-up the solution calculation by updating the frequency of Froude number during run time.
                """
            class p_v_controls(TUIMethod):
                """
                Sets pressure-velocity controls.
                """
            class p_v_controls_advanced(TUIMethod):
                """
                Set advanced pressure-velocity coupling controls.
                """
            class p_v_coupling(TUIMethod):
                """
                Selects which pressure-velocity coupling scheme is to be used. Five schemes are available:.
                """
            class phase_based_vof_discretization(TUIMethod):
                """
                Sets phase based slope limiter for VOF compressive scheme.
                """
            class pseudo_relaxation_factor(TUIMethod):
                """
                For backward compatibility, pseudo relaxation factor menu.
                """
            class pseudo_transient(TUIMethod):
                """
                For backward compatibility, pseudo transient (global time-step) formulation setup.
                """
            class pseudo_transient_expert(TUIMethod):
                """
                For backward compatibility, pseudo transient expert usage control.
                """
            class reactions(TUIMethod):
                """
                Enables the species reaction sources and sets relaxation factor.
                """
            class reduced_rank_extrapolation(TUIMethod):
                """
                .
                """
            class reduced_rank_extrapolation_options(TUIMethod):
                """
                .
                """
            class relaxation_factor(TUIMethod):
                """
                Enters the relaxation-factor menu.
                """
            class relaxation_method(TUIMethod):
                """
                Sets the solver relaxation method.
                """
            class reporting_interval(TUIMethod):
                """
                Sets the number of iterations for which convergence monitors are reported. The default is 1 (after every iteration).
                """
            class residual_smoothing(TUIMethod):
                """
                Sets the implicit residual smoothing parameters. This command is available only for the explicit coupled solver.
                """
            class residual_tolerance(TUIMethod):
                """
                Enters the residual tolerance menu.
                """
            class residual_verbosity(TUIMethod):
                """
                Sets the amount of residual information to be printed. A value of 0 (the default) prints residuals at the end of each fine grid iteration. A value of 1 prints residuals after every stage of the fine grid iteration. A value of 2 prints residuals after every stage on every grid level.
                """
            class second_order_time_options(TUIMethod):
                """
                Enables / disables the variable time step size formulation for second-order implicit transient formulations. If you disable the variable time step size formulation, note that any change in the time step size will introduce an error proportional to the change in the time step size ratio.
                """
            class set_all_species_together(TUIMethod):
                """
                Sets all species discretizations and URFs together.
                """
            class set_controls_to_default(TUIMethod):
                """
                Sets controls to default values.
                """
            class set_solution_methods_to_default(TUIMethod):
                """
                Sets the solution methods to the default settings.
                """
            class set_solution_steering(TUIMethod):
                """
                Sets solution steering parameters.
                """
            class slope_limiter_set(TUIMethod):
                """
                Selects a new Fluent solver slope limiter.
                """
            class solution_steering(TUIMethod):
                """
                Enables solution steering for the density-based solver.
                """
            class stiff_chemistry(TUIMethod):
                """
                Sets solver options for stiff chemistry solutions.
                """
            class surface_tension(TUIMethod):
                """
                Sets surface-tension calculation options.
                """
            class surface_tension_expert(TUIMethod):
                """
                Set surface-tension expert options.
                """
            class time_step(TUIMethod):
                """
                .
                """
            class under_relaxation(TUIMethod):
                """
                Enters the under-relaxation menu, which allows you to set the under-relaxation factor for each equation that is being solved in a segregated manner.
                """
            class variable_time_stepping(TUIMethod):
                """
                Set Multiphase-Specific Adaptive time stepping parameters.
                """
            class vof_explicit_controls(TUIMethod):
                """
                Sets the sub time step calculation method for VOF calculations.
                """
            class vof_numerics(TUIMethod):
                """
                Sets VOF numeric options.
                """

            class acoustics_wave_equation_controls(TUIMenu):
                """
                Enters the menu to specify parameters of the acoustics wave equation solver.
                """
                def __init__(self, service, version, mode, path):
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.max_iterations_per_timestep = self.__class__.max_iterations_per_timestep(service, version, mode, path + ["max_iterations_per_timestep"])
                    self.relative_convergence_criterion = self.__class__.relative_convergence_criterion(service, version, mode, path + ["relative_convergence_criterion"])
                    super().__init__(service, version, mode, path)
                class max_iterations_per_timestep(TUIMethod):
                    """
                    .
                    """
                class relative_convergence_criterion(TUIMethod):
                    """
                    .
                    """

                class expert(TUIMenu):
                    """
                    Enters the menu to specify the expert parameters.
                    """
                    def __init__(self, service, version, mode, path):
                        self.explicit_relaxation_factor = self.__class__.explicit_relaxation_factor(service, version, mode, path + ["explicit_relaxation_factor"])
                        self.under_relaxation_factor = self.__class__.under_relaxation_factor(service, version, mode, path + ["under_relaxation_factor"])
                        super().__init__(service, version, mode, path)
                    class explicit_relaxation_factor(TUIMethod):
                        """
                        Specifies the explicit relaxation factor. Should be used only with  bad meshes, when iterations do not converge.
                        """
                    class under_relaxation_factor(TUIMethod):
                        """
                        Specifies the implicit under-relaxation factor. Should be used only  with bad meshes, when the AMG linear solver does not converge.
                        """

            class advanced(TUIMenu):
                """
                Enters the advanced settings menu.
                """
                def __init__(self, service, version, mode, path):
                    self.anisotropic_solid_heat_transfer = self.__class__.anisotropic_solid_heat_transfer(service, version, mode, path + ["anisotropic_solid_heat_transfer"])
                    self.non_reflecting_boundary_treatment = self.__class__.non_reflecting_boundary_treatment(service, version, mode, path + ["non_reflecting_boundary_treatment"])
                    self.secondary_gradient_limiting = self.__class__.secondary_gradient_limiting(service, version, mode, path + ["secondary_gradient_limiting"])
                    self.turbomachinery_specific_numerics = self.__class__.turbomachinery_specific_numerics(service, version, mode, path + ["turbomachinery_specific_numerics"])
                    self.alternate_wall_temp_formulation = self.__class__.alternate_wall_temp_formulation(service, version, mode, path + ["alternate_wall_temp_formulation"])
                    self.anisotropic_heat_flux = self.__class__.anisotropic_heat_flux(service, version, mode, path + ["anisotropic_heat_flux"])
                    self.bcd_boundedness = self.__class__.bcd_boundedness(service, version, mode, path + ["bcd_boundedness"])
                    self.bcd_scheme_type = self.__class__.bcd_scheme_type(service, version, mode, path + ["bcd_scheme_type"])
                    self.bcd_weights_freeze = self.__class__.bcd_weights_freeze(service, version, mode, path + ["bcd_weights_freeze"])
                    self.correction_form = self.__class__.correction_form(service, version, mode, path + ["correction_form"])
                    self.energy_numerical_noise_filter = self.__class__.energy_numerical_noise_filter(service, version, mode, path + ["energy_numerical_noise_filter"])
                    self.energy_reconstruction_gradient_limiting = self.__class__.energy_reconstruction_gradient_limiting(service, version, mode, path + ["energy_reconstruction_gradient_limiting"])
                    self.explicit_under_relaxation_value = self.__class__.explicit_under_relaxation_value(service, version, mode, path + ["explicit_under_relaxation_value"])
                    self.linearized_mass_transfer_udf = self.__class__.linearized_mass_transfer_udf(service, version, mode, path + ["linearized_mass_transfer_udf"])
                    self.retain_cell_residuals = self.__class__.retain_cell_residuals(service, version, mode, path + ["retain_cell_residuals"])
                    self.retain_temporary_solver_mem = self.__class__.retain_temporary_solver_mem(service, version, mode, path + ["retain_temporary_solver_mem"])
                    self.show_all_discretization_schemes = self.__class__.show_all_discretization_schemes(service, version, mode, path + ["show_all_discretization_schemes"])
                    self.singhal_et_al_cavitation_model = self.__class__.singhal_et_al_cavitation_model(service, version, mode, path + ["singhal_et_al_cavitation_model"])
                    self.skewness_correction_enhanced = self.__class__.skewness_correction_enhanced(service, version, mode, path + ["skewness_correction_enhanced"])
                    self.volume_flux_for_single_phase = self.__class__.volume_flux_for_single_phase(service, version, mode, path + ["volume_flux_for_single_phase"])
                    super().__init__(service, version, mode, path)
                class alternate_wall_temp_formulation(TUIMethod):
                    """
                    Enables/disables an alternate formulation for wall temperatures.
                    """
                class anisotropic_heat_flux(TUIMethod):
                    """
                    Select the heat flux calculation methods.
                    """
                class bcd_boundedness(TUIMethod):
                    """
                    Specifies the BCD scheme parameter, which controls the boundedness strength of the BCD scheme in the pressure-based solver, as described in .
                    """
                class bcd_scheme_type(TUIMethod):
                    """
                    BCD scheme type (standard or tunable).
                    """
                class bcd_weights_freeze(TUIMethod):
                    """
                    Enables/disables freezing of weighting coefficients of the central differencing and the upwind components of the BCD scheme. This dialog command requires the iteration number, after which the BCD scheme weights are to be frozen at each timestep. Freezing the BCD weighting coefficients may help to improve convergence of the timestep iterations as described in .
                    """
                class correction_form(TUIMethod):
                    """
                    S.
                    """
                class energy_numerical_noise_filter(TUIMethod):
                    """
                    Enables/disables a filter to eliminate non-physical numerical noise in the energy field. Numerical noise can appear in solution fields where large variations in specific heat or combustion with phase change are present. Using the energy equation numerical noise filter increases robustness, but may make the solution slightly more diffusive. This text command is only available with the pressure-based solver.
                    """
                class energy_reconstruction_gradient_limiting(TUIMethod):
                    """
                    Enable limiting of reconstruction gradient for the energy equation.
                    """
                class explicit_under_relaxation_value(TUIMethod):
                    """
                    Explicit under-relaxation value.
                    """
                class linearized_mass_transfer_udf(TUIMethod):
                    """
                    Enables/disables the use of a linearized mass transfer user-defined function (that is, the DEFINE_LINEARIZED_MASS_TRANSFER macro), as opposed to a mass transfer user-defined function (that is, the DEFINE_MASS_TRANSFER macro).
                    """
                class retain_cell_residuals(TUIMethod):
                    """
                    Enables/disables the retention of cell residuals for postprocessing.
                    """
                class retain_temporary_solver_mem(TUIMethod):
                    """
                    Enables/disables the retention of temporary solver memory, which retains gradient data and makes some advanced options available for postprocessing.
                    """
                class show_all_discretization_schemes(TUIMethod):
                    """
                    Enables/disables the availability of all applicable discretization schemes.
                    """
                class singhal_et_al_cavitation_model(TUIMethod):
                    """
                    Enables/disables the availability of the Singhal et al. cavitation model option, which can then be enabled in the Multiphase Model dialog box or by using the following text command: define/phases/set-domain-properties/interaction-domain/heat-mass-reaction/cavitation/cavitation?.
                    """
                class skewness_correction_enhanced(TUIMethod):
                    """
                    Enable enhanced skewness correction scheme.
                    """
                class volume_flux_for_single_phase(TUIMethod):
                    """
                    Enable/disable volume flux formulation for single phase flows.
                    """

                class anisotropic_solid_heat_transfer(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.flux = self.__class__.flux(service, version, mode, path + ["flux"])
                        self.gradient = self.__class__.gradient(service, version, mode, path + ["gradient"])
                        self.relaxation = self.__class__.relaxation(service, version, mode, path + ["relaxation"])
                        super().__init__(service, version, mode, path)
                    class flux(TUIMethod):
                        """
                        .
                        """
                    class gradient(TUIMethod):
                        """
                        .
                        """
                    class relaxation(TUIMethod):
                        """
                        .
                        """

                class non_reflecting_boundary_treatment(TUIMenu):
                    """
                    Enter non reflecting boundary treatment using minimal pressure reflection approach menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.pressure_inlet = self.__class__.pressure_inlet(service, version, mode, path + ["pressure_inlet"])
                        self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                        self.velocity_inlet = self.__class__.velocity_inlet(service, version, mode, path + ["velocity_inlet"])
                        super().__init__(service, version, mode, path)
                    class pressure_inlet(TUIMethod):
                        """
                        Enabling the use of minimal pressure reflection treatment. This treatment will minimize pressure wave reflections from the boundaries on which this option is active, but not necessarily fully eliminating them. The reflections would be of an acceptable limit in order to not contaminate the solution, the simulation will gain from the robustness of the new algorithm compared to traditional non-reflecting boundary condition treatment.
                        """
                    class pressure_outlet(TUIMethod):
                        """
                        Enabling the use of minimal pressure reflection treatment. This treatment will minimize pressure wave reflections from the boundaries on which this option is active, but not necessarily fully eliminating them. The reflections would be of an acceptable limit in order to not contaminate the solution, the simulation will gain from the robustness of the new algorithm compared to traditional non-reflecting boundary condition treatment.
                        """
                    class velocity_inlet(TUIMethod):
                        """
                        Enabling the use of minimal pressure reflection treatment. This treatment will minimize pressure wave reflections from the boundaries on which this option is active, but not necessarily fully eliminating them. The reflections would be of an acceptable limit in order to not contaminate the solution, the simulation will gain from the robustness of the new algorithm compared to traditional non-reflecting boundary condition treatment.
                        """

                class secondary_gradient_limiting(TUIMenu):
                    """
                    Enters the secondary gradient limiting menu. This menu is only available when the define/models/solver/pressure-based text command is enabled.
                    """
                    def __init__(self, service, version, mode, path):
                        self.energy = self.__class__.energy(service, version, mode, path + ["energy"])
                        self.mesh_quality_limits = self.__class__.mesh_quality_limits(service, version, mode, path + ["mesh_quality_limits"])
                        self.uds = self.__class__.uds(service, version, mode, path + ["uds"])
                        super().__init__(service, version, mode, path)
                    class energy(TUIMethod):
                        """
                        Enables/disables secondary gradient limiting for the energy  calculations on coupled two-sided walls. This limiting can help prevent  divergence when the cells on such walls have poor orthogonality.
                        """
                    class mesh_quality_limits(TUIMethod):
                        """
                        Defines the mesh quality limits used when applying secondary  gradient limiting to faces on coupled two-sided walls. Shifting this  range closer to 1 will decrease the risk of divergence, but at the cost  of accuracy.
                        """
                    class uds(TUIMethod):
                        """
                        Enables/disables secondary gradient limiting for the user-defined  scalar (UDS) calculations on coupled two-sided walls. This limiting can  help prevent divergence when the cells on such walls have poor  orthogonality.
                        """

                class turbomachinery_specific_numerics(TUIMenu):
                    """
                    Enter turbomachinery-specific numerics menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.options = self.__class__.options(service, version, mode, path + ["options"])
                        self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                        super().__init__(service, version, mode, path)
                    class enable(TUIMethod):
                        """
                        Activate/deactivate turbomachinery-specific numerics.
                        """

                    class options(TUIMenu):
                        """
                        Enter turbomachinery-specific numerics options menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.gradient_limiter_combination = self.__class__.gradient_limiter_combination(service, version, mode, path + ["gradient_limiter_combination"])
                            self.pseudo_time_scale_type = self.__class__.pseudo_time_scale_type(service, version, mode, path + ["pseudo_time_scale_type"])
                            super().__init__(service, version, mode, path)
                        class gradient_limiter_combination(TUIMethod):
                            """
                            Select gradient limiter combination for turbomachinery-specific numerics.
                            """
                        class pseudo_time_scale_type(TUIMethod):
                            """
                            Select pseudo transient time scale type for turbomachinery-specific numerics.
                            """

            class amg_options(TUIMenu):
                """
                Enters the AMG options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.aggressive_amg_coarsening = self.__class__.aggressive_amg_coarsening(service, version, mode, path + ["aggressive_amg_coarsening"])
                    self.amg_gpgpu_options = self.__class__.amg_gpgpu_options(service, version, mode, path + ["amg_gpgpu_options"])
                    self.conservative_amg_coarsening = self.__class__.conservative_amg_coarsening(service, version, mode, path + ["conservative_amg_coarsening"])
                    self.laplace_coarsening = self.__class__.laplace_coarsening(service, version, mode, path + ["laplace_coarsening"])
                    super().__init__(service, version, mode, path)
                class aggressive_amg_coarsening(TUIMethod):
                    """
                    Enables / disables the use of a version of the AMG solver that is optimized for high coarsening rates. This option is recommended if the AMG solver diverges with the default settings.
                    """
                class amg_gpgpu_options(TUIMethod):
                    """
                    Set GPGPU AMG solver options.
                    """
                class conservative_amg_coarsening(TUIMethod):
                    """
                    Enables / disables the use of conservative coarsening techniques for scalar and/or coupled equations that can improve parallel performance and/or convergence for some difficult cases.
                    """
                class laplace_coarsening(TUIMethod):
                    """
                    Enables / disables Laplace coarsening for scalar and/or coupled equations.
                    """

            class contact_solution_controls(TUIMenu):
                """
                Solver controls for contact marks method.
                """
                def __init__(self, service, version, mode, path):
                    self.amg = self.__class__.amg(service, version, mode, path + ["amg"])
                    self.methods = self.__class__.methods(service, version, mode, path + ["methods"])
                    self.miscellaneous = self.__class__.miscellaneous(service, version, mode, path + ["miscellaneous"])
                    self.models = self.__class__.models(service, version, mode, path + ["models"])
                    self.parameters = self.__class__.parameters(service, version, mode, path + ["parameters"])
                    self.spatial = self.__class__.spatial(service, version, mode, path + ["spatial"])
                    self.transient = self.__class__.transient(service, version, mode, path + ["transient"])
                    self.set_settings_to_default = self.__class__.set_settings_to_default(service, version, mode, path + ["set_settings_to_default"])
                    self.solution_stabilization = self.__class__.solution_stabilization(service, version, mode, path + ["solution_stabilization"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    super().__init__(service, version, mode, path)
                class set_settings_to_default(TUIMethod):
                    """
                    Set contact solution stabilization to default.
                    """
                class solution_stabilization(TUIMethod):
                    """
                    .
                    """
                class verbosity(TUIMethod):
                    """
                    .
                    """

                class amg(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.coarsen_rate = self.__class__.coarsen_rate(service, version, mode, path + ["coarsen_rate"])
                        self.enforce_laplace_coarsening = self.__class__.enforce_laplace_coarsening(service, version, mode, path + ["enforce_laplace_coarsening"])
                        self.increase_pre_sweeps = self.__class__.increase_pre_sweeps(service, version, mode, path + ["increase_pre_sweeps"])
                        self.pre_sweeps = self.__class__.pre_sweeps(service, version, mode, path + ["pre_sweeps"])
                        self.specify_coarsening_rate = self.__class__.specify_coarsening_rate(service, version, mode, path + ["specify_coarsening_rate"])
                        super().__init__(service, version, mode, path)
                    class coarsen_rate(TUIMethod):
                        """
                        .
                        """
                    class enforce_laplace_coarsening(TUIMethod):
                        """
                        .
                        """
                    class increase_pre_sweeps(TUIMethod):
                        """
                        .
                        """
                    class pre_sweeps(TUIMethod):
                        """
                        .
                        """
                    class specify_coarsening_rate(TUIMethod):
                        """
                        .
                        """

                class methods(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.gradient_controls = self.__class__.gradient_controls(service, version, mode, path + ["gradient_controls"])
                        self.pressure_velocity_coupling_controls = self.__class__.pressure_velocity_coupling_controls(service, version, mode, path + ["pressure_velocity_coupling_controls"])
                        self.pressure_velocity_coupling_method = self.__class__.pressure_velocity_coupling_method(service, version, mode, path + ["pressure_velocity_coupling_method"])
                        self.specify_gradient_method = self.__class__.specify_gradient_method(service, version, mode, path + ["specify_gradient_method"])
                        super().__init__(service, version, mode, path)
                    class gradient_controls(TUIMethod):
                        """
                        .
                        """
                    class pressure_velocity_coupling_controls(TUIMethod):
                        """
                        .
                        """
                    class pressure_velocity_coupling_method(TUIMethod):
                        """
                        .
                        """
                    class specify_gradient_method(TUIMethod):
                        """
                        .
                        """

                class miscellaneous(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.compute_statistics = self.__class__.compute_statistics(service, version, mode, path + ["compute_statistics"])
                        self.statistics_level = self.__class__.statistics_level(service, version, mode, path + ["statistics_level"])
                        super().__init__(service, version, mode, path)
                    class compute_statistics(TUIMethod):
                        """
                        .
                        """
                    class statistics_level(TUIMethod):
                        """
                        .
                        """

                class models(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.model_ramping = self.__class__.model_ramping(service, version, mode, path + ["model_ramping"])
                        self.ramp_flow = self.__class__.ramp_flow(service, version, mode, path + ["ramp_flow"])
                        self.ramp_scalars = self.__class__.ramp_scalars(service, version, mode, path + ["ramp_scalars"])
                        self.ramp_turbulence = self.__class__.ramp_turbulence(service, version, mode, path + ["ramp_turbulence"])
                        super().__init__(service, version, mode, path)
                    class model_ramping(TUIMethod):
                        """
                        .
                        """
                    class ramp_flow(TUIMethod):
                        """
                        .
                        """
                    class ramp_scalars(TUIMethod):
                        """
                        .
                        """
                    class ramp_turbulence(TUIMethod):
                        """
                        .
                        """

                class parameters(TUIMenu):
                    """
                    Parameters used in stabilization strategy.
                    """
                    def __init__(self, service, version, mode, path):
                        self.extrapolation_method = self.__class__.extrapolation_method(service, version, mode, path + ["extrapolation_method"])
                        self.iterations = self.__class__.iterations(service, version, mode, path + ["iterations"])
                        self.persistence_fixed_duration = self.__class__.persistence_fixed_duration(service, version, mode, path + ["persistence_fixed_duration"])
                        self.persistence_fixed_time_steps = self.__class__.persistence_fixed_time_steps(service, version, mode, path + ["persistence_fixed_time_steps"])
                        self.solution_stabilization_persistence = self.__class__.solution_stabilization_persistence(service, version, mode, path + ["solution_stabilization_persistence"])
                        super().__init__(service, version, mode, path)
                    class extrapolation_method(TUIMethod):
                        """
                        Solution extrapolation method for cells changing status from contact to non-contact [0-none, 1-local extrapolation].
                        """
                    class iterations(TUIMethod):
                        """
                        .
                        """
                    class persistence_fixed_duration(TUIMethod):
                        """
                        .
                        """
                    class persistence_fixed_time_steps(TUIMethod):
                        """
                        .
                        """
                    class solution_stabilization_persistence(TUIMethod):
                        """
                        .
                        """

                class spatial(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.first_to_second_order_blending = self.__class__.first_to_second_order_blending(service, version, mode, path + ["first_to_second_order_blending"])
                        self.first_to_second_order_blending_list = self.__class__.first_to_second_order_blending_list(service, version, mode, path + ["first_to_second_order_blending_list"])
                        self.flow_skew_diffusion_exclude = self.__class__.flow_skew_diffusion_exclude(service, version, mode, path + ["flow_skew_diffusion_exclude"])
                        self.rhie_chow_flux_specify = self.__class__.rhie_chow_flux_specify(service, version, mode, path + ["rhie_chow_flux_specify"])
                        self.rhie_chow_method = self.__class__.rhie_chow_method(service, version, mode, path + ["rhie_chow_method"])
                        self.scalars_skew_diffusion_exclude = self.__class__.scalars_skew_diffusion_exclude(service, version, mode, path + ["scalars_skew_diffusion_exclude"])
                        self.scheme = self.__class__.scheme(service, version, mode, path + ["scheme"])
                        super().__init__(service, version, mode, path)
                    class first_to_second_order_blending(TUIMethod):
                        """
                        .
                        """
                    class first_to_second_order_blending_list(TUIMethod):
                        """
                        .
                        """
                    class flow_skew_diffusion_exclude(TUIMethod):
                        """
                        .
                        """
                    class rhie_chow_flux_specify(TUIMethod):
                        """
                        .
                        """
                    class rhie_chow_method(TUIMethod):
                        """
                        .
                        """
                    class scalars_skew_diffusion_exclude(TUIMethod):
                        """
                        .
                        """
                    class scheme(TUIMethod):
                        """
                        .
                        """

                class transient(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.time_scale_modification_factor = self.__class__.time_scale_modification_factor(service, version, mode, path + ["time_scale_modification_factor"])
                        self.time_scale_modification_method = self.__class__.time_scale_modification_method(service, version, mode, path + ["time_scale_modification_method"])
                        self.transient_parameters_specify = self.__class__.transient_parameters_specify(service, version, mode, path + ["transient_parameters_specify"])
                        self.transient_scheme = self.__class__.transient_scheme(service, version, mode, path + ["transient_scheme"])
                        super().__init__(service, version, mode, path)
                    class time_scale_modification_factor(TUIMethod):
                        """
                        .
                        """
                    class time_scale_modification_method(TUIMethod):
                        """
                        .
                        """
                    class transient_parameters_specify(TUIMethod):
                        """
                        .
                        """
                    class transient_scheme(TUIMethod):
                        """
                        .
                        """

            class data_sampling_options(TUIMenu):
                """
                Enter the menu for specifying quantities and zones for steady and unsteady flow statistics.
                """
                def __init__(self, service, version, mode, path):
                    self.dft_datasets = self.__class__.dft_datasets(service, version, mode, path + ["dft_datasets"])
                    self.add_datasets = self.__class__.add_datasets(service, version, mode, path + ["add_datasets"])
                    self.list_datasets = self.__class__.list_datasets(service, version, mode, path + ["list_datasets"])
                    self.remove_dataset = self.__class__.remove_dataset(service, version, mode, path + ["remove_dataset"])
                    super().__init__(service, version, mode, path)
                class add_datasets(TUIMethod):
                    """
                    Add a dataset. After providing the zones for a dataset, press [Enter] to move onto selecting quantities. Enter () to complete the quantity selection for this dataset.
                    """
                class list_datasets(TUIMethod):
                    """
                    Lists the combinations of zones and quantities that are defined for sampling steady and unsteady flow statistics.
                    """
                class remove_dataset(TUIMethod):
                    """
                    Remove dataset.
                    """

                class dft_datasets(TUIMenu):
                    """
                    Data sampling options for runtime discrete Fourier transform.
                    """
                    def __init__(self, service, version, mode, path):
                        self.add_band_datasets = self.__class__.add_band_datasets(service, version, mode, path + ["add_band_datasets"])
                        self.add_tone_datasets = self.__class__.add_tone_datasets(service, version, mode, path + ["add_tone_datasets"])
                        self.dataset_properties = self.__class__.dataset_properties(service, version, mode, path + ["dataset_properties"])
                        self.delete_dataset = self.__class__.delete_dataset(service, version, mode, path + ["delete_dataset"])
                        self.list_datasets = self.__class__.list_datasets(service, version, mode, path + ["list_datasets"])
                        self.quantities = self.__class__.quantities(service, version, mode, path + ["quantities"])
                        self.window_function = self.__class__.window_function(service, version, mode, path + ["window_function"])
                        self.zones = self.__class__.zones(service, version, mode, path + ["zones"])
                        super().__init__(service, version, mode, path)
                    class add_band_datasets(TUIMethod):
                        """
                        Add DFT datasets for a frequency band.
                        """
                    class add_tone_datasets(TUIMethod):
                        """
                        Add DFT datasets for a single tone.
                        """
                    class dataset_properties(TUIMethod):
                        """
                        Print properties of a DFT dataset.
                        """
                    class delete_dataset(TUIMethod):
                        """
                        Delete DFT datasets.
                        """
                    class list_datasets(TUIMethod):
                        """
                        List DFT datasets.
                        """
                    class quantities(TUIMethod):
                        """
                        Select quantities for a new DFT dataset. Enter () to complete the quantity selection.
                        """
                    class window_function(TUIMethod):
                        """
                        Select window function for a DFT dataset.
                        """
                    class zones(TUIMethod):
                        """
                        Select zones for a new DFT dataset.
                        """

            class divergence_prevention(TUIMenu):
                """
                Enters the divergence prevention menu. This menu is only available for the density-based solver.
                """
                def __init__(self, service, version, mode, path):
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enables a divergence prevention option so that Fluent applies under-relaxation to the variables in select cells where the temperature and/or pressure values are approaching the minimum and/or maximum limits.
                    """

            class enhanced_les_numerics(TUIMenu):
                """
                Enter enhanced LES options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.optimized_advection = self.__class__.optimized_advection(service, version, mode, path + ["optimized_advection"])
                    self.optimized_algorithm = self.__class__.optimized_algorithm(service, version, mode, path + ["optimized_algorithm"])
                    self.optimized_cd = self.__class__.optimized_cd(service, version, mode, path + ["optimized_cd"])
                    super().__init__(service, version, mode, path)
                class optimized_advection(TUIMethod):
                    """
                    Use advection scheme optimized for LES.
                    """
                class optimized_algorithm(TUIMethod):
                    """
                    Use solver algorithm optimized for LES.
                    """
                class optimized_cd(TUIMethod):
                    """
                    Use optimized central difference discretization.
                    """

            class fast_transient_settings(TUIMenu):
                """
                Enters the fast transient settings menu. This menu is only available for transient cases that use the density-based solver.
                """
                def __init__(self, service, version, mode, path):
                    self.rk2 = self.__class__.rk2(service, version, mode, path + ["rk2"])
                    super().__init__(service, version, mode, path)
                class rk2(TUIMethod):
                    """
                    Allows you to enable the use of a two-stage Runge-Kutta scheme for time integration, or revert to the default multi-stage Runge-Kutta scheme. This text command is only available for transient cases that use the density-based explicit formulation.
                    """

            class high_order_term_relaxation(TUIMenu):
                """
                Enter High Order Relaxation Menu.
                """
                def __init__(self, service, version, mode, path):
                    self.options = self.__class__.options(service, version, mode, path + ["options"])
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enables/disables High Order Term Relaxation.
                    """

                class options(TUIMenu):
                    """
                    High Order Term Relaxation Options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.variables = self.__class__.variables(service, version, mode, path + ["variables"])
                        self.relaxation_factor = self.__class__.relaxation_factor(service, version, mode, path + ["relaxation_factor"])
                        self.type = self.__class__.type(service, version, mode, path + ["type"])
                        super().__init__(service, version, mode, path)
                    class relaxation_factor(TUIMethod):
                        """
                        Sets the relaxation factor.
                        """
                    class type(TUIMethod):
                        """
                        Enter high order relaxation type.
                        """

                    class variables(TUIMenu):
                        """
                        Selects the variables.
                        """
                        def __init__(self, service, version, mode, path):
                            self.select = self.__class__.select(service, version, mode, path + ["select"])
                            super().__init__(service, version, mode, path)
                        class select(TUIMethod):
                            """
                            Select variables for high order term relaxation.
                            """

            class high_speed_numerics(TUIMenu):
                """
                Enter high-speed-numerics menu.
                """
                def __init__(self, service, version, mode, path):
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.visualize_pressure_discontinuity_sensor = self.__class__.visualize_pressure_discontinuity_sensor(service, version, mode, path + ["visualize_pressure_discontinuity_sensor"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enables/disables High Speed Numerics.
                    """
                class expert(TUIMethod):
                    """
                    Sets the level of stabilization used to achieve fast convergence. Enter a number 0-5 corresponding to the Mach number range that best characterizes the flow.
                    """
                class visualize_pressure_discontinuity_sensor(TUIMethod):
                    """
                    Makes available the Pressure Discontinuity Sensor which is a binary identifier equal to 1 if a cell is in proximity of a pressure discontinuity.
                    """

            class multiphase_numerics(TUIMenu):
                """
                Sets multiphase numerics options.
                """
                def __init__(self, service, version, mode, path):
                    self.advanced_stability_controls = self.__class__.advanced_stability_controls(service, version, mode, path + ["advanced_stability_controls"])
                    self.boiling_parameters = self.__class__.boiling_parameters(service, version, mode, path + ["boiling_parameters"])
                    self.compressible_flow = self.__class__.compressible_flow(service, version, mode, path + ["compressible_flow"])
                    self.default_controls = self.__class__.default_controls(service, version, mode, path + ["default_controls"])
                    self.face_pressure_controls = self.__class__.face_pressure_controls(service, version, mode, path + ["face_pressure_controls"])
                    self.heat_mass_transfer = self.__class__.heat_mass_transfer(service, version, mode, path + ["heat_mass_transfer"])
                    self.porous_media = self.__class__.porous_media(service, version, mode, path + ["porous_media"])
                    self.solution_stabilization = self.__class__.solution_stabilization(service, version, mode, path + ["solution_stabilization"])
                    self.viscous_flow = self.__class__.viscous_flow(service, version, mode, path + ["viscous_flow"])
                    self.stable_vof_settings = self.__class__.stable_vof_settings(service, version, mode, path + ["stable_vof_settings"])
                    super().__init__(service, version, mode, path)
                class stable_vof_settings(TUIMethod):
                    """
                    Execute Stable VOF settings.
                    """

                class advanced_stability_controls(TUIMenu):
                    """
                    Enters the menu for the stability controls for multiphase flows. For more information about the below option, see  and .
                    """
                    def __init__(self, service, version, mode, path):
                        self.anti_diffusion = self.__class__.anti_diffusion(service, version, mode, path + ["anti_diffusion"])
                        self.equation_order = self.__class__.equation_order(service, version, mode, path + ["equation_order"])
                        self.hybrid_nita = self.__class__.hybrid_nita(service, version, mode, path + ["hybrid_nita"])
                        self.num_ventilation = self.__class__.num_ventilation(service, version, mode, path + ["num_ventilation"])
                        self.p_v_coupling = self.__class__.p_v_coupling(service, version, mode, path + ["p_v_coupling"])
                        self.pseudo_time = self.__class__.pseudo_time(service, version, mode, path + ["pseudo_time"])
                        self.pseudo_transient = self.__class__.pseudo_transient(service, version, mode, path + ["pseudo_transient"])
                        self.velocity_limiting = self.__class__.velocity_limiting(service, version, mode, path + ["velocity_limiting"])
                        super().__init__(service, version, mode, path)

                    class anti_diffusion(TUIMenu):
                        """
                        Enters the anti-diffusion menu. This item is available for VOF cases  with the Interfacial Anti-Diffusion option  enabled.
                        """
                        def __init__(self, service, version, mode, path):
                            self.enable_dynamic_strength = self.__class__.enable_dynamic_strength(service, version, mode, path + ["enable_dynamic_strength"])
                            self.set_dynamic_strength_exponent = self.__class__.set_dynamic_strength_exponent(service, version, mode, path + ["set_dynamic_strength_exponent"])
                            self.set_maximum_dynamic_strength = self.__class__.set_maximum_dynamic_strength(service, version, mode, path + ["set_maximum_dynamic_strength"])
                            super().__init__(service, version, mode, path)
                        class enable_dynamic_strength(TUIMethod):
                            """
                            Enables dynamic strength to reduce compression in the direction tangential to the interface.
                            """
                        class set_dynamic_strength_exponent(TUIMethod):
                            """
                            Sets the cosine exponent in the dynamic strength treatment in ).
                            """
                        class set_maximum_dynamic_strength(TUIMethod):
                            """
                            Sets the maximum value of dynamic anti-diffusion strength in ).
                            """

                    class equation_order(TUIMenu):
                        """
                        Enters the equation order menu for homogeneous multiphase flow  models.
                        """
                        def __init__(self, service, version, mode, path):
                            self.solve_exp_vof_at_end = self.__class__.solve_exp_vof_at_end(service, version, mode, path + ["solve_exp_vof_at_end"])
                            self.solve_flow_last = self.__class__.solve_flow_last(service, version, mode, path + ["solve_flow_last"])
                            super().__init__(service, version, mode, path)
                        class solve_exp_vof_at_end(TUIMethod):
                            """
                            .
                            """
                        class solve_flow_last(TUIMethod):
                            """
                            When enabled, solves the flow equation at the end of the iteration. This improves the behavior at the start of new time-step if the solution does not converge properly.
                            """

                    class hybrid_nita(TUIMenu):
                        """
                        Enters the equation order menu for homogeneous multiphase flow  models.
                        """
                        def __init__(self, service, version, mode, path):
                            self.instability_detector = self.__class__.instability_detector(service, version, mode, path + ["instability_detector"])
                            self.initial_outer_iterations = self.__class__.initial_outer_iterations(service, version, mode, path + ["initial_outer_iterations"])
                            self.outer_iterations = self.__class__.outer_iterations(service, version, mode, path + ["outer_iterations"])
                            super().__init__(service, version, mode, path)
                        class initial_outer_iterations(TUIMethod):
                            """
                            Allows you to change the number of initial time-steps and the number of initial outer iterations to control solution stability.
                            """
                        class outer_iterations(TUIMethod):
                            """
                            Sets the number of outer iterations.
                            """

                        class instability_detector(TUIMenu):
                            """
                            Enters the menu for the instability detector controls.
                            """
                            def __init__(self, service, version, mode, path):
                                self.enable_instability_detector = self.__class__.enable_instability_detector(service, version, mode, path + ["enable_instability_detector"])
                                self.set_cfl_limit = self.__class__.set_cfl_limit(service, version, mode, path + ["set_cfl_limit"])
                                self.set_cfl_type = self.__class__.set_cfl_type(service, version, mode, path + ["set_cfl_type"])
                                self.set_velocity_limit = self.__class__.set_velocity_limit(service, version, mode, path + ["set_velocity_limit"])
                                self.unstable_event_outer_iterations = self.__class__.unstable_event_outer_iterations(service, version, mode, path + ["unstable_event_outer_iterations"])
                                super().__init__(service, version, mode, path)
                            class enable_instability_detector(TUIMethod):
                                """
                                Enables/disables the instability detector to deal with  possible instability problems. Once this option is enabled,  additional instability detection options become  available.
                                """
                            class set_cfl_limit(TUIMethod):
                                """
                                Sets the Courant number limit for detecting unstable  events. This command becomes available once the enable-instability-detector? text  option has been enabled.
                                """
                            class set_cfl_type(TUIMethod):
                                """
                                Selects the CFL number type for detection of an unstable  event. This command becomes available once the enable-instability-detector? text  option has been enabled.
                                """
                            class set_velocity_limit(TUIMethod):
                                """
                                Sets the velocity limit for detecting unstable events.  This command becomes available once the enable-instability-detector? text  option has been enabled.
                                """
                            class unstable_event_outer_iterations(TUIMethod):
                                """
                                Sets the number of outer iterations for an unstable  event.
                                """

                    class num_ventilation(TUIMenu):
                        """
                        Numerical Ventilation Menu for VOF Model.
                        """
                        def __init__(self, service, version, mode, path):
                            self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                            self.near_wall_treatment_options = self.__class__.near_wall_treatment_options(service, version, mode, path + ["near_wall_treatment_options"])
                            self.tau_estimation_options = self.__class__.tau_estimation_options(service, version, mode, path + ["tau_estimation_options"])
                            self.trapped_phase_vof_max = self.__class__.trapped_phase_vof_max(service, version, mode, path + ["trapped_phase_vof_max"])
                            self.trapped_phase_vof_min = self.__class__.trapped_phase_vof_min(service, version, mode, path + ["trapped_phase_vof_min"])
                            super().__init__(service, version, mode, path)
                        class enable(TUIMethod):
                            """
                            Enable numerical ventilation treatment to remove trapped phase adjacent to wall.
                            """
                        class near_wall_treatment_options(TUIMethod):
                            """
                            Set near wall treatment options.
                            """
                        class tau_estimation_options(TUIMethod):
                            """
                            Set time step size option for numerical ventilation treatment.
                            """
                        class trapped_phase_vof_max(TUIMethod):
                            """
                            Set trapped phase maximum volume fraction to activate numerical ventilation treatment for non-trapped phases.
                            """
                        class trapped_phase_vof_min(TUIMethod):
                            """
                            Set trapped phase minimum volume fraction to activate numerical ventilation treatment for trapped phase.
                            """

                    class p_v_coupling(TUIMenu):
                        """
                        Enters the menu for the pressure-velocity coupling controls.
                        """
                        def __init__(self, service, version, mode, path):
                            self.coupled_vof = self.__class__.coupled_vof(service, version, mode, path + ["coupled_vof"])
                            self.pressure_interpolation = self.__class__.pressure_interpolation(service, version, mode, path + ["pressure_interpolation"])
                            self.rhie_chow_flux = self.__class__.rhie_chow_flux(service, version, mode, path + ["rhie_chow_flux"])
                            self.skewness_correction = self.__class__.skewness_correction(service, version, mode, path + ["skewness_correction"])
                            super().__init__(service, version, mode, path)

                        class coupled_vof(TUIMenu):
                            """
                            Enters the stability control menu for VOF cases that involve the Coupled pressure-velocity coupling scheme.
                            """
                            def __init__(self, service, version, mode, path):
                                self.buoyancy_force_linearization = self.__class__.buoyancy_force_linearization(service, version, mode, path + ["buoyancy_force_linearization"])
                                super().__init__(service, version, mode, path)
                            class buoyancy_force_linearization(TUIMethod):
                                """
                                Allows you to use the linearized buoyancy force and the  blended treatment for the buoyancy force.
                                """

                        class pressure_interpolation(TUIMenu):
                            """
                            Enters the pressure interpolation menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.modified_bfw_scheme = self.__class__.modified_bfw_scheme(service, version, mode, path + ["modified_bfw_scheme"])
                                super().__init__(service, version, mode, path)
                            class modified_bfw_scheme(TUIMethod):
                                """
                                Enables/disables the modified body force weighted  interpolation scheme. See  for more information about  this option.
                                """

                        class rhie_chow_flux(TUIMenu):
                            """
                            Enters the stability controls menu for the Rhie-Chow interpolation.
                            """
                            def __init__(self, service, version, mode, path):
                                self.low_order_rhie_chow = self.__class__.low_order_rhie_chow(service, version, mode, path + ["low_order_rhie_chow"])
                                super().__init__(service, version, mode, path)
                            class low_order_rhie_chow(TUIMethod):
                                """
                                Enables/disables the low-order velocity interpolation in  the flux calculation.
                                """

                        class skewness_correction(TUIMenu):
                            """
                            Enters the skewness correction menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.limit_pressure_correction_gradient = self.__class__.limit_pressure_correction_gradient(service, version, mode, path + ["limit_pressure_correction_gradient"])
                                super().__init__(service, version, mode, path)
                            class limit_pressure_correction_gradient(TUIMethod):
                                """
                                Enables/disables the limited pressure correction  gradient in skewness terms for the PISO, SIMPLEC, or  fractional step pressure-coupling schemes.
                                """

                    class pseudo_time(TUIMenu):
                        """
                        Pseudo-Time stability controls for multiphase flow.
                        """
                        def __init__(self, service, version, mode, path):
                            self.auto_dt_advanced_controls = self.__class__.auto_dt_advanced_controls(service, version, mode, path + ["auto_dt_advanced_controls"])
                            self.false_time_step_linearization = self.__class__.false_time_step_linearization(service, version, mode, path + ["false_time_step_linearization"])
                            self.smoothed_density_stabilization_method = self.__class__.smoothed_density_stabilization_method(service, version, mode, path + ["smoothed_density_stabilization_method"])
                            super().__init__(service, version, mode, path)
                        class false_time_step_linearization(TUIMethod):
                            """
                            .
                            """
                        class smoothed_density_stabilization_method(TUIMethod):
                            """
                            .
                            """

                        class auto_dt_advanced_controls(TUIMenu):
                            """
                            Set automatic time-stepping controls for better solution stability.
                            """
                            def __init__(self, service, version, mode, path):
                                self.dt_factor_max = self.__class__.dt_factor_max(service, version, mode, path + ["dt_factor_max"])
                                self.dt_factor_min = self.__class__.dt_factor_min(service, version, mode, path + ["dt_factor_min"])
                                self.dt_init_limit = self.__class__.dt_init_limit(service, version, mode, path + ["dt_init_limit"])
                                self.dt_max = self.__class__.dt_max(service, version, mode, path + ["dt_max"])
                                self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                                self.max_velocity_ratio = self.__class__.max_velocity_ratio(service, version, mode, path + ["max_velocity_ratio"])
                                super().__init__(service, version, mode, path)
                            class dt_factor_max(TUIMethod):
                                """
                                .
                                """
                            class dt_factor_min(TUIMethod):
                                """
                                .
                                """
                            class dt_init_limit(TUIMethod):
                                """
                                .
                                """
                            class dt_max(TUIMethod):
                                """
                                .
                                """
                            class enable(TUIMethod):
                                """
                                .
                                """
                            class max_velocity_ratio(TUIMethod):
                                """
                                .
                                """

                    class pseudo_transient(TUIMenu):
                        """
                        Enters the stability control menu for  steady-state multiphase cases with the pseudo time method option  enabled.
                        """
                        def __init__(self, service, version, mode, path):
                            self.auto_dt_advanced_controls = self.__class__.auto_dt_advanced_controls(service, version, mode, path + ["auto_dt_advanced_controls"])
                            self.false_time_step_linearization = self.__class__.false_time_step_linearization(service, version, mode, path + ["false_time_step_linearization"])
                            self.smoothed_density_stabilization_method = self.__class__.smoothed_density_stabilization_method(service, version, mode, path + ["smoothed_density_stabilization_method"])
                            super().__init__(service, version, mode, path)
                        class false_time_step_linearization(TUIMethod):
                            """
                            When enabled, provides additional stability for buoyancy-driven flows with the pseudo time method option enabled by increasing the diagonal dominance using the false time step size.
                            """
                        class smoothed_density_stabilization_method(TUIMethod):
                            """
                            Smooths the cell density near the interface, therefore avoiding unphysical acceleration of the lighter phase in the vicinity of interface. The default number of density smoothings is 2. In case of very large unphysical velocities across the interface, you can increase this number when prompted with Number of density smoothings.
                            """

                        class auto_dt_advanced_controls(TUIMenu):
                            """
                            Set automatic time-stepping controls for better solution stability.
                            """
                            def __init__(self, service, version, mode, path):
                                self.dt_factor_max = self.__class__.dt_factor_max(service, version, mode, path + ["dt_factor_max"])
                                self.dt_factor_min = self.__class__.dt_factor_min(service, version, mode, path + ["dt_factor_min"])
                                self.dt_init_limit = self.__class__.dt_init_limit(service, version, mode, path + ["dt_init_limit"])
                                self.dt_max = self.__class__.dt_max(service, version, mode, path + ["dt_max"])
                                self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                                self.max_velocity_ratio = self.__class__.max_velocity_ratio(service, version, mode, path + ["max_velocity_ratio"])
                                super().__init__(service, version, mode, path)
                            class dt_factor_max(TUIMethod):
                                """
                                .
                                """
                            class dt_factor_min(TUIMethod):
                                """
                                .
                                """
                            class dt_init_limit(TUIMethod):
                                """
                                .
                                """
                            class dt_max(TUIMethod):
                                """
                                .
                                """
                            class enable(TUIMethod):
                                """
                                .
                                """
                            class max_velocity_ratio(TUIMethod):
                                """
                                .
                                """

                    class velocity_limiting(TUIMenu):
                        """
                        Velocity limiting related stabiity controls for multiphase flow.
                        """
                        def __init__(self, service, version, mode, path):
                            self.enable_velocity_limiting = self.__class__.enable_velocity_limiting(service, version, mode, path + ["enable_velocity_limiting"])
                            self.set_damping_strength = self.__class__.set_damping_strength(service, version, mode, path + ["set_damping_strength"])
                            self.set_damping_strengths = self.__class__.set_damping_strengths(service, version, mode, path + ["set_damping_strengths"])
                            self.set_velocity_and_vof_cutoffs = self.__class__.set_velocity_and_vof_cutoffs(service, version, mode, path + ["set_velocity_and_vof_cutoffs"])
                            self.set_velocity_cutoff = self.__class__.set_velocity_cutoff(service, version, mode, path + ["set_velocity_cutoff"])
                            self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                            super().__init__(service, version, mode, path)
                        class enable_velocity_limiting(TUIMethod):
                            """
                            .
                            """
                        class set_damping_strength(TUIMethod):
                            """
                            .
                            """
                        class set_damping_strengths(TUIMethod):
                            """
                            Set phase based damping strength.
                            """
                        class set_velocity_and_vof_cutoffs(TUIMethod):
                            """
                            Set phase based velocity limiting controls.
                            """
                        class set_velocity_cutoff(TUIMethod):
                            """
                            .
                            """
                        class verbosity(TUIMethod):
                            """
                            .
                            """

                class boiling_parameters(TUIMenu):
                    """
                    Enters the menu for the multiphase boiling model parameters.
                    """
                    def __init__(self, service, version, mode, path):
                        self.liquid_vof_factor = self.__class__.liquid_vof_factor(service, version, mode, path + ["liquid_vof_factor"])
                        self.thin_film = self.__class__.thin_film(service, version, mode, path + ["thin_film"])
                        super().__init__(service, version, mode, path)
                    class liquid_vof_factor(TUIMethod):
                        """
                        When enabled, considers liquid volume fraction effects by multiplying the heat transfer coefficients by the local liquid volume fraction.
                        """
                    class thin_film(TUIMethod):
                        """
                        When enabled, includes multiphase boiling thin film effects using .
                        """

                class compressible_flow(TUIMenu):
                    """
                    Enters the compressible multiphase flow numerics menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.alternate_bc_formulation = self.__class__.alternate_bc_formulation(service, version, mode, path + ["alternate_bc_formulation"])
                        self.enhanced_numerics = self.__class__.enhanced_numerics(service, version, mode, path + ["enhanced_numerics"])
                        super().__init__(service, version, mode, path)
                    class alternate_bc_formulation(TUIMethod):
                        """
                        Enables an alternative formulation for compressible phases at an  inlet boundary. This formulation calculates static temperature and  pressure using an iterative method based on fundamental thermodynamic  relations.
                        """
                    class enhanced_numerics(TUIMethod):
                        """
                        Enables an enhanced numerical treatment that provides better  stability at startup and during calculation of compressible  flows.
                        """

                class default_controls(TUIMenu):
                    """
                    Enters the default controls menu. This menu is available only for multiphase flows.
                    """
                    def __init__(self, service, version, mode, path):
                        self.recommended_defaults_for_existing_cases = self.__class__.recommended_defaults_for_existing_cases(service, version, mode, path + ["recommended_defaults_for_existing_cases"])
                        self.revert_to_pre_r20_point_1_default_settings = self.__class__.revert_to_pre_r20_point_1_default_settings(service, version, mode, path + ["revert_to_pre_r20_point_1_default_settings"])
                        super().__init__(service, version, mode, path)
                    class recommended_defaults_for_existing_cases(TUIMethod):
                        """
                        Applies the multiphase defaults (version 2020 R1) to the loaded case  file.
                        """
                    class revert_to_pre_r20_point_1_default_settings(TUIMethod):
                        """
                        .
                        """

                class face_pressure_controls(TUIMenu):
                    """
                    Enter the face pressure expert controls menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.face_pressure_options = self.__class__.face_pressure_options(service, version, mode, path + ["face_pressure_options"])
                        super().__init__(service, version, mode, path)
                    class face_pressure_options(TUIMethod):
                        """
                        Set face pressure options.
                        """

                class heat_mass_transfer(TUIMenu):
                    """
                    Enters the menu for the multiphase heat mass transfer parameters.
                    """
                    def __init__(self, service, version, mode, path):
                        self.area_density = self.__class__.area_density(service, version, mode, path + ["area_density"])
                        self.boiling = self.__class__.boiling(service, version, mode, path + ["boiling"])
                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                        self.evaporation_condensation = self.__class__.evaporation_condensation(service, version, mode, path + ["evaporation_condensation"])
                        self.alternative_energy_treatment = self.__class__.alternative_energy_treatment(service, version, mode, path + ["alternative_energy_treatment"])
                        super().__init__(service, version, mode, path)
                    class alternative_energy_treatment(TUIMethod):
                        """
                        Enables the alternative treatment of the energy sources. For more  information, see .
                        """

                    class area_density(TUIMenu):
                        """
                        Enters the menu for the area density.
                        """
                        def __init__(self, service, version, mode, path):
                            self.ia_grad_sym = self.__class__.ia_grad_sym(service, version, mode, path + ["ia_grad_sym"])
                            self.vof_min_seeding = self.__class__.vof_min_seeding(service, version, mode, path + ["vof_min_seeding"])
                            super().__init__(service, version, mode, path)
                        class ia_grad_sym(TUIMethod):
                            """
                            Enables/disables the interfacial area density Gradient-Symmetric model. For more information about this model, see .
                            """
                        class vof_min_seeding(TUIMethod):
                            """
                            Sets the minimum volume fraction for the area density and cavitation. This may be useful, for example, in cases when a species mass transfer model (such as the Symmetric model or Particle model) do not consider evaporation or condensation if the volume fraction of one of the phases is zero. The seeding allows for a phase change to occur in the fluid flow. The default value is 1e-6.
                            """

                    class boiling(TUIMenu):
                        """
                        Enters the menu for the advanced boiling options for the  semi-mechanistic boiling model.
                        """
                        def __init__(self, service, version, mode, path):
                            self.heat_flux_relaxation_factor = self.__class__.heat_flux_relaxation_factor(service, version, mode, path + ["heat_flux_relaxation_factor"])
                            self.show_expert_options = self.__class__.show_expert_options(service, version, mode, path + ["show_expert_options"])
                            self.two_resistance_boiling_framework = self.__class__.two_resistance_boiling_framework(service, version, mode, path + ["two_resistance_boiling_framework"])
                            super().__init__(service, version, mode, path)
                        class heat_flux_relaxation_factor(TUIMethod):
                            """
                            Sets the under-relaxation factor for boiling heat flux. See  for details.
                            """
                        class show_expert_options(TUIMethod):
                            """
                            Exposes the expert options for the semi-mechanistic boiling model. For more information about these options, see .
                            """
                        class two_resistance_boiling_framework(TUIMethod):
                            """
                            Enables/disables the two-resistance boiling framework to improve the robustness and accuracy of the solution of cases with multiple boiling mechanisms. For more information about this item, see .
                            """

                    class cavitation(TUIMenu):
                        """
                        Enters the cavitation heat mass transfer menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.display_clipped_pressure = self.__class__.display_clipped_pressure(service, version, mode, path + ["display_clipped_pressure"])
                            self.max_vapor_pressure_ratio = self.__class__.max_vapor_pressure_ratio(service, version, mode, path + ["max_vapor_pressure_ratio"])
                            self.min_vapor_pressure = self.__class__.min_vapor_pressure(service, version, mode, path + ["min_vapor_pressure"])
                            self.p_limit_method = self.__class__.p_limit_method(service, version, mode, path + ["p_limit_method"])
                            self.schnerr_cond_coeff = self.__class__.schnerr_cond_coeff(service, version, mode, path + ["schnerr_cond_coeff"])
                            self.schnerr_evap_coeff = self.__class__.schnerr_evap_coeff(service, version, mode, path + ["schnerr_evap_coeff"])
                            self.turbulent_diffusion = self.__class__.turbulent_diffusion(service, version, mode, path + ["turbulent_diffusion"])
                            super().__init__(service, version, mode, path)
                        class display_clipped_pressure(TUIMethod):
                            """
                            .
                            """
                        class max_vapor_pressure_ratio(TUIMethod):
                            """
                            Sets the maximum limit on the vapor pressure after the turbulence and thermal correction. The default value is five times the vapor pressure, with consideration of turbulent and thermal effects for each cell and phase.
                            """
                        class min_vapor_pressure(TUIMethod):
                            """
                            Sets the minimum vapor pressure limit for the cavitation mass-transfer model. The default value is 1 Pa.
                            """
                        class p_limit_method(TUIMethod):
                            """
                            .
                            """
                        class schnerr_cond_coeff(TUIMethod):
                            """
                            Sets the condensation coefficient for the Schnerr-Sauer model (  in ). The default and recommended value of 0.2.
                            """
                        class schnerr_evap_coeff(TUIMethod):
                            """
                            Sets the evaporation coefficient for the Schnerr-Sauer model (  in ). The default and recommended value of 1.
                            """
                        class turbulent_diffusion(TUIMethod):
                            """
                            Enables/disables the turbulent diffusion treatment for a cavitating turbulent flow. See  for details.
                            """

                    class evaporation_condensation(TUIMenu):
                        """
                        Evaporation-condensation advanced options menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.ia_norm_min_limit = self.__class__.ia_norm_min_limit(service, version, mode, path + ["ia_norm_min_limit"])
                            self.max_rel_humiditiy = self.__class__.max_rel_humiditiy(service, version, mode, path + ["max_rel_humiditiy"])
                            self.vof_from_max_limit = self.__class__.vof_from_max_limit(service, version, mode, path + ["vof_from_max_limit"])
                            self.vof_from_min_limit = self.__class__.vof_from_min_limit(service, version, mode, path + ["vof_from_min_limit"])
                            self.vof_to_max_limit = self.__class__.vof_to_max_limit(service, version, mode, path + ["vof_to_max_limit"])
                            self.vof_to_min_limit = self.__class__.vof_to_min_limit(service, version, mode, path + ["vof_to_min_limit"])
                            super().__init__(service, version, mode, path)
                        class ia_norm_min_limit(TUIMethod):
                            """
                            .
                            """
                        class max_rel_humiditiy(TUIMethod):
                            """
                            .
                            """
                        class vof_from_max_limit(TUIMethod):
                            """
                            .
                            """
                        class vof_from_min_limit(TUIMethod):
                            """
                            .
                            """
                        class vof_to_max_limit(TUIMethod):
                            """
                            .
                            """
                        class vof_to_min_limit(TUIMethod):
                            """
                            .
                            """

                class porous_media(TUIMenu):
                    """
                    Enters the porous media numerics menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.capillary_pressure_as_diffusion = self.__class__.capillary_pressure_as_diffusion(service, version, mode, path + ["capillary_pressure_as_diffusion"])
                        self.relative_permeability = self.__class__.relative_permeability(service, version, mode, path + ["relative_permeability"])
                        super().__init__(service, version, mode, path)
                    class capillary_pressure_as_diffusion(TUIMethod):
                        """
                        .
                        """
                    class relative_permeability(TUIMethod):
                        """
                        Allows you to fix the saturation (volume fraction) of the phase at  its user-specified residual saturation value.
                        """

                class solution_stabilization(TUIMenu):
                    """
                    Enters the solution-stabilization numerics menu. This item is available only for the VOF model.
                    """
                    def __init__(self, service, version, mode, path):
                        self.additional_stabilization_controls = self.__class__.additional_stabilization_controls(service, version, mode, path + ["additional_stabilization_controls"])
                        self.velocity_limiting_treatment = self.__class__.velocity_limiting_treatment(service, version, mode, path + ["velocity_limiting_treatment"])
                        self.execute_additional_stability_controls = self.__class__.execute_additional_stability_controls(service, version, mode, path + ["execute_additional_stability_controls"])
                        self.execute_advanced_stabilization = self.__class__.execute_advanced_stabilization(service, version, mode, path + ["execute_advanced_stabilization"])
                        self.execute_settings_optimization = self.__class__.execute_settings_optimization(service, version, mode, path + ["execute_settings_optimization"])
                        super().__init__(service, version, mode, path)
                    class execute_additional_stability_controls(TUIMethod):
                        """
                        When enabled, uses additional controls for improved solution  stability.
                        """
                    class execute_advanced_stabilization(TUIMethod):
                        """
                        When enabled, modifies solver settings for improved solution  stability.
                        """
                    class execute_settings_optimization(TUIMethod):
                        """
                        .
                        """

                    class additional_stabilization_controls(TUIMenu):
                        """
                        Enters the menu for additional advanced stability controls.
                        """
                        def __init__(self, service, version, mode, path):
                            self.blended_compressive_scheme = self.__class__.blended_compressive_scheme(service, version, mode, path + ["blended_compressive_scheme"])
                            self.pseudo_time_stabilization = self.__class__.pseudo_time_stabilization(service, version, mode, path + ["pseudo_time_stabilization"])
                            self.pseudo_transient_stabilization = self.__class__.pseudo_transient_stabilization(service, version, mode, path + ["pseudo_transient_stabilization"])
                            super().__init__(service, version, mode, path)
                        class blended_compressive_scheme(TUIMethod):
                            """
                            Enables/disables the blended compressive discretization scheme.
                            """
                        class pseudo_time_stabilization(TUIMethod):
                            """
                            .
                            """
                        class pseudo_transient_stabilization(TUIMethod):
                            """
                            Enables/disables the pseudo-transient momentum stabilization and false time step linearization methods.
                            """

                    class velocity_limiting_treatment(TUIMenu):
                        """
                        Enters the menu for the velocity-limiting-treatment.
                        """
                        def __init__(self, service, version, mode, path):
                            self.enable_velocity_limiting = self.__class__.enable_velocity_limiting(service, version, mode, path + ["enable_velocity_limiting"])
                            self.set_damping_strength = self.__class__.set_damping_strength(service, version, mode, path + ["set_damping_strength"])
                            self.set_damping_strengths = self.__class__.set_damping_strengths(service, version, mode, path + ["set_damping_strengths"])
                            self.set_velocity_and_vof_cutoffs = self.__class__.set_velocity_and_vof_cutoffs(service, version, mode, path + ["set_velocity_and_vof_cutoffs"])
                            self.set_velocity_cutoff = self.__class__.set_velocity_cutoff(service, version, mode, path + ["set_velocity_cutoff"])
                            self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                            super().__init__(service, version, mode, path)
                        class enable_velocity_limiting(TUIMethod):
                            """
                            Enables/disables the velocity limiting treatment.
                            """
                        class set_damping_strength(TUIMethod):
                            """
                            .
                            """
                        class set_damping_strengths(TUIMethod):
                            """
                            Set phase based damping strength.
                            """
                        class set_velocity_and_vof_cutoffs(TUIMethod):
                            """
                            Set phase based velocity limiting controls.
                            """
                        class set_velocity_cutoff(TUIMethod):
                            """
                            Specifies the maximum velocity magnitude.
                            """
                        class verbosity(TUIMethod):
                            """
                            When enabled, the solver prints the number of velocity limited cells at each iteration.
                            """

                class viscous_flow(TUIMenu):
                    """
                    Enters the viscous multiphase flow numerics menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.interfacial_artificial_viscosity = self.__class__.interfacial_artificial_viscosity(service, version, mode, path + ["interfacial_artificial_viscosity"])
                        self.turb_visc_based_damping = self.__class__.turb_visc_based_damping(service, version, mode, path + ["turb_visc_based_damping"])
                        self.viscosity_averaging = self.__class__.viscosity_averaging(service, version, mode, path + ["viscosity_averaging"])
                        super().__init__(service, version, mode, path)
                    class interfacial_artificial_viscosity(TUIMethod):
                        """
                        .
                        """
                    class turb_visc_based_damping(TUIMethod):
                        """
                        Turbulence viscosity based damping controls.
                        """
                    class viscosity_averaging(TUIMethod):
                        """
                        Forces harmonic averaging of cell viscosities to calculate face  viscosity used in momentum equation. This can improve convergence for  highly viscous flow applications (the VOF model only).
                        """

            class nita_expert_controls(TUIMenu):
                """
                Enters the NITA expert control menu.
                """
                def __init__(self, service, version, mode, path):
                    self.hybrid_nita_settings = self.__class__.hybrid_nita_settings(service, version, mode, path + ["hybrid_nita_settings"])
                    self.skewness_neighbor_coupling = self.__class__.skewness_neighbor_coupling(service, version, mode, path + ["skewness_neighbor_coupling"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    super().__init__(service, version, mode, path)
                class hybrid_nita_settings(TUIMethod):
                    """
                    Enables and sets hybrid NITA options. For more details, see .
                    """
                class skewness_neighbor_coupling(TUIMethod):
                    """
                    Enables/disables coupling of the neighbor and skewness corrections.
                    """
                class verbosity(TUIMethod):
                    """
                    .
                    """

            class open_channel_wave_options(TUIMenu):
                """
                Sets buffer layer height, verbosity, and open channel wave theory formulation.
                """
                def __init__(self, service, version, mode, path):
                    self.set_buffer_layer_ht = self.__class__.set_buffer_layer_ht(service, version, mode, path + ["set_buffer_layer_ht"])
                    self.set_verbosity = self.__class__.set_verbosity(service, version, mode, path + ["set_verbosity"])
                    self.stokes_wave_variants = self.__class__.stokes_wave_variants(service, version, mode, path + ["stokes_wave_variants"])
                    super().__init__(service, version, mode, path)
                class set_buffer_layer_ht(TUIMethod):
                    """
                    Sets the buffer layer height.
                    """
                class set_verbosity(TUIMethod):
                    """
                    Sets the open channel wave verbosity.
                    """
                class stokes_wave_variants(TUIMethod):
                    """
                    Specifies which open channel wave theory formulation Fluent uses.
                    """

            class overset(TUIMenu):
                """
                Specifies overset meshing solver options.
                """
                def __init__(self, service, version, mode, path):
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.high_order_pressure = self.__class__.high_order_pressure(service, version, mode, path + ["high_order_pressure"])
                    self.interpolation_method = self.__class__.interpolation_method(service, version, mode, path + ["interpolation_method"])
                    self.orphan_cell_treatment = self.__class__.orphan_cell_treatment(service, version, mode, path + ["orphan_cell_treatment"])
                    super().__init__(service, version, mode, path)
                class high_order_pressure(TUIMethod):
                    """
                    Uses the pressure gradient of the donor cell in the interpolation of pressure for its receptor cell.
                    """
                class interpolation_method(TUIMethod):
                    """
                    Selects the interpolation method for overset interfaces. Note that the least squares method is recommended for sliding mesh cases.
                    """
                class orphan_cell_treatment(TUIMethod):
                    """
                    Enables/disables a numerical treatment that attempts to assign reasonable data values to orphan cells.
                    """

                class expert(TUIMenu):
                    """
                    Enter overset expert solver options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.hybrid_mode_selection = self.__class__.hybrid_mode_selection(service, version, mode, path + ["hybrid_mode_selection"])
                        self.mass_flux_correction_method = self.__class__.mass_flux_correction_method(service, version, mode, path + ["mass_flux_correction_method"])
                        super().__init__(service, version, mode, path)
                    class hybrid_mode_selection(TUIMethod):
                        """
                        Mode for hybrid interpolation.
                        """
                    class mass_flux_correction_method(TUIMethod):
                        """
                        Enter mass flux correction option at overset interfaces.
                        """

            class poor_mesh_numerics(TUIMenu):
                """
                Enters the poor mesh numerics menu.
                """
                def __init__(self, service, version, mode, path):
                    self.register_based = self.__class__.register_based(service, version, mode, path + ["register_based"])
                    self.solution_based_pmn = self.__class__.solution_based_pmn(service, version, mode, path + ["solution_based_pmn"])
                    self.cell_quality_based = self.__class__.cell_quality_based(service, version, mode, path + ["cell_quality_based"])
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.enhanced_pmn = self.__class__.enhanced_pmn(service, version, mode, path + ["enhanced_pmn"])
                    self.gradient_quality_based = self.__class__.gradient_quality_based(service, version, mode, path + ["gradient_quality_based"])
                    self.grid_deficiency_identifier = self.__class__.grid_deficiency_identifier(service, version, mode, path + ["grid_deficiency_identifier"])
                    self.improve_solver_skewness_quality = self.__class__.improve_solver_skewness_quality(service, version, mode, path + ["improve_solver_skewness_quality"])
                    self.orthogonality_enhancing_cell_centroids = self.__class__.orthogonality_enhancing_cell_centroids(service, version, mode, path + ["orthogonality_enhancing_cell_centroids"])
                    self.print_poor_elements_count = self.__class__.print_poor_elements_count(service, version, mode, path + ["print_poor_elements_count"])
                    self.reset_poor_elements = self.__class__.reset_poor_elements(service, version, mode, path + ["reset_poor_elements"])
                    self.set_quality_threshold = self.__class__.set_quality_threshold(service, version, mode, path + ["set_quality_threshold"])
                    self.solution_and_quality_based = self.__class__.solution_and_quality_based(service, version, mode, path + ["solution_and_quality_based"])
                    self.turbulence_production_term = self.__class__.turbulence_production_term(service, version, mode, path + ["turbulence_production_term"])
                    self.update_grid_deficiency_identifier = self.__class__.update_grid_deficiency_identifier(service, version, mode, path + ["update_grid_deficiency_identifier"])
                    self.user_defined_on_register = self.__class__.user_defined_on_register(service, version, mode, path + ["user_defined_on_register"])
                    self.user_defined_on_register_auto = self.__class__.user_defined_on_register_auto(service, version, mode, path + ["user_defined_on_register_auto"])
                    super().__init__(service, version, mode, path)
                class cell_quality_based(TUIMethod):
                    """
                    Enables/disables the application of poor mesh numerics on cells with an orthogonal quality that is equal to or less than the threshold defined by the solve/set/poor-mesh-numerics/set-quality-threshold text command (which by default is set to 0.05).
                    """
                class enable(TUIMethod):
                    """
                    Enables/disables the application of poor mesh numerics on cells (those with an orthogonal quality of 0, as well as those identified by other enabled criteria), and defines whether the local solution correction is 0th, 1st, or 2nd order.
                    """
                class enhanced_pmn(TUIMethod):
                    """
                    This option is available with the density-based solver. When enabled, it will apply quality-based poor-mesh-numerics order=1 on any cells with a quality-measure below 0.2. In addition, their CFL number is limited to 1.0.
                    """
                class gradient_quality_based(TUIMethod):
                    """
                    Enables/disables the detection and treatment of poor cells using a criterion based on the cell gradient quality. Poor mesh numerics are applied when the criterion value is equal to or less than a threshold value defined as part of this text command. This criterion is only available with the pressure-based solver, and is not supported for cases that have periodic boundaries.
                    """
                class grid_deficiency_identifier(TUIMethod):
                    """
                    Adjust settings for grid deficiency identifier.
                    """
                class improve_solver_skewness_quality(TUIMethod):
                    """
                    Improve solver skewness metrics for better solver stability.
                    """
                class orthogonality_enhancing_cell_centroids(TUIMethod):
                    """
                    Enables/disables the relocation of select cell centroids, to improve the orthogonality metrics and solution stability. It is applied to cells when the criterion value is equal to or less than a threshold value defined as part of the text command. Note that the enhanced metrics are only apparent when reporting the quality in the solution mode of Fluent, and not in the meshing mode.
                    """
                class print_poor_elements_count(TUIMethod):
                    """
                    Prints out a listing of the poor cells for each criterion: default, cell quality, and user-defined, and (if enabled) cell gradient quality and solution and cell quality.
                    """
                class reset_poor_elements(TUIMethod):
                    """
                    Resets the list of poor cells included by the default, cell quality, user-defined, cell gradient quality, and solution and cell quality criteria.
                    """
                class set_quality_threshold(TUIMethod):
                    """
                    Sets the orthogonal quality threshold used for applying poor mesh numerics when the solve/set/poor-mesh-numerics/cell-quality-based? text command is enabled. By default, cells with an orthogonal quality of 0.05 or lower are corrected.
                    """
                class solution_and_quality_based(TUIMethod):
                    """
                    Enables/disables the detection and treatment of poor cells using a criterion based on the solution and cell quality. Poor mesh numerics are applied when the criterion value is equal to or less than a threshold value defined as part of this text command, and at a specified frequency (of iterations or time steps). This criterion is only available with the pressure-based solver.
                    """
                class turbulence_production_term(TUIMethod):
                    """
                    Enable/disable poor mesh numerics for turbulence production term.
                    """
                class update_grid_deficiency_identifier(TUIMethod):
                    """
                    Identify cells with possible negative impact on solver stability.
                    """
                class user_defined_on_register(TUIMethod):
                    """
                    Includes a register for the poor mesh numerics or not.
                    """
                class user_defined_on_register_auto(TUIMethod):
                    """
                    Set up the application of poor mesh numerics to cells in registers during the calculation at a specified frequency.
                    """

                class register_based(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                        self.new = self.__class__.new(service, version, mode, path + ["new"])
                        self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                        self.set = self.__class__.set(service, version, mode, path + ["set"])
                        super().__init__(service, version, mode, path)
                    class delete(TUIMethod):
                        """
                        .
                        """
                    class edit(TUIMethod):
                        """
                        Edit a definition for poor mesh numerics.
                        """
                    class list(TUIMethod):
                        """
                        .
                        """
                    class list_properties(TUIMethod):
                        """
                        .
                        """
                    class make_a_copy(TUIMethod):
                        """
                        .
                        """
                    class new(TUIMethod):
                        """
                        Add a new definition for poor mesh numerics.
                        """
                    class rename(TUIMethod):
                        """
                        Rename register-based object.
                        """
                    class set(TUIMethod):
                        """
                        .
                        """

                class solution_based_pmn(TUIMenu):
                    """
                    Solution based poor-mesh numerics menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                        self.mark_cfl_jump = self.__class__.mark_cfl_jump(service, version, mode, path + ["mark_cfl_jump"])
                        self.mark_cfl_limit = self.__class__.mark_cfl_limit(service, version, mode, path + ["mark_cfl_limit"])
                        self.mark_primary_solution_limits = self.__class__.mark_primary_solution_limits(service, version, mode, path + ["mark_primary_solution_limits"])
                        self.mark_velocity_limit = self.__class__.mark_velocity_limit(service, version, mode, path + ["mark_velocity_limit"])
                        super().__init__(service, version, mode, path)
                    class enable(TUIMethod):
                        """
                        Enable solution based treatment.
                        """
                    class mark_cfl_jump(TUIMethod):
                        """
                        Mark cells exceeding cfl jump in neighborhood.
                        """
                    class mark_cfl_limit(TUIMethod):
                        """
                        Mark cells exceeding cfl limit.
                        """
                    class mark_primary_solution_limits(TUIMethod):
                        """
                        Mark cells violating solution limits.
                        """
                    class mark_velocity_limit(TUIMethod):
                        """
                        Mark cells exceeding velocity limit.
                        """

            class poor_mesh_removal(TUIMenu):
                """
                Enter Poor Mesh Removal Menu.
                """
                def __init__(self, service, version, mode, path):
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.orthogonal_quality_threshold = self.__class__.orthogonal_quality_threshold(service, version, mode, path + ["orthogonal_quality_threshold"])
                    self.warpage_threshold = self.__class__.warpage_threshold(service, version, mode, path + ["warpage_threshold"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enable poor mesh removal.
                    """
                class orthogonal_quality_threshold(TUIMethod):
                    """
                    Set orthogonal quality threshold.
                    """
                class warpage_threshold(TUIMethod):
                    """
                    Set warapge threshold.
                    """

            class previous_defaults(TUIMenu):
                """
                Provides text commands that allow you to undo enhancements to the default solver behavior.
                """
                def __init__(self, service, version, mode, path):
                    self.undo_2019r1_default_changes = self.__class__.undo_2019r1_default_changes(service, version, mode, path + ["undo_2019r1_default_changes"])
                    self.undo_2019r3_default_changes = self.__class__.undo_2019r3_default_changes(service, version, mode, path + ["undo_2019r3_default_changes"])
                    self.undo_2021r1_default_changes = self.__class__.undo_2021r1_default_changes(service, version, mode, path + ["undo_2021r1_default_changes"])
                    self.undo_2021r2_default_changes = self.__class__.undo_2021r2_default_changes(service, version, mode, path + ["undo_2021r2_default_changes"])
                    self.undo_2022r1_default_changes = self.__class__.undo_2022r1_default_changes(service, version, mode, path + ["undo_2022r1_default_changes"])
                    self.undo_2023r1_default_changes = self.__class__.undo_2023r1_default_changes(service, version, mode, path + ["undo_2023r1_default_changes"])
                    self.undo_2023r2_default_changes = self.__class__.undo_2023r2_default_changes(service, version, mode, path + ["undo_2023r2_default_changes"])
                    self.undo_2024r1_default_changes = self.__class__.undo_2024r1_default_changes(service, version, mode, path + ["undo_2024r1_default_changes"])
                    self.undo_r19_point_0_default_changes = self.__class__.undo_r19_point_0_default_changes(service, version, mode, path + ["undo_r19_point_0_default_changes"])
                    super().__init__(service, version, mode, path)
                class undo_2019r1_default_changes(TUIMethod):
                    """
                    Allows you to undo enhancements introduced in version 2019 R1 of ANSYS Fluent, including:.
                    """
                class undo_2019r3_default_changes(TUIMethod):
                    """
                    Allows you to undo enhancements introduced in version 2019 R3 of ANSYS Fluent, including:.
                    """
                class undo_2021r1_default_changes(TUIMethod):
                    """
                    Allows you to undo enhancements introduced in version 2021 R1 of ANSYS Fluent, including:.
                    """
                class undo_2021r2_default_changes(TUIMethod):
                    """
                    Allows you to undo the following enhancements introduced in version 2021 R2 of ANSYS Fluent:.
                    """
                class undo_2022r1_default_changes(TUIMethod):
                    """
                    Allows you to undo the following enhancements introduced in version 2022 R1 of ANSYS Fluent:.
                    """
                class undo_2023r1_default_changes(TUIMethod):
                    """
                    Undo default changes introduced in 2023R1.
                    """
                class undo_2023r2_default_changes(TUIMethod):
                    """
                    Undo default changes introduced in 2023R2.
                    """
                class undo_2024r1_default_changes(TUIMethod):
                    """
                    Undo default changes introduced in 2024R1.
                    """
                class undo_r19_point_0_default_changes(TUIMethod):
                    """
                    Undo default changes introduced in R19.0.
                    """

            class pseudo_time_method(TUIMenu):
                """
                Enters the pseudo time method menu. This menu is only available for cases that use a pressure-based segregated solver (SIMPLE, SIMPLEC, or PISO) or for steady-state cases that use the pressure-based coupled solver or the density-based implicit solver.
                """
                def __init__(self, service, version, mode, path):
                    self.advanced_options = self.__class__.advanced_options(service, version, mode, path + ["advanced_options"])
                    self.convergence_acceleration_for_stretched_meshes = self.__class__.convergence_acceleration_for_stretched_meshes(service, version, mode, path + ["convergence_acceleration_for_stretched_meshes"])
                    self.explicit_relaxation = self.__class__.explicit_relaxation(service, version, mode, path + ["explicit_relaxation"])
                    self.formulation = self.__class__.formulation(service, version, mode, path + ["formulation"])
                    self.global_time_step_settings = self.__class__.global_time_step_settings(service, version, mode, path + ["global_time_step_settings"])
                    self.local_time_step_settings = self.__class__.local_time_step_settings(service, version, mode, path + ["local_time_step_settings"])
                    self.relaxation_bounds = self.__class__.relaxation_bounds(service, version, mode, path + ["relaxation_bounds"])
                    self.relaxation_factors = self.__class__.relaxation_factors(service, version, mode, path + ["relaxation_factors"])
                    self.relaxation_method = self.__class__.relaxation_method(service, version, mode, path + ["relaxation_method"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    super().__init__(service, version, mode, path)
                class advanced_options(TUIMethod):
                    """
                    Enters the advanced options menu, which allows you to enable / disable the pseudo time method for individual equations and define their pseudo time scale factors or under-relaxation factors, respectively. These settings only apply when the global time step formulation is selected.
                    """
                class convergence_acceleration_for_stretched_meshes(TUIMethod):
                    """
                    Enable convergence acceleration for stretched meshes to improve the convergence of the implicit pressure based solver on meshes with high cell stretching.
                    """
                class explicit_relaxation(TUIMethod):
                    """
                    Enable the explicit relaxation option for the pseudo time method.
                    """
                class formulation(TUIMethod):
                    """
                    Enables and sets the pseudo time step size formulation or disables the pseudo time method option.
                    """
                class global_time_step_settings(TUIMethod):
                    """
                    Defines the pseudo time settings for the calculation when the global time step formulation is selected.
                    """
                class local_time_step_settings(TUIMethod):
                    """
                    Defines the pseudo time Courant number when the local time step formulation is selected.
                    """
                class relaxation_bounds(TUIMethod):
                    """
                    Select relaxation bounding scheme for pseudo time method.
                    """
                class relaxation_factors(TUIMethod):
                    """
                    Enters the relaxation factors menu, where you can set the pseudo time explicit relaxation factors for individual equations. These factors only apply when the global time step formulation is selected.
                    """
                class relaxation_method(TUIMethod):
                    """
                    Select relaxation definition for pseudo time method.
                    """
                class verbosity(TUIMethod):
                    """
                    Sets the verbosity of the messages related to the pseudo time method.
                    """

            class slope_limiter_menu(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.direction = self.__class__.direction(service, version, mode, path + ["direction"])
                    self.filter = self.__class__.filter(service, version, mode, path + ["filter"])
                    self.type = self.__class__.type(service, version, mode, path + ["type"])
                    super().__init__(service, version, mode, path)
                class direction(TUIMethod):
                    """
                    .
                    """
                class filter(TUIMethod):
                    """
                    .
                    """
                class type(TUIMethod):
                    """
                    .
                    """

            class transient_controls(TUIMenu):
                """
                Enters the transient controls menu, which allows you to define settings related to time advancement for transient flow calculations.
                """
                def __init__(self, service, version, mode, path):
                    self.multiphase_specific_time_constraints = self.__class__.multiphase_specific_time_constraints(service, version, mode, path + ["multiphase_specific_time_constraints"])
                    self.cfl_based_time_stepping = self.__class__.cfl_based_time_stepping(service, version, mode, path + ["cfl_based_time_stepping"])
                    self.cfl_based_time_stepping_advanced_options = self.__class__.cfl_based_time_stepping_advanced_options(service, version, mode, path + ["cfl_based_time_stepping_advanced_options"])
                    self.duration_specification_method = self.__class__.duration_specification_method(service, version, mode, path + ["duration_specification_method"])
                    self.error_based_time_stepping = self.__class__.error_based_time_stepping(service, version, mode, path + ["error_based_time_stepping"])
                    self.extrapolate_eqn_vars = self.__class__.extrapolate_eqn_vars(service, version, mode, path + ["extrapolate_eqn_vars"])
                    self.extrapolate_vars = self.__class__.extrapolate_vars(service, version, mode, path + ["extrapolate_vars"])
                    self.fixed_periodic = self.__class__.fixed_periodic(service, version, mode, path + ["fixed_periodic"])
                    self.fixed_user_specified = self.__class__.fixed_user_specified(service, version, mode, path + ["fixed_user_specified"])
                    self.incremental_time = self.__class__.incremental_time(service, version, mode, path + ["incremental_time"])
                    self.max_flow_time = self.__class__.max_flow_time(service, version, mode, path + ["max_flow_time"])
                    self.max_iterations_per_time_step = self.__class__.max_iterations_per_time_step(service, version, mode, path + ["max_iterations_per_time_step"])
                    self.multiphase_specific_time_stepping = self.__class__.multiphase_specific_time_stepping(service, version, mode, path + ["multiphase_specific_time_stepping"])
                    self.number_of_time_steps = self.__class__.number_of_time_steps(service, version, mode, path + ["number_of_time_steps"])
                    self.predict_next_time = self.__class__.predict_next_time(service, version, mode, path + ["predict_next_time"])
                    self.rotating_mesh_flow_predictor = self.__class__.rotating_mesh_flow_predictor(service, version, mode, path + ["rotating_mesh_flow_predictor"])
                    self.solid_time_step_size = self.__class__.solid_time_step_size(service, version, mode, path + ["solid_time_step_size"])
                    self.solution_status = self.__class__.solution_status(service, version, mode, path + ["solution_status"])
                    self.specified_time_step = self.__class__.specified_time_step(service, version, mode, path + ["specified_time_step"])
                    self.time_step_size = self.__class__.time_step_size(service, version, mode, path + ["time_step_size"])
                    self.time_step_size_for_acoustic_export = self.__class__.time_step_size_for_acoustic_export(service, version, mode, path + ["time_step_size_for_acoustic_export"])
                    self.total_number_of_time_steps = self.__class__.total_number_of_time_steps(service, version, mode, path + ["total_number_of_time_steps"])
                    self.total_time = self.__class__.total_time(service, version, mode, path + ["total_time"])
                    self.udf_based_time_stepping = self.__class__.udf_based_time_stepping(service, version, mode, path + ["udf_based_time_stepping"])
                    self.undo_timestep = self.__class__.undo_timestep(service, version, mode, path + ["undo_timestep"])
                    super().__init__(service, version, mode, path)
                class cfl_based_time_stepping(TUIMethod):
                    """
                    Allows you to specify that an adaptive time stepping method is used in which the time step gets modified by ANSYS Fluent as the calculation proceeds such that the CourantFriedrichsLewy (CFL) condition is satisfied, using the specified Courant number.
                    """
                class cfl_based_time_stepping_advanced_options(TUIMethod):
                    """
                    .
                    """
                class duration_specification_method(TUIMethod):
                    """
                    Sets the method by which you will specify the duration of the calculation. The duration can be defined by the total time, the total number of time steps, the incremental time, or the number of incremental time steps. In this context, "total" indicates that Fluent will consider the amount of time / steps that have already been solved and stop appropriately, whereas "incremental" indicates that the solution will proceed for a specified amount of time / steps regardless of what has previously been calculated. This text command is only available when the time stepping is adaptive or based on a user-defined function.
                    """
                class error_based_time_stepping(TUIMethod):
                    """
                    Allows you to specify that an adaptive time stepping method is used in which the time step gets modified by ANSYS Fluent  based on the specified truncation error tolerance.
                    """
                class extrapolate_eqn_vars(TUIMethod):
                    """
                    Enters the extrapolation menu.
                    """
                class extrapolate_vars(TUIMethod):
                    """
                    Applies a predictor algorithm for computing initial conditions at time step n+1. The predictor algorithm is a computation that sets a better initial condition for the time step.
                    """
                class fixed_periodic(TUIMethod):
                    """
                    Allows you to specify that a fixed time stepping method is used in which a specified period or frequency is the basis for determining the time step size and number of time steps.
                    """
                class fixed_user_specified(TUIMethod):
                    """
                    Allows you to specify that a fixed time stepping method is used in which you directly specify the time step size and number of time steps.
                    """
                class incremental_time(TUIMethod):
                    """
                    Sets the amount of incremental (that is, additional) time to run the simulation, regardless of how much time has already been run in previous calculations. This text command is only available when the solve/set/transient-controls/duration-specification-method is set to3.
                    """
                class max_flow_time(TUIMethod):
                    """
                    Sets the maximum flow time.
                    """
                class max_iterations_per_time_step(TUIMethod):
                    """
                    Sets the number of time steps for a transient simulation.  This option is available when automatic initialization and case modification is enabled.
                    """
                class multiphase_specific_time_stepping(TUIMethod):
                    """
                    Allows you to specify that an adaptive time stepping method is used in which the time step gets modified by ANSYS Fluent  based on the convective time scale (global Courant number): the time-step-size calculation depends on the mesh density and velocity in interfacial cells. This method is available for all multiphase models using the implicit or explicit volume fraction formulation, except for the wet steam model.
                    """
                class number_of_time_steps(TUIMethod):
                    """
                    Sets the number of time steps for a transient simulation without starting the calculation.
                    """
                class predict_next_time(TUIMethod):
                    """
                    Applies a predictor algorithm for computing the next time step. The predictor algorithm is a computation that sets a better initial condition for the time step. It uses the rate of change between the prediction and the correction as an indicator for whether the next time step should be larger, smaller, or the same as the current one.
                    """
                class rotating_mesh_flow_predictor(TUIMethod):
                    """
                    Enables / disables an option that allows for better prediction of the flow field in rotating fluid zones at every time step, in order to speed up the calculation. This text command is only available for transient simulations.
                    """
                class solid_time_step_size(TUIMethod):
                    """
                    Allows you to specify that the time step size used for solid zones is independent from that used for fluid zones. This text command is only available when both a solid zone exists and energy is enabled.
                    """
                class solution_status(TUIMethod):
                    """
                    Allows you to open theSimulation Status dialog box, which reports details about the simulation.
                    """
                class specified_time_step(TUIMethod):
                    """
                    Specifies whether to define the transient advancement either directly by entering a time step size / period / frequency (using the text commands available in thesolve/set/transient-controls menu) or indirectly by entering a Courant number value (using the solve/set/courant-number text command). This text command is only available for the density-based solver when both the explicit formulation and explicit transient formulation are used.
                    """
                class time_step_size(TUIMethod):
                    """
                    Sets the magnitude of the (physical) time step . This text command is only available when the solve/set/transient-controls/fixed-user-specified text command is set toyes.
                    """
                class time_step_size_for_acoustic_export(TUIMethod):
                    """
                    Specifies the time interval for acoustic data sampling. This text command is only available when both the Ffowcs Williams and Hawkings model is selected and the density-based solver is used with the explicit formulation and explicit transient formulation.
                    """
                class total_number_of_time_steps(TUIMethod):
                    """
                    Sets the total number of time steps that the simulation will run (which includes any time steps that have already been run in previous calculations). This text command is only available when the solve/set/transient-controls/duration-specification-method is set to1.
                    """
                class total_time(TUIMethod):
                    """
                    Sets the total amount of time that the simulation will be run (which includes any time that has already been run in previous calculations). This text command is only available when the solve/set/transient-controls/duration-specification-method is set to2.
                    """
                class udf_based_time_stepping(TUIMethod):
                    """
                    Allows you to specify that the time step size is defined by a user-defined function (UDF) that uses theDEFINE_DELTAT macro.
                    """
                class undo_timestep(TUIMethod):
                    """
                    When enabled, if the truncation error within a time step exceeds the specified tolerance Fluent will automatically undo the current calculation and make another attempt with the time step reduced by 1/2. This will be attempted up to 5 times after which Fluent will accept the result and proceed to the next time step.
                    """

                class multiphase_specific_time_constraints(TUIMenu):
                    """
                    Enters the menu for setting multiphase-specific time constraints.
                    """
                    def __init__(self, service, version, mode, path):
                        self.time_scale_options = self.__class__.time_scale_options(service, version, mode, path + ["time_scale_options"])
                        self.moving_mesh_cfl_constraint = self.__class__.moving_mesh_cfl_constraint(service, version, mode, path + ["moving_mesh_cfl_constraint"])
                        self.physics_based_constraint = self.__class__.physics_based_constraint(service, version, mode, path + ["physics_based_constraint"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        super().__init__(service, version, mode, path)
                    class moving_mesh_cfl_constraint(TUIMethod):
                        """
                        .
                        """
                    class physics_based_constraint(TUIMethod):
                        """
                        Enables/disables the physics-driven time-step constraints.
                        """
                    class verbosity(TUIMethod):
                        """
                        When enabled, various time scales (depending on the selection) are  printed to the console window at every time step. This text command is  available with the moving mesh CFL constraint and with the physics-based  constraint.
                        """

                    class time_scale_options(TUIMenu):
                        """
                        Enters the menu for choosing the time-scale options. This menu  becomes available after you enable the physics-driven time-step  constraints using the solve/set/transient-controls/multiphase-specific-time-constraints/physics-based-constraint?  text command.
                        """
                        def __init__(self, service, version, mode, path):
                            self.acoustic_scale = self.__class__.acoustic_scale(service, version, mode, path + ["acoustic_scale"])
                            self.gravity_scale = self.__class__.gravity_scale(service, version, mode, path + ["gravity_scale"])
                            self.surface_tension_scale = self.__class__.surface_tension_scale(service, version, mode, path + ["surface_tension_scale"])
                            self.viscous_scale = self.__class__.viscous_scale(service, version, mode, path + ["viscous_scale"])
                            super().__init__(service, version, mode, path)
                        class acoustic_scale(TUIMethod):
                            """
                            Allows you to Include the acoustic time scale. This option is available only for compressible flows.
                            """
                        class gravity_scale(TUIMethod):
                            """
                            Allows you to Include the gravitational time scale. This option is available only if gravity is enabled.
                            """
                        class surface_tension_scale(TUIMethod):
                            """
                            Allows you to Include the surface-tension-driven time scale. This option is available only if the surface tension force modeling is enabled.
                            """
                        class viscous_scale(TUIMethod):
                            """
                            Allows you to Include the viscous time scale. This option is disabled by default. This command is not available with inviscid flows.
                            """

            class warped_face_gradient_correction(TUIMenu):
                """
                Enters the warped-face gradient correction menu.
                """
                def __init__(self, service, version, mode, path):
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.turbulence_options = self.__class__.turbulence_options(service, version, mode, path + ["turbulence_options"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enables/disables gradient enhancement computations and specifies whether Fluent uses fast or memory saving mode.
                    """
                class turbulence_options(TUIMethod):
                    """
                    Set turbulence Warped Face Gradient Correction.
                    """

    class surface(TUIMenu):
        """
        Enter the data surface manipulation menu.
        """
        def __init__(self, service, version, mode, path):
            self.post_processing_volume = self.__class__.post_processing_volume(service, version, mode, path + ["post_processing_volume"])
            self.query = self.__class__.query(service, version, mode, path + ["query"])
            self.circle_slice = self.__class__.circle_slice(service, version, mode, path + ["circle_slice"])
            self.closest_point_search = self.__class__.closest_point_search(service, version, mode, path + ["closest_point_search"])
            self.cone_slice = self.__class__.cone_slice(service, version, mode, path + ["cone_slice"])
            self.create_imprint_surface = self.__class__.create_imprint_surface(service, version, mode, path + ["create_imprint_surface"])
            self.delete_surface = self.__class__.delete_surface(service, version, mode, path + ["delete_surface"])
            self.edit_surface = self.__class__.edit_surface(service, version, mode, path + ["edit_surface"])
            self.ellipsoid_slice = self.__class__.ellipsoid_slice(service, version, mode, path + ["ellipsoid_slice"])
            self.expression_volume = self.__class__.expression_volume(service, version, mode, path + ["expression_volume"])
            self.group_surfaces = self.__class__.group_surfaces(service, version, mode, path + ["group_surfaces"])
            self.imprint_surface = self.__class__.imprint_surface(service, version, mode, path + ["imprint_surface"])
            self.iso_clip = self.__class__.iso_clip(service, version, mode, path + ["iso_clip"])
            self.iso_clip_multiple = self.__class__.iso_clip_multiple(service, version, mode, path + ["iso_clip_multiple"])
            self.iso_surface = self.__class__.iso_surface(service, version, mode, path + ["iso_surface"])
            self.line_slice = self.__class__.line_slice(service, version, mode, path + ["line_slice"])
            self.line_surface = self.__class__.line_surface(service, version, mode, path + ["line_surface"])
            self.list_surfaces = self.__class__.list_surfaces(service, version, mode, path + ["list_surfaces"])
            self.mouse_line = self.__class__.mouse_line(service, version, mode, path + ["mouse_line"])
            self.mouse_plane = self.__class__.mouse_plane(service, version, mode, path + ["mouse_plane"])
            self.mouse_rake = self.__class__.mouse_rake(service, version, mode, path + ["mouse_rake"])
            self.multiple_iso_surfaces = self.__class__.multiple_iso_surfaces(service, version, mode, path + ["multiple_iso_surfaces"])
            self.multiple_plane_surfaces = self.__class__.multiple_plane_surfaces(service, version, mode, path + ["multiple_plane_surfaces"])
            self.multiple_zone_surfaces = self.__class__.multiple_zone_surfaces(service, version, mode, path + ["multiple_zone_surfaces"])
            self.partition_surface = self.__class__.partition_surface(service, version, mode, path + ["partition_surface"])
            self.plane = self.__class__.plane(service, version, mode, path + ["plane"])
            self.plane_bounded = self.__class__.plane_bounded(service, version, mode, path + ["plane_bounded"])
            self.plane_point_n_normal = self.__class__.plane_point_n_normal(service, version, mode, path + ["plane_point_n_normal"])
            self.plane_slice = self.__class__.plane_slice(service, version, mode, path + ["plane_slice"])
            self.plane_surf_aligned = self.__class__.plane_surf_aligned(service, version, mode, path + ["plane_surf_aligned"])
            self.plane_surface = self.__class__.plane_surface(service, version, mode, path + ["plane_surface"])
            self.plane_view_plane_align = self.__class__.plane_view_plane_align(service, version, mode, path + ["plane_view_plane_align"])
            self.point_array = self.__class__.point_array(service, version, mode, path + ["point_array"])
            self.point_surface = self.__class__.point_surface(service, version, mode, path + ["point_surface"])
            self.quadric_slice = self.__class__.quadric_slice(service, version, mode, path + ["quadric_slice"])
            self.rake_surface = self.__class__.rake_surface(service, version, mode, path + ["rake_surface"])
            self.rename_surface = self.__class__.rename_surface(service, version, mode, path + ["rename_surface"])
            self.rendering_priority = self.__class__.rendering_priority(service, version, mode, path + ["rendering_priority"])
            self.reset_zone_surfaces = self.__class__.reset_zone_surfaces(service, version, mode, path + ["reset_zone_surfaces"])
            self.sphere_slice = self.__class__.sphere_slice(service, version, mode, path + ["sphere_slice"])
            self.structural_point_surface = self.__class__.structural_point_surface(service, version, mode, path + ["structural_point_surface"])
            self.surface_cells = self.__class__.surface_cells(service, version, mode, path + ["surface_cells"])
            self.transform_surface = self.__class__.transform_surface(service, version, mode, path + ["transform_surface"])
            self.ungroup_surface = self.__class__.ungroup_surface(service, version, mode, path + ["ungroup_surface"])
            self.zone_surface = self.__class__.zone_surface(service, version, mode, path + ["zone_surface"])
            super().__init__(service, version, mode, path)
        class circle_slice(TUIMethod):
            """
            Extracts a circular slice.
            """
        class closest_point_search(TUIMethod):
            """
            Enable the point surface algorithm to look for the nearest point instead of reporting a creation failure.
            """
        class cone_slice(TUIMethod):
            """
            Extract a cone slice.
            """
        class create_imprint_surface(TUIMethod):
            """
            Imprint surface.
            """
        class delete_surface(TUIMethod):
            """
            Removes a defined data surface.
            """
        class edit_surface(TUIMethod):
            """
            Allows you to edit any of the listed available surfaces.
            """
        class ellipsoid_slice(TUIMethod):
            """
            Extract a ellipsoid slice.
            """
        class expression_volume(TUIMethod):
            """
            Create volume with boolean expression.
            """
        class group_surfaces(TUIMethod):
            """
            Group a set of surfaces.
            """
        class imprint_surface(TUIMethod):
            """
            Enters the list of surfaces to imprint from and the name of the new imprinted surface.
            """
        class iso_clip(TUIMethod):
            """
            Clips a data surface (surface, curve, or point) between two isovalues.
            """
        class iso_clip_multiple(TUIMethod):
            """
            Clip a data surface (surface, curve, or point) between two iso-values.
            """
        class iso_surface(TUIMethod):
            """
            Extracts an iso-surface (surface, curve, or point) from the current data field.
            """
        class line_slice(TUIMethod):
            """
            Extracts a linear slice in 2D, given the normal to the line and a distance from the origin.
            """
        class line_surface(TUIMethod):
            """
            Defines a line" surface by specifying the two endpoint coordinates.
            """
        class list_surfaces(TUIMethod):
            """
            Displays the ID and name, and the number of point, curve, and surface facets of the current surfaces.
            """
        class mouse_line(TUIMethod):
            """
            Extracts a line surface that you define by using the mouse to select the endpoints.
            """
        class mouse_plane(TUIMethod):
            """
            Extracts a planar surface defined by selecting three points with the mouse.
            """
        class mouse_rake(TUIMethod):
            """
            Extracts a rake" surface that you define by using the mouse to select the endpoints.
            """
        class multiple_iso_surfaces(TUIMethod):
            """
            Creates multiple iso-surfaces at once. Accepts zone names, lists of zone IDs, and wildcards.
            """
        class multiple_plane_surfaces(TUIMethod):
            """
            Creates multiple planes at once. Accepts zone names, lists of zone IDs, and wildcards.
            """
        class multiple_zone_surfaces(TUIMethod):
            """
            Creates multiple data surfaces at one time. Accepts zone names, lists of zone IDs, and wildcards.
            """
        class partition_surface(TUIMethod):
            """
            Defines a data surface consisting of mesh faces on the partition boundary.
            """
        class plane(TUIMethod):
            """
            Create a plane given 3 points bounded by the domain.
            """
        class plane_bounded(TUIMethod):
            """
            Create a bounded surface.
            """
        class plane_point_n_normal(TUIMethod):
            """
            Create a plane from a point and normal.
            """
        class plane_slice(TUIMethod):
            """
            Extracts a planar slice.
            """
        class plane_surf_aligned(TUIMethod):
            """
            Create a plane aligned to a surface.
            """
        class plane_surface(TUIMethod):
            """
            Create a plane from a coordinate plane, point and normal, or three points.
            """
        class plane_view_plane_align(TUIMethod):
            """
            Create a plane aligned to a view-plane.
            """
        class point_array(TUIMethod):
            """
            Extracts a rectangular array of data points.
            """
        class point_surface(TUIMethod):
            """
            Defines a point" surface by specifying the coordinates.
            """
        class quadric_slice(TUIMethod):
            """
            Extracts a quadric slice.
            """
        class rake_surface(TUIMethod):
            """
            Extracts a rake" surface, given the coordinates of the endpoints.
            """
        class rename_surface(TUIMethod):
            """
            Renames a defined data surface.
            """
        class rendering_priority(TUIMethod):
            """
            Define Priority for given surface id.
            """
        class reset_zone_surfaces(TUIMethod):
            """
            Recreates missing surface zones by resetting the case surface list.
            """
        class sphere_slice(TUIMethod):
            """
            Extracts a spherical slice.
            """
        class structural_point_surface(TUIMethod):
            """
            Defines a structural point" surface by specifying the coordinates.
            """
        class surface_cells(TUIMethod):
            """
            Extracts all cells intersected by a data surface.
            """
        class transform_surface(TUIMethod):
            """
            Transforms surface.
            """
        class ungroup_surface(TUIMethod):
            """
            Ungroup the surface(if grouped).
            """
        class zone_surface(TUIMethod):
            """
            Creates a surface of a designated zone and gives it a specified name.
            """

        class post_processing_volume(TUIMenu):
            """
            Enter post-processing volume menu.
            """
            def __init__(self, service, version, mode, path):
                self.create_from_file = self.__class__.create_from_file(service, version, mode, path + ["create_from_file"])
                self.create_octree = self.__class__.create_octree(service, version, mode, path + ["create_octree"])
                super().__init__(service, version, mode, path)
            class create_from_file(TUIMethod):
                """
                Read post-processing mesh from file.
                """
            class create_octree(TUIMethod):
                """
                Create post-processing octree mesh based on current case.
                """

        class query(TUIMenu):
            """
            Enter surface query menu.
            """
            def __init__(self, service, version, mode, path):
                self.delete_query = self.__class__.delete_query(service, version, mode, path + ["delete_query"])
                self.list_named_selection = self.__class__.list_named_selection(service, version, mode, path + ["list_named_selection"])
                self.list_queries = self.__class__.list_queries(service, version, mode, path + ["list_queries"])
                self.list_surfaces = self.__class__.list_surfaces(service, version, mode, path + ["list_surfaces"])
                self.named_surface_list = self.__class__.named_surface_list(service, version, mode, path + ["named_surface_list"])
                super().__init__(service, version, mode, path)
            class delete_query(TUIMethod):
                """
                Delete saved query.
                """
            class list_named_selection(TUIMethod):
                """
                List named selection of surface type.
                """
            class list_queries(TUIMethod):
                """
                List all saved queries.
                """
            class list_surfaces(TUIMethod):
                """
                List surfaces.
                """
            class named_surface_list(TUIMethod):
                """
                Create named list of surfaces.
                """

    class turbo_post(TUIMenu):
        """
        Enter the turbo menu.
        """
        def __init__(self, service, version, mode, path):
            self.avg_contours = self.__class__.avg_contours(service, version, mode, path + ["avg_contours"])
            self.compute_report = self.__class__.compute_report(service, version, mode, path + ["compute_report"])
            self.current_topology = self.__class__.current_topology(service, version, mode, path + ["current_topology"])
            self.two_d_contours = self.__class__.two_d_contours(service, version, mode, path + ["two_d_contours"])
            self.write_report = self.__class__.write_report(service, version, mode, path + ["write_report"])
            self.xy_plot_avg = self.__class__.xy_plot_avg(service, version, mode, path + ["xy_plot_avg"])
            super().__init__(service, version, mode, path)
        class avg_contours(TUIMethod):
            """
            Displays average contours.
            """
        class compute_report(TUIMethod):
            """
            Computes turbomachinery quantities.
            """
        class current_topology(TUIMethod):
            """
            Sets the current turbo topology for global use.
            """
        class two_d_contours(TUIMethod):
            """
            Display 2d contours.
            """
        class write_report(TUIMethod):
            """
            Writes the turbo report to file.
            """
        class xy_plot_avg(TUIMethod):
            """
            Displays average XY plots.
            """

    class turbo_workflow(TUIMenu):
        """
        Enter the turbo workflow menu.
        """
        def __init__(self, service, version, mode, path):
            self.workflow = self.__class__.workflow(service, version, mode, path + ["workflow"])
            super().__init__(service, version, mode, path)

        class workflow(TUIMenu):
            """
            Enter the workflow menu.
            """
            def __init__(self, service, version, mode, path):
                self.disable = self.__class__.disable(service, version, mode, path + ["disable"])
                self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                self.reset = self.__class__.reset(service, version, mode, path + ["reset"])
                super().__init__(service, version, mode, path)
            class disable(TUIMethod):
                """
                Disable the workflow.
                """
            class enable(TUIMethod):
                """
                Enable the workflow.
                """
            class reset(TUIMethod):
                """
                Reset the workflow.
                """

    class views(TUIMenu):
        """
        .
        """
        def __init__(self, service, version, mode, path):
            self.camera = self.__class__.camera(service, version, mode, path + ["camera"])
            self.display_states = self.__class__.display_states(service, version, mode, path + ["display_states"])
            self.rendering_options = self.__class__.rendering_options(service, version, mode, path + ["rendering_options"])
            self.auto_scale = self.__class__.auto_scale(service, version, mode, path + ["auto_scale"])
            self.default_view = self.__class__.default_view(service, version, mode, path + ["default_view"])
            self.delete_view = self.__class__.delete_view(service, version, mode, path + ["delete_view"])
            self.last_view = self.__class__.last_view(service, version, mode, path + ["last_view"])
            self.list_views = self.__class__.list_views(service, version, mode, path + ["list_views"])
            self.next_view = self.__class__.next_view(service, version, mode, path + ["next_view"])
            self.read_views = self.__class__.read_views(service, version, mode, path + ["read_views"])
            self.restore_view = self.__class__.restore_view(service, version, mode, path + ["restore_view"])
            self.save_view = self.__class__.save_view(service, version, mode, path + ["save_view"])
            self.write_views = self.__class__.write_views(service, version, mode, path + ["write_views"])
            super().__init__(service, version, mode, path)
        class auto_scale(TUIMethod):
            """
            Scales and centers the current scene without changing its orientation.
            """
        class default_view(TUIMethod):
            """
            Resets view to front and center.
            """
        class delete_view(TUIMethod):
            """
            Removes a view from the list.
            """
        class last_view(TUIMethod):
            """
            Returns to the camera position before the last manipulation.
            """
        class list_views(TUIMethod):
            """
            Lists predefined and saved views.
            """
        class next_view(TUIMethod):
            """
            .
            """
        class read_views(TUIMethod):
            """
            Reads views from a view file.
            """
        class restore_view(TUIMethod):
            """
            Uses a saved view.
            """
        class save_view(TUIMethod):
            """
            Saves the current view to the view list.
            """
        class write_views(TUIMethod):
            """
            Writes selected views to a view file.
            """

        class camera(TUIMenu):
            """
            Enters the camera menu to modify the current viewing parameters.
            """
            def __init__(self, service, version, mode, path):
                self.dolly_camera = self.__class__.dolly_camera(service, version, mode, path + ["dolly_camera"])
                self.field = self.__class__.field(service, version, mode, path + ["field"])
                self.orbit_camera = self.__class__.orbit_camera(service, version, mode, path + ["orbit_camera"])
                self.pan_camera = self.__class__.pan_camera(service, version, mode, path + ["pan_camera"])
                self.position = self.__class__.position(service, version, mode, path + ["position"])
                self.projection = self.__class__.projection(service, version, mode, path + ["projection"])
                self.roll_camera = self.__class__.roll_camera(service, version, mode, path + ["roll_camera"])
                self.target = self.__class__.target(service, version, mode, path + ["target"])
                self.up_vector = self.__class__.up_vector(service, version, mode, path + ["up_vector"])
                self.zoom_camera = self.__class__.zoom_camera(service, version, mode, path + ["zoom_camera"])
                super().__init__(service, version, mode, path)
            class dolly_camera(TUIMethod):
                """
                Adjusts the camera position and target.
                """
            class field(TUIMethod):
                """
                Sets the field of view (width and height).
                """
            class orbit_camera(TUIMethod):
                """
                Adjusts the camera position without modifying the target.
                """
            class pan_camera(TUIMethod):
                """
                Adjusts the camera target without modifying the position.
                """
            class position(TUIMethod):
                """
                Sets the camera position.
                """
            class projection(TUIMethod):
                """
                .
                """
            class roll_camera(TUIMethod):
                """
                Adjusts the camera up-vector.
                """
            class target(TUIMethod):
                """
                Sets the point to be the center of the camera view.
                """
            class up_vector(TUIMethod):
                """
                Sets the camera up-vector.
                """
            class zoom_camera(TUIMethod):
                """
                Adjusts the cameras field of view. This operation is similar to dollying the camera in or out of the scene. Dollying causes objects in front to move past you. Zooming changes the perspective effect in the scene (and can be disconcerting).
                """

        class display_states(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                self.make_a_copy = self.__class__.make_a_copy(service, version, mode, path + ["make_a_copy"])
                self.new = self.__class__.new(service, version, mode, path + ["new"])
                self.read = self.__class__.read(service, version, mode, path + ["read"])
                self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                self.restore_state = self.__class__.restore_state(service, version, mode, path + ["restore_state"])
                self.use_active = self.__class__.use_active(service, version, mode, path + ["use_active"])
                self.write = self.__class__.write(service, version, mode, path + ["write"])
                super().__init__(service, version, mode, path)
            class copy(TUIMethod):
                """
                .
                """
            class delete(TUIMethod):
                """
                .
                """
            class edit(TUIMethod):
                """
                Edit display-states object.
                """
            class list(TUIMethod):
                """
                .
                """
            class list_properties(TUIMethod):
                """
                .
                """
            class make_a_copy(TUIMethod):
                """
                .
                """
            class new(TUIMethod):
                """
                Create a new display-states object.
                """
            class read(TUIMethod):
                """
                .
                """
            class rename(TUIMethod):
                """
                Rename display-states object.
                """
            class restore_state(TUIMethod):
                """
                .
                """
            class use_active(TUIMethod):
                """
                .
                """
            class write(TUIMethod):
                """
                .
                """

        class rendering_options(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.animation_option = self.__class__.animation_option(service, version, mode, path + ["animation_option"])
                self.auto_spin = self.__class__.auto_spin(service, version, mode, path + ["auto_spin"])
                self.color_map_alignment = self.__class__.color_map_alignment(service, version, mode, path + ["color_map_alignment"])
                self.device_info = self.__class__.device_info(service, version, mode, path + ["device_info"])
                self.double_buffering = self.__class__.double_buffering(service, version, mode, path + ["double_buffering"])
                self.driver = self.__class__.driver(service, version, mode, path + ["driver"])
                self.face_displacement = self.__class__.face_displacement(service, version, mode, path + ["face_displacement"])
                self.front_faces_transparent = self.__class__.front_faces_transparent(service, version, mode, path + ["front_faces_transparent"])
                self.hidden_surface_method = self.__class__.hidden_surface_method(service, version, mode, path + ["hidden_surface_method"])
                self.hidden_surfaces = self.__class__.hidden_surfaces(service, version, mode, path + ["hidden_surfaces"])
                self.set_rendering_options = self.__class__.set_rendering_options(service, version, mode, path + ["set_rendering_options"])
                self.show_colormap = self.__class__.show_colormap(service, version, mode, path + ["show_colormap"])
                super().__init__(service, version, mode, path)
            class animation_option(TUIMethod):
                """
                .
                """
            class auto_spin(TUIMethod):
                """
                .
                """
            class color_map_alignment(TUIMethod):
                """
                .
                """
            class device_info(TUIMethod):
                """
                .
                """
            class double_buffering(TUIMethod):
                """
                .
                """
            class driver(TUIMethod):
                """
                .
                """
            class face_displacement(TUIMethod):
                """
                .
                """
            class front_faces_transparent(TUIMethod):
                """
                .
                """
            class hidden_surface_method(TUIMethod):
                """
                .
                """
            class hidden_surfaces(TUIMethod):
                """
                .
                """
            class set_rendering_options(TUIMethod):
                """
                .
                """
            class show_colormap(TUIMethod):
                """
                .
                """
